/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/pdfjs-dist/build/pdf.worker.mjs":
/*!******************************************************!*\
  !*** ./node_modules/pdfjs-dist/build/pdf.worker.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WorkerMessageHandler: () => (/* binding */ __webpack_exports__WorkerMessageHandler)\n/* harmony export */ });\n/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2023 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n */\n\n/******/ // The require scope\n/******/ var __nested_webpack_require_839__ = {};\n/******/ \n/************************************************************************/\n/******/ /* webpack/runtime/define property getters */\n/******/ (() => {\n/******/ \t// define getter functions for harmony exports\n/******/ \t__nested_webpack_require_839__.d = (exports, definition) => {\n/******/ \t\tfor(var key in definition) {\n/******/ \t\t\tif(__nested_webpack_require_839__.o(definition, key) && !__nested_webpack_require_839__.o(exports, key)) {\n/******/ \t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t};\n/******/ })();\n/******/ \n/******/ /* webpack/runtime/hasOwnProperty shorthand */\n/******/ (() => {\n/******/ \t__nested_webpack_require_839__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ })();\n/******/ \n/************************************************************************/\nvar __nested_webpack_exports__ = globalThis.pdfjsWorker = {};\n\n// EXPORTS\n__nested_webpack_require_839__.d(__nested_webpack_exports__, {\n  WorkerMessageHandler: () => (/* reexport */ WorkerMessageHandler)\n});\n\n;// CONCATENATED MODULE: ./src/shared/util.js\nconst isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\nconst IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];\nconst FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\nconst MAX_IMAGE_SIZE_TO_CACHE = 10e6;\nconst LINE_FACTOR = 1.35;\nconst LINE_DESCENT_FACTOR = 0.35;\nconst BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;\nconst RenderingIntentFlag = {\n  ANY: 0x01,\n  DISPLAY: 0x02,\n  PRINT: 0x04,\n  SAVE: 0x08,\n  ANNOTATIONS_FORMS: 0x10,\n  ANNOTATIONS_STORAGE: 0x20,\n  ANNOTATIONS_DISABLE: 0x40,\n  OPLIST: 0x100\n};\nconst AnnotationMode = {\n  DISABLE: 0,\n  ENABLE: 1,\n  ENABLE_FORMS: 2,\n  ENABLE_STORAGE: 3\n};\nconst AnnotationEditorPrefix = \"pdfjs_internal_editor_\";\nconst AnnotationEditorType = {\n  DISABLE: -1,\n  NONE: 0,\n  FREETEXT: 3,\n  HIGHLIGHT: 9,\n  STAMP: 13,\n  INK: 15\n};\nconst AnnotationEditorParamsType = {\n  RESIZE: 1,\n  CREATE: 2,\n  FREETEXT_SIZE: 11,\n  FREETEXT_COLOR: 12,\n  FREETEXT_OPACITY: 13,\n  INK_COLOR: 21,\n  INK_THICKNESS: 22,\n  INK_OPACITY: 23,\n  HIGHLIGHT_COLOR: 31,\n  HIGHLIGHT_DEFAULT_COLOR: 32,\n  HIGHLIGHT_THICKNESS: 33,\n  HIGHLIGHT_FREE: 34,\n  HIGHLIGHT_SHOW_ALL: 35\n};\nconst PermissionFlag = {\n  PRINT: 0x04,\n  MODIFY_CONTENTS: 0x08,\n  COPY: 0x10,\n  MODIFY_ANNOTATIONS: 0x20,\n  FILL_INTERACTIVE_FORMS: 0x100,\n  COPY_FOR_ACCESSIBILITY: 0x200,\n  ASSEMBLE: 0x400,\n  PRINT_HIGH_QUALITY: 0x800\n};\nconst TextRenderingMode = {\n  FILL: 0,\n  STROKE: 1,\n  FILL_STROKE: 2,\n  INVISIBLE: 3,\n  FILL_ADD_TO_PATH: 4,\n  STROKE_ADD_TO_PATH: 5,\n  FILL_STROKE_ADD_TO_PATH: 6,\n  ADD_TO_PATH: 7,\n  FILL_STROKE_MASK: 3,\n  ADD_TO_PATH_FLAG: 4\n};\nconst ImageKind = {\n  GRAYSCALE_1BPP: 1,\n  RGB_24BPP: 2,\n  RGBA_32BPP: 3\n};\nconst AnnotationType = {\n  TEXT: 1,\n  LINK: 2,\n  FREETEXT: 3,\n  LINE: 4,\n  SQUARE: 5,\n  CIRCLE: 6,\n  POLYGON: 7,\n  POLYLINE: 8,\n  HIGHLIGHT: 9,\n  UNDERLINE: 10,\n  SQUIGGLY: 11,\n  STRIKEOUT: 12,\n  STAMP: 13,\n  CARET: 14,\n  INK: 15,\n  POPUP: 16,\n  FILEATTACHMENT: 17,\n  SOUND: 18,\n  MOVIE: 19,\n  WIDGET: 20,\n  SCREEN: 21,\n  PRINTERMARK: 22,\n  TRAPNET: 23,\n  WATERMARK: 24,\n  THREED: 25,\n  REDACT: 26\n};\nconst AnnotationReplyType = {\n  GROUP: \"Group\",\n  REPLY: \"R\"\n};\nconst AnnotationFlag = {\n  INVISIBLE: 0x01,\n  HIDDEN: 0x02,\n  PRINT: 0x04,\n  NOZOOM: 0x08,\n  NOROTATE: 0x10,\n  NOVIEW: 0x20,\n  READONLY: 0x40,\n  LOCKED: 0x80,\n  TOGGLENOVIEW: 0x100,\n  LOCKEDCONTENTS: 0x200\n};\nconst AnnotationFieldFlag = {\n  READONLY: 0x0000001,\n  REQUIRED: 0x0000002,\n  NOEXPORT: 0x0000004,\n  MULTILINE: 0x0001000,\n  PASSWORD: 0x0002000,\n  NOTOGGLETOOFF: 0x0004000,\n  RADIO: 0x0008000,\n  PUSHBUTTON: 0x0010000,\n  COMBO: 0x0020000,\n  EDIT: 0x0040000,\n  SORT: 0x0080000,\n  FILESELECT: 0x0100000,\n  MULTISELECT: 0x0200000,\n  DONOTSPELLCHECK: 0x0400000,\n  DONOTSCROLL: 0x0800000,\n  COMB: 0x1000000,\n  RICHTEXT: 0x2000000,\n  RADIOSINUNISON: 0x2000000,\n  COMMITONSELCHANGE: 0x4000000\n};\nconst AnnotationBorderStyleType = {\n  SOLID: 1,\n  DASHED: 2,\n  BEVELED: 3,\n  INSET: 4,\n  UNDERLINE: 5\n};\nconst AnnotationActionEventType = {\n  E: \"Mouse Enter\",\n  X: \"Mouse Exit\",\n  D: \"Mouse Down\",\n  U: \"Mouse Up\",\n  Fo: \"Focus\",\n  Bl: \"Blur\",\n  PO: \"PageOpen\",\n  PC: \"PageClose\",\n  PV: \"PageVisible\",\n  PI: \"PageInvisible\",\n  K: \"Keystroke\",\n  F: \"Format\",\n  V: \"Validate\",\n  C: \"Calculate\"\n};\nconst DocumentActionEventType = {\n  WC: \"WillClose\",\n  WS: \"WillSave\",\n  DS: \"DidSave\",\n  WP: \"WillPrint\",\n  DP: \"DidPrint\"\n};\nconst PageActionEventType = {\n  O: \"PageOpen\",\n  C: \"PageClose\"\n};\nconst VerbosityLevel = {\n  ERRORS: 0,\n  WARNINGS: 1,\n  INFOS: 5\n};\nconst CMapCompressionType = {\n  NONE: 0,\n  BINARY: 1\n};\nconst OPS = {\n  dependency: 1,\n  setLineWidth: 2,\n  setLineCap: 3,\n  setLineJoin: 4,\n  setMiterLimit: 5,\n  setDash: 6,\n  setRenderingIntent: 7,\n  setFlatness: 8,\n  setGState: 9,\n  save: 10,\n  restore: 11,\n  transform: 12,\n  moveTo: 13,\n  lineTo: 14,\n  curveTo: 15,\n  curveTo2: 16,\n  curveTo3: 17,\n  closePath: 18,\n  rectangle: 19,\n  stroke: 20,\n  closeStroke: 21,\n  fill: 22,\n  eoFill: 23,\n  fillStroke: 24,\n  eoFillStroke: 25,\n  closeFillStroke: 26,\n  closeEOFillStroke: 27,\n  endPath: 28,\n  clip: 29,\n  eoClip: 30,\n  beginText: 31,\n  endText: 32,\n  setCharSpacing: 33,\n  setWordSpacing: 34,\n  setHScale: 35,\n  setLeading: 36,\n  setFont: 37,\n  setTextRenderingMode: 38,\n  setTextRise: 39,\n  moveText: 40,\n  setLeadingMoveText: 41,\n  setTextMatrix: 42,\n  nextLine: 43,\n  showText: 44,\n  showSpacedText: 45,\n  nextLineShowText: 46,\n  nextLineSetSpacingShowText: 47,\n  setCharWidth: 48,\n  setCharWidthAndBounds: 49,\n  setStrokeColorSpace: 50,\n  setFillColorSpace: 51,\n  setStrokeColor: 52,\n  setStrokeColorN: 53,\n  setFillColor: 54,\n  setFillColorN: 55,\n  setStrokeGray: 56,\n  setFillGray: 57,\n  setStrokeRGBColor: 58,\n  setFillRGBColor: 59,\n  setStrokeCMYKColor: 60,\n  setFillCMYKColor: 61,\n  shadingFill: 62,\n  beginInlineImage: 63,\n  beginImageData: 64,\n  endInlineImage: 65,\n  paintXObject: 66,\n  markPoint: 67,\n  markPointProps: 68,\n  beginMarkedContent: 69,\n  beginMarkedContentProps: 70,\n  endMarkedContent: 71,\n  beginCompat: 72,\n  endCompat: 73,\n  paintFormXObjectBegin: 74,\n  paintFormXObjectEnd: 75,\n  beginGroup: 76,\n  endGroup: 77,\n  beginAnnotation: 80,\n  endAnnotation: 81,\n  paintImageMaskXObject: 83,\n  paintImageMaskXObjectGroup: 84,\n  paintImageXObject: 85,\n  paintInlineImageXObject: 86,\n  paintInlineImageXObjectGroup: 87,\n  paintImageXObjectRepeat: 88,\n  paintImageMaskXObjectRepeat: 89,\n  paintSolidColorImageMask: 90,\n  constructPath: 91\n};\nconst PasswordResponses = {\n  NEED_PASSWORD: 1,\n  INCORRECT_PASSWORD: 2\n};\nlet verbosity = VerbosityLevel.WARNINGS;\nfunction setVerbosityLevel(level) {\n  if (Number.isInteger(level)) {\n    verbosity = level;\n  }\n}\nfunction getVerbosityLevel() {\n  return verbosity;\n}\nfunction info(msg) {\n  if (verbosity >= VerbosityLevel.INFOS) {\n    console.log(`Info: ${msg}`);\n  }\n}\nfunction warn(msg) {\n  if (verbosity >= VerbosityLevel.WARNINGS) {\n    console.log(`Warning: ${msg}`);\n  }\n}\nfunction unreachable(msg) {\n  throw new Error(msg);\n}\nfunction assert(cond, msg) {\n  if (!cond) {\n    unreachable(msg);\n  }\n}\nfunction _isValidProtocol(url) {\n  switch (url?.protocol) {\n    case \"http:\":\n    case \"https:\":\n    case \"ftp:\":\n    case \"mailto:\":\n    case \"tel:\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n  if (!url) {\n    return null;\n  }\n  try {\n    if (options && typeof url === \"string\") {\n      if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n        const dots = url.match(/\\./g);\n        if (dots?.length >= 2) {\n          url = `http://${url}`;\n        }\n      }\n      if (options.tryConvertEncoding) {\n        try {\n          url = stringToUTF8String(url);\n        } catch {}\n      }\n    }\n    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n    if (_isValidProtocol(absoluteUrl)) {\n      return absoluteUrl;\n    }\n  } catch {}\n  return null;\n}\nfunction shadow(obj, prop, value, nonSerializable = false) {\n  Object.defineProperty(obj, prop, {\n    value,\n    enumerable: !nonSerializable,\n    configurable: true,\n    writable: false\n  });\n  return value;\n}\nconst BaseException = function BaseExceptionClosure() {\n  function BaseException(message, name) {\n    if (this.constructor === BaseException) {\n      unreachable(\"Cannot initialize BaseException.\");\n    }\n    this.message = message;\n    this.name = name;\n  }\n  BaseException.prototype = new Error();\n  BaseException.constructor = BaseException;\n  return BaseException;\n}();\nclass PasswordException extends BaseException {\n  constructor(msg, code) {\n    super(msg, \"PasswordException\");\n    this.code = code;\n  }\n}\nclass UnknownErrorException extends BaseException {\n  constructor(msg, details) {\n    super(msg, \"UnknownErrorException\");\n    this.details = details;\n  }\n}\nclass InvalidPDFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"InvalidPDFException\");\n  }\n}\nclass MissingPDFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"MissingPDFException\");\n  }\n}\nclass UnexpectedResponseException extends BaseException {\n  constructor(msg, status) {\n    super(msg, \"UnexpectedResponseException\");\n    this.status = status;\n  }\n}\nclass FormatError extends BaseException {\n  constructor(msg) {\n    super(msg, \"FormatError\");\n  }\n}\nclass AbortException extends BaseException {\n  constructor(msg) {\n    super(msg, \"AbortException\");\n  }\n}\nfunction bytesToString(bytes) {\n  if (typeof bytes !== \"object\" || bytes?.length === undefined) {\n    unreachable(\"Invalid argument for bytesToString\");\n  }\n  const length = bytes.length;\n  const MAX_ARGUMENT_COUNT = 8192;\n  if (length < MAX_ARGUMENT_COUNT) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n  const strBuf = [];\n  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\n    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n    const chunk = bytes.subarray(i, chunkEnd);\n    strBuf.push(String.fromCharCode.apply(null, chunk));\n  }\n  return strBuf.join(\"\");\n}\nfunction stringToBytes(str) {\n  if (typeof str !== \"string\") {\n    unreachable(\"Invalid argument for stringToBytes\");\n  }\n  const length = str.length;\n  const bytes = new Uint8Array(length);\n  for (let i = 0; i < length; ++i) {\n    bytes[i] = str.charCodeAt(i) & 0xff;\n  }\n  return bytes;\n}\nfunction string32(value) {\n  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n}\nfunction objectSize(obj) {\n  return Object.keys(obj).length;\n}\nfunction objectFromMap(map) {\n  const obj = Object.create(null);\n  for (const [key, value] of map) {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction isLittleEndian() {\n  const buffer8 = new Uint8Array(4);\n  buffer8[0] = 1;\n  const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n  return view32[0] === 1;\n}\nfunction isEvalSupported() {\n  try {\n    new Function(\"\");\n    return true;\n  } catch {\n    return false;\n  }\n}\nclass FeatureTest {\n  static get isLittleEndian() {\n    return shadow(this, \"isLittleEndian\", isLittleEndian());\n  }\n  static get isEvalSupported() {\n    return shadow(this, \"isEvalSupported\", isEvalSupported());\n  }\n  static get isOffscreenCanvasSupported() {\n    return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n  }\n  static get platform() {\n    if (typeof navigator !== \"undefined\" && typeof navigator?.platform === \"string\") {\n      return shadow(this, \"platform\", {\n        isMac: navigator.platform.includes(\"Mac\")\n      });\n    }\n    return shadow(this, \"platform\", {\n      isMac: false\n    });\n  }\n  static get isCSSRoundSupported() {\n    return shadow(this, \"isCSSRoundSupported\", globalThis.CSS?.supports?.(\"width: round(1.5px, 1px)\"));\n  }\n}\nconst hexNumbers = Array.from(Array(256).keys(), n => n.toString(16).padStart(2, \"0\"));\nclass Util {\n  static makeHexColor(r, g, b) {\n    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n  }\n  static scaleMinMax(transform, minMax) {\n    let temp;\n    if (transform[0]) {\n      if (transform[0] < 0) {\n        temp = minMax[0];\n        minMax[0] = minMax[2];\n        minMax[2] = temp;\n      }\n      minMax[0] *= transform[0];\n      minMax[2] *= transform[0];\n      if (transform[3] < 0) {\n        temp = minMax[1];\n        minMax[1] = minMax[3];\n        minMax[3] = temp;\n      }\n      minMax[1] *= transform[3];\n      minMax[3] *= transform[3];\n    } else {\n      temp = minMax[0];\n      minMax[0] = minMax[1];\n      minMax[1] = temp;\n      temp = minMax[2];\n      minMax[2] = minMax[3];\n      minMax[3] = temp;\n      if (transform[1] < 0) {\n        temp = minMax[1];\n        minMax[1] = minMax[3];\n        minMax[3] = temp;\n      }\n      minMax[1] *= transform[1];\n      minMax[3] *= transform[1];\n      if (transform[2] < 0) {\n        temp = minMax[0];\n        minMax[0] = minMax[2];\n        minMax[2] = temp;\n      }\n      minMax[0] *= transform[2];\n      minMax[2] *= transform[2];\n    }\n    minMax[0] += transform[4];\n    minMax[1] += transform[5];\n    minMax[2] += transform[4];\n    minMax[3] += transform[5];\n  }\n  static transform(m1, m2) {\n    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n  }\n  static applyTransform(p, m) {\n    const xt = p[0] * m[0] + p[1] * m[2] + m[4];\n    const yt = p[0] * m[1] + p[1] * m[3] + m[5];\n    return [xt, yt];\n  }\n  static applyInverseTransform(p, m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n    return [xt, yt];\n  }\n  static getAxialAlignedBoundingBox(r, m) {\n    const p1 = this.applyTransform(r, m);\n    const p2 = this.applyTransform(r.slice(2, 4), m);\n    const p3 = this.applyTransform([r[0], r[3]], m);\n    const p4 = this.applyTransform([r[2], r[1]], m);\n    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];\n  }\n  static inverseTransform(m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\n  }\n  static singularValueDecompose2dScale(m) {\n    const transpose = [m[0], m[2], m[1], m[3]];\n    const a = m[0] * transpose[0] + m[1] * transpose[2];\n    const b = m[0] * transpose[1] + m[1] * transpose[3];\n    const c = m[2] * transpose[0] + m[3] * transpose[2];\n    const d = m[2] * transpose[1] + m[3] * transpose[3];\n    const first = (a + d) / 2;\n    const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;\n    const sx = first + second || 1;\n    const sy = first - second || 1;\n    return [Math.sqrt(sx), Math.sqrt(sy)];\n  }\n  static normalizeRect(rect) {\n    const r = rect.slice(0);\n    if (rect[0] > rect[2]) {\n      r[0] = rect[2];\n      r[2] = rect[0];\n    }\n    if (rect[1] > rect[3]) {\n      r[1] = rect[3];\n      r[3] = rect[1];\n    }\n    return r;\n  }\n  static intersect(rect1, rect2) {\n    const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));\n    const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));\n    if (xLow > xHigh) {\n      return null;\n    }\n    const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));\n    const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));\n    if (yLow > yHigh) {\n      return null;\n    }\n    return [xLow, yLow, xHigh, yHigh];\n  }\n  static #getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, t, minMax) {\n    if (t <= 0 || t >= 1) {\n      return;\n    }\n    const mt = 1 - t;\n    const tt = t * t;\n    const ttt = tt * t;\n    const x = mt * (mt * (mt * x0 + 3 * t * x1) + 3 * tt * x2) + ttt * x3;\n    const y = mt * (mt * (mt * y0 + 3 * t * y1) + 3 * tt * y2) + ttt * y3;\n    minMax[0] = Math.min(minMax[0], x);\n    minMax[1] = Math.min(minMax[1], y);\n    minMax[2] = Math.max(minMax[2], x);\n    minMax[3] = Math.max(minMax[3], y);\n  }\n  static #getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, a, b, c, minMax) {\n    if (Math.abs(a) < 1e-12) {\n      if (Math.abs(b) >= 1e-12) {\n        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, -c / b, minMax);\n      }\n      return;\n    }\n    const delta = b ** 2 - 4 * c * a;\n    if (delta < 0) {\n      return;\n    }\n    const sqrtDelta = Math.sqrt(delta);\n    const a2 = 2 * a;\n    this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b + sqrtDelta) / a2, minMax);\n    this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b - sqrtDelta) / a2, minMax);\n  }\n  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n    if (minMax) {\n      minMax[0] = Math.min(minMax[0], x0, x3);\n      minMax[1] = Math.min(minMax[1], y0, y3);\n      minMax[2] = Math.max(minMax[2], x0, x3);\n      minMax[3] = Math.max(minMax[3], y0, y3);\n    } else {\n      minMax = [Math.min(x0, x3), Math.min(y0, y3), Math.max(x0, x3), Math.max(y0, y3)];\n    }\n    this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-x0 + 3 * (x1 - x2) + x3), 6 * (x0 - 2 * x1 + x2), 3 * (x1 - x0), minMax);\n    this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-y0 + 3 * (y1 - y2) + y3), 6 * (y0 - 2 * y1 + y2), 3 * (y1 - y0), minMax);\n    return minMax;\n  }\n}\nconst PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];\nfunction stringToPDFString(str) {\n  if (str[0] >= \"\\xEF\") {\n    let encoding;\n    if (str[0] === \"\\xFE\" && str[1] === \"\\xFF\") {\n      encoding = \"utf-16be\";\n      if (str.length % 2 === 1) {\n        str = str.slice(0, -1);\n      }\n    } else if (str[0] === \"\\xFF\" && str[1] === \"\\xFE\") {\n      encoding = \"utf-16le\";\n      if (str.length % 2 === 1) {\n        str = str.slice(0, -1);\n      }\n    } else if (str[0] === \"\\xEF\" && str[1] === \"\\xBB\" && str[2] === \"\\xBF\") {\n      encoding = \"utf-8\";\n    }\n    if (encoding) {\n      try {\n        const decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        const buffer = stringToBytes(str);\n        const decoded = decoder.decode(buffer);\n        if (!decoded.includes(\"\\x1b\")) {\n          return decoded;\n        }\n        return decoded.replaceAll(/\\x1b[^\\x1b]*(?:\\x1b|$)/g, \"\");\n      } catch (ex) {\n        warn(`stringToPDFString: \"${ex}\".`);\n      }\n    }\n  }\n  const strBuf = [];\n  for (let i = 0, ii = str.length; i < ii; i++) {\n    const charCode = str.charCodeAt(i);\n    if (charCode === 0x1b) {\n      while (++i < ii && str.charCodeAt(i) !== 0x1b) {}\n      continue;\n    }\n    const code = PDFStringTranslateTable[charCode];\n    strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n  }\n  return strBuf.join(\"\");\n}\nfunction stringToUTF8String(str) {\n  return decodeURIComponent(escape(str));\n}\nfunction utf8StringToString(str) {\n  return unescape(encodeURIComponent(str));\n}\nfunction isArrayEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (let i = 0, ii = arr1.length; i < ii; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getModificationDate(date = new Date()) {\n  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, \"0\"), date.getUTCDate().toString().padStart(2, \"0\"), date.getUTCHours().toString().padStart(2, \"0\"), date.getUTCMinutes().toString().padStart(2, \"0\"), date.getUTCSeconds().toString().padStart(2, \"0\")];\n  return buffer.join(\"\");\n}\nlet NormalizeRegex = null;\nlet NormalizationMap = null;\nfunction normalizeUnicode(str) {\n  if (!NormalizeRegex) {\n    NormalizeRegex = /([\\u00a0\\u00b5\\u037e\\u0eb3\\u2000-\\u200a\\u202f\\u2126\\ufb00-\\ufb04\\ufb06\\ufb20-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufba1\\ufba4-\\ufba9\\ufbae-\\ufbb1\\ufbd3-\\ufbdc\\ufbde-\\ufbe7\\ufbea-\\ufbf8\\ufbfc-\\ufbfd\\ufc00-\\ufc5d\\ufc64-\\ufcf1\\ufcf5-\\ufd3d\\ufd88\\ufdf4\\ufdfa-\\ufdfb\\ufe71\\ufe77\\ufe79\\ufe7b\\ufe7d]+)|(\\ufb05+)/gu;\n    NormalizationMap = new Map([[\"ﬅ\", \"ſt\"]]);\n  }\n  return str.replaceAll(NormalizeRegex, (_, p1, p2) => p1 ? p1.normalize(\"NFKC\") : NormalizationMap.get(p2));\n}\nfunction getUuid() {\n  if (typeof crypto !== \"undefined\" && typeof crypto?.randomUUID === \"function\") {\n    return crypto.randomUUID();\n  }\n  const buf = new Uint8Array(32);\n  if (typeof crypto !== \"undefined\" && typeof crypto?.getRandomValues === \"function\") {\n    crypto.getRandomValues(buf);\n  } else {\n    for (let i = 0; i < 32; i++) {\n      buf[i] = Math.floor(Math.random() * 255);\n    }\n  }\n  return bytesToString(buf);\n}\nconst AnnotationPrefix = \"pdfjs_internal_id_\";\nconst FontRenderOps = {\n  BEZIER_CURVE_TO: 0,\n  MOVE_TO: 1,\n  LINE_TO: 2,\n  QUADRATIC_CURVE_TO: 3,\n  RESTORE: 4,\n  SAVE: 5,\n  SCALE: 6,\n  TRANSFORM: 7,\n  TRANSLATE: 8\n};\n\n;// CONCATENATED MODULE: ./src/core/primitives.js\n\nconst CIRCULAR_REF = Symbol(\"CIRCULAR_REF\");\nconst EOF = Symbol(\"EOF\");\nlet CmdCache = Object.create(null);\nlet NameCache = Object.create(null);\nlet RefCache = Object.create(null);\nfunction clearPrimitiveCaches() {\n  CmdCache = Object.create(null);\n  NameCache = Object.create(null);\n  RefCache = Object.create(null);\n}\nclass Name {\n  constructor(name) {\n    this.name = name;\n  }\n  static get(name) {\n    return NameCache[name] ||= new Name(name);\n  }\n}\nclass Cmd {\n  constructor(cmd) {\n    this.cmd = cmd;\n  }\n  static get(cmd) {\n    return CmdCache[cmd] ||= new Cmd(cmd);\n  }\n}\nconst nonSerializable = function nonSerializableClosure() {\n  return nonSerializable;\n};\nclass Dict {\n  constructor(xref = null) {\n    this._map = Object.create(null);\n    this.xref = xref;\n    this.objId = null;\n    this.suppressEncryption = false;\n    this.__nonSerializable__ = nonSerializable;\n  }\n  assignXref(newXref) {\n    this.xref = newXref;\n  }\n  get size() {\n    return Object.keys(this._map).length;\n  }\n  get(key1, key2, key3) {\n    let value = this._map[key1];\n    if (value === undefined && key2 !== undefined) {\n      value = this._map[key2];\n      if (value === undefined && key3 !== undefined) {\n        value = this._map[key3];\n      }\n    }\n    if (value instanceof Ref && this.xref) {\n      return this.xref.fetch(value, this.suppressEncryption);\n    }\n    return value;\n  }\n  async getAsync(key1, key2, key3) {\n    let value = this._map[key1];\n    if (value === undefined && key2 !== undefined) {\n      value = this._map[key2];\n      if (value === undefined && key3 !== undefined) {\n        value = this._map[key3];\n      }\n    }\n    if (value instanceof Ref && this.xref) {\n      return this.xref.fetchAsync(value, this.suppressEncryption);\n    }\n    return value;\n  }\n  getArray(key1, key2, key3) {\n    let value = this._map[key1];\n    if (value === undefined && key2 !== undefined) {\n      value = this._map[key2];\n      if (value === undefined && key3 !== undefined) {\n        value = this._map[key3];\n      }\n    }\n    if (value instanceof Ref && this.xref) {\n      value = this.xref.fetch(value, this.suppressEncryption);\n    }\n    if (Array.isArray(value)) {\n      value = value.slice();\n      for (let i = 0, ii = value.length; i < ii; i++) {\n        if (value[i] instanceof Ref && this.xref) {\n          value[i] = this.xref.fetch(value[i], this.suppressEncryption);\n        }\n      }\n    }\n    return value;\n  }\n  getRaw(key) {\n    return this._map[key];\n  }\n  getKeys() {\n    return Object.keys(this._map);\n  }\n  getRawValues() {\n    return Object.values(this._map);\n  }\n  set(key, value) {\n    this._map[key] = value;\n  }\n  has(key) {\n    return this._map[key] !== undefined;\n  }\n  forEach(callback) {\n    for (const key in this._map) {\n      callback(key, this.get(key));\n    }\n  }\n  static get empty() {\n    const emptyDict = new Dict(null);\n    emptyDict.set = (key, value) => {\n      unreachable(\"Should not call `set` on the empty dictionary.\");\n    };\n    return shadow(this, \"empty\", emptyDict);\n  }\n  static merge({\n    xref,\n    dictArray,\n    mergeSubDicts = false\n  }) {\n    const mergedDict = new Dict(xref),\n      properties = new Map();\n    for (const dict of dictArray) {\n      if (!(dict instanceof Dict)) {\n        continue;\n      }\n      for (const [key, value] of Object.entries(dict._map)) {\n        let property = properties.get(key);\n        if (property === undefined) {\n          property = [];\n          properties.set(key, property);\n        } else if (!mergeSubDicts || !(value instanceof Dict)) {\n          continue;\n        }\n        property.push(value);\n      }\n    }\n    for (const [name, values] of properties) {\n      if (values.length === 1 || !(values[0] instanceof Dict)) {\n        mergedDict._map[name] = values[0];\n        continue;\n      }\n      const subDict = new Dict(xref);\n      for (const dict of values) {\n        for (const [key, value] of Object.entries(dict._map)) {\n          if (subDict._map[key] === undefined) {\n            subDict._map[key] = value;\n          }\n        }\n      }\n      if (subDict.size > 0) {\n        mergedDict._map[name] = subDict;\n      }\n    }\n    properties.clear();\n    return mergedDict.size > 0 ? mergedDict : Dict.empty;\n  }\n  clone() {\n    const dict = new Dict(this.xref);\n    for (const key of this.getKeys()) {\n      dict.set(key, this.getRaw(key));\n    }\n    return dict;\n  }\n}\nclass Ref {\n  constructor(num, gen) {\n    this.num = num;\n    this.gen = gen;\n  }\n  toString() {\n    if (this.gen === 0) {\n      return `${this.num}R`;\n    }\n    return `${this.num}R${this.gen}`;\n  }\n  static fromString(str) {\n    const ref = RefCache[str];\n    if (ref) {\n      return ref;\n    }\n    const m = /^(\\d+)R(\\d*)$/.exec(str);\n    if (!m || m[1] === \"0\") {\n      return null;\n    }\n    return RefCache[str] = new Ref(parseInt(m[1]), !m[2] ? 0 : parseInt(m[2]));\n  }\n  static get(num, gen) {\n    const key = gen === 0 ? `${num}R` : `${num}R${gen}`;\n    return RefCache[key] ||= new Ref(num, gen);\n  }\n}\nclass RefSet {\n  constructor(parent = null) {\n    this._set = new Set(parent?._set);\n  }\n  has(ref) {\n    return this._set.has(ref.toString());\n  }\n  put(ref) {\n    this._set.add(ref.toString());\n  }\n  remove(ref) {\n    this._set.delete(ref.toString());\n  }\n  [Symbol.iterator]() {\n    return this._set.values();\n  }\n  clear() {\n    this._set.clear();\n  }\n}\nclass RefSetCache {\n  constructor() {\n    this._map = new Map();\n  }\n  get size() {\n    return this._map.size;\n  }\n  get(ref) {\n    return this._map.get(ref.toString());\n  }\n  has(ref) {\n    return this._map.has(ref.toString());\n  }\n  put(ref, obj) {\n    this._map.set(ref.toString(), obj);\n  }\n  putAlias(ref, aliasRef) {\n    this._map.set(ref.toString(), this.get(aliasRef));\n  }\n  [Symbol.iterator]() {\n    return this._map.values();\n  }\n  clear() {\n    this._map.clear();\n  }\n  *items() {\n    for (const [ref, value] of this._map) {\n      yield [Ref.fromString(ref), value];\n    }\n  }\n}\nfunction isName(v, name) {\n  return v instanceof Name && (name === undefined || v.name === name);\n}\nfunction isCmd(v, cmd) {\n  return v instanceof Cmd && (cmd === undefined || v.cmd === cmd);\n}\nfunction isDict(v, type) {\n  return v instanceof Dict && (type === undefined || isName(v.get(\"Type\"), type));\n}\nfunction isRefsEqual(v1, v2) {\n  return v1.num === v2.num && v1.gen === v2.gen;\n}\n\n;// CONCATENATED MODULE: ./src/core/base_stream.js\n\nclass BaseStream {\n  constructor() {\n    if (this.constructor === BaseStream) {\n      unreachable(\"Cannot initialize BaseStream.\");\n    }\n  }\n  get length() {\n    unreachable(\"Abstract getter `length` accessed\");\n  }\n  get isEmpty() {\n    unreachable(\"Abstract getter `isEmpty` accessed\");\n  }\n  get isDataLoaded() {\n    return shadow(this, \"isDataLoaded\", true);\n  }\n  getByte() {\n    unreachable(\"Abstract method `getByte` called\");\n  }\n  getBytes(length) {\n    unreachable(\"Abstract method `getBytes` called\");\n  }\n  peekByte() {\n    const peekedByte = this.getByte();\n    if (peekedByte !== -1) {\n      this.pos--;\n    }\n    return peekedByte;\n  }\n  peekBytes(length) {\n    const bytes = this.getBytes(length);\n    this.pos -= bytes.length;\n    return bytes;\n  }\n  getUint16() {\n    const b0 = this.getByte();\n    const b1 = this.getByte();\n    if (b0 === -1 || b1 === -1) {\n      return -1;\n    }\n    return (b0 << 8) + b1;\n  }\n  getInt32() {\n    const b0 = this.getByte();\n    const b1 = this.getByte();\n    const b2 = this.getByte();\n    const b3 = this.getByte();\n    return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;\n  }\n  getByteRange(begin, end) {\n    unreachable(\"Abstract method `getByteRange` called\");\n  }\n  getString(length) {\n    return bytesToString(this.getBytes(length));\n  }\n  skip(n) {\n    this.pos += n || 1;\n  }\n  reset() {\n    unreachable(\"Abstract method `reset` called\");\n  }\n  moveStart() {\n    unreachable(\"Abstract method `moveStart` called\");\n  }\n  makeSubStream(start, length, dict = null) {\n    unreachable(\"Abstract method `makeSubStream` called\");\n  }\n  getBaseStreams() {\n    return null;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/core_utils.js\n\n\n\nconst PDF_VERSION_REGEXP = /^[1-9]\\.\\d$/;\nfunction getLookupTableFactory(initializer) {\n  let lookup;\n  return function () {\n    if (initializer) {\n      lookup = Object.create(null);\n      initializer(lookup);\n      initializer = null;\n    }\n    return lookup;\n  };\n}\nclass MissingDataException extends BaseException {\n  constructor(begin, end) {\n    super(`Missing data [${begin}, ${end})`, \"MissingDataException\");\n    this.begin = begin;\n    this.end = end;\n  }\n}\nclass ParserEOFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"ParserEOFException\");\n  }\n}\nclass XRefEntryException extends BaseException {\n  constructor(msg) {\n    super(msg, \"XRefEntryException\");\n  }\n}\nclass XRefParseException extends BaseException {\n  constructor(msg) {\n    super(msg, \"XRefParseException\");\n  }\n}\nfunction arrayBuffersToBytes(arr) {\n  const length = arr.length;\n  if (length === 0) {\n    return new Uint8Array(0);\n  }\n  if (length === 1) {\n    return new Uint8Array(arr[0]);\n  }\n  let dataLength = 0;\n  for (let i = 0; i < length; i++) {\n    dataLength += arr[i].byteLength;\n  }\n  const data = new Uint8Array(dataLength);\n  let pos = 0;\n  for (let i = 0; i < length; i++) {\n    const item = new Uint8Array(arr[i]);\n    data.set(item, pos);\n    pos += item.byteLength;\n  }\n  return data;\n}\nfunction getInheritableProperty({\n  dict,\n  key,\n  getArray = false,\n  stopWhenFound = true\n}) {\n  let values;\n  const visited = new RefSet();\n  while (dict instanceof Dict && !(dict.objId && visited.has(dict.objId))) {\n    if (dict.objId) {\n      visited.put(dict.objId);\n    }\n    const value = getArray ? dict.getArray(key) : dict.get(key);\n    if (value !== undefined) {\n      if (stopWhenFound) {\n        return value;\n      }\n      (values ||= []).push(value);\n    }\n    dict = dict.get(\"Parent\");\n  }\n  return values;\n}\nconst ROMAN_NUMBER_MAP = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", \"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\", \"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\nfunction toRomanNumerals(number, lowerCase = false) {\n  assert(Number.isInteger(number) && number > 0, \"The number should be a positive integer.\");\n  const romanBuf = [];\n  let pos;\n  while (number >= 1000) {\n    number -= 1000;\n    romanBuf.push(\"M\");\n  }\n  pos = number / 100 | 0;\n  number %= 100;\n  romanBuf.push(ROMAN_NUMBER_MAP[pos]);\n  pos = number / 10 | 0;\n  number %= 10;\n  romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);\n  romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);\n  const romanStr = romanBuf.join(\"\");\n  return lowerCase ? romanStr.toLowerCase() : romanStr;\n}\nfunction log2(x) {\n  if (x <= 0) {\n    return 0;\n  }\n  return Math.ceil(Math.log2(x));\n}\nfunction readInt8(data, offset) {\n  return data[offset] << 24 >> 24;\n}\nfunction readUint16(data, offset) {\n  return data[offset] << 8 | data[offset + 1];\n}\nfunction readUint32(data, offset) {\n  return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;\n}\nfunction isWhiteSpace(ch) {\n  return ch === 0x20 || ch === 0x09 || ch === 0x0d || ch === 0x0a;\n}\nfunction isNumberArray(arr, len) {\n  return Array.isArray(arr) && (len === null || arr.length === len) && arr.every(x => typeof x === \"number\");\n}\nfunction parseXFAPath(path) {\n  const positionPattern = /(.+)\\[(\\d+)\\]$/;\n  return path.split(\".\").map(component => {\n    const m = component.match(positionPattern);\n    if (m) {\n      return {\n        name: m[1],\n        pos: parseInt(m[2], 10)\n      };\n    }\n    return {\n      name: component,\n      pos: 0\n    };\n  });\n}\nfunction escapePDFName(str) {\n  const buffer = [];\n  let start = 0;\n  for (let i = 0, ii = str.length; i < ii; i++) {\n    const char = str.charCodeAt(i);\n    if (char < 0x21 || char > 0x7e || char === 0x23 || char === 0x28 || char === 0x29 || char === 0x3c || char === 0x3e || char === 0x5b || char === 0x5d || char === 0x7b || char === 0x7d || char === 0x2f || char === 0x25) {\n      if (start < i) {\n        buffer.push(str.substring(start, i));\n      }\n      buffer.push(`#${char.toString(16)}`);\n      start = i + 1;\n    }\n  }\n  if (buffer.length === 0) {\n    return str;\n  }\n  if (start < str.length) {\n    buffer.push(str.substring(start, str.length));\n  }\n  return buffer.join(\"\");\n}\nfunction escapeString(str) {\n  return str.replaceAll(/([()\\\\\\n\\r])/g, match => {\n    if (match === \"\\n\") {\n      return \"\\\\n\";\n    } else if (match === \"\\r\") {\n      return \"\\\\r\";\n    }\n    return `\\\\${match}`;\n  });\n}\nfunction _collectJS(entry, xref, list, parents) {\n  if (!entry) {\n    return;\n  }\n  let parent = null;\n  if (entry instanceof Ref) {\n    if (parents.has(entry)) {\n      return;\n    }\n    parent = entry;\n    parents.put(parent);\n    entry = xref.fetch(entry);\n  }\n  if (Array.isArray(entry)) {\n    for (const element of entry) {\n      _collectJS(element, xref, list, parents);\n    }\n  } else if (entry instanceof Dict) {\n    if (isName(entry.get(\"S\"), \"JavaScript\")) {\n      const js = entry.get(\"JS\");\n      let code;\n      if (js instanceof BaseStream) {\n        code = js.getString();\n      } else if (typeof js === \"string\") {\n        code = js;\n      }\n      code &&= stringToPDFString(code).replaceAll(\"\\x00\", \"\");\n      if (code) {\n        list.push(code);\n      }\n    }\n    _collectJS(entry.getRaw(\"Next\"), xref, list, parents);\n  }\n  if (parent) {\n    parents.remove(parent);\n  }\n}\nfunction collectActions(xref, dict, eventType) {\n  const actions = Object.create(null);\n  const additionalActionsDicts = getInheritableProperty({\n    dict,\n    key: \"AA\",\n    stopWhenFound: false\n  });\n  if (additionalActionsDicts) {\n    for (let i = additionalActionsDicts.length - 1; i >= 0; i--) {\n      const additionalActions = additionalActionsDicts[i];\n      if (!(additionalActions instanceof Dict)) {\n        continue;\n      }\n      for (const key of additionalActions.getKeys()) {\n        const action = eventType[key];\n        if (!action) {\n          continue;\n        }\n        const actionDict = additionalActions.getRaw(key);\n        const parents = new RefSet();\n        const list = [];\n        _collectJS(actionDict, xref, list, parents);\n        if (list.length > 0) {\n          actions[action] = list;\n        }\n      }\n    }\n  }\n  if (dict.has(\"A\")) {\n    const actionDict = dict.get(\"A\");\n    const parents = new RefSet();\n    const list = [];\n    _collectJS(actionDict, xref, list, parents);\n    if (list.length > 0) {\n      actions.Action = list;\n    }\n  }\n  return objectSize(actions) > 0 ? actions : null;\n}\nconst XMLEntities = {\n  0x3c: \"&lt;\",\n  0x3e: \"&gt;\",\n  0x26: \"&amp;\",\n  0x22: \"&quot;\",\n  0x27: \"&apos;\"\n};\nfunction* codePointIter(str) {\n  for (let i = 0, ii = str.length; i < ii; i++) {\n    const char = str.codePointAt(i);\n    if (char > 0xd7ff && (char < 0xe000 || char > 0xfffd)) {\n      i++;\n    }\n    yield char;\n  }\n}\nfunction encodeToXmlString(str) {\n  const buffer = [];\n  let start = 0;\n  for (let i = 0, ii = str.length; i < ii; i++) {\n    const char = str.codePointAt(i);\n    if (0x20 <= char && char <= 0x7e) {\n      const entity = XMLEntities[char];\n      if (entity) {\n        if (start < i) {\n          buffer.push(str.substring(start, i));\n        }\n        buffer.push(entity);\n        start = i + 1;\n      }\n    } else {\n      if (start < i) {\n        buffer.push(str.substring(start, i));\n      }\n      buffer.push(`&#x${char.toString(16).toUpperCase()};`);\n      if (char > 0xd7ff && (char < 0xe000 || char > 0xfffd)) {\n        i++;\n      }\n      start = i + 1;\n    }\n  }\n  if (buffer.length === 0) {\n    return str;\n  }\n  if (start < str.length) {\n    buffer.push(str.substring(start, str.length));\n  }\n  return buffer.join(\"\");\n}\nfunction validateFontName(fontFamily, mustWarn = false) {\n  const m = /^(\"|').*(\"|')$/.exec(fontFamily);\n  if (m && m[1] === m[2]) {\n    const re = new RegExp(`[^\\\\\\\\]${m[1]}`);\n    if (re.test(fontFamily.slice(1, -1))) {\n      if (mustWarn) {\n        warn(`FontFamily contains unescaped ${m[1]}: ${fontFamily}.`);\n      }\n      return false;\n    }\n  } else {\n    for (const ident of fontFamily.split(/[ \\t]+/)) {\n      if (/^(\\d|(-(\\d|-)))/.test(ident) || !/^[\\w-\\\\]+$/.test(ident)) {\n        if (mustWarn) {\n          warn(`FontFamily contains invalid <custom-ident>: ${fontFamily}.`);\n        }\n        return false;\n      }\n    }\n  }\n  return true;\n}\nfunction validateCSSFont(cssFontInfo) {\n  const DEFAULT_CSS_FONT_OBLIQUE = \"14\";\n  const DEFAULT_CSS_FONT_WEIGHT = \"400\";\n  const CSS_FONT_WEIGHT_VALUES = new Set([\"100\", \"200\", \"300\", \"400\", \"500\", \"600\", \"700\", \"800\", \"900\", \"1000\", \"normal\", \"bold\", \"bolder\", \"lighter\"]);\n  const {\n    fontFamily,\n    fontWeight,\n    italicAngle\n  } = cssFontInfo;\n  if (!validateFontName(fontFamily, true)) {\n    return false;\n  }\n  const weight = fontWeight ? fontWeight.toString() : \"\";\n  cssFontInfo.fontWeight = CSS_FONT_WEIGHT_VALUES.has(weight) ? weight : DEFAULT_CSS_FONT_WEIGHT;\n  const angle = parseFloat(italicAngle);\n  cssFontInfo.italicAngle = isNaN(angle) || angle < -90 || angle > 90 ? DEFAULT_CSS_FONT_OBLIQUE : italicAngle.toString();\n  return true;\n}\nfunction recoverJsURL(str) {\n  const URL_OPEN_METHODS = [\"app.launchURL\", \"window.open\", \"xfa.host.gotoURL\"];\n  const regex = new RegExp(\"^\\\\s*(\" + URL_OPEN_METHODS.join(\"|\").replaceAll(\".\", \"\\\\.\") + \")\\\\((?:'|\\\")([^'\\\"]*)(?:'|\\\")(?:,\\\\s*(\\\\w+)\\\\)|\\\\))\", \"i\");\n  const jsUrl = regex.exec(str);\n  if (jsUrl?.[2]) {\n    const url = jsUrl[2];\n    let newWindow = false;\n    if (jsUrl[3] === \"true\" && jsUrl[1] === \"app.launchURL\") {\n      newWindow = true;\n    }\n    return {\n      url,\n      newWindow\n    };\n  }\n  return null;\n}\nfunction numberToString(value) {\n  if (Number.isInteger(value)) {\n    return value.toString();\n  }\n  const roundedValue = Math.round(value * 100);\n  if (roundedValue % 100 === 0) {\n    return (roundedValue / 100).toString();\n  }\n  if (roundedValue % 10 === 0) {\n    return value.toFixed(1);\n  }\n  return value.toFixed(2);\n}\nfunction getNewAnnotationsMap(annotationStorage) {\n  if (!annotationStorage) {\n    return null;\n  }\n  const newAnnotationsByPage = new Map();\n  for (const [key, value] of annotationStorage) {\n    if (!key.startsWith(AnnotationEditorPrefix)) {\n      continue;\n    }\n    let annotations = newAnnotationsByPage.get(value.pageIndex);\n    if (!annotations) {\n      annotations = [];\n      newAnnotationsByPage.set(value.pageIndex, annotations);\n    }\n    annotations.push(value);\n  }\n  return newAnnotationsByPage.size > 0 ? newAnnotationsByPage : null;\n}\nfunction isAscii(str) {\n  return /^[\\x00-\\x7F]*$/.test(str);\n}\nfunction stringToUTF16HexString(str) {\n  const buf = [];\n  for (let i = 0, ii = str.length; i < ii; i++) {\n    const char = str.charCodeAt(i);\n    buf.push((char >> 8 & 0xff).toString(16).padStart(2, \"0\"), (char & 0xff).toString(16).padStart(2, \"0\"));\n  }\n  return buf.join(\"\");\n}\nfunction stringToUTF16String(str, bigEndian = false) {\n  const buf = [];\n  if (bigEndian) {\n    buf.push(\"\\xFE\\xFF\");\n  }\n  for (let i = 0, ii = str.length; i < ii; i++) {\n    const char = str.charCodeAt(i);\n    buf.push(String.fromCharCode(char >> 8 & 0xff), String.fromCharCode(char & 0xff));\n  }\n  return buf.join(\"\");\n}\nfunction getRotationMatrix(rotation, width, height) {\n  switch (rotation) {\n    case 90:\n      return [0, 1, -1, 0, width, 0];\n    case 180:\n      return [-1, 0, 0, -1, width, height];\n    case 270:\n      return [0, -1, 1, 0, 0, height];\n    default:\n      throw new Error(\"Invalid rotation\");\n  }\n}\nfunction getSizeInBytes(x) {\n  return Math.ceil(Math.ceil(Math.log2(1 + x)) / 8);\n}\n\n;// CONCATENATED MODULE: ./src/core/stream.js\n\n\nclass Stream extends BaseStream {\n  constructor(arrayBuffer, start, length, dict) {\n    super();\n    this.bytes = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);\n    this.start = start || 0;\n    this.pos = this.start;\n    this.end = start + length || this.bytes.length;\n    this.dict = dict;\n  }\n  get length() {\n    return this.end - this.start;\n  }\n  get isEmpty() {\n    return this.length === 0;\n  }\n  getByte() {\n    if (this.pos >= this.end) {\n      return -1;\n    }\n    return this.bytes[this.pos++];\n  }\n  getBytes(length) {\n    const bytes = this.bytes;\n    const pos = this.pos;\n    const strEnd = this.end;\n    if (!length) {\n      return bytes.subarray(pos, strEnd);\n    }\n    let end = pos + length;\n    if (end > strEnd) {\n      end = strEnd;\n    }\n    this.pos = end;\n    return bytes.subarray(pos, end);\n  }\n  getByteRange(begin, end) {\n    if (begin < 0) {\n      begin = 0;\n    }\n    if (end > this.end) {\n      end = this.end;\n    }\n    return this.bytes.subarray(begin, end);\n  }\n  reset() {\n    this.pos = this.start;\n  }\n  moveStart() {\n    this.start = this.pos;\n  }\n  makeSubStream(start, length, dict = null) {\n    return new Stream(this.bytes.buffer, start, length, dict);\n  }\n}\nclass StringStream extends Stream {\n  constructor(str) {\n    super(stringToBytes(str));\n  }\n}\nclass NullStream extends Stream {\n  constructor() {\n    super(new Uint8Array(0));\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/chunked_stream.js\n\n\n\nclass ChunkedStream extends Stream {\n  constructor(length, chunkSize, manager) {\n    super(new Uint8Array(length), 0, length, null);\n    this.chunkSize = chunkSize;\n    this._loadedChunks = new Set();\n    this.numChunks = Math.ceil(length / chunkSize);\n    this.manager = manager;\n    this.progressiveDataLength = 0;\n    this.lastSuccessfulEnsureByteChunk = -1;\n  }\n  getMissingChunks() {\n    const chunks = [];\n    for (let chunk = 0, n = this.numChunks; chunk < n; ++chunk) {\n      if (!this._loadedChunks.has(chunk)) {\n        chunks.push(chunk);\n      }\n    }\n    return chunks;\n  }\n  get numChunksLoaded() {\n    return this._loadedChunks.size;\n  }\n  get isDataLoaded() {\n    return this.numChunksLoaded === this.numChunks;\n  }\n  onReceiveData(begin, chunk) {\n    const chunkSize = this.chunkSize;\n    if (begin % chunkSize !== 0) {\n      throw new Error(`Bad begin offset: ${begin}`);\n    }\n    const end = begin + chunk.byteLength;\n    if (end % chunkSize !== 0 && end !== this.bytes.length) {\n      throw new Error(`Bad end offset: ${end}`);\n    }\n    this.bytes.set(new Uint8Array(chunk), begin);\n    const beginChunk = Math.floor(begin / chunkSize);\n    const endChunk = Math.floor((end - 1) / chunkSize) + 1;\n    for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {\n      this._loadedChunks.add(curChunk);\n    }\n  }\n  onReceiveProgressiveData(data) {\n    let position = this.progressiveDataLength;\n    const beginChunk = Math.floor(position / this.chunkSize);\n    this.bytes.set(new Uint8Array(data), position);\n    position += data.byteLength;\n    this.progressiveDataLength = position;\n    const endChunk = position >= this.end ? this.numChunks : Math.floor(position / this.chunkSize);\n    for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {\n      this._loadedChunks.add(curChunk);\n    }\n  }\n  ensureByte(pos) {\n    if (pos < this.progressiveDataLength) {\n      return;\n    }\n    const chunk = Math.floor(pos / this.chunkSize);\n    if (chunk > this.numChunks) {\n      return;\n    }\n    if (chunk === this.lastSuccessfulEnsureByteChunk) {\n      return;\n    }\n    if (!this._loadedChunks.has(chunk)) {\n      throw new MissingDataException(pos, pos + 1);\n    }\n    this.lastSuccessfulEnsureByteChunk = chunk;\n  }\n  ensureRange(begin, end) {\n    if (begin >= end) {\n      return;\n    }\n    if (end <= this.progressiveDataLength) {\n      return;\n    }\n    const beginChunk = Math.floor(begin / this.chunkSize);\n    if (beginChunk > this.numChunks) {\n      return;\n    }\n    const endChunk = Math.min(Math.floor((end - 1) / this.chunkSize) + 1, this.numChunks);\n    for (let chunk = beginChunk; chunk < endChunk; ++chunk) {\n      if (!this._loadedChunks.has(chunk)) {\n        throw new MissingDataException(begin, end);\n      }\n    }\n  }\n  nextEmptyChunk(beginChunk) {\n    const numChunks = this.numChunks;\n    for (let i = 0; i < numChunks; ++i) {\n      const chunk = (beginChunk + i) % numChunks;\n      if (!this._loadedChunks.has(chunk)) {\n        return chunk;\n      }\n    }\n    return null;\n  }\n  hasChunk(chunk) {\n    return this._loadedChunks.has(chunk);\n  }\n  getByte() {\n    const pos = this.pos;\n    if (pos >= this.end) {\n      return -1;\n    }\n    if (pos >= this.progressiveDataLength) {\n      this.ensureByte(pos);\n    }\n    return this.bytes[this.pos++];\n  }\n  getBytes(length) {\n    const bytes = this.bytes;\n    const pos = this.pos;\n    const strEnd = this.end;\n    if (!length) {\n      if (strEnd > this.progressiveDataLength) {\n        this.ensureRange(pos, strEnd);\n      }\n      return bytes.subarray(pos, strEnd);\n    }\n    let end = pos + length;\n    if (end > strEnd) {\n      end = strEnd;\n    }\n    if (end > this.progressiveDataLength) {\n      this.ensureRange(pos, end);\n    }\n    this.pos = end;\n    return bytes.subarray(pos, end);\n  }\n  getByteRange(begin, end) {\n    if (begin < 0) {\n      begin = 0;\n    }\n    if (end > this.end) {\n      end = this.end;\n    }\n    if (end > this.progressiveDataLength) {\n      this.ensureRange(begin, end);\n    }\n    return this.bytes.subarray(begin, end);\n  }\n  makeSubStream(start, length, dict = null) {\n    if (length) {\n      if (start + length > this.progressiveDataLength) {\n        this.ensureRange(start, start + length);\n      }\n    } else if (start >= this.progressiveDataLength) {\n      this.ensureByte(start);\n    }\n    function ChunkedStreamSubstream() {}\n    ChunkedStreamSubstream.prototype = Object.create(this);\n    ChunkedStreamSubstream.prototype.getMissingChunks = function () {\n      const chunkSize = this.chunkSize;\n      const beginChunk = Math.floor(this.start / chunkSize);\n      const endChunk = Math.floor((this.end - 1) / chunkSize) + 1;\n      const missingChunks = [];\n      for (let chunk = beginChunk; chunk < endChunk; ++chunk) {\n        if (!this._loadedChunks.has(chunk)) {\n          missingChunks.push(chunk);\n        }\n      }\n      return missingChunks;\n    };\n    Object.defineProperty(ChunkedStreamSubstream.prototype, \"isDataLoaded\", {\n      get() {\n        if (this.numChunksLoaded === this.numChunks) {\n          return true;\n        }\n        return this.getMissingChunks().length === 0;\n      },\n      configurable: true\n    });\n    const subStream = new ChunkedStreamSubstream();\n    subStream.pos = subStream.start = start;\n    subStream.end = start + length || this.end;\n    subStream.dict = dict;\n    return subStream;\n  }\n  getBaseStreams() {\n    return [this];\n  }\n}\nclass ChunkedStreamManager {\n  constructor(pdfNetworkStream, args) {\n    this.length = args.length;\n    this.chunkSize = args.rangeChunkSize;\n    this.stream = new ChunkedStream(this.length, this.chunkSize, this);\n    this.pdfNetworkStream = pdfNetworkStream;\n    this.disableAutoFetch = args.disableAutoFetch;\n    this.msgHandler = args.msgHandler;\n    this.currRequestId = 0;\n    this._chunksNeededByRequest = new Map();\n    this._requestsByChunk = new Map();\n    this._promisesByRequest = new Map();\n    this.progressiveDataLength = 0;\n    this.aborted = false;\n    this._loadedStreamCapability = Promise.withResolvers();\n  }\n  sendRequest(begin, end) {\n    const rangeReader = this.pdfNetworkStream.getRangeReader(begin, end);\n    if (!rangeReader.isStreamingSupported) {\n      rangeReader.onProgress = this.onProgress.bind(this);\n    }\n    let chunks = [],\n      loaded = 0;\n    return new Promise((resolve, reject) => {\n      const readChunk = ({\n        value,\n        done\n      }) => {\n        try {\n          if (done) {\n            const chunkData = arrayBuffersToBytes(chunks);\n            chunks = null;\n            resolve(chunkData);\n            return;\n          }\n          loaded += value.byteLength;\n          if (rangeReader.isStreamingSupported) {\n            this.onProgress({\n              loaded\n            });\n          }\n          chunks.push(value);\n          rangeReader.read().then(readChunk, reject);\n        } catch (e) {\n          reject(e);\n        }\n      };\n      rangeReader.read().then(readChunk, reject);\n    }).then(data => {\n      if (this.aborted) {\n        return;\n      }\n      this.onReceiveData({\n        chunk: data,\n        begin\n      });\n    });\n  }\n  requestAllChunks(noFetch = false) {\n    if (!noFetch) {\n      const missingChunks = this.stream.getMissingChunks();\n      this._requestChunks(missingChunks);\n    }\n    return this._loadedStreamCapability.promise;\n  }\n  _requestChunks(chunks) {\n    const requestId = this.currRequestId++;\n    const chunksNeeded = new Set();\n    this._chunksNeededByRequest.set(requestId, chunksNeeded);\n    for (const chunk of chunks) {\n      if (!this.stream.hasChunk(chunk)) {\n        chunksNeeded.add(chunk);\n      }\n    }\n    if (chunksNeeded.size === 0) {\n      return Promise.resolve();\n    }\n    const capability = Promise.withResolvers();\n    this._promisesByRequest.set(requestId, capability);\n    const chunksToRequest = [];\n    for (const chunk of chunksNeeded) {\n      let requestIds = this._requestsByChunk.get(chunk);\n      if (!requestIds) {\n        requestIds = [];\n        this._requestsByChunk.set(chunk, requestIds);\n        chunksToRequest.push(chunk);\n      }\n      requestIds.push(requestId);\n    }\n    if (chunksToRequest.length > 0) {\n      const groupedChunksToRequest = this.groupChunks(chunksToRequest);\n      for (const groupedChunk of groupedChunksToRequest) {\n        const begin = groupedChunk.beginChunk * this.chunkSize;\n        const end = Math.min(groupedChunk.endChunk * this.chunkSize, this.length);\n        this.sendRequest(begin, end).catch(capability.reject);\n      }\n    }\n    return capability.promise.catch(reason => {\n      if (this.aborted) {\n        return;\n      }\n      throw reason;\n    });\n  }\n  getStream() {\n    return this.stream;\n  }\n  requestRange(begin, end) {\n    end = Math.min(end, this.length);\n    const beginChunk = this.getBeginChunk(begin);\n    const endChunk = this.getEndChunk(end);\n    const chunks = [];\n    for (let chunk = beginChunk; chunk < endChunk; ++chunk) {\n      chunks.push(chunk);\n    }\n    return this._requestChunks(chunks);\n  }\n  requestRanges(ranges = []) {\n    const chunksToRequest = [];\n    for (const range of ranges) {\n      const beginChunk = this.getBeginChunk(range.begin);\n      const endChunk = this.getEndChunk(range.end);\n      for (let chunk = beginChunk; chunk < endChunk; ++chunk) {\n        if (!chunksToRequest.includes(chunk)) {\n          chunksToRequest.push(chunk);\n        }\n      }\n    }\n    chunksToRequest.sort(function (a, b) {\n      return a - b;\n    });\n    return this._requestChunks(chunksToRequest);\n  }\n  groupChunks(chunks) {\n    const groupedChunks = [];\n    let beginChunk = -1;\n    let prevChunk = -1;\n    for (let i = 0, ii = chunks.length; i < ii; ++i) {\n      const chunk = chunks[i];\n      if (beginChunk < 0) {\n        beginChunk = chunk;\n      }\n      if (prevChunk >= 0 && prevChunk + 1 !== chunk) {\n        groupedChunks.push({\n          beginChunk,\n          endChunk: prevChunk + 1\n        });\n        beginChunk = chunk;\n      }\n      if (i + 1 === chunks.length) {\n        groupedChunks.push({\n          beginChunk,\n          endChunk: chunk + 1\n        });\n      }\n      prevChunk = chunk;\n    }\n    return groupedChunks;\n  }\n  onProgress(args) {\n    this.msgHandler.send(\"DocProgress\", {\n      loaded: this.stream.numChunksLoaded * this.chunkSize + args.loaded,\n      total: this.length\n    });\n  }\n  onReceiveData(args) {\n    const chunk = args.chunk;\n    const isProgressive = args.begin === undefined;\n    const begin = isProgressive ? this.progressiveDataLength : args.begin;\n    const end = begin + chunk.byteLength;\n    const beginChunk = Math.floor(begin / this.chunkSize);\n    const endChunk = end < this.length ? Math.floor(end / this.chunkSize) : Math.ceil(end / this.chunkSize);\n    if (isProgressive) {\n      this.stream.onReceiveProgressiveData(chunk);\n      this.progressiveDataLength = end;\n    } else {\n      this.stream.onReceiveData(begin, chunk);\n    }\n    if (this.stream.isDataLoaded) {\n      this._loadedStreamCapability.resolve(this.stream);\n    }\n    const loadedRequests = [];\n    for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {\n      const requestIds = this._requestsByChunk.get(curChunk);\n      if (!requestIds) {\n        continue;\n      }\n      this._requestsByChunk.delete(curChunk);\n      for (const requestId of requestIds) {\n        const chunksNeeded = this._chunksNeededByRequest.get(requestId);\n        if (chunksNeeded.has(curChunk)) {\n          chunksNeeded.delete(curChunk);\n        }\n        if (chunksNeeded.size > 0) {\n          continue;\n        }\n        loadedRequests.push(requestId);\n      }\n    }\n    if (!this.disableAutoFetch && this._requestsByChunk.size === 0) {\n      let nextEmptyChunk;\n      if (this.stream.numChunksLoaded === 1) {\n        const lastChunk = this.stream.numChunks - 1;\n        if (!this.stream.hasChunk(lastChunk)) {\n          nextEmptyChunk = lastChunk;\n        }\n      } else {\n        nextEmptyChunk = this.stream.nextEmptyChunk(endChunk);\n      }\n      if (Number.isInteger(nextEmptyChunk)) {\n        this._requestChunks([nextEmptyChunk]);\n      }\n    }\n    for (const requestId of loadedRequests) {\n      const capability = this._promisesByRequest.get(requestId);\n      this._promisesByRequest.delete(requestId);\n      capability.resolve();\n    }\n    this.msgHandler.send(\"DocProgress\", {\n      loaded: this.stream.numChunksLoaded * this.chunkSize,\n      total: this.length\n    });\n  }\n  onError(err) {\n    this._loadedStreamCapability.reject(err);\n  }\n  getBeginChunk(begin) {\n    return Math.floor(begin / this.chunkSize);\n  }\n  getEndChunk(end) {\n    return Math.floor((end - 1) / this.chunkSize) + 1;\n  }\n  abort(reason) {\n    this.aborted = true;\n    this.pdfNetworkStream?.cancelAllRequests(reason);\n    for (const capability of this._promisesByRequest.values()) {\n      capability.reject(reason);\n    }\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/colorspace.js\n\n\n\n\nfunction resizeRgbImage(src, dest, w1, h1, w2, h2, alpha01) {\n  const COMPONENTS = 3;\n  alpha01 = alpha01 !== 1 ? 0 : alpha01;\n  const xRatio = w1 / w2;\n  const yRatio = h1 / h2;\n  let newIndex = 0,\n    oldIndex;\n  const xScaled = new Uint16Array(w2);\n  const w1Scanline = w1 * COMPONENTS;\n  for (let i = 0; i < w2; i++) {\n    xScaled[i] = Math.floor(i * xRatio) * COMPONENTS;\n  }\n  for (let i = 0; i < h2; i++) {\n    const py = Math.floor(i * yRatio) * w1Scanline;\n    for (let j = 0; j < w2; j++) {\n      oldIndex = py + xScaled[j];\n      dest[newIndex++] = src[oldIndex++];\n      dest[newIndex++] = src[oldIndex++];\n      dest[newIndex++] = src[oldIndex++];\n      newIndex += alpha01;\n    }\n  }\n}\nclass ColorSpace {\n  constructor(name, numComps) {\n    if (this.constructor === ColorSpace) {\n      unreachable(\"Cannot initialize ColorSpace.\");\n    }\n    this.name = name;\n    this.numComps = numComps;\n  }\n  getRgb(src, srcOffset) {\n    const rgb = new Uint8ClampedArray(3);\n    this.getRgbItem(src, srcOffset, rgb, 0);\n    return rgb;\n  }\n  getRgbItem(src, srcOffset, dest, destOffset) {\n    unreachable(\"Should not call ColorSpace.getRgbItem\");\n  }\n  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {\n    unreachable(\"Should not call ColorSpace.getRgbBuffer\");\n  }\n  getOutputLength(inputLength, alpha01) {\n    unreachable(\"Should not call ColorSpace.getOutputLength\");\n  }\n  isPassthrough(bits) {\n    return false;\n  }\n  isDefaultDecode(decodeMap, bpc) {\n    return ColorSpace.isDefaultDecode(decodeMap, this.numComps);\n  }\n  fillRgb(dest, originalWidth, originalHeight, width, height, actualHeight, bpc, comps, alpha01) {\n    const count = originalWidth * originalHeight;\n    let rgbBuf = null;\n    const numComponentColors = 1 << bpc;\n    const needsResizing = originalHeight !== height || originalWidth !== width;\n    if (this.isPassthrough(bpc)) {\n      rgbBuf = comps;\n    } else if (this.numComps === 1 && count > numComponentColors && this.name !== \"DeviceGray\" && this.name !== \"DeviceRGB\") {\n      const allColors = bpc <= 8 ? new Uint8Array(numComponentColors) : new Uint16Array(numComponentColors);\n      for (let i = 0; i < numComponentColors; i++) {\n        allColors[i] = i;\n      }\n      const colorMap = new Uint8ClampedArray(numComponentColors * 3);\n      this.getRgbBuffer(allColors, 0, numComponentColors, colorMap, 0, bpc, 0);\n      if (!needsResizing) {\n        let destPos = 0;\n        for (let i = 0; i < count; ++i) {\n          const key = comps[i] * 3;\n          dest[destPos++] = colorMap[key];\n          dest[destPos++] = colorMap[key + 1];\n          dest[destPos++] = colorMap[key + 2];\n          destPos += alpha01;\n        }\n      } else {\n        rgbBuf = new Uint8Array(count * 3);\n        let rgbPos = 0;\n        for (let i = 0; i < count; ++i) {\n          const key = comps[i] * 3;\n          rgbBuf[rgbPos++] = colorMap[key];\n          rgbBuf[rgbPos++] = colorMap[key + 1];\n          rgbBuf[rgbPos++] = colorMap[key + 2];\n        }\n      }\n    } else if (!needsResizing) {\n      this.getRgbBuffer(comps, 0, width * actualHeight, dest, 0, bpc, alpha01);\n    } else {\n      rgbBuf = new Uint8ClampedArray(count * 3);\n      this.getRgbBuffer(comps, 0, count, rgbBuf, 0, bpc, 0);\n    }\n    if (rgbBuf) {\n      if (needsResizing) {\n        resizeRgbImage(rgbBuf, dest, originalWidth, originalHeight, width, height, alpha01);\n      } else {\n        let destPos = 0,\n          rgbPos = 0;\n        for (let i = 0, ii = width * actualHeight; i < ii; i++) {\n          dest[destPos++] = rgbBuf[rgbPos++];\n          dest[destPos++] = rgbBuf[rgbPos++];\n          dest[destPos++] = rgbBuf[rgbPos++];\n          destPos += alpha01;\n        }\n      }\n    }\n  }\n  get usesZeroToOneRange() {\n    return shadow(this, \"usesZeroToOneRange\", true);\n  }\n  static _cache(cacheKey, xref, localColorSpaceCache, parsedColorSpace) {\n    if (!localColorSpaceCache) {\n      throw new Error('ColorSpace._cache - expected \"localColorSpaceCache\" argument.');\n    }\n    if (!parsedColorSpace) {\n      throw new Error('ColorSpace._cache - expected \"parsedColorSpace\" argument.');\n    }\n    let csName, csRef;\n    if (cacheKey instanceof Ref) {\n      csRef = cacheKey;\n      cacheKey = xref.fetch(cacheKey);\n    }\n    if (cacheKey instanceof Name) {\n      csName = cacheKey.name;\n    }\n    if (csName || csRef) {\n      localColorSpaceCache.set(csName, csRef, parsedColorSpace);\n    }\n  }\n  static getCached(cacheKey, xref, localColorSpaceCache) {\n    if (!localColorSpaceCache) {\n      throw new Error('ColorSpace.getCached - expected \"localColorSpaceCache\" argument.');\n    }\n    if (cacheKey instanceof Ref) {\n      const localColorSpace = localColorSpaceCache.getByRef(cacheKey);\n      if (localColorSpace) {\n        return localColorSpace;\n      }\n      try {\n        cacheKey = xref.fetch(cacheKey);\n      } catch (ex) {\n        if (ex instanceof MissingDataException) {\n          throw ex;\n        }\n      }\n    }\n    if (cacheKey instanceof Name) {\n      const localColorSpace = localColorSpaceCache.getByName(cacheKey.name);\n      if (localColorSpace) {\n        return localColorSpace;\n      }\n    }\n    return null;\n  }\n  static async parseAsync({\n    cs,\n    xref,\n    resources = null,\n    pdfFunctionFactory,\n    localColorSpaceCache\n  }) {\n    const parsedColorSpace = this._parse(cs, xref, resources, pdfFunctionFactory);\n    this._cache(cs, xref, localColorSpaceCache, parsedColorSpace);\n    return parsedColorSpace;\n  }\n  static parse({\n    cs,\n    xref,\n    resources = null,\n    pdfFunctionFactory,\n    localColorSpaceCache\n  }) {\n    const cachedColorSpace = this.getCached(cs, xref, localColorSpaceCache);\n    if (cachedColorSpace) {\n      return cachedColorSpace;\n    }\n    const parsedColorSpace = this._parse(cs, xref, resources, pdfFunctionFactory);\n    this._cache(cs, xref, localColorSpaceCache, parsedColorSpace);\n    return parsedColorSpace;\n  }\n  static _parse(cs, xref, resources = null, pdfFunctionFactory) {\n    cs = xref.fetchIfRef(cs);\n    if (cs instanceof Name) {\n      switch (cs.name) {\n        case \"G\":\n        case \"DeviceGray\":\n          return this.singletons.gray;\n        case \"RGB\":\n        case \"DeviceRGB\":\n          return this.singletons.rgb;\n        case \"CMYK\":\n        case \"DeviceCMYK\":\n          return this.singletons.cmyk;\n        case \"Pattern\":\n          return new PatternCS(null);\n        default:\n          if (resources instanceof Dict) {\n            const colorSpaces = resources.get(\"ColorSpace\");\n            if (colorSpaces instanceof Dict) {\n              const resourcesCS = colorSpaces.get(cs.name);\n              if (resourcesCS) {\n                if (resourcesCS instanceof Name) {\n                  return this._parse(resourcesCS, xref, resources, pdfFunctionFactory);\n                }\n                cs = resourcesCS;\n                break;\n              }\n            }\n          }\n          throw new FormatError(`Unrecognized ColorSpace: ${cs.name}`);\n      }\n    }\n    if (Array.isArray(cs)) {\n      const mode = xref.fetchIfRef(cs[0]).name;\n      let params, numComps, baseCS, whitePoint, blackPoint, gamma;\n      switch (mode) {\n        case \"G\":\n        case \"DeviceGray\":\n          return this.singletons.gray;\n        case \"RGB\":\n        case \"DeviceRGB\":\n          return this.singletons.rgb;\n        case \"CMYK\":\n        case \"DeviceCMYK\":\n          return this.singletons.cmyk;\n        case \"CalGray\":\n          params = xref.fetchIfRef(cs[1]);\n          whitePoint = params.getArray(\"WhitePoint\");\n          blackPoint = params.getArray(\"BlackPoint\");\n          gamma = params.get(\"Gamma\");\n          return new CalGrayCS(whitePoint, blackPoint, gamma);\n        case \"CalRGB\":\n          params = xref.fetchIfRef(cs[1]);\n          whitePoint = params.getArray(\"WhitePoint\");\n          blackPoint = params.getArray(\"BlackPoint\");\n          gamma = params.getArray(\"Gamma\");\n          const matrix = params.getArray(\"Matrix\");\n          return new CalRGBCS(whitePoint, blackPoint, gamma, matrix);\n        case \"ICCBased\":\n          const stream = xref.fetchIfRef(cs[1]);\n          const dict = stream.dict;\n          numComps = dict.get(\"N\");\n          const alt = dict.get(\"Alternate\");\n          if (alt) {\n            const altCS = this._parse(alt, xref, resources, pdfFunctionFactory);\n            if (altCS.numComps === numComps) {\n              return altCS;\n            }\n            warn(\"ICCBased color space: Ignoring incorrect /Alternate entry.\");\n          }\n          if (numComps === 1) {\n            return this.singletons.gray;\n          } else if (numComps === 3) {\n            return this.singletons.rgb;\n          } else if (numComps === 4) {\n            return this.singletons.cmyk;\n          }\n          break;\n        case \"Pattern\":\n          baseCS = cs[1] || null;\n          if (baseCS) {\n            baseCS = this._parse(baseCS, xref, resources, pdfFunctionFactory);\n          }\n          return new PatternCS(baseCS);\n        case \"I\":\n        case \"Indexed\":\n          baseCS = this._parse(cs[1], xref, resources, pdfFunctionFactory);\n          const hiVal = xref.fetchIfRef(cs[2]) + 1;\n          const lookup = xref.fetchIfRef(cs[3]);\n          return new IndexedCS(baseCS, hiVal, lookup);\n        case \"Separation\":\n        case \"DeviceN\":\n          const name = xref.fetchIfRef(cs[1]);\n          numComps = Array.isArray(name) ? name.length : 1;\n          baseCS = this._parse(cs[2], xref, resources, pdfFunctionFactory);\n          const tintFn = pdfFunctionFactory.create(cs[3]);\n          return new AlternateCS(numComps, baseCS, tintFn);\n        case \"Lab\":\n          params = xref.fetchIfRef(cs[1]);\n          whitePoint = params.getArray(\"WhitePoint\");\n          blackPoint = params.getArray(\"BlackPoint\");\n          const range = params.getArray(\"Range\");\n          return new LabCS(whitePoint, blackPoint, range);\n        default:\n          throw new FormatError(`Unimplemented ColorSpace object: ${mode}`);\n      }\n    }\n    throw new FormatError(`Unrecognized ColorSpace object: ${cs}`);\n  }\n  static isDefaultDecode(decode, numComps) {\n    if (!Array.isArray(decode)) {\n      return true;\n    }\n    if (numComps * 2 !== decode.length) {\n      warn(\"The decode map is not the correct length\");\n      return true;\n    }\n    for (let i = 0, ii = decode.length; i < ii; i += 2) {\n      if (decode[i] !== 0 || decode[i + 1] !== 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n  static get singletons() {\n    return shadow(this, \"singletons\", {\n      get gray() {\n        return shadow(this, \"gray\", new DeviceGrayCS());\n      },\n      get rgb() {\n        return shadow(this, \"rgb\", new DeviceRgbCS());\n      },\n      get cmyk() {\n        return shadow(this, \"cmyk\", new DeviceCmykCS());\n      }\n    });\n  }\n}\nclass AlternateCS extends ColorSpace {\n  constructor(numComps, base, tintFn) {\n    super(\"Alternate\", numComps);\n    this.base = base;\n    this.tintFn = tintFn;\n    this.tmpBuf = new Float32Array(base.numComps);\n  }\n  getRgbItem(src, srcOffset, dest, destOffset) {\n    const tmpBuf = this.tmpBuf;\n    this.tintFn(src, srcOffset, tmpBuf, 0);\n    this.base.getRgbItem(tmpBuf, 0, dest, destOffset);\n  }\n  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {\n    const tintFn = this.tintFn;\n    const base = this.base;\n    const scale = 1 / ((1 << bits) - 1);\n    const baseNumComps = base.numComps;\n    const usesZeroToOneRange = base.usesZeroToOneRange;\n    const isPassthrough = (base.isPassthrough(8) || !usesZeroToOneRange) && alpha01 === 0;\n    let pos = isPassthrough ? destOffset : 0;\n    const baseBuf = isPassthrough ? dest : new Uint8ClampedArray(baseNumComps * count);\n    const numComps = this.numComps;\n    const scaled = new Float32Array(numComps);\n    const tinted = new Float32Array(baseNumComps);\n    let i, j;\n    for (i = 0; i < count; i++) {\n      for (j = 0; j < numComps; j++) {\n        scaled[j] = src[srcOffset++] * scale;\n      }\n      tintFn(scaled, 0, tinted, 0);\n      if (usesZeroToOneRange) {\n        for (j = 0; j < baseNumComps; j++) {\n          baseBuf[pos++] = tinted[j] * 255;\n        }\n      } else {\n        base.getRgbItem(tinted, 0, baseBuf, pos);\n        pos += baseNumComps;\n      }\n    }\n    if (!isPassthrough) {\n      base.getRgbBuffer(baseBuf, 0, count, dest, destOffset, 8, alpha01);\n    }\n  }\n  getOutputLength(inputLength, alpha01) {\n    return this.base.getOutputLength(inputLength * this.base.numComps / this.numComps, alpha01);\n  }\n}\nclass PatternCS extends ColorSpace {\n  constructor(baseCS) {\n    super(\"Pattern\", null);\n    this.base = baseCS;\n  }\n  isDefaultDecode(decodeMap, bpc) {\n    unreachable(\"Should not call PatternCS.isDefaultDecode\");\n  }\n}\nclass IndexedCS extends ColorSpace {\n  constructor(base, highVal, lookup) {\n    super(\"Indexed\", 1);\n    this.base = base;\n    this.highVal = highVal;\n    const length = base.numComps * highVal;\n    this.lookup = new Uint8Array(length);\n    if (lookup instanceof BaseStream) {\n      const bytes = lookup.getBytes(length);\n      this.lookup.set(bytes);\n    } else if (typeof lookup === \"string\") {\n      for (let i = 0; i < length; ++i) {\n        this.lookup[i] = lookup.charCodeAt(i) & 0xff;\n      }\n    } else {\n      throw new FormatError(`IndexedCS - unrecognized lookup table: ${lookup}`);\n    }\n  }\n  getRgbItem(src, srcOffset, dest, destOffset) {\n    const numComps = this.base.numComps;\n    const start = src[srcOffset] * numComps;\n    this.base.getRgbBuffer(this.lookup, start, 1, dest, destOffset, 8, 0);\n  }\n  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {\n    const base = this.base;\n    const numComps = base.numComps;\n    const outputDelta = base.getOutputLength(numComps, alpha01);\n    const lookup = this.lookup;\n    for (let i = 0; i < count; ++i) {\n      const lookupPos = src[srcOffset++] * numComps;\n      base.getRgbBuffer(lookup, lookupPos, 1, dest, destOffset, 8, alpha01);\n      destOffset += outputDelta;\n    }\n  }\n  getOutputLength(inputLength, alpha01) {\n    return this.base.getOutputLength(inputLength * this.base.numComps, alpha01);\n  }\n  isDefaultDecode(decodeMap, bpc) {\n    if (!Array.isArray(decodeMap)) {\n      return true;\n    }\n    if (decodeMap.length !== 2) {\n      warn(\"Decode map length is not correct\");\n      return true;\n    }\n    if (!Number.isInteger(bpc) || bpc < 1) {\n      warn(\"Bits per component is not correct\");\n      return true;\n    }\n    return decodeMap[0] === 0 && decodeMap[1] === (1 << bpc) - 1;\n  }\n}\nclass DeviceGrayCS extends ColorSpace {\n  constructor() {\n    super(\"DeviceGray\", 1);\n  }\n  getRgbItem(src, srcOffset, dest, destOffset) {\n    const c = src[srcOffset] * 255;\n    dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = c;\n  }\n  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {\n    const scale = 255 / ((1 << bits) - 1);\n    let j = srcOffset,\n      q = destOffset;\n    for (let i = 0; i < count; ++i) {\n      const c = scale * src[j++];\n      dest[q++] = c;\n      dest[q++] = c;\n      dest[q++] = c;\n      q += alpha01;\n    }\n  }\n  getOutputLength(inputLength, alpha01) {\n    return inputLength * (3 + alpha01);\n  }\n}\nclass DeviceRgbCS extends ColorSpace {\n  constructor() {\n    super(\"DeviceRGB\", 3);\n  }\n  getRgbItem(src, srcOffset, dest, destOffset) {\n    dest[destOffset] = src[srcOffset] * 255;\n    dest[destOffset + 1] = src[srcOffset + 1] * 255;\n    dest[destOffset + 2] = src[srcOffset + 2] * 255;\n  }\n  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {\n    if (bits === 8 && alpha01 === 0) {\n      dest.set(src.subarray(srcOffset, srcOffset + count * 3), destOffset);\n      return;\n    }\n    const scale = 255 / ((1 << bits) - 1);\n    let j = srcOffset,\n      q = destOffset;\n    for (let i = 0; i < count; ++i) {\n      dest[q++] = scale * src[j++];\n      dest[q++] = scale * src[j++];\n      dest[q++] = scale * src[j++];\n      q += alpha01;\n    }\n  }\n  getOutputLength(inputLength, alpha01) {\n    return inputLength * (3 + alpha01) / 3 | 0;\n  }\n  isPassthrough(bits) {\n    return bits === 8;\n  }\n}\nclass DeviceCmykCS extends ColorSpace {\n  constructor() {\n    super(\"DeviceCMYK\", 4);\n  }\n  #toRgb(src, srcOffset, srcScale, dest, destOffset) {\n    const c = src[srcOffset] * srcScale;\n    const m = src[srcOffset + 1] * srcScale;\n    const y = src[srcOffset + 2] * srcScale;\n    const k = src[srcOffset + 3] * srcScale;\n    dest[destOffset] = 255 + c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k + -285.2331026137004) + m * (1.7149763477362134 * m - 5.6096736904047315 * y + -17.873870861415444 * k - 5.497006427196366) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 17.5119270841813) + k * (-21.86122147463605 * k - 189.48180835922747);\n    dest[destOffset + 1] = 255 + c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k + -79.2970844816548) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 190.9453302588951) + y * (4.444339102852739 * y + 9.8632861493405 * k - 24.86741582555878) + k * (-20.737325471181034 * k - 187.80453709719578);\n    dest[destOffset + 2] = 255 + c * (0.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - 0.23883238689178934 * k + -14.183576799673286) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 112.23884253719248) + y * (0.03296041114873217 * y + 115.60384449646641 * k + -193.58209356861505) + k * (-22.33816807309886 * k - 180.12613974708367);\n  }\n  getRgbItem(src, srcOffset, dest, destOffset) {\n    this.#toRgb(src, srcOffset, 1, dest, destOffset);\n  }\n  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {\n    const scale = 1 / ((1 << bits) - 1);\n    for (let i = 0; i < count; i++) {\n      this.#toRgb(src, srcOffset, scale, dest, destOffset);\n      srcOffset += 4;\n      destOffset += 3 + alpha01;\n    }\n  }\n  getOutputLength(inputLength, alpha01) {\n    return inputLength / 4 * (3 + alpha01) | 0;\n  }\n}\nclass CalGrayCS extends ColorSpace {\n  constructor(whitePoint, blackPoint, gamma) {\n    super(\"CalGray\", 1);\n    if (!whitePoint) {\n      throw new FormatError(\"WhitePoint missing - required for color space CalGray\");\n    }\n    [this.XW, this.YW, this.ZW] = whitePoint;\n    [this.XB, this.YB, this.ZB] = blackPoint || [0, 0, 0];\n    this.G = gamma || 1;\n    if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {\n      throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);\n    }\n    if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {\n      info(`Invalid BlackPoint for ${this.name}, falling back to default.`);\n      this.XB = this.YB = this.ZB = 0;\n    }\n    if (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) {\n      warn(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ` + `ZB: ${this.ZB}, only default values are supported.`);\n    }\n    if (this.G < 1) {\n      info(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`);\n      this.G = 1;\n    }\n  }\n  #toRgb(src, srcOffset, dest, destOffset, scale) {\n    const A = src[srcOffset] * scale;\n    const AG = A ** this.G;\n    const L = this.YW * AG;\n    const val = Math.max(295.8 * L ** 0.3333333333333333 - 40.8, 0);\n    dest[destOffset] = val;\n    dest[destOffset + 1] = val;\n    dest[destOffset + 2] = val;\n  }\n  getRgbItem(src, srcOffset, dest, destOffset) {\n    this.#toRgb(src, srcOffset, dest, destOffset, 1);\n  }\n  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {\n    const scale = 1 / ((1 << bits) - 1);\n    for (let i = 0; i < count; ++i) {\n      this.#toRgb(src, srcOffset, dest, destOffset, scale);\n      srcOffset += 1;\n      destOffset += 3 + alpha01;\n    }\n  }\n  getOutputLength(inputLength, alpha01) {\n    return inputLength * (3 + alpha01);\n  }\n}\nclass CalRGBCS extends ColorSpace {\n  static #BRADFORD_SCALE_MATRIX = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]);\n  static #BRADFORD_SCALE_INVERSE_MATRIX = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -0.0085287, 0.0400428, 0.9684867]);\n  static #SRGB_D65_XYZ_TO_RGB_MATRIX = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.9692660, 1.8760108, 0.0415560, 0.0556434, -0.2040259, 1.0572252]);\n  static #FLAT_WHITEPOINT_MATRIX = new Float32Array([1, 1, 1]);\n  static #tempNormalizeMatrix = new Float32Array(3);\n  static #tempConvertMatrix1 = new Float32Array(3);\n  static #tempConvertMatrix2 = new Float32Array(3);\n  static #DECODE_L_CONSTANT = ((8 + 16) / 116) ** 3 / 8.0;\n  constructor(whitePoint, blackPoint, gamma, matrix) {\n    super(\"CalRGB\", 3);\n    if (!whitePoint) {\n      throw new FormatError(\"WhitePoint missing - required for color space CalRGB\");\n    }\n    const [XW, YW, ZW] = this.whitePoint = whitePoint;\n    const [XB, YB, ZB] = this.blackPoint = blackPoint || new Float32Array(3);\n    [this.GR, this.GG, this.GB] = gamma || new Float32Array([1, 1, 1]);\n    [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = matrix || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);\n    if (XW < 0 || ZW < 0 || YW !== 1) {\n      throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);\n    }\n    if (XB < 0 || YB < 0 || ZB < 0) {\n      info(`Invalid BlackPoint for ${this.name} [${XB}, ${YB}, ${ZB}], ` + \"falling back to default.\");\n      this.blackPoint = new Float32Array(3);\n    }\n    if (this.GR < 0 || this.GG < 0 || this.GB < 0) {\n      info(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ` + `${this.name}, falling back to default.`);\n      this.GR = this.GG = this.GB = 1;\n    }\n  }\n  #matrixProduct(a, b, result) {\n    result[0] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n    result[1] = a[3] * b[0] + a[4] * b[1] + a[5] * b[2];\n    result[2] = a[6] * b[0] + a[7] * b[1] + a[8] * b[2];\n  }\n  #toFlat(sourceWhitePoint, LMS, result) {\n    result[0] = LMS[0] * 1 / sourceWhitePoint[0];\n    result[1] = LMS[1] * 1 / sourceWhitePoint[1];\n    result[2] = LMS[2] * 1 / sourceWhitePoint[2];\n  }\n  #toD65(sourceWhitePoint, LMS, result) {\n    const D65X = 0.95047;\n    const D65Y = 1;\n    const D65Z = 1.08883;\n    result[0] = LMS[0] * D65X / sourceWhitePoint[0];\n    result[1] = LMS[1] * D65Y / sourceWhitePoint[1];\n    result[2] = LMS[2] * D65Z / sourceWhitePoint[2];\n  }\n  #sRGBTransferFunction(color) {\n    if (color <= 0.0031308) {\n      return this.#adjustToRange(0, 1, 12.92 * color);\n    }\n    if (color >= 0.99554525) {\n      return 1;\n    }\n    return this.#adjustToRange(0, 1, (1 + 0.055) * color ** (1 / 2.4) - 0.055);\n  }\n  #adjustToRange(min, max, value) {\n    return Math.max(min, Math.min(max, value));\n  }\n  #decodeL(L) {\n    if (L < 0) {\n      return -this.#decodeL(-L);\n    }\n    if (L > 8.0) {\n      return ((L + 16) / 116) ** 3;\n    }\n    return L * CalRGBCS.#DECODE_L_CONSTANT;\n  }\n  #compensateBlackPoint(sourceBlackPoint, XYZ_Flat, result) {\n    if (sourceBlackPoint[0] === 0 && sourceBlackPoint[1] === 0 && sourceBlackPoint[2] === 0) {\n      result[0] = XYZ_Flat[0];\n      result[1] = XYZ_Flat[1];\n      result[2] = XYZ_Flat[2];\n      return;\n    }\n    const zeroDecodeL = this.#decodeL(0);\n    const X_DST = zeroDecodeL;\n    const X_SRC = this.#decodeL(sourceBlackPoint[0]);\n    const Y_DST = zeroDecodeL;\n    const Y_SRC = this.#decodeL(sourceBlackPoint[1]);\n    const Z_DST = zeroDecodeL;\n    const Z_SRC = this.#decodeL(sourceBlackPoint[2]);\n    const X_Scale = (1 - X_DST) / (1 - X_SRC);\n    const X_Offset = 1 - X_Scale;\n    const Y_Scale = (1 - Y_DST) / (1 - Y_SRC);\n    const Y_Offset = 1 - Y_Scale;\n    const Z_Scale = (1 - Z_DST) / (1 - Z_SRC);\n    const Z_Offset = 1 - Z_Scale;\n    result[0] = XYZ_Flat[0] * X_Scale + X_Offset;\n    result[1] = XYZ_Flat[1] * Y_Scale + Y_Offset;\n    result[2] = XYZ_Flat[2] * Z_Scale + Z_Offset;\n  }\n  #normalizeWhitePointToFlat(sourceWhitePoint, XYZ_In, result) {\n    if (sourceWhitePoint[0] === 1 && sourceWhitePoint[2] === 1) {\n      result[0] = XYZ_In[0];\n      result[1] = XYZ_In[1];\n      result[2] = XYZ_In[2];\n      return;\n    }\n    const LMS = result;\n    this.#matrixProduct(CalRGBCS.#BRADFORD_SCALE_MATRIX, XYZ_In, LMS);\n    const LMS_Flat = CalRGBCS.#tempNormalizeMatrix;\n    this.#toFlat(sourceWhitePoint, LMS, LMS_Flat);\n    this.#matrixProduct(CalRGBCS.#BRADFORD_SCALE_INVERSE_MATRIX, LMS_Flat, result);\n  }\n  #normalizeWhitePointToD65(sourceWhitePoint, XYZ_In, result) {\n    const LMS = result;\n    this.#matrixProduct(CalRGBCS.#BRADFORD_SCALE_MATRIX, XYZ_In, LMS);\n    const LMS_D65 = CalRGBCS.#tempNormalizeMatrix;\n    this.#toD65(sourceWhitePoint, LMS, LMS_D65);\n    this.#matrixProduct(CalRGBCS.#BRADFORD_SCALE_INVERSE_MATRIX, LMS_D65, result);\n  }\n  #toRgb(src, srcOffset, dest, destOffset, scale) {\n    const A = this.#adjustToRange(0, 1, src[srcOffset] * scale);\n    const B = this.#adjustToRange(0, 1, src[srcOffset + 1] * scale);\n    const C = this.#adjustToRange(0, 1, src[srcOffset + 2] * scale);\n    const AGR = A === 1 ? 1 : A ** this.GR;\n    const BGG = B === 1 ? 1 : B ** this.GG;\n    const CGB = C === 1 ? 1 : C ** this.GB;\n    const X = this.MXA * AGR + this.MXB * BGG + this.MXC * CGB;\n    const Y = this.MYA * AGR + this.MYB * BGG + this.MYC * CGB;\n    const Z = this.MZA * AGR + this.MZB * BGG + this.MZC * CGB;\n    const XYZ = CalRGBCS.#tempConvertMatrix1;\n    XYZ[0] = X;\n    XYZ[1] = Y;\n    XYZ[2] = Z;\n    const XYZ_Flat = CalRGBCS.#tempConvertMatrix2;\n    this.#normalizeWhitePointToFlat(this.whitePoint, XYZ, XYZ_Flat);\n    const XYZ_Black = CalRGBCS.#tempConvertMatrix1;\n    this.#compensateBlackPoint(this.blackPoint, XYZ_Flat, XYZ_Black);\n    const XYZ_D65 = CalRGBCS.#tempConvertMatrix2;\n    this.#normalizeWhitePointToD65(CalRGBCS.#FLAT_WHITEPOINT_MATRIX, XYZ_Black, XYZ_D65);\n    const SRGB = CalRGBCS.#tempConvertMatrix1;\n    this.#matrixProduct(CalRGBCS.#SRGB_D65_XYZ_TO_RGB_MATRIX, XYZ_D65, SRGB);\n    dest[destOffset] = this.#sRGBTransferFunction(SRGB[0]) * 255;\n    dest[destOffset + 1] = this.#sRGBTransferFunction(SRGB[1]) * 255;\n    dest[destOffset + 2] = this.#sRGBTransferFunction(SRGB[2]) * 255;\n  }\n  getRgbItem(src, srcOffset, dest, destOffset) {\n    this.#toRgb(src, srcOffset, dest, destOffset, 1);\n  }\n  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {\n    const scale = 1 / ((1 << bits) - 1);\n    for (let i = 0; i < count; ++i) {\n      this.#toRgb(src, srcOffset, dest, destOffset, scale);\n      srcOffset += 3;\n      destOffset += 3 + alpha01;\n    }\n  }\n  getOutputLength(inputLength, alpha01) {\n    return inputLength * (3 + alpha01) / 3 | 0;\n  }\n}\nclass LabCS extends ColorSpace {\n  constructor(whitePoint, blackPoint, range) {\n    super(\"Lab\", 3);\n    if (!whitePoint) {\n      throw new FormatError(\"WhitePoint missing - required for color space Lab\");\n    }\n    [this.XW, this.YW, this.ZW] = whitePoint;\n    [this.amin, this.amax, this.bmin, this.bmax] = range || [-100, 100, -100, 100];\n    [this.XB, this.YB, this.ZB] = blackPoint || [0, 0, 0];\n    if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {\n      throw new FormatError(\"Invalid WhitePoint components, no fallback available\");\n    }\n    if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {\n      info(\"Invalid BlackPoint, falling back to default\");\n      this.XB = this.YB = this.ZB = 0;\n    }\n    if (this.amin > this.amax || this.bmin > this.bmax) {\n      info(\"Invalid Range, falling back to defaults\");\n      this.amin = -100;\n      this.amax = 100;\n      this.bmin = -100;\n      this.bmax = 100;\n    }\n  }\n  #fn_g(x) {\n    return x >= 6 / 29 ? x ** 3 : 108 / 841 * (x - 4 / 29);\n  }\n  #decode(value, high1, low2, high2) {\n    return low2 + value * (high2 - low2) / high1;\n  }\n  #toRgb(src, srcOffset, maxVal, dest, destOffset) {\n    let Ls = src[srcOffset];\n    let as = src[srcOffset + 1];\n    let bs = src[srcOffset + 2];\n    if (maxVal !== false) {\n      Ls = this.#decode(Ls, maxVal, 0, 100);\n      as = this.#decode(as, maxVal, this.amin, this.amax);\n      bs = this.#decode(bs, maxVal, this.bmin, this.bmax);\n    }\n    if (as > this.amax) {\n      as = this.amax;\n    } else if (as < this.amin) {\n      as = this.amin;\n    }\n    if (bs > this.bmax) {\n      bs = this.bmax;\n    } else if (bs < this.bmin) {\n      bs = this.bmin;\n    }\n    const M = (Ls + 16) / 116;\n    const L = M + as / 500;\n    const N = M - bs / 200;\n    const X = this.XW * this.#fn_g(L);\n    const Y = this.YW * this.#fn_g(M);\n    const Z = this.ZW * this.#fn_g(N);\n    let r, g, b;\n    if (this.ZW < 1) {\n      r = X * 3.1339 + Y * -1.617 + Z * -0.4906;\n      g = X * -0.9785 + Y * 1.916 + Z * 0.0333;\n      b = X * 0.072 + Y * -0.229 + Z * 1.4057;\n    } else {\n      r = X * 3.2406 + Y * -1.5372 + Z * -0.4986;\n      g = X * -0.9689 + Y * 1.8758 + Z * 0.0415;\n      b = X * 0.0557 + Y * -0.204 + Z * 1.057;\n    }\n    dest[destOffset] = Math.sqrt(r) * 255;\n    dest[destOffset + 1] = Math.sqrt(g) * 255;\n    dest[destOffset + 2] = Math.sqrt(b) * 255;\n  }\n  getRgbItem(src, srcOffset, dest, destOffset) {\n    this.#toRgb(src, srcOffset, false, dest, destOffset);\n  }\n  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {\n    const maxVal = (1 << bits) - 1;\n    for (let i = 0; i < count; i++) {\n      this.#toRgb(src, srcOffset, maxVal, dest, destOffset);\n      srcOffset += 3;\n      destOffset += 3 + alpha01;\n    }\n  }\n  getOutputLength(inputLength, alpha01) {\n    return inputLength * (3 + alpha01) / 3 | 0;\n  }\n  isDefaultDecode(decodeMap, bpc) {\n    return true;\n  }\n  get usesZeroToOneRange() {\n    return shadow(this, \"usesZeroToOneRange\", false);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/binary_cmap.js\n\nfunction hexToInt(a, size) {\n  let n = 0;\n  for (let i = 0; i <= size; i++) {\n    n = n << 8 | a[i];\n  }\n  return n >>> 0;\n}\nfunction hexToStr(a, size) {\n  if (size === 1) {\n    return String.fromCharCode(a[0], a[1]);\n  }\n  if (size === 3) {\n    return String.fromCharCode(a[0], a[1], a[2], a[3]);\n  }\n  return String.fromCharCode(...a.subarray(0, size + 1));\n}\nfunction addHex(a, b, size) {\n  let c = 0;\n  for (let i = size; i >= 0; i--) {\n    c += a[i] + b[i];\n    a[i] = c & 255;\n    c >>= 8;\n  }\n}\nfunction incHex(a, size) {\n  let c = 1;\n  for (let i = size; i >= 0 && c > 0; i--) {\n    c += a[i];\n    a[i] = c & 255;\n    c >>= 8;\n  }\n}\nconst MAX_NUM_SIZE = 16;\nconst MAX_ENCODED_NUM_SIZE = 19;\nclass BinaryCMapStream {\n  constructor(data) {\n    this.buffer = data;\n    this.pos = 0;\n    this.end = data.length;\n    this.tmpBuf = new Uint8Array(MAX_ENCODED_NUM_SIZE);\n  }\n  readByte() {\n    if (this.pos >= this.end) {\n      return -1;\n    }\n    return this.buffer[this.pos++];\n  }\n  readNumber() {\n    let n = 0;\n    let last;\n    do {\n      const b = this.readByte();\n      if (b < 0) {\n        throw new FormatError(\"unexpected EOF in bcmap\");\n      }\n      last = !(b & 0x80);\n      n = n << 7 | b & 0x7f;\n    } while (!last);\n    return n;\n  }\n  readSigned() {\n    const n = this.readNumber();\n    return n & 1 ? ~(n >>> 1) : n >>> 1;\n  }\n  readHex(num, size) {\n    num.set(this.buffer.subarray(this.pos, this.pos + size + 1));\n    this.pos += size + 1;\n  }\n  readHexNumber(num, size) {\n    let last;\n    const stack = this.tmpBuf;\n    let sp = 0;\n    do {\n      const b = this.readByte();\n      if (b < 0) {\n        throw new FormatError(\"unexpected EOF in bcmap\");\n      }\n      last = !(b & 0x80);\n      stack[sp++] = b & 0x7f;\n    } while (!last);\n    let i = size,\n      buffer = 0,\n      bufferSize = 0;\n    while (i >= 0) {\n      while (bufferSize < 8 && stack.length > 0) {\n        buffer |= stack[--sp] << bufferSize;\n        bufferSize += 7;\n      }\n      num[i] = buffer & 255;\n      i--;\n      buffer >>= 8;\n      bufferSize -= 8;\n    }\n  }\n  readHexSigned(num, size) {\n    this.readHexNumber(num, size);\n    const sign = num[size] & 1 ? 255 : 0;\n    let c = 0;\n    for (let i = 0; i <= size; i++) {\n      c = (c & 1) << 8 | num[i];\n      num[i] = c >> 1 ^ sign;\n    }\n  }\n  readString() {\n    const len = this.readNumber(),\n      buf = new Array(len);\n    for (let i = 0; i < len; i++) {\n      buf[i] = this.readNumber();\n    }\n    return String.fromCharCode(...buf);\n  }\n}\nclass BinaryCMapReader {\n  async process(data, cMap, extend) {\n    const stream = new BinaryCMapStream(data);\n    const header = stream.readByte();\n    cMap.vertical = !!(header & 1);\n    let useCMap = null;\n    const start = new Uint8Array(MAX_NUM_SIZE);\n    const end = new Uint8Array(MAX_NUM_SIZE);\n    const char = new Uint8Array(MAX_NUM_SIZE);\n    const charCode = new Uint8Array(MAX_NUM_SIZE);\n    const tmp = new Uint8Array(MAX_NUM_SIZE);\n    let code;\n    let b;\n    while ((b = stream.readByte()) >= 0) {\n      const type = b >> 5;\n      if (type === 7) {\n        switch (b & 0x1f) {\n          case 0:\n            stream.readString();\n            break;\n          case 1:\n            useCMap = stream.readString();\n            break;\n        }\n        continue;\n      }\n      const sequence = !!(b & 0x10);\n      const dataSize = b & 15;\n      if (dataSize + 1 > MAX_NUM_SIZE) {\n        throw new Error(\"BinaryCMapReader.process: Invalid dataSize.\");\n      }\n      const ucs2DataSize = 1;\n      const subitemsCount = stream.readNumber();\n      switch (type) {\n        case 0:\n          stream.readHex(start, dataSize);\n          stream.readHexNumber(end, dataSize);\n          addHex(end, start, dataSize);\n          cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));\n          for (let i = 1; i < subitemsCount; i++) {\n            incHex(end, dataSize);\n            stream.readHexNumber(start, dataSize);\n            addHex(start, end, dataSize);\n            stream.readHexNumber(end, dataSize);\n            addHex(end, start, dataSize);\n            cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));\n          }\n          break;\n        case 1:\n          stream.readHex(start, dataSize);\n          stream.readHexNumber(end, dataSize);\n          addHex(end, start, dataSize);\n          stream.readNumber();\n          for (let i = 1; i < subitemsCount; i++) {\n            incHex(end, dataSize);\n            stream.readHexNumber(start, dataSize);\n            addHex(start, end, dataSize);\n            stream.readHexNumber(end, dataSize);\n            addHex(end, start, dataSize);\n            stream.readNumber();\n          }\n          break;\n        case 2:\n          stream.readHex(char, dataSize);\n          code = stream.readNumber();\n          cMap.mapOne(hexToInt(char, dataSize), code);\n          for (let i = 1; i < subitemsCount; i++) {\n            incHex(char, dataSize);\n            if (!sequence) {\n              stream.readHexNumber(tmp, dataSize);\n              addHex(char, tmp, dataSize);\n            }\n            code = stream.readSigned() + (code + 1);\n            cMap.mapOne(hexToInt(char, dataSize), code);\n          }\n          break;\n        case 3:\n          stream.readHex(start, dataSize);\n          stream.readHexNumber(end, dataSize);\n          addHex(end, start, dataSize);\n          code = stream.readNumber();\n          cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);\n          for (let i = 1; i < subitemsCount; i++) {\n            incHex(end, dataSize);\n            if (!sequence) {\n              stream.readHexNumber(start, dataSize);\n              addHex(start, end, dataSize);\n            } else {\n              start.set(end);\n            }\n            stream.readHexNumber(end, dataSize);\n            addHex(end, start, dataSize);\n            code = stream.readNumber();\n            cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);\n          }\n          break;\n        case 4:\n          stream.readHex(char, ucs2DataSize);\n          stream.readHex(charCode, dataSize);\n          cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));\n          for (let i = 1; i < subitemsCount; i++) {\n            incHex(char, ucs2DataSize);\n            if (!sequence) {\n              stream.readHexNumber(tmp, ucs2DataSize);\n              addHex(char, tmp, ucs2DataSize);\n            }\n            incHex(charCode, dataSize);\n            stream.readHexSigned(tmp, dataSize);\n            addHex(charCode, tmp, dataSize);\n            cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));\n          }\n          break;\n        case 5:\n          stream.readHex(start, ucs2DataSize);\n          stream.readHexNumber(end, ucs2DataSize);\n          addHex(end, start, ucs2DataSize);\n          stream.readHex(charCode, dataSize);\n          cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));\n          for (let i = 1; i < subitemsCount; i++) {\n            incHex(end, ucs2DataSize);\n            if (!sequence) {\n              stream.readHexNumber(start, ucs2DataSize);\n              addHex(start, end, ucs2DataSize);\n            } else {\n              start.set(end);\n            }\n            stream.readHexNumber(end, ucs2DataSize);\n            addHex(end, start, ucs2DataSize);\n            stream.readHex(charCode, dataSize);\n            cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));\n          }\n          break;\n        default:\n          throw new Error(`BinaryCMapReader.process - unknown type: ${type}`);\n      }\n    }\n    if (useCMap) {\n      return extend(useCMap);\n    }\n    return cMap;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/decode_stream.js\n\n\nconst emptyBuffer = new Uint8Array(0);\nclass DecodeStream extends BaseStream {\n  constructor(maybeMinBufferLength) {\n    super();\n    this._rawMinBufferLength = maybeMinBufferLength || 0;\n    this.pos = 0;\n    this.bufferLength = 0;\n    this.eof = false;\n    this.buffer = emptyBuffer;\n    this.minBufferLength = 512;\n    if (maybeMinBufferLength) {\n      while (this.minBufferLength < maybeMinBufferLength) {\n        this.minBufferLength *= 2;\n      }\n    }\n  }\n  get isEmpty() {\n    while (!this.eof && this.bufferLength === 0) {\n      this.readBlock();\n    }\n    return this.bufferLength === 0;\n  }\n  ensureBuffer(requested) {\n    const buffer = this.buffer;\n    if (requested <= buffer.byteLength) {\n      return buffer;\n    }\n    let size = this.minBufferLength;\n    while (size < requested) {\n      size *= 2;\n    }\n    const buffer2 = new Uint8Array(size);\n    buffer2.set(buffer);\n    return this.buffer = buffer2;\n  }\n  getByte() {\n    const pos = this.pos;\n    while (this.bufferLength <= pos) {\n      if (this.eof) {\n        return -1;\n      }\n      this.readBlock();\n    }\n    return this.buffer[this.pos++];\n  }\n  getBytes(length, ignoreColorSpace = false) {\n    const pos = this.pos;\n    let end;\n    if (length) {\n      this.ensureBuffer(pos + length);\n      end = pos + length;\n      while (!this.eof && this.bufferLength < end) {\n        this.readBlock(ignoreColorSpace);\n      }\n      const bufEnd = this.bufferLength;\n      if (end > bufEnd) {\n        end = bufEnd;\n      }\n    } else {\n      while (!this.eof) {\n        this.readBlock(ignoreColorSpace);\n      }\n      end = this.bufferLength;\n    }\n    this.pos = end;\n    return this.buffer.subarray(pos, end);\n  }\n  reset() {\n    this.pos = 0;\n  }\n  makeSubStream(start, length, dict = null) {\n    if (length === undefined) {\n      while (!this.eof) {\n        this.readBlock();\n      }\n    } else {\n      const end = start + length;\n      while (this.bufferLength <= end && !this.eof) {\n        this.readBlock();\n      }\n    }\n    return new Stream(this.buffer, start, length, dict);\n  }\n  getBaseStreams() {\n    return this.str ? this.str.getBaseStreams() : null;\n  }\n}\nclass StreamsSequenceStream extends DecodeStream {\n  constructor(streams, onError = null) {\n    let maybeLength = 0;\n    for (const stream of streams) {\n      maybeLength += stream instanceof DecodeStream ? stream._rawMinBufferLength : stream.length;\n    }\n    super(maybeLength);\n    this.streams = streams;\n    this._onError = onError;\n  }\n  readBlock() {\n    const streams = this.streams;\n    if (streams.length === 0) {\n      this.eof = true;\n      return;\n    }\n    const stream = streams.shift();\n    let chunk;\n    try {\n      chunk = stream.getBytes();\n    } catch (reason) {\n      if (this._onError) {\n        this._onError(reason, stream.dict?.objId);\n        return;\n      }\n      throw reason;\n    }\n    const bufferLength = this.bufferLength;\n    const newLength = bufferLength + chunk.length;\n    const buffer = this.ensureBuffer(newLength);\n    buffer.set(chunk, bufferLength);\n    this.bufferLength = newLength;\n  }\n  getBaseStreams() {\n    const baseStreamsBuf = [];\n    for (const stream of this.streams) {\n      const baseStreams = stream.getBaseStreams();\n      if (baseStreams) {\n        baseStreamsBuf.push(...baseStreams);\n      }\n    }\n    return baseStreamsBuf.length > 0 ? baseStreamsBuf : null;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/ascii_85_stream.js\n\n\nclass Ascii85Stream extends DecodeStream {\n  constructor(str, maybeLength) {\n    if (maybeLength) {\n      maybeLength *= 0.8;\n    }\n    super(maybeLength);\n    this.str = str;\n    this.dict = str.dict;\n    this.input = new Uint8Array(5);\n  }\n  readBlock() {\n    const TILDA_CHAR = 0x7e;\n    const Z_LOWER_CHAR = 0x7a;\n    const EOF = -1;\n    const str = this.str;\n    let c = str.getByte();\n    while (isWhiteSpace(c)) {\n      c = str.getByte();\n    }\n    if (c === EOF || c === TILDA_CHAR) {\n      this.eof = true;\n      return;\n    }\n    const bufferLength = this.bufferLength;\n    let buffer, i;\n    if (c === Z_LOWER_CHAR) {\n      buffer = this.ensureBuffer(bufferLength + 4);\n      for (i = 0; i < 4; ++i) {\n        buffer[bufferLength + i] = 0;\n      }\n      this.bufferLength += 4;\n    } else {\n      const input = this.input;\n      input[0] = c;\n      for (i = 1; i < 5; ++i) {\n        c = str.getByte();\n        while (isWhiteSpace(c)) {\n          c = str.getByte();\n        }\n        input[i] = c;\n        if (c === EOF || c === TILDA_CHAR) {\n          break;\n        }\n      }\n      buffer = this.ensureBuffer(bufferLength + i - 1);\n      this.bufferLength += i - 1;\n      if (i < 5) {\n        for (; i < 5; ++i) {\n          input[i] = 0x21 + 84;\n        }\n        this.eof = true;\n      }\n      let t = 0;\n      for (i = 0; i < 5; ++i) {\n        t = t * 85 + (input[i] - 0x21);\n      }\n      for (i = 3; i >= 0; --i) {\n        buffer[bufferLength + i] = t & 0xff;\n        t >>= 8;\n      }\n    }\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/ascii_hex_stream.js\n\nclass AsciiHexStream extends DecodeStream {\n  constructor(str, maybeLength) {\n    if (maybeLength) {\n      maybeLength *= 0.5;\n    }\n    super(maybeLength);\n    this.str = str;\n    this.dict = str.dict;\n    this.firstDigit = -1;\n  }\n  readBlock() {\n    const UPSTREAM_BLOCK_SIZE = 8000;\n    const bytes = this.str.getBytes(UPSTREAM_BLOCK_SIZE);\n    if (!bytes.length) {\n      this.eof = true;\n      return;\n    }\n    const maxDecodeLength = bytes.length + 1 >> 1;\n    const buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);\n    let bufferLength = this.bufferLength;\n    let firstDigit = this.firstDigit;\n    for (const ch of bytes) {\n      let digit;\n      if (ch >= 0x30 && ch <= 0x39) {\n        digit = ch & 0x0f;\n      } else if (ch >= 0x41 && ch <= 0x46 || ch >= 0x61 && ch <= 0x66) {\n        digit = (ch & 0x0f) + 9;\n      } else if (ch === 0x3e) {\n        this.eof = true;\n        break;\n      } else {\n        continue;\n      }\n      if (firstDigit < 0) {\n        firstDigit = digit;\n      } else {\n        buffer[bufferLength++] = firstDigit << 4 | digit;\n        firstDigit = -1;\n      }\n    }\n    if (firstDigit >= 0 && this.eof) {\n      buffer[bufferLength++] = firstDigit << 4;\n      firstDigit = -1;\n    }\n    this.firstDigit = firstDigit;\n    this.bufferLength = bufferLength;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/ccitt.js\n\nconst ccittEOL = -2;\nconst ccittEOF = -1;\nconst twoDimPass = 0;\nconst twoDimHoriz = 1;\nconst twoDimVert0 = 2;\nconst twoDimVertR1 = 3;\nconst twoDimVertL1 = 4;\nconst twoDimVertR2 = 5;\nconst twoDimVertL2 = 6;\nconst twoDimVertR3 = 7;\nconst twoDimVertL3 = 8;\nconst twoDimTable = [[-1, -1], [-1, -1], [7, twoDimVertL3], [7, twoDimVertR3], [6, twoDimVertL2], [6, twoDimVertL2], [6, twoDimVertR2], [6, twoDimVertR2], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0]];\nconst whiteTable1 = [[-1, -1], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]];\nconst whiteTable2 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]];\nconst blackTable1 = [[-1, -1], [-1, -1], [12, ccittEOL], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]];\nconst blackTable2 = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]];\nconst blackTable3 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];\nclass CCITTFaxDecoder {\n  constructor(source, options = {}) {\n    if (!source || typeof source.next !== \"function\") {\n      throw new Error('CCITTFaxDecoder - invalid \"source\" parameter.');\n    }\n    this.source = source;\n    this.eof = false;\n    this.encoding = options.K || 0;\n    this.eoline = options.EndOfLine || false;\n    this.byteAlign = options.EncodedByteAlign || false;\n    this.columns = options.Columns || 1728;\n    this.rows = options.Rows || 0;\n    this.eoblock = options.EndOfBlock ?? true;\n    this.black = options.BlackIs1 || false;\n    this.codingLine = new Uint32Array(this.columns + 1);\n    this.refLine = new Uint32Array(this.columns + 2);\n    this.codingLine[0] = this.columns;\n    this.codingPos = 0;\n    this.row = 0;\n    this.nextLine2D = this.encoding < 0;\n    this.inputBits = 0;\n    this.inputBuf = 0;\n    this.outputBits = 0;\n    this.rowsDone = false;\n    let code1;\n    while ((code1 = this._lookBits(12)) === 0) {\n      this._eatBits(1);\n    }\n    if (code1 === 1) {\n      this._eatBits(12);\n    }\n    if (this.encoding > 0) {\n      this.nextLine2D = !this._lookBits(1);\n      this._eatBits(1);\n    }\n  }\n  readNextChar() {\n    if (this.eof) {\n      return -1;\n    }\n    const refLine = this.refLine;\n    const codingLine = this.codingLine;\n    const columns = this.columns;\n    let refPos, blackPixels, bits, i;\n    if (this.outputBits === 0) {\n      if (this.rowsDone) {\n        this.eof = true;\n      }\n      if (this.eof) {\n        return -1;\n      }\n      this.err = false;\n      let code1, code2, code3;\n      if (this.nextLine2D) {\n        for (i = 0; codingLine[i] < columns; ++i) {\n          refLine[i] = codingLine[i];\n        }\n        refLine[i++] = columns;\n        refLine[i] = columns;\n        codingLine[0] = 0;\n        this.codingPos = 0;\n        refPos = 0;\n        blackPixels = 0;\n        while (codingLine[this.codingPos] < columns) {\n          code1 = this._getTwoDimCode();\n          switch (code1) {\n            case twoDimPass:\n              this._addPixels(refLine[refPos + 1], blackPixels);\n              if (refLine[refPos + 1] < columns) {\n                refPos += 2;\n              }\n              break;\n            case twoDimHoriz:\n              code1 = code2 = 0;\n              if (blackPixels) {\n                do {\n                  code1 += code3 = this._getBlackCode();\n                } while (code3 >= 64);\n                do {\n                  code2 += code3 = this._getWhiteCode();\n                } while (code3 >= 64);\n              } else {\n                do {\n                  code1 += code3 = this._getWhiteCode();\n                } while (code3 >= 64);\n                do {\n                  code2 += code3 = this._getBlackCode();\n                } while (code3 >= 64);\n              }\n              this._addPixels(codingLine[this.codingPos] + code1, blackPixels);\n              if (codingLine[this.codingPos] < columns) {\n                this._addPixels(codingLine[this.codingPos] + code2, blackPixels ^ 1);\n              }\n              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {\n                refPos += 2;\n              }\n              break;\n            case twoDimVertR3:\n              this._addPixels(refLine[refPos] + 3, blackPixels);\n              blackPixels ^= 1;\n              if (codingLine[this.codingPos] < columns) {\n                ++refPos;\n                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {\n                  refPos += 2;\n                }\n              }\n              break;\n            case twoDimVertR2:\n              this._addPixels(refLine[refPos] + 2, blackPixels);\n              blackPixels ^= 1;\n              if (codingLine[this.codingPos] < columns) {\n                ++refPos;\n                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {\n                  refPos += 2;\n                }\n              }\n              break;\n            case twoDimVertR1:\n              this._addPixels(refLine[refPos] + 1, blackPixels);\n              blackPixels ^= 1;\n              if (codingLine[this.codingPos] < columns) {\n                ++refPos;\n                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {\n                  refPos += 2;\n                }\n              }\n              break;\n            case twoDimVert0:\n              this._addPixels(refLine[refPos], blackPixels);\n              blackPixels ^= 1;\n              if (codingLine[this.codingPos] < columns) {\n                ++refPos;\n                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {\n                  refPos += 2;\n                }\n              }\n              break;\n            case twoDimVertL3:\n              this._addPixelsNeg(refLine[refPos] - 3, blackPixels);\n              blackPixels ^= 1;\n              if (codingLine[this.codingPos] < columns) {\n                if (refPos > 0) {\n                  --refPos;\n                } else {\n                  ++refPos;\n                }\n                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {\n                  refPos += 2;\n                }\n              }\n              break;\n            case twoDimVertL2:\n              this._addPixelsNeg(refLine[refPos] - 2, blackPixels);\n              blackPixels ^= 1;\n              if (codingLine[this.codingPos] < columns) {\n                if (refPos > 0) {\n                  --refPos;\n                } else {\n                  ++refPos;\n                }\n                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {\n                  refPos += 2;\n                }\n              }\n              break;\n            case twoDimVertL1:\n              this._addPixelsNeg(refLine[refPos] - 1, blackPixels);\n              blackPixels ^= 1;\n              if (codingLine[this.codingPos] < columns) {\n                if (refPos > 0) {\n                  --refPos;\n                } else {\n                  ++refPos;\n                }\n                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {\n                  refPos += 2;\n                }\n              }\n              break;\n            case ccittEOF:\n              this._addPixels(columns, 0);\n              this.eof = true;\n              break;\n            default:\n              info(\"bad 2d code\");\n              this._addPixels(columns, 0);\n              this.err = true;\n          }\n        }\n      } else {\n        codingLine[0] = 0;\n        this.codingPos = 0;\n        blackPixels = 0;\n        while (codingLine[this.codingPos] < columns) {\n          code1 = 0;\n          if (blackPixels) {\n            do {\n              code1 += code3 = this._getBlackCode();\n            } while (code3 >= 64);\n          } else {\n            do {\n              code1 += code3 = this._getWhiteCode();\n            } while (code3 >= 64);\n          }\n          this._addPixels(codingLine[this.codingPos] + code1, blackPixels);\n          blackPixels ^= 1;\n        }\n      }\n      let gotEOL = false;\n      if (this.byteAlign) {\n        this.inputBits &= ~7;\n      }\n      if (!this.eoblock && this.row === this.rows - 1) {\n        this.rowsDone = true;\n      } else {\n        code1 = this._lookBits(12);\n        if (this.eoline) {\n          while (code1 !== ccittEOF && code1 !== 1) {\n            this._eatBits(1);\n            code1 = this._lookBits(12);\n          }\n        } else {\n          while (code1 === 0) {\n            this._eatBits(1);\n            code1 = this._lookBits(12);\n          }\n        }\n        if (code1 === 1) {\n          this._eatBits(12);\n          gotEOL = true;\n        } else if (code1 === ccittEOF) {\n          this.eof = true;\n        }\n      }\n      if (!this.eof && this.encoding > 0 && !this.rowsDone) {\n        this.nextLine2D = !this._lookBits(1);\n        this._eatBits(1);\n      }\n      if (this.eoblock && gotEOL && this.byteAlign) {\n        code1 = this._lookBits(12);\n        if (code1 === 1) {\n          this._eatBits(12);\n          if (this.encoding > 0) {\n            this._lookBits(1);\n            this._eatBits(1);\n          }\n          if (this.encoding >= 0) {\n            for (i = 0; i < 4; ++i) {\n              code1 = this._lookBits(12);\n              if (code1 !== 1) {\n                info(\"bad rtc code: \" + code1);\n              }\n              this._eatBits(12);\n              if (this.encoding > 0) {\n                this._lookBits(1);\n                this._eatBits(1);\n              }\n            }\n          }\n          this.eof = true;\n        }\n      } else if (this.err && this.eoline) {\n        while (true) {\n          code1 = this._lookBits(13);\n          if (code1 === ccittEOF) {\n            this.eof = true;\n            return -1;\n          }\n          if (code1 >> 1 === 1) {\n            break;\n          }\n          this._eatBits(1);\n        }\n        this._eatBits(12);\n        if (this.encoding > 0) {\n          this._eatBits(1);\n          this.nextLine2D = !(code1 & 1);\n        }\n      }\n      this.outputBits = codingLine[0] > 0 ? codingLine[this.codingPos = 0] : codingLine[this.codingPos = 1];\n      this.row++;\n    }\n    let c;\n    if (this.outputBits >= 8) {\n      c = this.codingPos & 1 ? 0 : 0xff;\n      this.outputBits -= 8;\n      if (this.outputBits === 0 && codingLine[this.codingPos] < columns) {\n        this.codingPos++;\n        this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];\n      }\n    } else {\n      bits = 8;\n      c = 0;\n      do {\n        if (typeof this.outputBits !== \"number\") {\n          throw new FormatError('Invalid /CCITTFaxDecode data, \"outputBits\" must be a number.');\n        }\n        if (this.outputBits > bits) {\n          c <<= bits;\n          if (!(this.codingPos & 1)) {\n            c |= 0xff >> 8 - bits;\n          }\n          this.outputBits -= bits;\n          bits = 0;\n        } else {\n          c <<= this.outputBits;\n          if (!(this.codingPos & 1)) {\n            c |= 0xff >> 8 - this.outputBits;\n          }\n          bits -= this.outputBits;\n          this.outputBits = 0;\n          if (codingLine[this.codingPos] < columns) {\n            this.codingPos++;\n            this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];\n          } else if (bits > 0) {\n            c <<= bits;\n            bits = 0;\n          }\n        }\n      } while (bits);\n    }\n    if (this.black) {\n      c ^= 0xff;\n    }\n    return c;\n  }\n  _addPixels(a1, blackPixels) {\n    const codingLine = this.codingLine;\n    let codingPos = this.codingPos;\n    if (a1 > codingLine[codingPos]) {\n      if (a1 > this.columns) {\n        info(\"row is wrong length\");\n        this.err = true;\n        a1 = this.columns;\n      }\n      if (codingPos & 1 ^ blackPixels) {\n        ++codingPos;\n      }\n      codingLine[codingPos] = a1;\n    }\n    this.codingPos = codingPos;\n  }\n  _addPixelsNeg(a1, blackPixels) {\n    const codingLine = this.codingLine;\n    let codingPos = this.codingPos;\n    if (a1 > codingLine[codingPos]) {\n      if (a1 > this.columns) {\n        info(\"row is wrong length\");\n        this.err = true;\n        a1 = this.columns;\n      }\n      if (codingPos & 1 ^ blackPixels) {\n        ++codingPos;\n      }\n      codingLine[codingPos] = a1;\n    } else if (a1 < codingLine[codingPos]) {\n      if (a1 < 0) {\n        info(\"invalid code\");\n        this.err = true;\n        a1 = 0;\n      }\n      while (codingPos > 0 && a1 < codingLine[codingPos - 1]) {\n        --codingPos;\n      }\n      codingLine[codingPos] = a1;\n    }\n    this.codingPos = codingPos;\n  }\n  _findTableCode(start, end, table, limit) {\n    const limitValue = limit || 0;\n    for (let i = start; i <= end; ++i) {\n      let code = this._lookBits(i);\n      if (code === ccittEOF) {\n        return [true, 1, false];\n      }\n      if (i < end) {\n        code <<= end - i;\n      }\n      if (!limitValue || code >= limitValue) {\n        const p = table[code - limitValue];\n        if (p[0] === i) {\n          this._eatBits(i);\n          return [true, p[1], true];\n        }\n      }\n    }\n    return [false, 0, false];\n  }\n  _getTwoDimCode() {\n    let code = 0;\n    let p;\n    if (this.eoblock) {\n      code = this._lookBits(7);\n      p = twoDimTable[code];\n      if (p?.[0] > 0) {\n        this._eatBits(p[0]);\n        return p[1];\n      }\n    } else {\n      const result = this._findTableCode(1, 7, twoDimTable);\n      if (result[0] && result[2]) {\n        return result[1];\n      }\n    }\n    info(\"Bad two dim code\");\n    return ccittEOF;\n  }\n  _getWhiteCode() {\n    let code = 0;\n    let p;\n    if (this.eoblock) {\n      code = this._lookBits(12);\n      if (code === ccittEOF) {\n        return 1;\n      }\n      p = code >> 5 === 0 ? whiteTable1[code] : whiteTable2[code >> 3];\n      if (p[0] > 0) {\n        this._eatBits(p[0]);\n        return p[1];\n      }\n    } else {\n      let result = this._findTableCode(1, 9, whiteTable2);\n      if (result[0]) {\n        return result[1];\n      }\n      result = this._findTableCode(11, 12, whiteTable1);\n      if (result[0]) {\n        return result[1];\n      }\n    }\n    info(\"bad white code\");\n    this._eatBits(1);\n    return 1;\n  }\n  _getBlackCode() {\n    let code, p;\n    if (this.eoblock) {\n      code = this._lookBits(13);\n      if (code === ccittEOF) {\n        return 1;\n      }\n      if (code >> 7 === 0) {\n        p = blackTable1[code];\n      } else if (code >> 9 === 0 && code >> 7 !== 0) {\n        p = blackTable2[(code >> 1) - 64];\n      } else {\n        p = blackTable3[code >> 7];\n      }\n      if (p[0] > 0) {\n        this._eatBits(p[0]);\n        return p[1];\n      }\n    } else {\n      let result = this._findTableCode(2, 6, blackTable3);\n      if (result[0]) {\n        return result[1];\n      }\n      result = this._findTableCode(7, 12, blackTable2, 64);\n      if (result[0]) {\n        return result[1];\n      }\n      result = this._findTableCode(10, 13, blackTable1);\n      if (result[0]) {\n        return result[1];\n      }\n    }\n    info(\"bad black code\");\n    this._eatBits(1);\n    return 1;\n  }\n  _lookBits(n) {\n    let c;\n    while (this.inputBits < n) {\n      if ((c = this.source.next()) === -1) {\n        if (this.inputBits === 0) {\n          return ccittEOF;\n        }\n        return this.inputBuf << n - this.inputBits & 0xffff >> 16 - n;\n      }\n      this.inputBuf = this.inputBuf << 8 | c;\n      this.inputBits += 8;\n    }\n    return this.inputBuf >> this.inputBits - n & 0xffff >> 16 - n;\n  }\n  _eatBits(n) {\n    if ((this.inputBits -= n) < 0) {\n      this.inputBits = 0;\n    }\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/ccitt_stream.js\n\n\n\nclass CCITTFaxStream extends DecodeStream {\n  constructor(str, maybeLength, params) {\n    super(maybeLength);\n    this.str = str;\n    this.dict = str.dict;\n    if (!(params instanceof Dict)) {\n      params = Dict.empty;\n    }\n    const source = {\n      next() {\n        return str.getByte();\n      }\n    };\n    this.ccittFaxDecoder = new CCITTFaxDecoder(source, {\n      K: params.get(\"K\"),\n      EndOfLine: params.get(\"EndOfLine\"),\n      EncodedByteAlign: params.get(\"EncodedByteAlign\"),\n      Columns: params.get(\"Columns\"),\n      Rows: params.get(\"Rows\"),\n      EndOfBlock: params.get(\"EndOfBlock\"),\n      BlackIs1: params.get(\"BlackIs1\")\n    });\n  }\n  readBlock() {\n    while (!this.eof) {\n      const c = this.ccittFaxDecoder.readNextChar();\n      if (c === -1) {\n        this.eof = true;\n        return;\n      }\n      this.ensureBuffer(this.bufferLength + 1);\n      this.buffer[this.bufferLength++] = c;\n    }\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/flate_stream.js\n\n\nconst codeLenCodeMap = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\nconst lengthDecode = new Int32Array([0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a, 0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f, 0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073, 0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102]);\nconst distDecode = new Int32Array([0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d, 0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1, 0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01, 0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001]);\nconst fixedLitCodeTab = [new Int32Array([0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0, 0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0, 0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0, 0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8, 0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8, 0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8, 0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4, 0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4, 0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4, 0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc, 0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec, 0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc, 0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2, 0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2, 0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2, 0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca, 0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea, 0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da, 0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6, 0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6, 0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6, 0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce, 0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee, 0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de, 0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe, 0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1, 0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1, 0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1, 0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9, 0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9, 0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9, 0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5, 0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5, 0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5, 0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd, 0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed, 0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd, 0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3, 0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3, 0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3, 0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb, 0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb, 0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db, 0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7, 0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7, 0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7, 0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf, 0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef, 0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df, 0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff]), 9];\nconst fixedDistCodeTab = [new Int32Array([0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c, 0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000, 0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d, 0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000]), 5];\nclass FlateStream extends DecodeStream {\n  constructor(str, maybeLength) {\n    super(maybeLength);\n    this.str = str;\n    this.dict = str.dict;\n    const cmf = str.getByte();\n    const flg = str.getByte();\n    if (cmf === -1 || flg === -1) {\n      throw new FormatError(`Invalid header in flate stream: ${cmf}, ${flg}`);\n    }\n    if ((cmf & 0x0f) !== 0x08) {\n      throw new FormatError(`Unknown compression method in flate stream: ${cmf}, ${flg}`);\n    }\n    if (((cmf << 8) + flg) % 31 !== 0) {\n      throw new FormatError(`Bad FCHECK in flate stream: ${cmf}, ${flg}`);\n    }\n    if (flg & 0x20) {\n      throw new FormatError(`FDICT bit set in flate stream: ${cmf}, ${flg}`);\n    }\n    this.codeSize = 0;\n    this.codeBuf = 0;\n  }\n  getBits(bits) {\n    const str = this.str;\n    let codeSize = this.codeSize;\n    let codeBuf = this.codeBuf;\n    let b;\n    while (codeSize < bits) {\n      if ((b = str.getByte()) === -1) {\n        throw new FormatError(\"Bad encoding in flate stream\");\n      }\n      codeBuf |= b << codeSize;\n      codeSize += 8;\n    }\n    b = codeBuf & (1 << bits) - 1;\n    this.codeBuf = codeBuf >> bits;\n    this.codeSize = codeSize -= bits;\n    return b;\n  }\n  getCode(table) {\n    const str = this.str;\n    const codes = table[0];\n    const maxLen = table[1];\n    let codeSize = this.codeSize;\n    let codeBuf = this.codeBuf;\n    let b;\n    while (codeSize < maxLen) {\n      if ((b = str.getByte()) === -1) {\n        break;\n      }\n      codeBuf |= b << codeSize;\n      codeSize += 8;\n    }\n    const code = codes[codeBuf & (1 << maxLen) - 1];\n    const codeLen = code >> 16;\n    const codeVal = code & 0xffff;\n    if (codeLen < 1 || codeSize < codeLen) {\n      throw new FormatError(\"Bad encoding in flate stream\");\n    }\n    this.codeBuf = codeBuf >> codeLen;\n    this.codeSize = codeSize - codeLen;\n    return codeVal;\n  }\n  generateHuffmanTable(lengths) {\n    const n = lengths.length;\n    let maxLen = 0;\n    let i;\n    for (i = 0; i < n; ++i) {\n      if (lengths[i] > maxLen) {\n        maxLen = lengths[i];\n      }\n    }\n    const size = 1 << maxLen;\n    const codes = new Int32Array(size);\n    for (let len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {\n      for (let val = 0; val < n; ++val) {\n        if (lengths[val] === len) {\n          let code2 = 0;\n          let t = code;\n          for (i = 0; i < len; ++i) {\n            code2 = code2 << 1 | t & 1;\n            t >>= 1;\n          }\n          for (i = code2; i < size; i += skip) {\n            codes[i] = len << 16 | val;\n          }\n          ++code;\n        }\n      }\n    }\n    return [codes, maxLen];\n  }\n  #endsStreamOnError(err) {\n    info(err);\n    this.eof = true;\n  }\n  readBlock() {\n    let buffer, len;\n    const str = this.str;\n    let hdr = this.getBits(3);\n    if (hdr & 1) {\n      this.eof = true;\n    }\n    hdr >>= 1;\n    if (hdr === 0) {\n      let b;\n      if ((b = str.getByte()) === -1) {\n        this.#endsStreamOnError(\"Bad block header in flate stream\");\n        return;\n      }\n      let blockLen = b;\n      if ((b = str.getByte()) === -1) {\n        this.#endsStreamOnError(\"Bad block header in flate stream\");\n        return;\n      }\n      blockLen |= b << 8;\n      if ((b = str.getByte()) === -1) {\n        this.#endsStreamOnError(\"Bad block header in flate stream\");\n        return;\n      }\n      let check = b;\n      if ((b = str.getByte()) === -1) {\n        this.#endsStreamOnError(\"Bad block header in flate stream\");\n        return;\n      }\n      check |= b << 8;\n      if (check !== (~blockLen & 0xffff) && (blockLen !== 0 || check !== 0)) {\n        throw new FormatError(\"Bad uncompressed block length in flate stream\");\n      }\n      this.codeBuf = 0;\n      this.codeSize = 0;\n      const bufferLength = this.bufferLength,\n        end = bufferLength + blockLen;\n      buffer = this.ensureBuffer(end);\n      this.bufferLength = end;\n      if (blockLen === 0) {\n        if (str.peekByte() === -1) {\n          this.eof = true;\n        }\n      } else {\n        const block = str.getBytes(blockLen);\n        buffer.set(block, bufferLength);\n        if (block.length < blockLen) {\n          this.eof = true;\n        }\n      }\n      return;\n    }\n    let litCodeTable;\n    let distCodeTable;\n    if (hdr === 1) {\n      litCodeTable = fixedLitCodeTab;\n      distCodeTable = fixedDistCodeTab;\n    } else if (hdr === 2) {\n      const numLitCodes = this.getBits(5) + 257;\n      const numDistCodes = this.getBits(5) + 1;\n      const numCodeLenCodes = this.getBits(4) + 4;\n      const codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);\n      let i;\n      for (i = 0; i < numCodeLenCodes; ++i) {\n        codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);\n      }\n      const codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);\n      len = 0;\n      i = 0;\n      const codes = numLitCodes + numDistCodes;\n      const codeLengths = new Uint8Array(codes);\n      let bitsLength, bitsOffset, what;\n      while (i < codes) {\n        const code = this.getCode(codeLenCodeTab);\n        if (code === 16) {\n          bitsLength = 2;\n          bitsOffset = 3;\n          what = len;\n        } else if (code === 17) {\n          bitsLength = 3;\n          bitsOffset = 3;\n          what = len = 0;\n        } else if (code === 18) {\n          bitsLength = 7;\n          bitsOffset = 11;\n          what = len = 0;\n        } else {\n          codeLengths[i++] = len = code;\n          continue;\n        }\n        let repeatLength = this.getBits(bitsLength) + bitsOffset;\n        while (repeatLength-- > 0) {\n          codeLengths[i++] = what;\n        }\n      }\n      litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));\n      distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));\n    } else {\n      throw new FormatError(\"Unknown block type in flate stream\");\n    }\n    buffer = this.buffer;\n    let limit = buffer ? buffer.length : 0;\n    let pos = this.bufferLength;\n    while (true) {\n      let code1 = this.getCode(litCodeTable);\n      if (code1 < 256) {\n        if (pos + 1 >= limit) {\n          buffer = this.ensureBuffer(pos + 1);\n          limit = buffer.length;\n        }\n        buffer[pos++] = code1;\n        continue;\n      }\n      if (code1 === 256) {\n        this.bufferLength = pos;\n        return;\n      }\n      code1 -= 257;\n      code1 = lengthDecode[code1];\n      let code2 = code1 >> 16;\n      if (code2 > 0) {\n        code2 = this.getBits(code2);\n      }\n      len = (code1 & 0xffff) + code2;\n      code1 = this.getCode(distCodeTable);\n      code1 = distDecode[code1];\n      code2 = code1 >> 16;\n      if (code2 > 0) {\n        code2 = this.getBits(code2);\n      }\n      const dist = (code1 & 0xffff) + code2;\n      if (pos + len >= limit) {\n        buffer = this.ensureBuffer(pos + len);\n        limit = buffer.length;\n      }\n      for (let k = 0; k < len; ++k, ++pos) {\n        buffer[pos] = buffer[pos - dist];\n      }\n    }\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/arithmetic_decoder.js\nconst QeTable = [{\n  qe: 0x5601,\n  nmps: 1,\n  nlps: 1,\n  switchFlag: 1\n}, {\n  qe: 0x3401,\n  nmps: 2,\n  nlps: 6,\n  switchFlag: 0\n}, {\n  qe: 0x1801,\n  nmps: 3,\n  nlps: 9,\n  switchFlag: 0\n}, {\n  qe: 0x0ac1,\n  nmps: 4,\n  nlps: 12,\n  switchFlag: 0\n}, {\n  qe: 0x0521,\n  nmps: 5,\n  nlps: 29,\n  switchFlag: 0\n}, {\n  qe: 0x0221,\n  nmps: 38,\n  nlps: 33,\n  switchFlag: 0\n}, {\n  qe: 0x5601,\n  nmps: 7,\n  nlps: 6,\n  switchFlag: 1\n}, {\n  qe: 0x5401,\n  nmps: 8,\n  nlps: 14,\n  switchFlag: 0\n}, {\n  qe: 0x4801,\n  nmps: 9,\n  nlps: 14,\n  switchFlag: 0\n}, {\n  qe: 0x3801,\n  nmps: 10,\n  nlps: 14,\n  switchFlag: 0\n}, {\n  qe: 0x3001,\n  nmps: 11,\n  nlps: 17,\n  switchFlag: 0\n}, {\n  qe: 0x2401,\n  nmps: 12,\n  nlps: 18,\n  switchFlag: 0\n}, {\n  qe: 0x1c01,\n  nmps: 13,\n  nlps: 20,\n  switchFlag: 0\n}, {\n  qe: 0x1601,\n  nmps: 29,\n  nlps: 21,\n  switchFlag: 0\n}, {\n  qe: 0x5601,\n  nmps: 15,\n  nlps: 14,\n  switchFlag: 1\n}, {\n  qe: 0x5401,\n  nmps: 16,\n  nlps: 14,\n  switchFlag: 0\n}, {\n  qe: 0x5101,\n  nmps: 17,\n  nlps: 15,\n  switchFlag: 0\n}, {\n  qe: 0x4801,\n  nmps: 18,\n  nlps: 16,\n  switchFlag: 0\n}, {\n  qe: 0x3801,\n  nmps: 19,\n  nlps: 17,\n  switchFlag: 0\n}, {\n  qe: 0x3401,\n  nmps: 20,\n  nlps: 18,\n  switchFlag: 0\n}, {\n  qe: 0x3001,\n  nmps: 21,\n  nlps: 19,\n  switchFlag: 0\n}, {\n  qe: 0x2801,\n  nmps: 22,\n  nlps: 19,\n  switchFlag: 0\n}, {\n  qe: 0x2401,\n  nmps: 23,\n  nlps: 20,\n  switchFlag: 0\n}, {\n  qe: 0x2201,\n  nmps: 24,\n  nlps: 21,\n  switchFlag: 0\n}, {\n  qe: 0x1c01,\n  nmps: 25,\n  nlps: 22,\n  switchFlag: 0\n}, {\n  qe: 0x1801,\n  nmps: 26,\n  nlps: 23,\n  switchFlag: 0\n}, {\n  qe: 0x1601,\n  nmps: 27,\n  nlps: 24,\n  switchFlag: 0\n}, {\n  qe: 0x1401,\n  nmps: 28,\n  nlps: 25,\n  switchFlag: 0\n}, {\n  qe: 0x1201,\n  nmps: 29,\n  nlps: 26,\n  switchFlag: 0\n}, {\n  qe: 0x1101,\n  nmps: 30,\n  nlps: 27,\n  switchFlag: 0\n}, {\n  qe: 0x0ac1,\n  nmps: 31,\n  nlps: 28,\n  switchFlag: 0\n}, {\n  qe: 0x09c1,\n  nmps: 32,\n  nlps: 29,\n  switchFlag: 0\n}, {\n  qe: 0x08a1,\n  nmps: 33,\n  nlps: 30,\n  switchFlag: 0\n}, {\n  qe: 0x0521,\n  nmps: 34,\n  nlps: 31,\n  switchFlag: 0\n}, {\n  qe: 0x0441,\n  nmps: 35,\n  nlps: 32,\n  switchFlag: 0\n}, {\n  qe: 0x02a1,\n  nmps: 36,\n  nlps: 33,\n  switchFlag: 0\n}, {\n  qe: 0x0221,\n  nmps: 37,\n  nlps: 34,\n  switchFlag: 0\n}, {\n  qe: 0x0141,\n  nmps: 38,\n  nlps: 35,\n  switchFlag: 0\n}, {\n  qe: 0x0111,\n  nmps: 39,\n  nlps: 36,\n  switchFlag: 0\n}, {\n  qe: 0x0085,\n  nmps: 40,\n  nlps: 37,\n  switchFlag: 0\n}, {\n  qe: 0x0049,\n  nmps: 41,\n  nlps: 38,\n  switchFlag: 0\n}, {\n  qe: 0x0025,\n  nmps: 42,\n  nlps: 39,\n  switchFlag: 0\n}, {\n  qe: 0x0015,\n  nmps: 43,\n  nlps: 40,\n  switchFlag: 0\n}, {\n  qe: 0x0009,\n  nmps: 44,\n  nlps: 41,\n  switchFlag: 0\n}, {\n  qe: 0x0005,\n  nmps: 45,\n  nlps: 42,\n  switchFlag: 0\n}, {\n  qe: 0x0001,\n  nmps: 45,\n  nlps: 43,\n  switchFlag: 0\n}, {\n  qe: 0x5601,\n  nmps: 46,\n  nlps: 46,\n  switchFlag: 0\n}];\nclass ArithmeticDecoder {\n  constructor(data, start, end) {\n    this.data = data;\n    this.bp = start;\n    this.dataEnd = end;\n    this.chigh = data[start];\n    this.clow = 0;\n    this.byteIn();\n    this.chigh = this.chigh << 7 & 0xffff | this.clow >> 9 & 0x7f;\n    this.clow = this.clow << 7 & 0xffff;\n    this.ct -= 7;\n    this.a = 0x8000;\n  }\n  byteIn() {\n    const data = this.data;\n    let bp = this.bp;\n    if (data[bp] === 0xff) {\n      if (data[bp + 1] > 0x8f) {\n        this.clow += 0xff00;\n        this.ct = 8;\n      } else {\n        bp++;\n        this.clow += data[bp] << 9;\n        this.ct = 7;\n        this.bp = bp;\n      }\n    } else {\n      bp++;\n      this.clow += bp < this.dataEnd ? data[bp] << 8 : 0xff00;\n      this.ct = 8;\n      this.bp = bp;\n    }\n    if (this.clow > 0xffff) {\n      this.chigh += this.clow >> 16;\n      this.clow &= 0xffff;\n    }\n  }\n  readBit(contexts, pos) {\n    let cx_index = contexts[pos] >> 1,\n      cx_mps = contexts[pos] & 1;\n    const qeTableIcx = QeTable[cx_index];\n    const qeIcx = qeTableIcx.qe;\n    let d;\n    let a = this.a - qeIcx;\n    if (this.chigh < qeIcx) {\n      if (a < qeIcx) {\n        a = qeIcx;\n        d = cx_mps;\n        cx_index = qeTableIcx.nmps;\n      } else {\n        a = qeIcx;\n        d = 1 ^ cx_mps;\n        if (qeTableIcx.switchFlag === 1) {\n          cx_mps = d;\n        }\n        cx_index = qeTableIcx.nlps;\n      }\n    } else {\n      this.chigh -= qeIcx;\n      if ((a & 0x8000) !== 0) {\n        this.a = a;\n        return cx_mps;\n      }\n      if (a < qeIcx) {\n        d = 1 ^ cx_mps;\n        if (qeTableIcx.switchFlag === 1) {\n          cx_mps = d;\n        }\n        cx_index = qeTableIcx.nlps;\n      } else {\n        d = cx_mps;\n        cx_index = qeTableIcx.nmps;\n      }\n    }\n    do {\n      if (this.ct === 0) {\n        this.byteIn();\n      }\n      a <<= 1;\n      this.chigh = this.chigh << 1 & 0xffff | this.clow >> 15 & 1;\n      this.clow = this.clow << 1 & 0xffff;\n      this.ct--;\n    } while ((a & 0x8000) === 0);\n    this.a = a;\n    contexts[pos] = cx_index << 1 | cx_mps;\n    return d;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/jbig2.js\n\n\n\n\nclass Jbig2Error extends BaseException {\n  constructor(msg) {\n    super(msg, \"Jbig2Error\");\n  }\n}\nclass ContextCache {\n  getContexts(id) {\n    if (id in this) {\n      return this[id];\n    }\n    return this[id] = new Int8Array(1 << 16);\n  }\n}\nclass DecodingContext {\n  constructor(data, start, end) {\n    this.data = data;\n    this.start = start;\n    this.end = end;\n  }\n  get decoder() {\n    const decoder = new ArithmeticDecoder(this.data, this.start, this.end);\n    return shadow(this, \"decoder\", decoder);\n  }\n  get contextCache() {\n    const cache = new ContextCache();\n    return shadow(this, \"contextCache\", cache);\n  }\n}\nconst MAX_INT_32 = 2 ** 31 - 1;\nconst MIN_INT_32 = -(2 ** 31);\nfunction decodeInteger(contextCache, procedure, decoder) {\n  const contexts = contextCache.getContexts(procedure);\n  let prev = 1;\n  function readBits(length) {\n    let v = 0;\n    for (let i = 0; i < length; i++) {\n      const bit = decoder.readBit(contexts, prev);\n      prev = prev < 256 ? prev << 1 | bit : (prev << 1 | bit) & 511 | 256;\n      v = v << 1 | bit;\n    }\n    return v >>> 0;\n  }\n  const sign = readBits(1);\n  const value = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);\n  let signedValue;\n  if (sign === 0) {\n    signedValue = value;\n  } else if (value > 0) {\n    signedValue = -value;\n  }\n  if (signedValue >= MIN_INT_32 && signedValue <= MAX_INT_32) {\n    return signedValue;\n  }\n  return null;\n}\nfunction decodeIAID(contextCache, decoder, codeLength) {\n  const contexts = contextCache.getContexts(\"IAID\");\n  let prev = 1;\n  for (let i = 0; i < codeLength; i++) {\n    const bit = decoder.readBit(contexts, prev);\n    prev = prev << 1 | bit;\n  }\n  if (codeLength < 31) {\n    return prev & (1 << codeLength) - 1;\n  }\n  return prev & 0x7fffffff;\n}\nconst SegmentTypes = [\"SymbolDictionary\", null, null, null, \"IntermediateTextRegion\", null, \"ImmediateTextRegion\", \"ImmediateLosslessTextRegion\", null, null, null, null, null, null, null, null, \"PatternDictionary\", null, null, null, \"IntermediateHalftoneRegion\", null, \"ImmediateHalftoneRegion\", \"ImmediateLosslessHalftoneRegion\", null, null, null, null, null, null, null, null, null, null, null, null, \"IntermediateGenericRegion\", null, \"ImmediateGenericRegion\", \"ImmediateLosslessGenericRegion\", \"IntermediateGenericRefinementRegion\", null, \"ImmediateGenericRefinementRegion\", \"ImmediateLosslessGenericRefinementRegion\", null, null, null, null, \"PageInformation\", \"EndOfPage\", \"EndOfStripe\", \"EndOfFile\", \"Profiles\", \"Tables\", null, null, null, null, null, null, null, null, \"Extension\"];\nconst CodingTemplates = [[{\n  x: -1,\n  y: -2\n}, {\n  x: 0,\n  y: -2\n}, {\n  x: 1,\n  y: -2\n}, {\n  x: -2,\n  y: -1\n}, {\n  x: -1,\n  y: -1\n}, {\n  x: 0,\n  y: -1\n}, {\n  x: 1,\n  y: -1\n}, {\n  x: 2,\n  y: -1\n}, {\n  x: -4,\n  y: 0\n}, {\n  x: -3,\n  y: 0\n}, {\n  x: -2,\n  y: 0\n}, {\n  x: -1,\n  y: 0\n}], [{\n  x: -1,\n  y: -2\n}, {\n  x: 0,\n  y: -2\n}, {\n  x: 1,\n  y: -2\n}, {\n  x: 2,\n  y: -2\n}, {\n  x: -2,\n  y: -1\n}, {\n  x: -1,\n  y: -1\n}, {\n  x: 0,\n  y: -1\n}, {\n  x: 1,\n  y: -1\n}, {\n  x: 2,\n  y: -1\n}, {\n  x: -3,\n  y: 0\n}, {\n  x: -2,\n  y: 0\n}, {\n  x: -1,\n  y: 0\n}], [{\n  x: -1,\n  y: -2\n}, {\n  x: 0,\n  y: -2\n}, {\n  x: 1,\n  y: -2\n}, {\n  x: -2,\n  y: -1\n}, {\n  x: -1,\n  y: -1\n}, {\n  x: 0,\n  y: -1\n}, {\n  x: 1,\n  y: -1\n}, {\n  x: -2,\n  y: 0\n}, {\n  x: -1,\n  y: 0\n}], [{\n  x: -3,\n  y: -1\n}, {\n  x: -2,\n  y: -1\n}, {\n  x: -1,\n  y: -1\n}, {\n  x: 0,\n  y: -1\n}, {\n  x: 1,\n  y: -1\n}, {\n  x: -4,\n  y: 0\n}, {\n  x: -3,\n  y: 0\n}, {\n  x: -2,\n  y: 0\n}, {\n  x: -1,\n  y: 0\n}]];\nconst RefinementTemplates = [{\n  coding: [{\n    x: 0,\n    y: -1\n  }, {\n    x: 1,\n    y: -1\n  }, {\n    x: -1,\n    y: 0\n  }],\n  reference: [{\n    x: 0,\n    y: -1\n  }, {\n    x: 1,\n    y: -1\n  }, {\n    x: -1,\n    y: 0\n  }, {\n    x: 0,\n    y: 0\n  }, {\n    x: 1,\n    y: 0\n  }, {\n    x: -1,\n    y: 1\n  }, {\n    x: 0,\n    y: 1\n  }, {\n    x: 1,\n    y: 1\n  }]\n}, {\n  coding: [{\n    x: -1,\n    y: -1\n  }, {\n    x: 0,\n    y: -1\n  }, {\n    x: 1,\n    y: -1\n  }, {\n    x: -1,\n    y: 0\n  }],\n  reference: [{\n    x: 0,\n    y: -1\n  }, {\n    x: -1,\n    y: 0\n  }, {\n    x: 0,\n    y: 0\n  }, {\n    x: 1,\n    y: 0\n  }, {\n    x: 0,\n    y: 1\n  }, {\n    x: 1,\n    y: 1\n  }]\n}];\nconst ReusedContexts = [0x9b25, 0x0795, 0x00e5, 0x0195];\nconst RefinementReusedContexts = [0x0020, 0x0008];\nfunction decodeBitmapTemplate0(width, height, decodingContext) {\n  const decoder = decodingContext.decoder;\n  const contexts = decodingContext.contextCache.getContexts(\"GB\");\n  const bitmap = [];\n  let contextLabel, i, j, pixel, row, row1, row2;\n  const OLD_PIXEL_MASK = 0x7bf7;\n  for (i = 0; i < height; i++) {\n    row = bitmap[i] = new Uint8Array(width);\n    row1 = i < 1 ? row : bitmap[i - 1];\n    row2 = i < 2 ? row : bitmap[i - 2];\n    contextLabel = row2[0] << 13 | row2[1] << 12 | row2[2] << 11 | row1[0] << 7 | row1[1] << 6 | row1[2] << 5 | row1[3] << 4;\n    for (j = 0; j < width; j++) {\n      row[j] = pixel = decoder.readBit(contexts, contextLabel);\n      contextLabel = (contextLabel & OLD_PIXEL_MASK) << 1 | (j + 3 < width ? row2[j + 3] << 11 : 0) | (j + 4 < width ? row1[j + 4] << 4 : 0) | pixel;\n    }\n  }\n  return bitmap;\n}\nfunction decodeBitmap(mmr, width, height, templateIndex, prediction, skip, at, decodingContext) {\n  if (mmr) {\n    const input = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);\n    return decodeMMRBitmap(input, width, height, false);\n  }\n  if (templateIndex === 0 && !skip && !prediction && at.length === 4 && at[0].x === 3 && at[0].y === -1 && at[1].x === -3 && at[1].y === -1 && at[2].x === 2 && at[2].y === -2 && at[3].x === -2 && at[3].y === -2) {\n    return decodeBitmapTemplate0(width, height, decodingContext);\n  }\n  const useskip = !!skip;\n  const template = CodingTemplates[templateIndex].concat(at);\n  template.sort(function (a, b) {\n    return a.y - b.y || a.x - b.x;\n  });\n  const templateLength = template.length;\n  const templateX = new Int8Array(templateLength);\n  const templateY = new Int8Array(templateLength);\n  const changingTemplateEntries = [];\n  let reuseMask = 0,\n    minX = 0,\n    maxX = 0,\n    minY = 0;\n  let c, k;\n  for (k = 0; k < templateLength; k++) {\n    templateX[k] = template[k].x;\n    templateY[k] = template[k].y;\n    minX = Math.min(minX, template[k].x);\n    maxX = Math.max(maxX, template[k].x);\n    minY = Math.min(minY, template[k].y);\n    if (k < templateLength - 1 && template[k].y === template[k + 1].y && template[k].x === template[k + 1].x - 1) {\n      reuseMask |= 1 << templateLength - 1 - k;\n    } else {\n      changingTemplateEntries.push(k);\n    }\n  }\n  const changingEntriesLength = changingTemplateEntries.length;\n  const changingTemplateX = new Int8Array(changingEntriesLength);\n  const changingTemplateY = new Int8Array(changingEntriesLength);\n  const changingTemplateBit = new Uint16Array(changingEntriesLength);\n  for (c = 0; c < changingEntriesLength; c++) {\n    k = changingTemplateEntries[c];\n    changingTemplateX[c] = template[k].x;\n    changingTemplateY[c] = template[k].y;\n    changingTemplateBit[c] = 1 << templateLength - 1 - k;\n  }\n  const sbb_left = -minX;\n  const sbb_top = -minY;\n  const sbb_right = width - maxX;\n  const pseudoPixelContext = ReusedContexts[templateIndex];\n  let row = new Uint8Array(width);\n  const bitmap = [];\n  const decoder = decodingContext.decoder;\n  const contexts = decodingContext.contextCache.getContexts(\"GB\");\n  let ltp = 0,\n    j,\n    i0,\n    j0,\n    contextLabel = 0,\n    bit,\n    shift;\n  for (let i = 0; i < height; i++) {\n    if (prediction) {\n      const sltp = decoder.readBit(contexts, pseudoPixelContext);\n      ltp ^= sltp;\n      if (ltp) {\n        bitmap.push(row);\n        continue;\n      }\n    }\n    row = new Uint8Array(row);\n    bitmap.push(row);\n    for (j = 0; j < width; j++) {\n      if (useskip && skip[i][j]) {\n        row[j] = 0;\n        continue;\n      }\n      if (j >= sbb_left && j < sbb_right && i >= sbb_top) {\n        contextLabel = contextLabel << 1 & reuseMask;\n        for (k = 0; k < changingEntriesLength; k++) {\n          i0 = i + changingTemplateY[k];\n          j0 = j + changingTemplateX[k];\n          bit = bitmap[i0][j0];\n          if (bit) {\n            bit = changingTemplateBit[k];\n            contextLabel |= bit;\n          }\n        }\n      } else {\n        contextLabel = 0;\n        shift = templateLength - 1;\n        for (k = 0; k < templateLength; k++, shift--) {\n          j0 = j + templateX[k];\n          if (j0 >= 0 && j0 < width) {\n            i0 = i + templateY[k];\n            if (i0 >= 0) {\n              bit = bitmap[i0][j0];\n              if (bit) {\n                contextLabel |= bit << shift;\n              }\n            }\n          }\n        }\n      }\n      const pixel = decoder.readBit(contexts, contextLabel);\n      row[j] = pixel;\n    }\n  }\n  return bitmap;\n}\nfunction decodeRefinement(width, height, templateIndex, referenceBitmap, offsetX, offsetY, prediction, at, decodingContext) {\n  let codingTemplate = RefinementTemplates[templateIndex].coding;\n  if (templateIndex === 0) {\n    codingTemplate = codingTemplate.concat([at[0]]);\n  }\n  const codingTemplateLength = codingTemplate.length;\n  const codingTemplateX = new Int32Array(codingTemplateLength);\n  const codingTemplateY = new Int32Array(codingTemplateLength);\n  let k;\n  for (k = 0; k < codingTemplateLength; k++) {\n    codingTemplateX[k] = codingTemplate[k].x;\n    codingTemplateY[k] = codingTemplate[k].y;\n  }\n  let referenceTemplate = RefinementTemplates[templateIndex].reference;\n  if (templateIndex === 0) {\n    referenceTemplate = referenceTemplate.concat([at[1]]);\n  }\n  const referenceTemplateLength = referenceTemplate.length;\n  const referenceTemplateX = new Int32Array(referenceTemplateLength);\n  const referenceTemplateY = new Int32Array(referenceTemplateLength);\n  for (k = 0; k < referenceTemplateLength; k++) {\n    referenceTemplateX[k] = referenceTemplate[k].x;\n    referenceTemplateY[k] = referenceTemplate[k].y;\n  }\n  const referenceWidth = referenceBitmap[0].length;\n  const referenceHeight = referenceBitmap.length;\n  const pseudoPixelContext = RefinementReusedContexts[templateIndex];\n  const bitmap = [];\n  const decoder = decodingContext.decoder;\n  const contexts = decodingContext.contextCache.getContexts(\"GR\");\n  let ltp = 0;\n  for (let i = 0; i < height; i++) {\n    if (prediction) {\n      const sltp = decoder.readBit(contexts, pseudoPixelContext);\n      ltp ^= sltp;\n      if (ltp) {\n        throw new Jbig2Error(\"prediction is not supported\");\n      }\n    }\n    const row = new Uint8Array(width);\n    bitmap.push(row);\n    for (let j = 0; j < width; j++) {\n      let i0, j0;\n      let contextLabel = 0;\n      for (k = 0; k < codingTemplateLength; k++) {\n        i0 = i + codingTemplateY[k];\n        j0 = j + codingTemplateX[k];\n        if (i0 < 0 || j0 < 0 || j0 >= width) {\n          contextLabel <<= 1;\n        } else {\n          contextLabel = contextLabel << 1 | bitmap[i0][j0];\n        }\n      }\n      for (k = 0; k < referenceTemplateLength; k++) {\n        i0 = i + referenceTemplateY[k] - offsetY;\n        j0 = j + referenceTemplateX[k] - offsetX;\n        if (i0 < 0 || i0 >= referenceHeight || j0 < 0 || j0 >= referenceWidth) {\n          contextLabel <<= 1;\n        } else {\n          contextLabel = contextLabel << 1 | referenceBitmap[i0][j0];\n        }\n      }\n      const pixel = decoder.readBit(contexts, contextLabel);\n      row[j] = pixel;\n    }\n  }\n  return bitmap;\n}\nfunction decodeSymbolDictionary(huffman, refinement, symbols, numberOfNewSymbols, numberOfExportedSymbols, huffmanTables, templateIndex, at, refinementTemplateIndex, refinementAt, decodingContext, huffmanInput) {\n  if (huffman && refinement) {\n    throw new Jbig2Error(\"symbol refinement with Huffman is not supported\");\n  }\n  const newSymbols = [];\n  let currentHeight = 0;\n  let symbolCodeLength = log2(symbols.length + numberOfNewSymbols);\n  const decoder = decodingContext.decoder;\n  const contextCache = decodingContext.contextCache;\n  let tableB1, symbolWidths;\n  if (huffman) {\n    tableB1 = getStandardTable(1);\n    symbolWidths = [];\n    symbolCodeLength = Math.max(symbolCodeLength, 1);\n  }\n  while (newSymbols.length < numberOfNewSymbols) {\n    const deltaHeight = huffman ? huffmanTables.tableDeltaHeight.decode(huffmanInput) : decodeInteger(contextCache, \"IADH\", decoder);\n    currentHeight += deltaHeight;\n    let currentWidth = 0,\n      totalWidth = 0;\n    const firstSymbol = huffman ? symbolWidths.length : 0;\n    while (true) {\n      const deltaWidth = huffman ? huffmanTables.tableDeltaWidth.decode(huffmanInput) : decodeInteger(contextCache, \"IADW\", decoder);\n      if (deltaWidth === null) {\n        break;\n      }\n      currentWidth += deltaWidth;\n      totalWidth += currentWidth;\n      let bitmap;\n      if (refinement) {\n        const numberOfInstances = decodeInteger(contextCache, \"IAAI\", decoder);\n        if (numberOfInstances > 1) {\n          bitmap = decodeTextRegion(huffman, refinement, currentWidth, currentHeight, 0, numberOfInstances, 1, symbols.concat(newSymbols), symbolCodeLength, 0, 0, 1, 0, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, 0, huffmanInput);\n        } else {\n          const symbolId = decodeIAID(contextCache, decoder, symbolCodeLength);\n          const rdx = decodeInteger(contextCache, \"IARDX\", decoder);\n          const rdy = decodeInteger(contextCache, \"IARDY\", decoder);\n          const symbol = symbolId < symbols.length ? symbols[symbolId] : newSymbols[symbolId - symbols.length];\n          bitmap = decodeRefinement(currentWidth, currentHeight, refinementTemplateIndex, symbol, rdx, rdy, false, refinementAt, decodingContext);\n        }\n        newSymbols.push(bitmap);\n      } else if (huffman) {\n        symbolWidths.push(currentWidth);\n      } else {\n        bitmap = decodeBitmap(false, currentWidth, currentHeight, templateIndex, false, null, at, decodingContext);\n        newSymbols.push(bitmap);\n      }\n    }\n    if (huffman && !refinement) {\n      const bitmapSize = huffmanTables.tableBitmapSize.decode(huffmanInput);\n      huffmanInput.byteAlign();\n      let collectiveBitmap;\n      if (bitmapSize === 0) {\n        collectiveBitmap = readUncompressedBitmap(huffmanInput, totalWidth, currentHeight);\n      } else {\n        const originalEnd = huffmanInput.end;\n        const bitmapEnd = huffmanInput.position + bitmapSize;\n        huffmanInput.end = bitmapEnd;\n        collectiveBitmap = decodeMMRBitmap(huffmanInput, totalWidth, currentHeight, false);\n        huffmanInput.end = originalEnd;\n        huffmanInput.position = bitmapEnd;\n      }\n      const numberOfSymbolsDecoded = symbolWidths.length;\n      if (firstSymbol === numberOfSymbolsDecoded - 1) {\n        newSymbols.push(collectiveBitmap);\n      } else {\n        let i,\n          y,\n          xMin = 0,\n          xMax,\n          bitmapWidth,\n          symbolBitmap;\n        for (i = firstSymbol; i < numberOfSymbolsDecoded; i++) {\n          bitmapWidth = symbolWidths[i];\n          xMax = xMin + bitmapWidth;\n          symbolBitmap = [];\n          for (y = 0; y < currentHeight; y++) {\n            symbolBitmap.push(collectiveBitmap[y].subarray(xMin, xMax));\n          }\n          newSymbols.push(symbolBitmap);\n          xMin = xMax;\n        }\n      }\n    }\n  }\n  const exportedSymbols = [],\n    flags = [];\n  let currentFlag = false,\n    i,\n    ii;\n  const totalSymbolsLength = symbols.length + numberOfNewSymbols;\n  while (flags.length < totalSymbolsLength) {\n    let runLength = huffman ? tableB1.decode(huffmanInput) : decodeInteger(contextCache, \"IAEX\", decoder);\n    while (runLength--) {\n      flags.push(currentFlag);\n    }\n    currentFlag = !currentFlag;\n  }\n  for (i = 0, ii = symbols.length; i < ii; i++) {\n    if (flags[i]) {\n      exportedSymbols.push(symbols[i]);\n    }\n  }\n  for (let j = 0; j < numberOfNewSymbols; i++, j++) {\n    if (flags[i]) {\n      exportedSymbols.push(newSymbols[j]);\n    }\n  }\n  return exportedSymbols;\n}\nfunction decodeTextRegion(huffman, refinement, width, height, defaultPixelValue, numberOfSymbolInstances, stripSize, inputSymbols, symbolCodeLength, transposed, dsOffset, referenceCorner, combinationOperator, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, logStripSize, huffmanInput) {\n  if (huffman && refinement) {\n    throw new Jbig2Error(\"refinement with Huffman is not supported\");\n  }\n  const bitmap = [];\n  let i, row;\n  for (i = 0; i < height; i++) {\n    row = new Uint8Array(width);\n    if (defaultPixelValue) {\n      for (let j = 0; j < width; j++) {\n        row[j] = defaultPixelValue;\n      }\n    }\n    bitmap.push(row);\n  }\n  const decoder = decodingContext.decoder;\n  const contextCache = decodingContext.contextCache;\n  let stripT = huffman ? -huffmanTables.tableDeltaT.decode(huffmanInput) : -decodeInteger(contextCache, \"IADT\", decoder);\n  let firstS = 0;\n  i = 0;\n  while (i < numberOfSymbolInstances) {\n    const deltaT = huffman ? huffmanTables.tableDeltaT.decode(huffmanInput) : decodeInteger(contextCache, \"IADT\", decoder);\n    stripT += deltaT;\n    const deltaFirstS = huffman ? huffmanTables.tableFirstS.decode(huffmanInput) : decodeInteger(contextCache, \"IAFS\", decoder);\n    firstS += deltaFirstS;\n    let currentS = firstS;\n    do {\n      let currentT = 0;\n      if (stripSize > 1) {\n        currentT = huffman ? huffmanInput.readBits(logStripSize) : decodeInteger(contextCache, \"IAIT\", decoder);\n      }\n      const t = stripSize * stripT + currentT;\n      const symbolId = huffman ? huffmanTables.symbolIDTable.decode(huffmanInput) : decodeIAID(contextCache, decoder, symbolCodeLength);\n      const applyRefinement = refinement && (huffman ? huffmanInput.readBit() : decodeInteger(contextCache, \"IARI\", decoder));\n      let symbolBitmap = inputSymbols[symbolId];\n      let symbolWidth = symbolBitmap[0].length;\n      let symbolHeight = symbolBitmap.length;\n      if (applyRefinement) {\n        const rdw = decodeInteger(contextCache, \"IARDW\", decoder);\n        const rdh = decodeInteger(contextCache, \"IARDH\", decoder);\n        const rdx = decodeInteger(contextCache, \"IARDX\", decoder);\n        const rdy = decodeInteger(contextCache, \"IARDY\", decoder);\n        symbolWidth += rdw;\n        symbolHeight += rdh;\n        symbolBitmap = decodeRefinement(symbolWidth, symbolHeight, refinementTemplateIndex, symbolBitmap, (rdw >> 1) + rdx, (rdh >> 1) + rdy, false, refinementAt, decodingContext);\n      }\n      let increment = 0;\n      if (!transposed) {\n        if (referenceCorner > 1) {\n          currentS += symbolWidth - 1;\n        } else {\n          increment = symbolWidth - 1;\n        }\n      } else if (!(referenceCorner & 1)) {\n        currentS += symbolHeight - 1;\n      } else {\n        increment = symbolHeight - 1;\n      }\n      const offsetT = t - (referenceCorner & 1 ? 0 : symbolHeight - 1);\n      const offsetS = currentS - (referenceCorner & 2 ? symbolWidth - 1 : 0);\n      let s2, t2, symbolRow;\n      if (transposed) {\n        for (s2 = 0; s2 < symbolHeight; s2++) {\n          row = bitmap[offsetS + s2];\n          if (!row) {\n            continue;\n          }\n          symbolRow = symbolBitmap[s2];\n          const maxWidth = Math.min(width - offsetT, symbolWidth);\n          switch (combinationOperator) {\n            case 0:\n              for (t2 = 0; t2 < maxWidth; t2++) {\n                row[offsetT + t2] |= symbolRow[t2];\n              }\n              break;\n            case 2:\n              for (t2 = 0; t2 < maxWidth; t2++) {\n                row[offsetT + t2] ^= symbolRow[t2];\n              }\n              break;\n            default:\n              throw new Jbig2Error(`operator ${combinationOperator} is not supported`);\n          }\n        }\n      } else {\n        for (t2 = 0; t2 < symbolHeight; t2++) {\n          row = bitmap[offsetT + t2];\n          if (!row) {\n            continue;\n          }\n          symbolRow = symbolBitmap[t2];\n          switch (combinationOperator) {\n            case 0:\n              for (s2 = 0; s2 < symbolWidth; s2++) {\n                row[offsetS + s2] |= symbolRow[s2];\n              }\n              break;\n            case 2:\n              for (s2 = 0; s2 < symbolWidth; s2++) {\n                row[offsetS + s2] ^= symbolRow[s2];\n              }\n              break;\n            default:\n              throw new Jbig2Error(`operator ${combinationOperator} is not supported`);\n          }\n        }\n      }\n      i++;\n      const deltaS = huffman ? huffmanTables.tableDeltaS.decode(huffmanInput) : decodeInteger(contextCache, \"IADS\", decoder);\n      if (deltaS === null) {\n        break;\n      }\n      currentS += increment + deltaS + dsOffset;\n    } while (true);\n  }\n  return bitmap;\n}\nfunction decodePatternDictionary(mmr, patternWidth, patternHeight, maxPatternIndex, template, decodingContext) {\n  const at = [];\n  if (!mmr) {\n    at.push({\n      x: -patternWidth,\n      y: 0\n    });\n    if (template === 0) {\n      at.push({\n        x: -3,\n        y: -1\n      }, {\n        x: 2,\n        y: -2\n      }, {\n        x: -2,\n        y: -2\n      });\n    }\n  }\n  const collectiveWidth = (maxPatternIndex + 1) * patternWidth;\n  const collectiveBitmap = decodeBitmap(mmr, collectiveWidth, patternHeight, template, false, null, at, decodingContext);\n  const patterns = [];\n  for (let i = 0; i <= maxPatternIndex; i++) {\n    const patternBitmap = [];\n    const xMin = patternWidth * i;\n    const xMax = xMin + patternWidth;\n    for (let y = 0; y < patternHeight; y++) {\n      patternBitmap.push(collectiveBitmap[y].subarray(xMin, xMax));\n    }\n    patterns.push(patternBitmap);\n  }\n  return patterns;\n}\nfunction decodeHalftoneRegion(mmr, patterns, template, regionWidth, regionHeight, defaultPixelValue, enableSkip, combinationOperator, gridWidth, gridHeight, gridOffsetX, gridOffsetY, gridVectorX, gridVectorY, decodingContext) {\n  const skip = null;\n  if (enableSkip) {\n    throw new Jbig2Error(\"skip is not supported\");\n  }\n  if (combinationOperator !== 0) {\n    throw new Jbig2Error(`operator \"${combinationOperator}\" is not supported in halftone region`);\n  }\n  const regionBitmap = [];\n  let i, j, row;\n  for (i = 0; i < regionHeight; i++) {\n    row = new Uint8Array(regionWidth);\n    if (defaultPixelValue) {\n      for (j = 0; j < regionWidth; j++) {\n        row[j] = defaultPixelValue;\n      }\n    }\n    regionBitmap.push(row);\n  }\n  const numberOfPatterns = patterns.length;\n  const pattern0 = patterns[0];\n  const patternWidth = pattern0[0].length,\n    patternHeight = pattern0.length;\n  const bitsPerValue = log2(numberOfPatterns);\n  const at = [];\n  if (!mmr) {\n    at.push({\n      x: template <= 1 ? 3 : 2,\n      y: -1\n    });\n    if (template === 0) {\n      at.push({\n        x: -3,\n        y: -1\n      }, {\n        x: 2,\n        y: -2\n      }, {\n        x: -2,\n        y: -2\n      });\n    }\n  }\n  const grayScaleBitPlanes = [];\n  let mmrInput, bitmap;\n  if (mmr) {\n    mmrInput = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);\n  }\n  for (i = bitsPerValue - 1; i >= 0; i--) {\n    if (mmr) {\n      bitmap = decodeMMRBitmap(mmrInput, gridWidth, gridHeight, true);\n    } else {\n      bitmap = decodeBitmap(false, gridWidth, gridHeight, template, false, skip, at, decodingContext);\n    }\n    grayScaleBitPlanes[i] = bitmap;\n  }\n  let mg, ng, bit, patternIndex, patternBitmap, x, y, patternRow, regionRow;\n  for (mg = 0; mg < gridHeight; mg++) {\n    for (ng = 0; ng < gridWidth; ng++) {\n      bit = 0;\n      patternIndex = 0;\n      for (j = bitsPerValue - 1; j >= 0; j--) {\n        bit ^= grayScaleBitPlanes[j][mg][ng];\n        patternIndex |= bit << j;\n      }\n      patternBitmap = patterns[patternIndex];\n      x = gridOffsetX + mg * gridVectorY + ng * gridVectorX >> 8;\n      y = gridOffsetY + mg * gridVectorX - ng * gridVectorY >> 8;\n      if (x >= 0 && x + patternWidth <= regionWidth && y >= 0 && y + patternHeight <= regionHeight) {\n        for (i = 0; i < patternHeight; i++) {\n          regionRow = regionBitmap[y + i];\n          patternRow = patternBitmap[i];\n          for (j = 0; j < patternWidth; j++) {\n            regionRow[x + j] |= patternRow[j];\n          }\n        }\n      } else {\n        let regionX, regionY;\n        for (i = 0; i < patternHeight; i++) {\n          regionY = y + i;\n          if (regionY < 0 || regionY >= regionHeight) {\n            continue;\n          }\n          regionRow = regionBitmap[regionY];\n          patternRow = patternBitmap[i];\n          for (j = 0; j < patternWidth; j++) {\n            regionX = x + j;\n            if (regionX >= 0 && regionX < regionWidth) {\n              regionRow[regionX] |= patternRow[j];\n            }\n          }\n        }\n      }\n    }\n  }\n  return regionBitmap;\n}\nfunction readSegmentHeader(data, start) {\n  const segmentHeader = {};\n  segmentHeader.number = readUint32(data, start);\n  const flags = data[start + 4];\n  const segmentType = flags & 0x3f;\n  if (!SegmentTypes[segmentType]) {\n    throw new Jbig2Error(\"invalid segment type: \" + segmentType);\n  }\n  segmentHeader.type = segmentType;\n  segmentHeader.typeName = SegmentTypes[segmentType];\n  segmentHeader.deferredNonRetain = !!(flags & 0x80);\n  const pageAssociationFieldSize = !!(flags & 0x40);\n  const referredFlags = data[start + 5];\n  let referredToCount = referredFlags >> 5 & 7;\n  const retainBits = [referredFlags & 31];\n  let position = start + 6;\n  if (referredFlags === 7) {\n    referredToCount = readUint32(data, position - 1) & 0x1fffffff;\n    position += 3;\n    let bytes = referredToCount + 7 >> 3;\n    retainBits[0] = data[position++];\n    while (--bytes > 0) {\n      retainBits.push(data[position++]);\n    }\n  } else if (referredFlags === 5 || referredFlags === 6) {\n    throw new Jbig2Error(\"invalid referred-to flags\");\n  }\n  segmentHeader.retainBits = retainBits;\n  let referredToSegmentNumberSize = 4;\n  if (segmentHeader.number <= 256) {\n    referredToSegmentNumberSize = 1;\n  } else if (segmentHeader.number <= 65536) {\n    referredToSegmentNumberSize = 2;\n  }\n  const referredTo = [];\n  let i, ii;\n  for (i = 0; i < referredToCount; i++) {\n    let number;\n    if (referredToSegmentNumberSize === 1) {\n      number = data[position];\n    } else if (referredToSegmentNumberSize === 2) {\n      number = readUint16(data, position);\n    } else {\n      number = readUint32(data, position);\n    }\n    referredTo.push(number);\n    position += referredToSegmentNumberSize;\n  }\n  segmentHeader.referredTo = referredTo;\n  if (!pageAssociationFieldSize) {\n    segmentHeader.pageAssociation = data[position++];\n  } else {\n    segmentHeader.pageAssociation = readUint32(data, position);\n    position += 4;\n  }\n  segmentHeader.length = readUint32(data, position);\n  position += 4;\n  if (segmentHeader.length === 0xffffffff) {\n    if (segmentType === 38) {\n      const genericRegionInfo = readRegionSegmentInformation(data, position);\n      const genericRegionSegmentFlags = data[position + RegionSegmentInformationFieldLength];\n      const genericRegionMmr = !!(genericRegionSegmentFlags & 1);\n      const searchPatternLength = 6;\n      const searchPattern = new Uint8Array(searchPatternLength);\n      if (!genericRegionMmr) {\n        searchPattern[0] = 0xff;\n        searchPattern[1] = 0xac;\n      }\n      searchPattern[2] = genericRegionInfo.height >>> 24 & 0xff;\n      searchPattern[3] = genericRegionInfo.height >> 16 & 0xff;\n      searchPattern[4] = genericRegionInfo.height >> 8 & 0xff;\n      searchPattern[5] = genericRegionInfo.height & 0xff;\n      for (i = position, ii = data.length; i < ii; i++) {\n        let j = 0;\n        while (j < searchPatternLength && searchPattern[j] === data[i + j]) {\n          j++;\n        }\n        if (j === searchPatternLength) {\n          segmentHeader.length = i + searchPatternLength;\n          break;\n        }\n      }\n      if (segmentHeader.length === 0xffffffff) {\n        throw new Jbig2Error(\"segment end was not found\");\n      }\n    } else {\n      throw new Jbig2Error(\"invalid unknown segment length\");\n    }\n  }\n  segmentHeader.headerEnd = position;\n  return segmentHeader;\n}\nfunction readSegments(header, data, start, end) {\n  const segments = [];\n  let position = start;\n  while (position < end) {\n    const segmentHeader = readSegmentHeader(data, position);\n    position = segmentHeader.headerEnd;\n    const segment = {\n      header: segmentHeader,\n      data\n    };\n    if (!header.randomAccess) {\n      segment.start = position;\n      position += segmentHeader.length;\n      segment.end = position;\n    }\n    segments.push(segment);\n    if (segmentHeader.type === 51) {\n      break;\n    }\n  }\n  if (header.randomAccess) {\n    for (let i = 0, ii = segments.length; i < ii; i++) {\n      segments[i].start = position;\n      position += segments[i].header.length;\n      segments[i].end = position;\n    }\n  }\n  return segments;\n}\nfunction readRegionSegmentInformation(data, start) {\n  return {\n    width: readUint32(data, start),\n    height: readUint32(data, start + 4),\n    x: readUint32(data, start + 8),\n    y: readUint32(data, start + 12),\n    combinationOperator: data[start + 16] & 7\n  };\n}\nconst RegionSegmentInformationFieldLength = 17;\nfunction processSegment(segment, visitor) {\n  const header = segment.header;\n  const data = segment.data,\n    end = segment.end;\n  let position = segment.start;\n  let args, at, i, atLength;\n  switch (header.type) {\n    case 0:\n      const dictionary = {};\n      const dictionaryFlags = readUint16(data, position);\n      dictionary.huffman = !!(dictionaryFlags & 1);\n      dictionary.refinement = !!(dictionaryFlags & 2);\n      dictionary.huffmanDHSelector = dictionaryFlags >> 2 & 3;\n      dictionary.huffmanDWSelector = dictionaryFlags >> 4 & 3;\n      dictionary.bitmapSizeSelector = dictionaryFlags >> 6 & 1;\n      dictionary.aggregationInstancesSelector = dictionaryFlags >> 7 & 1;\n      dictionary.bitmapCodingContextUsed = !!(dictionaryFlags & 256);\n      dictionary.bitmapCodingContextRetained = !!(dictionaryFlags & 512);\n      dictionary.template = dictionaryFlags >> 10 & 3;\n      dictionary.refinementTemplate = dictionaryFlags >> 12 & 1;\n      position += 2;\n      if (!dictionary.huffman) {\n        atLength = dictionary.template === 0 ? 4 : 1;\n        at = [];\n        for (i = 0; i < atLength; i++) {\n          at.push({\n            x: readInt8(data, position),\n            y: readInt8(data, position + 1)\n          });\n          position += 2;\n        }\n        dictionary.at = at;\n      }\n      if (dictionary.refinement && !dictionary.refinementTemplate) {\n        at = [];\n        for (i = 0; i < 2; i++) {\n          at.push({\n            x: readInt8(data, position),\n            y: readInt8(data, position + 1)\n          });\n          position += 2;\n        }\n        dictionary.refinementAt = at;\n      }\n      dictionary.numberOfExportedSymbols = readUint32(data, position);\n      position += 4;\n      dictionary.numberOfNewSymbols = readUint32(data, position);\n      position += 4;\n      args = [dictionary, header.number, header.referredTo, data, position, end];\n      break;\n    case 6:\n    case 7:\n      const textRegion = {};\n      textRegion.info = readRegionSegmentInformation(data, position);\n      position += RegionSegmentInformationFieldLength;\n      const textRegionSegmentFlags = readUint16(data, position);\n      position += 2;\n      textRegion.huffman = !!(textRegionSegmentFlags & 1);\n      textRegion.refinement = !!(textRegionSegmentFlags & 2);\n      textRegion.logStripSize = textRegionSegmentFlags >> 2 & 3;\n      textRegion.stripSize = 1 << textRegion.logStripSize;\n      textRegion.referenceCorner = textRegionSegmentFlags >> 4 & 3;\n      textRegion.transposed = !!(textRegionSegmentFlags & 64);\n      textRegion.combinationOperator = textRegionSegmentFlags >> 7 & 3;\n      textRegion.defaultPixelValue = textRegionSegmentFlags >> 9 & 1;\n      textRegion.dsOffset = textRegionSegmentFlags << 17 >> 27;\n      textRegion.refinementTemplate = textRegionSegmentFlags >> 15 & 1;\n      if (textRegion.huffman) {\n        const textRegionHuffmanFlags = readUint16(data, position);\n        position += 2;\n        textRegion.huffmanFS = textRegionHuffmanFlags & 3;\n        textRegion.huffmanDS = textRegionHuffmanFlags >> 2 & 3;\n        textRegion.huffmanDT = textRegionHuffmanFlags >> 4 & 3;\n        textRegion.huffmanRefinementDW = textRegionHuffmanFlags >> 6 & 3;\n        textRegion.huffmanRefinementDH = textRegionHuffmanFlags >> 8 & 3;\n        textRegion.huffmanRefinementDX = textRegionHuffmanFlags >> 10 & 3;\n        textRegion.huffmanRefinementDY = textRegionHuffmanFlags >> 12 & 3;\n        textRegion.huffmanRefinementSizeSelector = !!(textRegionHuffmanFlags & 0x4000);\n      }\n      if (textRegion.refinement && !textRegion.refinementTemplate) {\n        at = [];\n        for (i = 0; i < 2; i++) {\n          at.push({\n            x: readInt8(data, position),\n            y: readInt8(data, position + 1)\n          });\n          position += 2;\n        }\n        textRegion.refinementAt = at;\n      }\n      textRegion.numberOfSymbolInstances = readUint32(data, position);\n      position += 4;\n      args = [textRegion, header.referredTo, data, position, end];\n      break;\n    case 16:\n      const patternDictionary = {};\n      const patternDictionaryFlags = data[position++];\n      patternDictionary.mmr = !!(patternDictionaryFlags & 1);\n      patternDictionary.template = patternDictionaryFlags >> 1 & 3;\n      patternDictionary.patternWidth = data[position++];\n      patternDictionary.patternHeight = data[position++];\n      patternDictionary.maxPatternIndex = readUint32(data, position);\n      position += 4;\n      args = [patternDictionary, header.number, data, position, end];\n      break;\n    case 22:\n    case 23:\n      const halftoneRegion = {};\n      halftoneRegion.info = readRegionSegmentInformation(data, position);\n      position += RegionSegmentInformationFieldLength;\n      const halftoneRegionFlags = data[position++];\n      halftoneRegion.mmr = !!(halftoneRegionFlags & 1);\n      halftoneRegion.template = halftoneRegionFlags >> 1 & 3;\n      halftoneRegion.enableSkip = !!(halftoneRegionFlags & 8);\n      halftoneRegion.combinationOperator = halftoneRegionFlags >> 4 & 7;\n      halftoneRegion.defaultPixelValue = halftoneRegionFlags >> 7 & 1;\n      halftoneRegion.gridWidth = readUint32(data, position);\n      position += 4;\n      halftoneRegion.gridHeight = readUint32(data, position);\n      position += 4;\n      halftoneRegion.gridOffsetX = readUint32(data, position) & 0xffffffff;\n      position += 4;\n      halftoneRegion.gridOffsetY = readUint32(data, position) & 0xffffffff;\n      position += 4;\n      halftoneRegion.gridVectorX = readUint16(data, position);\n      position += 2;\n      halftoneRegion.gridVectorY = readUint16(data, position);\n      position += 2;\n      args = [halftoneRegion, header.referredTo, data, position, end];\n      break;\n    case 38:\n    case 39:\n      const genericRegion = {};\n      genericRegion.info = readRegionSegmentInformation(data, position);\n      position += RegionSegmentInformationFieldLength;\n      const genericRegionSegmentFlags = data[position++];\n      genericRegion.mmr = !!(genericRegionSegmentFlags & 1);\n      genericRegion.template = genericRegionSegmentFlags >> 1 & 3;\n      genericRegion.prediction = !!(genericRegionSegmentFlags & 8);\n      if (!genericRegion.mmr) {\n        atLength = genericRegion.template === 0 ? 4 : 1;\n        at = [];\n        for (i = 0; i < atLength; i++) {\n          at.push({\n            x: readInt8(data, position),\n            y: readInt8(data, position + 1)\n          });\n          position += 2;\n        }\n        genericRegion.at = at;\n      }\n      args = [genericRegion, data, position, end];\n      break;\n    case 48:\n      const pageInfo = {\n        width: readUint32(data, position),\n        height: readUint32(data, position + 4),\n        resolutionX: readUint32(data, position + 8),\n        resolutionY: readUint32(data, position + 12)\n      };\n      if (pageInfo.height === 0xffffffff) {\n        delete pageInfo.height;\n      }\n      const pageSegmentFlags = data[position + 16];\n      readUint16(data, position + 17);\n      pageInfo.lossless = !!(pageSegmentFlags & 1);\n      pageInfo.refinement = !!(pageSegmentFlags & 2);\n      pageInfo.defaultPixelValue = pageSegmentFlags >> 2 & 1;\n      pageInfo.combinationOperator = pageSegmentFlags >> 3 & 3;\n      pageInfo.requiresBuffer = !!(pageSegmentFlags & 32);\n      pageInfo.combinationOperatorOverride = !!(pageSegmentFlags & 64);\n      args = [pageInfo];\n      break;\n    case 49:\n      break;\n    case 50:\n      break;\n    case 51:\n      break;\n    case 53:\n      args = [header.number, data, position, end];\n      break;\n    case 62:\n      break;\n    default:\n      throw new Jbig2Error(`segment type ${header.typeName}(${header.type}) is not implemented`);\n  }\n  const callbackName = \"on\" + header.typeName;\n  if (callbackName in visitor) {\n    visitor[callbackName].apply(visitor, args);\n  }\n}\nfunction processSegments(segments, visitor) {\n  for (let i = 0, ii = segments.length; i < ii; i++) {\n    processSegment(segments[i], visitor);\n  }\n}\nfunction parseJbig2Chunks(chunks) {\n  const visitor = new SimpleSegmentVisitor();\n  for (let i = 0, ii = chunks.length; i < ii; i++) {\n    const chunk = chunks[i];\n    const segments = readSegments({}, chunk.data, chunk.start, chunk.end);\n    processSegments(segments, visitor);\n  }\n  return visitor.buffer;\n}\nfunction parseJbig2(data) {\n  throw new Error(\"Not implemented: parseJbig2\");\n}\nclass SimpleSegmentVisitor {\n  onPageInformation(info) {\n    this.currentPageInfo = info;\n    const rowSize = info.width + 7 >> 3;\n    const buffer = new Uint8ClampedArray(rowSize * info.height);\n    if (info.defaultPixelValue) {\n      buffer.fill(0xff);\n    }\n    this.buffer = buffer;\n  }\n  drawBitmap(regionInfo, bitmap) {\n    const pageInfo = this.currentPageInfo;\n    const width = regionInfo.width,\n      height = regionInfo.height;\n    const rowSize = pageInfo.width + 7 >> 3;\n    const combinationOperator = pageInfo.combinationOperatorOverride ? regionInfo.combinationOperator : pageInfo.combinationOperator;\n    const buffer = this.buffer;\n    const mask0 = 128 >> (regionInfo.x & 7);\n    let offset0 = regionInfo.y * rowSize + (regionInfo.x >> 3);\n    let i, j, mask, offset;\n    switch (combinationOperator) {\n      case 0:\n        for (i = 0; i < height; i++) {\n          mask = mask0;\n          offset = offset0;\n          for (j = 0; j < width; j++) {\n            if (bitmap[i][j]) {\n              buffer[offset] |= mask;\n            }\n            mask >>= 1;\n            if (!mask) {\n              mask = 128;\n              offset++;\n            }\n          }\n          offset0 += rowSize;\n        }\n        break;\n      case 2:\n        for (i = 0; i < height; i++) {\n          mask = mask0;\n          offset = offset0;\n          for (j = 0; j < width; j++) {\n            if (bitmap[i][j]) {\n              buffer[offset] ^= mask;\n            }\n            mask >>= 1;\n            if (!mask) {\n              mask = 128;\n              offset++;\n            }\n          }\n          offset0 += rowSize;\n        }\n        break;\n      default:\n        throw new Jbig2Error(`operator ${combinationOperator} is not supported`);\n    }\n  }\n  onImmediateGenericRegion(region, data, start, end) {\n    const regionInfo = region.info;\n    const decodingContext = new DecodingContext(data, start, end);\n    const bitmap = decodeBitmap(region.mmr, regionInfo.width, regionInfo.height, region.template, region.prediction, null, region.at, decodingContext);\n    this.drawBitmap(regionInfo, bitmap);\n  }\n  onImmediateLosslessGenericRegion() {\n    this.onImmediateGenericRegion(...arguments);\n  }\n  onSymbolDictionary(dictionary, currentSegment, referredSegments, data, start, end) {\n    let huffmanTables, huffmanInput;\n    if (dictionary.huffman) {\n      huffmanTables = getSymbolDictionaryHuffmanTables(dictionary, referredSegments, this.customTables);\n      huffmanInput = new Reader(data, start, end);\n    }\n    let symbols = this.symbols;\n    if (!symbols) {\n      this.symbols = symbols = {};\n    }\n    const inputSymbols = [];\n    for (const referredSegment of referredSegments) {\n      const referredSymbols = symbols[referredSegment];\n      if (referredSymbols) {\n        inputSymbols.push(...referredSymbols);\n      }\n    }\n    const decodingContext = new DecodingContext(data, start, end);\n    symbols[currentSegment] = decodeSymbolDictionary(dictionary.huffman, dictionary.refinement, inputSymbols, dictionary.numberOfNewSymbols, dictionary.numberOfExportedSymbols, huffmanTables, dictionary.template, dictionary.at, dictionary.refinementTemplate, dictionary.refinementAt, decodingContext, huffmanInput);\n  }\n  onImmediateTextRegion(region, referredSegments, data, start, end) {\n    const regionInfo = region.info;\n    let huffmanTables, huffmanInput;\n    const symbols = this.symbols;\n    const inputSymbols = [];\n    for (const referredSegment of referredSegments) {\n      const referredSymbols = symbols[referredSegment];\n      if (referredSymbols) {\n        inputSymbols.push(...referredSymbols);\n      }\n    }\n    const symbolCodeLength = log2(inputSymbols.length);\n    if (region.huffman) {\n      huffmanInput = new Reader(data, start, end);\n      huffmanTables = getTextRegionHuffmanTables(region, referredSegments, this.customTables, inputSymbols.length, huffmanInput);\n    }\n    const decodingContext = new DecodingContext(data, start, end);\n    const bitmap = decodeTextRegion(region.huffman, region.refinement, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.numberOfSymbolInstances, region.stripSize, inputSymbols, symbolCodeLength, region.transposed, region.dsOffset, region.referenceCorner, region.combinationOperator, huffmanTables, region.refinementTemplate, region.refinementAt, decodingContext, region.logStripSize, huffmanInput);\n    this.drawBitmap(regionInfo, bitmap);\n  }\n  onImmediateLosslessTextRegion() {\n    this.onImmediateTextRegion(...arguments);\n  }\n  onPatternDictionary(dictionary, currentSegment, data, start, end) {\n    let patterns = this.patterns;\n    if (!patterns) {\n      this.patterns = patterns = {};\n    }\n    const decodingContext = new DecodingContext(data, start, end);\n    patterns[currentSegment] = decodePatternDictionary(dictionary.mmr, dictionary.patternWidth, dictionary.patternHeight, dictionary.maxPatternIndex, dictionary.template, decodingContext);\n  }\n  onImmediateHalftoneRegion(region, referredSegments, data, start, end) {\n    const patterns = this.patterns[referredSegments[0]];\n    const regionInfo = region.info;\n    const decodingContext = new DecodingContext(data, start, end);\n    const bitmap = decodeHalftoneRegion(region.mmr, patterns, region.template, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.enableSkip, region.combinationOperator, region.gridWidth, region.gridHeight, region.gridOffsetX, region.gridOffsetY, region.gridVectorX, region.gridVectorY, decodingContext);\n    this.drawBitmap(regionInfo, bitmap);\n  }\n  onImmediateLosslessHalftoneRegion() {\n    this.onImmediateHalftoneRegion(...arguments);\n  }\n  onTables(currentSegment, data, start, end) {\n    let customTables = this.customTables;\n    if (!customTables) {\n      this.customTables = customTables = {};\n    }\n    customTables[currentSegment] = decodeTablesSegment(data, start, end);\n  }\n}\nclass HuffmanLine {\n  constructor(lineData) {\n    if (lineData.length === 2) {\n      this.isOOB = true;\n      this.rangeLow = 0;\n      this.prefixLength = lineData[0];\n      this.rangeLength = 0;\n      this.prefixCode = lineData[1];\n      this.isLowerRange = false;\n    } else {\n      this.isOOB = false;\n      this.rangeLow = lineData[0];\n      this.prefixLength = lineData[1];\n      this.rangeLength = lineData[2];\n      this.prefixCode = lineData[3];\n      this.isLowerRange = lineData[4] === \"lower\";\n    }\n  }\n}\nclass HuffmanTreeNode {\n  constructor(line) {\n    this.children = [];\n    if (line) {\n      this.isLeaf = true;\n      this.rangeLength = line.rangeLength;\n      this.rangeLow = line.rangeLow;\n      this.isLowerRange = line.isLowerRange;\n      this.isOOB = line.isOOB;\n    } else {\n      this.isLeaf = false;\n    }\n  }\n  buildTree(line, shift) {\n    const bit = line.prefixCode >> shift & 1;\n    if (shift <= 0) {\n      this.children[bit] = new HuffmanTreeNode(line);\n    } else {\n      let node = this.children[bit];\n      if (!node) {\n        this.children[bit] = node = new HuffmanTreeNode(null);\n      }\n      node.buildTree(line, shift - 1);\n    }\n  }\n  decodeNode(reader) {\n    if (this.isLeaf) {\n      if (this.isOOB) {\n        return null;\n      }\n      const htOffset = reader.readBits(this.rangeLength);\n      return this.rangeLow + (this.isLowerRange ? -htOffset : htOffset);\n    }\n    const node = this.children[reader.readBit()];\n    if (!node) {\n      throw new Jbig2Error(\"invalid Huffman data\");\n    }\n    return node.decodeNode(reader);\n  }\n}\nclass HuffmanTable {\n  constructor(lines, prefixCodesDone) {\n    if (!prefixCodesDone) {\n      this.assignPrefixCodes(lines);\n    }\n    this.rootNode = new HuffmanTreeNode(null);\n    for (let i = 0, ii = lines.length; i < ii; i++) {\n      const line = lines[i];\n      if (line.prefixLength > 0) {\n        this.rootNode.buildTree(line, line.prefixLength - 1);\n      }\n    }\n  }\n  decode(reader) {\n    return this.rootNode.decodeNode(reader);\n  }\n  assignPrefixCodes(lines) {\n    const linesLength = lines.length;\n    let prefixLengthMax = 0;\n    for (let i = 0; i < linesLength; i++) {\n      prefixLengthMax = Math.max(prefixLengthMax, lines[i].prefixLength);\n    }\n    const histogram = new Uint32Array(prefixLengthMax + 1);\n    for (let i = 0; i < linesLength; i++) {\n      histogram[lines[i].prefixLength]++;\n    }\n    let currentLength = 1,\n      firstCode = 0,\n      currentCode,\n      currentTemp,\n      line;\n    histogram[0] = 0;\n    while (currentLength <= prefixLengthMax) {\n      firstCode = firstCode + histogram[currentLength - 1] << 1;\n      currentCode = firstCode;\n      currentTemp = 0;\n      while (currentTemp < linesLength) {\n        line = lines[currentTemp];\n        if (line.prefixLength === currentLength) {\n          line.prefixCode = currentCode;\n          currentCode++;\n        }\n        currentTemp++;\n      }\n      currentLength++;\n    }\n  }\n}\nfunction decodeTablesSegment(data, start, end) {\n  const flags = data[start];\n  const lowestValue = readUint32(data, start + 1) & 0xffffffff;\n  const highestValue = readUint32(data, start + 5) & 0xffffffff;\n  const reader = new Reader(data, start + 9, end);\n  const prefixSizeBits = (flags >> 1 & 7) + 1;\n  const rangeSizeBits = (flags >> 4 & 7) + 1;\n  const lines = [];\n  let prefixLength,\n    rangeLength,\n    currentRangeLow = lowestValue;\n  do {\n    prefixLength = reader.readBits(prefixSizeBits);\n    rangeLength = reader.readBits(rangeSizeBits);\n    lines.push(new HuffmanLine([currentRangeLow, prefixLength, rangeLength, 0]));\n    currentRangeLow += 1 << rangeLength;\n  } while (currentRangeLow < highestValue);\n  prefixLength = reader.readBits(prefixSizeBits);\n  lines.push(new HuffmanLine([lowestValue - 1, prefixLength, 32, 0, \"lower\"]));\n  prefixLength = reader.readBits(prefixSizeBits);\n  lines.push(new HuffmanLine([highestValue, prefixLength, 32, 0]));\n  if (flags & 1) {\n    prefixLength = reader.readBits(prefixSizeBits);\n    lines.push(new HuffmanLine([prefixLength, 0]));\n  }\n  return new HuffmanTable(lines, false);\n}\nconst standardTablesCache = {};\nfunction getStandardTable(number) {\n  let table = standardTablesCache[number];\n  if (table) {\n    return table;\n  }\n  let lines;\n  switch (number) {\n    case 1:\n      lines = [[0, 1, 4, 0x0], [16, 2, 8, 0x2], [272, 3, 16, 0x6], [65808, 3, 32, 0x7]];\n      break;\n    case 2:\n      lines = [[0, 1, 0, 0x0], [1, 2, 0, 0x2], [2, 3, 0, 0x6], [3, 4, 3, 0xe], [11, 5, 6, 0x1e], [75, 6, 32, 0x3e], [6, 0x3f]];\n      break;\n    case 3:\n      lines = [[-256, 8, 8, 0xfe], [0, 1, 0, 0x0], [1, 2, 0, 0x2], [2, 3, 0, 0x6], [3, 4, 3, 0xe], [11, 5, 6, 0x1e], [-257, 8, 32, 0xff, \"lower\"], [75, 7, 32, 0x7e], [6, 0x3e]];\n      break;\n    case 4:\n      lines = [[1, 1, 0, 0x0], [2, 2, 0, 0x2], [3, 3, 0, 0x6], [4, 4, 3, 0xe], [12, 5, 6, 0x1e], [76, 5, 32, 0x1f]];\n      break;\n    case 5:\n      lines = [[-255, 7, 8, 0x7e], [1, 1, 0, 0x0], [2, 2, 0, 0x2], [3, 3, 0, 0x6], [4, 4, 3, 0xe], [12, 5, 6, 0x1e], [-256, 7, 32, 0x7f, \"lower\"], [76, 6, 32, 0x3e]];\n      break;\n    case 6:\n      lines = [[-2048, 5, 10, 0x1c], [-1024, 4, 9, 0x8], [-512, 4, 8, 0x9], [-256, 4, 7, 0xa], [-128, 5, 6, 0x1d], [-64, 5, 5, 0x1e], [-32, 4, 5, 0xb], [0, 2, 7, 0x0], [128, 3, 7, 0x2], [256, 3, 8, 0x3], [512, 4, 9, 0xc], [1024, 4, 10, 0xd], [-2049, 6, 32, 0x3e, \"lower\"], [2048, 6, 32, 0x3f]];\n      break;\n    case 7:\n      lines = [[-1024, 4, 9, 0x8], [-512, 3, 8, 0x0], [-256, 4, 7, 0x9], [-128, 5, 6, 0x1a], [-64, 5, 5, 0x1b], [-32, 4, 5, 0xa], [0, 4, 5, 0xb], [32, 5, 5, 0x1c], [64, 5, 6, 0x1d], [128, 4, 7, 0xc], [256, 3, 8, 0x1], [512, 3, 9, 0x2], [1024, 3, 10, 0x3], [-1025, 5, 32, 0x1e, \"lower\"], [2048, 5, 32, 0x1f]];\n      break;\n    case 8:\n      lines = [[-15, 8, 3, 0xfc], [-7, 9, 1, 0x1fc], [-5, 8, 1, 0xfd], [-3, 9, 0, 0x1fd], [-2, 7, 0, 0x7c], [-1, 4, 0, 0xa], [0, 2, 1, 0x0], [2, 5, 0, 0x1a], [3, 6, 0, 0x3a], [4, 3, 4, 0x4], [20, 6, 1, 0x3b], [22, 4, 4, 0xb], [38, 4, 5, 0xc], [70, 5, 6, 0x1b], [134, 5, 7, 0x1c], [262, 6, 7, 0x3c], [390, 7, 8, 0x7d], [646, 6, 10, 0x3d], [-16, 9, 32, 0x1fe, \"lower\"], [1670, 9, 32, 0x1ff], [2, 0x1]];\n      break;\n    case 9:\n      lines = [[-31, 8, 4, 0xfc], [-15, 9, 2, 0x1fc], [-11, 8, 2, 0xfd], [-7, 9, 1, 0x1fd], [-5, 7, 1, 0x7c], [-3, 4, 1, 0xa], [-1, 3, 1, 0x2], [1, 3, 1, 0x3], [3, 5, 1, 0x1a], [5, 6, 1, 0x3a], [7, 3, 5, 0x4], [39, 6, 2, 0x3b], [43, 4, 5, 0xb], [75, 4, 6, 0xc], [139, 5, 7, 0x1b], [267, 5, 8, 0x1c], [523, 6, 8, 0x3c], [779, 7, 9, 0x7d], [1291, 6, 11, 0x3d], [-32, 9, 32, 0x1fe, \"lower\"], [3339, 9, 32, 0x1ff], [2, 0x0]];\n      break;\n    case 10:\n      lines = [[-21, 7, 4, 0x7a], [-5, 8, 0, 0xfc], [-4, 7, 0, 0x7b], [-3, 5, 0, 0x18], [-2, 2, 2, 0x0], [2, 5, 0, 0x19], [3, 6, 0, 0x36], [4, 7, 0, 0x7c], [5, 8, 0, 0xfd], [6, 2, 6, 0x1], [70, 5, 5, 0x1a], [102, 6, 5, 0x37], [134, 6, 6, 0x38], [198, 6, 7, 0x39], [326, 6, 8, 0x3a], [582, 6, 9, 0x3b], [1094, 6, 10, 0x3c], [2118, 7, 11, 0x7d], [-22, 8, 32, 0xfe, \"lower\"], [4166, 8, 32, 0xff], [2, 0x2]];\n      break;\n    case 11:\n      lines = [[1, 1, 0, 0x0], [2, 2, 1, 0x2], [4, 4, 0, 0xc], [5, 4, 1, 0xd], [7, 5, 1, 0x1c], [9, 5, 2, 0x1d], [13, 6, 2, 0x3c], [17, 7, 2, 0x7a], [21, 7, 3, 0x7b], [29, 7, 4, 0x7c], [45, 7, 5, 0x7d], [77, 7, 6, 0x7e], [141, 7, 32, 0x7f]];\n      break;\n    case 12:\n      lines = [[1, 1, 0, 0x0], [2, 2, 0, 0x2], [3, 3, 1, 0x6], [5, 5, 0, 0x1c], [6, 5, 1, 0x1d], [8, 6, 1, 0x3c], [10, 7, 0, 0x7a], [11, 7, 1, 0x7b], [13, 7, 2, 0x7c], [17, 7, 3, 0x7d], [25, 7, 4, 0x7e], [41, 8, 5, 0xfe], [73, 8, 32, 0xff]];\n      break;\n    case 13:\n      lines = [[1, 1, 0, 0x0], [2, 3, 0, 0x4], [3, 4, 0, 0xc], [4, 5, 0, 0x1c], [5, 4, 1, 0xd], [7, 3, 3, 0x5], [15, 6, 1, 0x3a], [17, 6, 2, 0x3b], [21, 6, 3, 0x3c], [29, 6, 4, 0x3d], [45, 6, 5, 0x3e], [77, 7, 6, 0x7e], [141, 7, 32, 0x7f]];\n      break;\n    case 14:\n      lines = [[-2, 3, 0, 0x4], [-1, 3, 0, 0x5], [0, 1, 0, 0x0], [1, 3, 0, 0x6], [2, 3, 0, 0x7]];\n      break;\n    case 15:\n      lines = [[-24, 7, 4, 0x7c], [-8, 6, 2, 0x3c], [-4, 5, 1, 0x1c], [-2, 4, 0, 0xc], [-1, 3, 0, 0x4], [0, 1, 0, 0x0], [1, 3, 0, 0x5], [2, 4, 0, 0xd], [3, 5, 1, 0x1d], [5, 6, 2, 0x3d], [9, 7, 4, 0x7d], [-25, 7, 32, 0x7e, \"lower\"], [25, 7, 32, 0x7f]];\n      break;\n    default:\n      throw new Jbig2Error(`standard table B.${number} does not exist`);\n  }\n  for (let i = 0, ii = lines.length; i < ii; i++) {\n    lines[i] = new HuffmanLine(lines[i]);\n  }\n  table = new HuffmanTable(lines, true);\n  standardTablesCache[number] = table;\n  return table;\n}\nclass Reader {\n  constructor(data, start, end) {\n    this.data = data;\n    this.start = start;\n    this.end = end;\n    this.position = start;\n    this.shift = -1;\n    this.currentByte = 0;\n  }\n  readBit() {\n    if (this.shift < 0) {\n      if (this.position >= this.end) {\n        throw new Jbig2Error(\"end of data while reading bit\");\n      }\n      this.currentByte = this.data[this.position++];\n      this.shift = 7;\n    }\n    const bit = this.currentByte >> this.shift & 1;\n    this.shift--;\n    return bit;\n  }\n  readBits(numBits) {\n    let result = 0,\n      i;\n    for (i = numBits - 1; i >= 0; i--) {\n      result |= this.readBit() << i;\n    }\n    return result;\n  }\n  byteAlign() {\n    this.shift = -1;\n  }\n  next() {\n    if (this.position >= this.end) {\n      return -1;\n    }\n    return this.data[this.position++];\n  }\n}\nfunction getCustomHuffmanTable(index, referredTo, customTables) {\n  let currentIndex = 0;\n  for (let i = 0, ii = referredTo.length; i < ii; i++) {\n    const table = customTables[referredTo[i]];\n    if (table) {\n      if (index === currentIndex) {\n        return table;\n      }\n      currentIndex++;\n    }\n  }\n  throw new Jbig2Error(\"can't find custom Huffman table\");\n}\nfunction getTextRegionHuffmanTables(textRegion, referredTo, customTables, numberOfSymbols, reader) {\n  const codes = [];\n  for (let i = 0; i <= 34; i++) {\n    const codeLength = reader.readBits(4);\n    codes.push(new HuffmanLine([i, codeLength, 0, 0]));\n  }\n  const runCodesTable = new HuffmanTable(codes, false);\n  codes.length = 0;\n  for (let i = 0; i < numberOfSymbols;) {\n    const codeLength = runCodesTable.decode(reader);\n    if (codeLength >= 32) {\n      let repeatedLength, numberOfRepeats, j;\n      switch (codeLength) {\n        case 32:\n          if (i === 0) {\n            throw new Jbig2Error(\"no previous value in symbol ID table\");\n          }\n          numberOfRepeats = reader.readBits(2) + 3;\n          repeatedLength = codes[i - 1].prefixLength;\n          break;\n        case 33:\n          numberOfRepeats = reader.readBits(3) + 3;\n          repeatedLength = 0;\n          break;\n        case 34:\n          numberOfRepeats = reader.readBits(7) + 11;\n          repeatedLength = 0;\n          break;\n        default:\n          throw new Jbig2Error(\"invalid code length in symbol ID table\");\n      }\n      for (j = 0; j < numberOfRepeats; j++) {\n        codes.push(new HuffmanLine([i, repeatedLength, 0, 0]));\n        i++;\n      }\n    } else {\n      codes.push(new HuffmanLine([i, codeLength, 0, 0]));\n      i++;\n    }\n  }\n  reader.byteAlign();\n  const symbolIDTable = new HuffmanTable(codes, false);\n  let customIndex = 0,\n    tableFirstS,\n    tableDeltaS,\n    tableDeltaT;\n  switch (textRegion.huffmanFS) {\n    case 0:\n    case 1:\n      tableFirstS = getStandardTable(textRegion.huffmanFS + 6);\n      break;\n    case 3:\n      tableFirstS = getCustomHuffmanTable(customIndex, referredTo, customTables);\n      customIndex++;\n      break;\n    default:\n      throw new Jbig2Error(\"invalid Huffman FS selector\");\n  }\n  switch (textRegion.huffmanDS) {\n    case 0:\n    case 1:\n    case 2:\n      tableDeltaS = getStandardTable(textRegion.huffmanDS + 8);\n      break;\n    case 3:\n      tableDeltaS = getCustomHuffmanTable(customIndex, referredTo, customTables);\n      customIndex++;\n      break;\n    default:\n      throw new Jbig2Error(\"invalid Huffman DS selector\");\n  }\n  switch (textRegion.huffmanDT) {\n    case 0:\n    case 1:\n    case 2:\n      tableDeltaT = getStandardTable(textRegion.huffmanDT + 11);\n      break;\n    case 3:\n      tableDeltaT = getCustomHuffmanTable(customIndex, referredTo, customTables);\n      customIndex++;\n      break;\n    default:\n      throw new Jbig2Error(\"invalid Huffman DT selector\");\n  }\n  if (textRegion.refinement) {\n    throw new Jbig2Error(\"refinement with Huffman is not supported\");\n  }\n  return {\n    symbolIDTable,\n    tableFirstS,\n    tableDeltaS,\n    tableDeltaT\n  };\n}\nfunction getSymbolDictionaryHuffmanTables(dictionary, referredTo, customTables) {\n  let customIndex = 0,\n    tableDeltaHeight,\n    tableDeltaWidth;\n  switch (dictionary.huffmanDHSelector) {\n    case 0:\n    case 1:\n      tableDeltaHeight = getStandardTable(dictionary.huffmanDHSelector + 4);\n      break;\n    case 3:\n      tableDeltaHeight = getCustomHuffmanTable(customIndex, referredTo, customTables);\n      customIndex++;\n      break;\n    default:\n      throw new Jbig2Error(\"invalid Huffman DH selector\");\n  }\n  switch (dictionary.huffmanDWSelector) {\n    case 0:\n    case 1:\n      tableDeltaWidth = getStandardTable(dictionary.huffmanDWSelector + 2);\n      break;\n    case 3:\n      tableDeltaWidth = getCustomHuffmanTable(customIndex, referredTo, customTables);\n      customIndex++;\n      break;\n    default:\n      throw new Jbig2Error(\"invalid Huffman DW selector\");\n  }\n  let tableBitmapSize, tableAggregateInstances;\n  if (dictionary.bitmapSizeSelector) {\n    tableBitmapSize = getCustomHuffmanTable(customIndex, referredTo, customTables);\n    customIndex++;\n  } else {\n    tableBitmapSize = getStandardTable(1);\n  }\n  if (dictionary.aggregationInstancesSelector) {\n    tableAggregateInstances = getCustomHuffmanTable(customIndex, referredTo, customTables);\n  } else {\n    tableAggregateInstances = getStandardTable(1);\n  }\n  return {\n    tableDeltaHeight,\n    tableDeltaWidth,\n    tableBitmapSize,\n    tableAggregateInstances\n  };\n}\nfunction readUncompressedBitmap(reader, width, height) {\n  const bitmap = [];\n  for (let y = 0; y < height; y++) {\n    const row = new Uint8Array(width);\n    bitmap.push(row);\n    for (let x = 0; x < width; x++) {\n      row[x] = reader.readBit();\n    }\n    reader.byteAlign();\n  }\n  return bitmap;\n}\nfunction decodeMMRBitmap(input, width, height, endOfBlock) {\n  const params = {\n    K: -1,\n    Columns: width,\n    Rows: height,\n    BlackIs1: true,\n    EndOfBlock: endOfBlock\n  };\n  const decoder = new CCITTFaxDecoder(input, params);\n  const bitmap = [];\n  let currentByte,\n    eof = false;\n  for (let y = 0; y < height; y++) {\n    const row = new Uint8Array(width);\n    bitmap.push(row);\n    let shift = -1;\n    for (let x = 0; x < width; x++) {\n      if (shift < 0) {\n        currentByte = decoder.readNextChar();\n        if (currentByte === -1) {\n          currentByte = 0;\n          eof = true;\n        }\n        shift = 7;\n      }\n      row[x] = currentByte >> shift & 1;\n      shift--;\n    }\n  }\n  if (endOfBlock && !eof) {\n    const lookForEOFLimit = 5;\n    for (let i = 0; i < lookForEOFLimit; i++) {\n      if (decoder.readNextChar() === -1) {\n        break;\n      }\n    }\n  }\n  return bitmap;\n}\nclass Jbig2Image {\n  parseChunks(chunks) {\n    return parseJbig2Chunks(chunks);\n  }\n  parse(data) {\n    throw new Error(\"Not implemented: Jbig2Image.parse\");\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/jbig2_stream.js\n\n\n\n\n\nclass Jbig2Stream extends DecodeStream {\n  constructor(stream, maybeLength, params) {\n    super(maybeLength);\n    this.stream = stream;\n    this.dict = stream.dict;\n    this.maybeLength = maybeLength;\n    this.params = params;\n  }\n  get bytes() {\n    return shadow(this, \"bytes\", this.stream.getBytes(this.maybeLength));\n  }\n  ensureBuffer(requested) {}\n  readBlock() {\n    if (this.eof) {\n      return;\n    }\n    const jbig2Image = new Jbig2Image();\n    const chunks = [];\n    if (this.params instanceof Dict) {\n      const globalsStream = this.params.get(\"JBIG2Globals\");\n      if (globalsStream instanceof BaseStream) {\n        const globals = globalsStream.getBytes();\n        chunks.push({\n          data: globals,\n          start: 0,\n          end: globals.length\n        });\n      }\n    }\n    chunks.push({\n      data: this.bytes,\n      start: 0,\n      end: this.bytes.length\n    });\n    const data = jbig2Image.parseChunks(chunks);\n    const dataLength = data.length;\n    for (let i = 0; i < dataLength; i++) {\n      data[i] ^= 0xff;\n    }\n    this.buffer = data;\n    this.bufferLength = dataLength;\n    this.eof = true;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/shared/image_utils.js\n\nfunction convertToRGBA(params) {\n  switch (params.kind) {\n    case ImageKind.GRAYSCALE_1BPP:\n      return convertBlackAndWhiteToRGBA(params);\n    case ImageKind.RGB_24BPP:\n      return convertRGBToRGBA(params);\n  }\n  return null;\n}\nfunction convertBlackAndWhiteToRGBA({\n  src,\n  srcPos = 0,\n  dest,\n  width,\n  height,\n  nonBlackColor = 0xffffffff,\n  inverseDecode = false\n}) {\n  const black = FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n  const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor];\n  const widthInSource = width >> 3;\n  const widthRemainder = width & 7;\n  const srcLength = src.length;\n  dest = new Uint32Array(dest.buffer);\n  let destPos = 0;\n  for (let i = 0; i < height; i++) {\n    for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {\n      const elem = srcPos < srcLength ? src[srcPos] : 255;\n      dest[destPos++] = elem & 0b10000000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1000000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b100000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b10000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b100 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b10 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1 ? oneMapping : zeroMapping;\n    }\n    if (widthRemainder === 0) {\n      continue;\n    }\n    const elem = srcPos < srcLength ? src[srcPos++] : 255;\n    for (let j = 0; j < widthRemainder; j++) {\n      dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;\n    }\n  }\n  return {\n    srcPos,\n    destPos\n  };\n}\nfunction convertRGBToRGBA({\n  src,\n  srcPos = 0,\n  dest,\n  destPos = 0,\n  width,\n  height\n}) {\n  let i = 0;\n  const len32 = src.length >> 2;\n  const src32 = new Uint32Array(src.buffer, srcPos, len32);\n  if (FeatureTest.isLittleEndian) {\n    for (; i < len32 - 2; i += 3, destPos += 4) {\n      const s1 = src32[i];\n      const s2 = src32[i + 1];\n      const s3 = src32[i + 2];\n      dest[destPos] = s1 | 0xff000000;\n      dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;\n      dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;\n      dest[destPos + 3] = s3 >>> 8 | 0xff000000;\n    }\n    for (let j = i * 4, jj = src.length; j < jj; j += 3) {\n      dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;\n    }\n  } else {\n    for (; i < len32 - 2; i += 3, destPos += 4) {\n      const s1 = src32[i];\n      const s2 = src32[i + 1];\n      const s3 = src32[i + 2];\n      dest[destPos] = s1 | 0xff;\n      dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;\n      dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;\n      dest[destPos + 3] = s3 << 8 | 0xff;\n    }\n    for (let j = i * 4, jj = src.length; j < jj; j += 3) {\n      dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;\n    }\n  }\n  return {\n    srcPos,\n    destPos\n  };\n}\nfunction grayToRGBA(src, dest) {\n  if (FeatureTest.isLittleEndian) {\n    for (let i = 0, ii = src.length; i < ii; i++) {\n      dest[i] = src[i] * 0x10101 | 0xff000000;\n    }\n  } else {\n    for (let i = 0, ii = src.length; i < ii; i++) {\n      dest[i] = src[i] * 0x1010100 | 0x000000ff;\n    }\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/jpg.js\n\n\n\nclass JpegError extends BaseException {\n  constructor(msg) {\n    super(msg, \"JpegError\");\n  }\n}\nclass DNLMarkerError extends BaseException {\n  constructor(message, scanLines) {\n    super(message, \"DNLMarkerError\");\n    this.scanLines = scanLines;\n  }\n}\nclass EOIMarkerError extends BaseException {\n  constructor(msg) {\n    super(msg, \"EOIMarkerError\");\n  }\n}\nconst dctZigZag = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);\nconst dctCos1 = 4017;\nconst dctSin1 = 799;\nconst dctCos3 = 3406;\nconst dctSin3 = 2276;\nconst dctCos6 = 1567;\nconst dctSin6 = 3784;\nconst dctSqrt2 = 5793;\nconst dctSqrt1d2 = 2896;\nfunction buildHuffmanTable(codeLengths, values) {\n  let k = 0,\n    i,\n    j,\n    length = 16;\n  while (length > 0 && !codeLengths[length - 1]) {\n    length--;\n  }\n  const code = [{\n    children: [],\n    index: 0\n  }];\n  let p = code[0],\n    q;\n  for (i = 0; i < length; i++) {\n    for (j = 0; j < codeLengths[i]; j++) {\n      p = code.pop();\n      p.children[p.index] = values[k];\n      while (p.index > 0) {\n        p = code.pop();\n      }\n      p.index++;\n      code.push(p);\n      while (code.length <= i) {\n        code.push(q = {\n          children: [],\n          index: 0\n        });\n        p.children[p.index] = q.children;\n        p = q;\n      }\n      k++;\n    }\n    if (i + 1 < length) {\n      code.push(q = {\n        children: [],\n        index: 0\n      });\n      p.children[p.index] = q.children;\n      p = q;\n    }\n  }\n  return code[0].children;\n}\nfunction getBlockBufferOffset(component, row, col) {\n  return 64 * ((component.blocksPerLine + 1) * row + col);\n}\nfunction decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, parseDNLMarker = false) {\n  const mcusPerLine = frame.mcusPerLine;\n  const progressive = frame.progressive;\n  const startOffset = offset;\n  let bitsData = 0,\n    bitsCount = 0;\n  function readBit() {\n    if (bitsCount > 0) {\n      bitsCount--;\n      return bitsData >> bitsCount & 1;\n    }\n    bitsData = data[offset++];\n    if (bitsData === 0xff) {\n      const nextByte = data[offset++];\n      if (nextByte) {\n        if (nextByte === 0xdc && parseDNLMarker) {\n          offset += 2;\n          const scanLines = readUint16(data, offset);\n          offset += 2;\n          if (scanLines > 0 && scanLines !== frame.scanLines) {\n            throw new DNLMarkerError(\"Found DNL marker (0xFFDC) while parsing scan data\", scanLines);\n          }\n        } else if (nextByte === 0xd9) {\n          if (parseDNLMarker) {\n            const maybeScanLines = blockRow * (frame.precision === 8 ? 8 : 0);\n            if (maybeScanLines > 0 && Math.round(frame.scanLines / maybeScanLines) >= 5) {\n              throw new DNLMarkerError(\"Found EOI marker (0xFFD9) while parsing scan data, \" + \"possibly caused by incorrect `scanLines` parameter\", maybeScanLines);\n            }\n          }\n          throw new EOIMarkerError(\"Found EOI marker (0xFFD9) while parsing scan data\");\n        }\n        throw new JpegError(`unexpected marker ${(bitsData << 8 | nextByte).toString(16)}`);\n      }\n    }\n    bitsCount = 7;\n    return bitsData >>> 7;\n  }\n  function decodeHuffman(tree) {\n    let node = tree;\n    while (true) {\n      node = node[readBit()];\n      switch (typeof node) {\n        case \"number\":\n          return node;\n        case \"object\":\n          continue;\n      }\n      throw new JpegError(\"invalid huffman sequence\");\n    }\n  }\n  function receive(length) {\n    let n = 0;\n    while (length > 0) {\n      n = n << 1 | readBit();\n      length--;\n    }\n    return n;\n  }\n  function receiveAndExtend(length) {\n    if (length === 1) {\n      return readBit() === 1 ? 1 : -1;\n    }\n    const n = receive(length);\n    if (n >= 1 << length - 1) {\n      return n;\n    }\n    return n + (-1 << length) + 1;\n  }\n  function decodeBaseline(component, blockOffset) {\n    const t = decodeHuffman(component.huffmanTableDC);\n    const diff = t === 0 ? 0 : receiveAndExtend(t);\n    component.blockData[blockOffset] = component.pred += diff;\n    let k = 1;\n    while (k < 64) {\n      const rs = decodeHuffman(component.huffmanTableAC);\n      const s = rs & 15,\n        r = rs >> 4;\n      if (s === 0) {\n        if (r < 15) {\n          break;\n        }\n        k += 16;\n        continue;\n      }\n      k += r;\n      const z = dctZigZag[k];\n      component.blockData[blockOffset + z] = receiveAndExtend(s);\n      k++;\n    }\n  }\n  function decodeDCFirst(component, blockOffset) {\n    const t = decodeHuffman(component.huffmanTableDC);\n    const diff = t === 0 ? 0 : receiveAndExtend(t) << successive;\n    component.blockData[blockOffset] = component.pred += diff;\n  }\n  function decodeDCSuccessive(component, blockOffset) {\n    component.blockData[blockOffset] |= readBit() << successive;\n  }\n  let eobrun = 0;\n  function decodeACFirst(component, blockOffset) {\n    if (eobrun > 0) {\n      eobrun--;\n      return;\n    }\n    let k = spectralStart;\n    const e = spectralEnd;\n    while (k <= e) {\n      const rs = decodeHuffman(component.huffmanTableAC);\n      const s = rs & 15,\n        r = rs >> 4;\n      if (s === 0) {\n        if (r < 15) {\n          eobrun = receive(r) + (1 << r) - 1;\n          break;\n        }\n        k += 16;\n        continue;\n      }\n      k += r;\n      const z = dctZigZag[k];\n      component.blockData[blockOffset + z] = receiveAndExtend(s) * (1 << successive);\n      k++;\n    }\n  }\n  let successiveACState = 0,\n    successiveACNextValue;\n  function decodeACSuccessive(component, blockOffset) {\n    let k = spectralStart;\n    const e = spectralEnd;\n    let r = 0;\n    let s;\n    let rs;\n    while (k <= e) {\n      const offsetZ = blockOffset + dctZigZag[k];\n      const sign = component.blockData[offsetZ] < 0 ? -1 : 1;\n      switch (successiveACState) {\n        case 0:\n          rs = decodeHuffman(component.huffmanTableAC);\n          s = rs & 15;\n          r = rs >> 4;\n          if (s === 0) {\n            if (r < 15) {\n              eobrun = receive(r) + (1 << r);\n              successiveACState = 4;\n            } else {\n              r = 16;\n              successiveACState = 1;\n            }\n          } else {\n            if (s !== 1) {\n              throw new JpegError(\"invalid ACn encoding\");\n            }\n            successiveACNextValue = receiveAndExtend(s);\n            successiveACState = r ? 2 : 3;\n          }\n          continue;\n        case 1:\n        case 2:\n          if (component.blockData[offsetZ]) {\n            component.blockData[offsetZ] += sign * (readBit() << successive);\n          } else {\n            r--;\n            if (r === 0) {\n              successiveACState = successiveACState === 2 ? 3 : 0;\n            }\n          }\n          break;\n        case 3:\n          if (component.blockData[offsetZ]) {\n            component.blockData[offsetZ] += sign * (readBit() << successive);\n          } else {\n            component.blockData[offsetZ] = successiveACNextValue << successive;\n            successiveACState = 0;\n          }\n          break;\n        case 4:\n          if (component.blockData[offsetZ]) {\n            component.blockData[offsetZ] += sign * (readBit() << successive);\n          }\n          break;\n      }\n      k++;\n    }\n    if (successiveACState === 4) {\n      eobrun--;\n      if (eobrun === 0) {\n        successiveACState = 0;\n      }\n    }\n  }\n  let blockRow = 0;\n  function decodeMcu(component, decode, mcu, row, col) {\n    const mcuRow = mcu / mcusPerLine | 0;\n    const mcuCol = mcu % mcusPerLine;\n    blockRow = mcuRow * component.v + row;\n    const blockCol = mcuCol * component.h + col;\n    const blockOffset = getBlockBufferOffset(component, blockRow, blockCol);\n    decode(component, blockOffset);\n  }\n  function decodeBlock(component, decode, mcu) {\n    blockRow = mcu / component.blocksPerLine | 0;\n    const blockCol = mcu % component.blocksPerLine;\n    const blockOffset = getBlockBufferOffset(component, blockRow, blockCol);\n    decode(component, blockOffset);\n  }\n  const componentsLength = components.length;\n  let component, i, j, k, n;\n  let decodeFn;\n  if (progressive) {\n    if (spectralStart === 0) {\n      decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n    } else {\n      decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n    }\n  } else {\n    decodeFn = decodeBaseline;\n  }\n  let mcu = 0,\n    fileMarker;\n  const mcuExpected = componentsLength === 1 ? components[0].blocksPerLine * components[0].blocksPerColumn : mcusPerLine * frame.mcusPerColumn;\n  let h, v;\n  while (mcu <= mcuExpected) {\n    const mcuToRead = resetInterval ? Math.min(mcuExpected - mcu, resetInterval) : mcuExpected;\n    if (mcuToRead > 0) {\n      for (i = 0; i < componentsLength; i++) {\n        components[i].pred = 0;\n      }\n      eobrun = 0;\n      if (componentsLength === 1) {\n        component = components[0];\n        for (n = 0; n < mcuToRead; n++) {\n          decodeBlock(component, decodeFn, mcu);\n          mcu++;\n        }\n      } else {\n        for (n = 0; n < mcuToRead; n++) {\n          for (i = 0; i < componentsLength; i++) {\n            component = components[i];\n            h = component.h;\n            v = component.v;\n            for (j = 0; j < v; j++) {\n              for (k = 0; k < h; k++) {\n                decodeMcu(component, decodeFn, mcu, j, k);\n              }\n            }\n          }\n          mcu++;\n        }\n      }\n    }\n    bitsCount = 0;\n    fileMarker = findNextFileMarker(data, offset);\n    if (!fileMarker) {\n      break;\n    }\n    if (fileMarker.invalid) {\n      const partialMsg = mcuToRead > 0 ? \"unexpected\" : \"excessive\";\n      warn(`decodeScan - ${partialMsg} MCU data, current marker is: ${fileMarker.invalid}`);\n      offset = fileMarker.offset;\n    }\n    if (fileMarker.marker >= 0xffd0 && fileMarker.marker <= 0xffd7) {\n      offset += 2;\n    } else {\n      break;\n    }\n  }\n  return offset - startOffset;\n}\nfunction quantizeAndInverse(component, blockBufferOffset, p) {\n  const qt = component.quantizationTable,\n    blockData = component.blockData;\n  let v0, v1, v2, v3, v4, v5, v6, v7;\n  let p0, p1, p2, p3, p4, p5, p6, p7;\n  let t;\n  if (!qt) {\n    throw new JpegError(\"missing required Quantization Table.\");\n  }\n  for (let row = 0; row < 64; row += 8) {\n    p0 = blockData[blockBufferOffset + row];\n    p1 = blockData[blockBufferOffset + row + 1];\n    p2 = blockData[blockBufferOffset + row + 2];\n    p3 = blockData[blockBufferOffset + row + 3];\n    p4 = blockData[blockBufferOffset + row + 4];\n    p5 = blockData[blockBufferOffset + row + 5];\n    p6 = blockData[blockBufferOffset + row + 6];\n    p7 = blockData[blockBufferOffset + row + 7];\n    p0 *= qt[row];\n    if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {\n      t = dctSqrt2 * p0 + 512 >> 10;\n      p[row] = t;\n      p[row + 1] = t;\n      p[row + 2] = t;\n      p[row + 3] = t;\n      p[row + 4] = t;\n      p[row + 5] = t;\n      p[row + 6] = t;\n      p[row + 7] = t;\n      continue;\n    }\n    p1 *= qt[row + 1];\n    p2 *= qt[row + 2];\n    p3 *= qt[row + 3];\n    p4 *= qt[row + 4];\n    p5 *= qt[row + 5];\n    p6 *= qt[row + 6];\n    p7 *= qt[row + 7];\n    v0 = dctSqrt2 * p0 + 128 >> 8;\n    v1 = dctSqrt2 * p4 + 128 >> 8;\n    v2 = p2;\n    v3 = p6;\n    v4 = dctSqrt1d2 * (p1 - p7) + 128 >> 8;\n    v7 = dctSqrt1d2 * (p1 + p7) + 128 >> 8;\n    v5 = p3 << 4;\n    v6 = p5 << 4;\n    v0 = v0 + v1 + 1 >> 1;\n    v1 = v0 - v1;\n    t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;\n    v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;\n    v3 = t;\n    v4 = v4 + v6 + 1 >> 1;\n    v6 = v4 - v6;\n    v7 = v7 + v5 + 1 >> 1;\n    v5 = v7 - v5;\n    v0 = v0 + v3 + 1 >> 1;\n    v3 = v0 - v3;\n    v1 = v1 + v2 + 1 >> 1;\n    v2 = v1 - v2;\n    t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;\n    v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;\n    v7 = t;\n    t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;\n    v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;\n    v6 = t;\n    p[row] = v0 + v7;\n    p[row + 7] = v0 - v7;\n    p[row + 1] = v1 + v6;\n    p[row + 6] = v1 - v6;\n    p[row + 2] = v2 + v5;\n    p[row + 5] = v2 - v5;\n    p[row + 3] = v3 + v4;\n    p[row + 4] = v3 - v4;\n  }\n  for (let col = 0; col < 8; ++col) {\n    p0 = p[col];\n    p1 = p[col + 8];\n    p2 = p[col + 16];\n    p3 = p[col + 24];\n    p4 = p[col + 32];\n    p5 = p[col + 40];\n    p6 = p[col + 48];\n    p7 = p[col + 56];\n    if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {\n      t = dctSqrt2 * p0 + 8192 >> 14;\n      if (t < -2040) {\n        t = 0;\n      } else if (t >= 2024) {\n        t = 255;\n      } else {\n        t = t + 2056 >> 4;\n      }\n      blockData[blockBufferOffset + col] = t;\n      blockData[blockBufferOffset + col + 8] = t;\n      blockData[blockBufferOffset + col + 16] = t;\n      blockData[blockBufferOffset + col + 24] = t;\n      blockData[blockBufferOffset + col + 32] = t;\n      blockData[blockBufferOffset + col + 40] = t;\n      blockData[blockBufferOffset + col + 48] = t;\n      blockData[blockBufferOffset + col + 56] = t;\n      continue;\n    }\n    v0 = dctSqrt2 * p0 + 2048 >> 12;\n    v1 = dctSqrt2 * p4 + 2048 >> 12;\n    v2 = p2;\n    v3 = p6;\n    v4 = dctSqrt1d2 * (p1 - p7) + 2048 >> 12;\n    v7 = dctSqrt1d2 * (p1 + p7) + 2048 >> 12;\n    v5 = p3;\n    v6 = p5;\n    v0 = (v0 + v1 + 1 >> 1) + 4112;\n    v1 = v0 - v1;\n    t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;\n    v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;\n    v3 = t;\n    v4 = v4 + v6 + 1 >> 1;\n    v6 = v4 - v6;\n    v7 = v7 + v5 + 1 >> 1;\n    v5 = v7 - v5;\n    v0 = v0 + v3 + 1 >> 1;\n    v3 = v0 - v3;\n    v1 = v1 + v2 + 1 >> 1;\n    v2 = v1 - v2;\n    t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;\n    v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;\n    v7 = t;\n    t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;\n    v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;\n    v6 = t;\n    p0 = v0 + v7;\n    p7 = v0 - v7;\n    p1 = v1 + v6;\n    p6 = v1 - v6;\n    p2 = v2 + v5;\n    p5 = v2 - v5;\n    p3 = v3 + v4;\n    p4 = v3 - v4;\n    if (p0 < 16) {\n      p0 = 0;\n    } else if (p0 >= 4080) {\n      p0 = 255;\n    } else {\n      p0 >>= 4;\n    }\n    if (p1 < 16) {\n      p1 = 0;\n    } else if (p1 >= 4080) {\n      p1 = 255;\n    } else {\n      p1 >>= 4;\n    }\n    if (p2 < 16) {\n      p2 = 0;\n    } else if (p2 >= 4080) {\n      p2 = 255;\n    } else {\n      p2 >>= 4;\n    }\n    if (p3 < 16) {\n      p3 = 0;\n    } else if (p3 >= 4080) {\n      p3 = 255;\n    } else {\n      p3 >>= 4;\n    }\n    if (p4 < 16) {\n      p4 = 0;\n    } else if (p4 >= 4080) {\n      p4 = 255;\n    } else {\n      p4 >>= 4;\n    }\n    if (p5 < 16) {\n      p5 = 0;\n    } else if (p5 >= 4080) {\n      p5 = 255;\n    } else {\n      p5 >>= 4;\n    }\n    if (p6 < 16) {\n      p6 = 0;\n    } else if (p6 >= 4080) {\n      p6 = 255;\n    } else {\n      p6 >>= 4;\n    }\n    if (p7 < 16) {\n      p7 = 0;\n    } else if (p7 >= 4080) {\n      p7 = 255;\n    } else {\n      p7 >>= 4;\n    }\n    blockData[blockBufferOffset + col] = p0;\n    blockData[blockBufferOffset + col + 8] = p1;\n    blockData[blockBufferOffset + col + 16] = p2;\n    blockData[blockBufferOffset + col + 24] = p3;\n    blockData[blockBufferOffset + col + 32] = p4;\n    blockData[blockBufferOffset + col + 40] = p5;\n    blockData[blockBufferOffset + col + 48] = p6;\n    blockData[blockBufferOffset + col + 56] = p7;\n  }\n}\nfunction buildComponentData(frame, component) {\n  const blocksPerLine = component.blocksPerLine;\n  const blocksPerColumn = component.blocksPerColumn;\n  const computationBuffer = new Int16Array(64);\n  for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n    for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n      const offset = getBlockBufferOffset(component, blockRow, blockCol);\n      quantizeAndInverse(component, offset, computationBuffer);\n    }\n  }\n  return component.blockData;\n}\nfunction findNextFileMarker(data, currentPos, startPos = currentPos) {\n  const maxPos = data.length - 1;\n  let newPos = startPos < currentPos ? startPos : currentPos;\n  if (currentPos >= maxPos) {\n    return null;\n  }\n  const currentMarker = readUint16(data, currentPos);\n  if (currentMarker >= 0xffc0 && currentMarker <= 0xfffe) {\n    return {\n      invalid: null,\n      marker: currentMarker,\n      offset: currentPos\n    };\n  }\n  let newMarker = readUint16(data, newPos);\n  while (!(newMarker >= 0xffc0 && newMarker <= 0xfffe)) {\n    if (++newPos >= maxPos) {\n      return null;\n    }\n    newMarker = readUint16(data, newPos);\n  }\n  return {\n    invalid: currentMarker.toString(16),\n    marker: newMarker,\n    offset: newPos\n  };\n}\nclass JpegImage {\n  constructor({\n    decodeTransform = null,\n    colorTransform = -1\n  } = {}) {\n    this._decodeTransform = decodeTransform;\n    this._colorTransform = colorTransform;\n  }\n  parse(data, {\n    dnlScanLines = null\n  } = {}) {\n    function readDataBlock() {\n      const length = readUint16(data, offset);\n      offset += 2;\n      let endOffset = offset + length - 2;\n      const fileMarker = findNextFileMarker(data, endOffset, offset);\n      if (fileMarker?.invalid) {\n        warn(\"readDataBlock - incorrect length, current marker is: \" + fileMarker.invalid);\n        endOffset = fileMarker.offset;\n      }\n      const array = data.subarray(offset, endOffset);\n      offset += array.length;\n      return array;\n    }\n    function prepareComponents(frame) {\n      const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);\n      const mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);\n      for (const component of frame.components) {\n        const blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);\n        const blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV);\n        const blocksPerLineForMcu = mcusPerLine * component.h;\n        const blocksPerColumnForMcu = mcusPerColumn * component.v;\n        const blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);\n        component.blockData = new Int16Array(blocksBufferSize);\n        component.blocksPerLine = blocksPerLine;\n        component.blocksPerColumn = blocksPerColumn;\n      }\n      frame.mcusPerLine = mcusPerLine;\n      frame.mcusPerColumn = mcusPerColumn;\n    }\n    let offset = 0;\n    let jfif = null;\n    let adobe = null;\n    let frame, resetInterval;\n    let numSOSMarkers = 0;\n    const quantizationTables = [];\n    const huffmanTablesAC = [],\n      huffmanTablesDC = [];\n    let fileMarker = readUint16(data, offset);\n    offset += 2;\n    if (fileMarker !== 0xffd8) {\n      throw new JpegError(\"SOI not found\");\n    }\n    fileMarker = readUint16(data, offset);\n    offset += 2;\n    markerLoop: while (fileMarker !== 0xffd9) {\n      let i, j, l;\n      switch (fileMarker) {\n        case 0xffe0:\n        case 0xffe1:\n        case 0xffe2:\n        case 0xffe3:\n        case 0xffe4:\n        case 0xffe5:\n        case 0xffe6:\n        case 0xffe7:\n        case 0xffe8:\n        case 0xffe9:\n        case 0xffea:\n        case 0xffeb:\n        case 0xffec:\n        case 0xffed:\n        case 0xffee:\n        case 0xffef:\n        case 0xfffe:\n          const appData = readDataBlock();\n          if (fileMarker === 0xffe0) {\n            if (appData[0] === 0x4a && appData[1] === 0x46 && appData[2] === 0x49 && appData[3] === 0x46 && appData[4] === 0) {\n              jfif = {\n                version: {\n                  major: appData[5],\n                  minor: appData[6]\n                },\n                densityUnits: appData[7],\n                xDensity: appData[8] << 8 | appData[9],\n                yDensity: appData[10] << 8 | appData[11],\n                thumbWidth: appData[12],\n                thumbHeight: appData[13],\n                thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])\n              };\n            }\n          }\n          if (fileMarker === 0xffee) {\n            if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6f && appData[3] === 0x62 && appData[4] === 0x65) {\n              adobe = {\n                version: appData[5] << 8 | appData[6],\n                flags0: appData[7] << 8 | appData[8],\n                flags1: appData[9] << 8 | appData[10],\n                transformCode: appData[11]\n              };\n            }\n          }\n          break;\n        case 0xffdb:\n          const quantizationTablesLength = readUint16(data, offset);\n          offset += 2;\n          const quantizationTablesEnd = quantizationTablesLength + offset - 2;\n          let z;\n          while (offset < quantizationTablesEnd) {\n            const quantizationTableSpec = data[offset++];\n            const tableData = new Uint16Array(64);\n            if (quantizationTableSpec >> 4 === 0) {\n              for (j = 0; j < 64; j++) {\n                z = dctZigZag[j];\n                tableData[z] = data[offset++];\n              }\n            } else if (quantizationTableSpec >> 4 === 1) {\n              for (j = 0; j < 64; j++) {\n                z = dctZigZag[j];\n                tableData[z] = readUint16(data, offset);\n                offset += 2;\n              }\n            } else {\n              throw new JpegError(\"DQT - invalid table spec\");\n            }\n            quantizationTables[quantizationTableSpec & 15] = tableData;\n          }\n          break;\n        case 0xffc0:\n        case 0xffc1:\n        case 0xffc2:\n          if (frame) {\n            throw new JpegError(\"Only single frame JPEGs supported\");\n          }\n          offset += 2;\n          frame = {};\n          frame.extended = fileMarker === 0xffc1;\n          frame.progressive = fileMarker === 0xffc2;\n          frame.precision = data[offset++];\n          const sofScanLines = readUint16(data, offset);\n          offset += 2;\n          frame.scanLines = dnlScanLines || sofScanLines;\n          frame.samplesPerLine = readUint16(data, offset);\n          offset += 2;\n          frame.components = [];\n          frame.componentIds = {};\n          const componentsCount = data[offset++];\n          let maxH = 0,\n            maxV = 0;\n          for (i = 0; i < componentsCount; i++) {\n            const componentId = data[offset];\n            const h = data[offset + 1] >> 4;\n            const v = data[offset + 1] & 15;\n            if (maxH < h) {\n              maxH = h;\n            }\n            if (maxV < v) {\n              maxV = v;\n            }\n            const qId = data[offset + 2];\n            l = frame.components.push({\n              h,\n              v,\n              quantizationId: qId,\n              quantizationTable: null\n            });\n            frame.componentIds[componentId] = l - 1;\n            offset += 3;\n          }\n          frame.maxH = maxH;\n          frame.maxV = maxV;\n          prepareComponents(frame);\n          break;\n        case 0xffc4:\n          const huffmanLength = readUint16(data, offset);\n          offset += 2;\n          for (i = 2; i < huffmanLength;) {\n            const huffmanTableSpec = data[offset++];\n            const codeLengths = new Uint8Array(16);\n            let codeLengthSum = 0;\n            for (j = 0; j < 16; j++, offset++) {\n              codeLengthSum += codeLengths[j] = data[offset];\n            }\n            const huffmanValues = new Uint8Array(codeLengthSum);\n            for (j = 0; j < codeLengthSum; j++, offset++) {\n              huffmanValues[j] = data[offset];\n            }\n            i += 17 + codeLengthSum;\n            (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);\n          }\n          break;\n        case 0xffdd:\n          offset += 2;\n          resetInterval = readUint16(data, offset);\n          offset += 2;\n          break;\n        case 0xffda:\n          const parseDNLMarker = ++numSOSMarkers === 1 && !dnlScanLines;\n          offset += 2;\n          const selectorsCount = data[offset++],\n            components = [];\n          for (i = 0; i < selectorsCount; i++) {\n            const index = data[offset++];\n            const componentIndex = frame.componentIds[index];\n            const component = frame.components[componentIndex];\n            component.index = index;\n            const tableSpec = data[offset++];\n            component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];\n            component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];\n            components.push(component);\n          }\n          const spectralStart = data[offset++],\n            spectralEnd = data[offset++],\n            successiveApproximation = data[offset++];\n          try {\n            const processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, parseDNLMarker);\n            offset += processed;\n          } catch (ex) {\n            if (ex instanceof DNLMarkerError) {\n              warn(`${ex.message} -- attempting to re-parse the JPEG image.`);\n              return this.parse(data, {\n                dnlScanLines: ex.scanLines\n              });\n            } else if (ex instanceof EOIMarkerError) {\n              warn(`${ex.message} -- ignoring the rest of the image data.`);\n              break markerLoop;\n            }\n            throw ex;\n          }\n          break;\n        case 0xffdc:\n          offset += 4;\n          break;\n        case 0xffff:\n          if (data[offset] !== 0xff) {\n            offset--;\n          }\n          break;\n        default:\n          const nextFileMarker = findNextFileMarker(data, offset - 2, offset - 3);\n          if (nextFileMarker?.invalid) {\n            warn(\"JpegImage.parse - unexpected data, current marker is: \" + nextFileMarker.invalid);\n            offset = nextFileMarker.offset;\n            break;\n          }\n          if (!nextFileMarker || offset >= data.length - 1) {\n            warn(\"JpegImage.parse - reached the end of the image data \" + \"without finding an EOI marker (0xFFD9).\");\n            break markerLoop;\n          }\n          throw new JpegError(\"JpegImage.parse - unknown marker: \" + fileMarker.toString(16));\n      }\n      fileMarker = readUint16(data, offset);\n      offset += 2;\n    }\n    if (!frame) {\n      throw new JpegError(\"JpegImage.parse - no frame data found.\");\n    }\n    this.width = frame.samplesPerLine;\n    this.height = frame.scanLines;\n    this.jfif = jfif;\n    this.adobe = adobe;\n    this.components = [];\n    for (const component of frame.components) {\n      const quantizationTable = quantizationTables[component.quantizationId];\n      if (quantizationTable) {\n        component.quantizationTable = quantizationTable;\n      }\n      this.components.push({\n        index: component.index,\n        output: buildComponentData(frame, component),\n        scaleX: component.h / frame.maxH,\n        scaleY: component.v / frame.maxV,\n        blocksPerLine: component.blocksPerLine,\n        blocksPerColumn: component.blocksPerColumn\n      });\n    }\n    this.numComponents = this.components.length;\n    return undefined;\n  }\n  _getLinearizedBlockData(width, height, isSourcePDF = false) {\n    const scaleX = this.width / width,\n      scaleY = this.height / height;\n    let component, componentScaleX, componentScaleY, blocksPerScanline;\n    let x, y, i, j, k;\n    let index;\n    let offset = 0;\n    let output;\n    const numComponents = this.components.length;\n    const dataLength = width * height * numComponents;\n    const data = new Uint8ClampedArray(dataLength);\n    const xScaleBlockOffset = new Uint32Array(width);\n    const mask3LSB = 0xfffffff8;\n    let lastComponentScaleX;\n    for (i = 0; i < numComponents; i++) {\n      component = this.components[i];\n      componentScaleX = component.scaleX * scaleX;\n      componentScaleY = component.scaleY * scaleY;\n      offset = i;\n      output = component.output;\n      blocksPerScanline = component.blocksPerLine + 1 << 3;\n      if (componentScaleX !== lastComponentScaleX) {\n        for (x = 0; x < width; x++) {\n          j = 0 | x * componentScaleX;\n          xScaleBlockOffset[x] = (j & mask3LSB) << 3 | j & 7;\n        }\n        lastComponentScaleX = componentScaleX;\n      }\n      for (y = 0; y < height; y++) {\n        j = 0 | y * componentScaleY;\n        index = blocksPerScanline * (j & mask3LSB) | (j & 7) << 3;\n        for (x = 0; x < width; x++) {\n          data[offset] = output[index + xScaleBlockOffset[x]];\n          offset += numComponents;\n        }\n      }\n    }\n    let transform = this._decodeTransform;\n    if (!isSourcePDF && numComponents === 4 && !transform) {\n      transform = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]);\n    }\n    if (transform) {\n      for (i = 0; i < dataLength;) {\n        for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {\n          data[i] = (data[i] * transform[k] >> 8) + transform[k + 1];\n        }\n      }\n    }\n    return data;\n  }\n  get _isColorConversionNeeded() {\n    if (this.adobe) {\n      return !!this.adobe.transformCode;\n    }\n    if (this.numComponents === 3) {\n      if (this._colorTransform === 0) {\n        return false;\n      } else if (this.components[0].index === 0x52 && this.components[1].index === 0x47 && this.components[2].index === 0x42) {\n        return false;\n      }\n      return true;\n    }\n    if (this._colorTransform === 1) {\n      return true;\n    }\n    return false;\n  }\n  _convertYccToRgb(data) {\n    let Y, Cb, Cr;\n    for (let i = 0, length = data.length; i < length; i += 3) {\n      Y = data[i];\n      Cb = data[i + 1];\n      Cr = data[i + 2];\n      data[i] = Y - 179.456 + 1.402 * Cr;\n      data[i + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;\n      data[i + 2] = Y - 226.816 + 1.772 * Cb;\n    }\n    return data;\n  }\n  _convertYccToRgba(data, out) {\n    for (let i = 0, j = 0, length = data.length; i < length; i += 3, j += 4) {\n      const Y = data[i];\n      const Cb = data[i + 1];\n      const Cr = data[i + 2];\n      out[j] = Y - 179.456 + 1.402 * Cr;\n      out[j + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;\n      out[j + 2] = Y - 226.816 + 1.772 * Cb;\n      out[j + 3] = 255;\n    }\n    return out;\n  }\n  _convertYcckToRgb(data) {\n    let Y, Cb, Cr, k;\n    let offset = 0;\n    for (let i = 0, length = data.length; i < length; i += 4) {\n      Y = data[i];\n      Cb = data[i + 1];\n      Cr = data[i + 2];\n      k = data[i + 3];\n      data[offset++] = -122.67195406894 + Cb * (-6.60635669420364e-5 * Cb + 0.000437130475926232 * Cr - 5.4080610064599e-5 * Y + 0.00048449797120281 * k - 0.154362151871126) + Cr * (-0.000957964378445773 * Cr + 0.000817076911346625 * Y - 0.00477271405408747 * k + 1.53380253221734) + Y * (0.000961250184130688 * Y - 0.00266257332283933 * k + 0.48357088451265) + k * (-0.000336197177618394 * k + 0.484791561490776);\n      data[offset++] = 107.268039397724 + Cb * (2.19927104525741e-5 * Cb - 0.000640992018297945 * Cr + 0.000659397001245577 * Y + 0.000426105652938837 * k - 0.176491792462875) + Cr * (-0.000778269941513683 * Cr + 0.00130872261408275 * Y + 0.000770482631801132 * k - 0.151051492775562) + Y * (0.00126935368114843 * Y - 0.00265090189010898 * k + 0.25802910206845) + k * (-0.000318913117588328 * k - 0.213742400323665);\n      data[offset++] = -20.810012546947 + Cb * (-0.000570115196973677 * Cb - 2.63409051004589e-5 * Cr + 0.0020741088115012 * Y - 0.00288260236853442 * k + 0.814272968359295) + Cr * (-1.53496057440975e-5 * Cr - 0.000132689043961446 * Y + 0.000560833691242812 * k - 0.195152027534049) + Y * (0.00174418132927582 * Y - 0.00255243321439347 * k + 0.116935020465145) + k * (-0.000343531996510555 * k + 0.24165260232407);\n    }\n    return data.subarray(0, offset);\n  }\n  _convertYcckToRgba(data) {\n    for (let i = 0, length = data.length; i < length; i += 4) {\n      const Y = data[i];\n      const Cb = data[i + 1];\n      const Cr = data[i + 2];\n      const k = data[i + 3];\n      data[i] = -122.67195406894 + Cb * (-6.60635669420364e-5 * Cb + 0.000437130475926232 * Cr - 5.4080610064599e-5 * Y + 0.00048449797120281 * k - 0.154362151871126) + Cr * (-0.000957964378445773 * Cr + 0.000817076911346625 * Y - 0.00477271405408747 * k + 1.53380253221734) + Y * (0.000961250184130688 * Y - 0.00266257332283933 * k + 0.48357088451265) + k * (-0.000336197177618394 * k + 0.484791561490776);\n      data[i + 1] = 107.268039397724 + Cb * (2.19927104525741e-5 * Cb - 0.000640992018297945 * Cr + 0.000659397001245577 * Y + 0.000426105652938837 * k - 0.176491792462875) + Cr * (-0.000778269941513683 * Cr + 0.00130872261408275 * Y + 0.000770482631801132 * k - 0.151051492775562) + Y * (0.00126935368114843 * Y - 0.00265090189010898 * k + 0.25802910206845) + k * (-0.000318913117588328 * k - 0.213742400323665);\n      data[i + 2] = -20.810012546947 + Cb * (-0.000570115196973677 * Cb - 2.63409051004589e-5 * Cr + 0.0020741088115012 * Y - 0.00288260236853442 * k + 0.814272968359295) + Cr * (-1.53496057440975e-5 * Cr - 0.000132689043961446 * Y + 0.000560833691242812 * k - 0.195152027534049) + Y * (0.00174418132927582 * Y - 0.00255243321439347 * k + 0.116935020465145) + k * (-0.000343531996510555 * k + 0.24165260232407);\n      data[i + 3] = 255;\n    }\n    return data;\n  }\n  _convertYcckToCmyk(data) {\n    let Y, Cb, Cr;\n    for (let i = 0, length = data.length; i < length; i += 4) {\n      Y = data[i];\n      Cb = data[i + 1];\n      Cr = data[i + 2];\n      data[i] = 434.456 - Y - 1.402 * Cr;\n      data[i + 1] = 119.541 - Y + 0.344 * Cb + 0.714 * Cr;\n      data[i + 2] = 481.816 - Y - 1.772 * Cb;\n    }\n    return data;\n  }\n  _convertCmykToRgb(data) {\n    let c, m, y, k;\n    let offset = 0;\n    for (let i = 0, length = data.length; i < length; i += 4) {\n      c = data[i];\n      m = data[i + 1];\n      y = data[i + 2];\n      k = data[i + 3];\n      data[offset++] = 255 + c * (-0.00006747147073602441 * c + 0.0008379262121013727 * m + 0.0002894718188643294 * y + 0.003264231057537806 * k - 1.1185611867203937) + m * (0.000026374107616089405 * m - 0.00008626949158638572 * y - 0.0002748769067499491 * k - 0.02155688794978967) + y * (-0.00003878099212869363 * y - 0.0003267808279485286 * k + 0.0686742238595345) - k * (0.0003361971776183937 * k + 0.7430659151342254);\n      data[offset++] = 255 + c * (0.00013596372813588848 * c + 0.000924537132573585 * m + 0.00010567359618683593 * y + 0.0004791864687436512 * k - 0.3109689587515875) + m * (-0.00023545346108370344 * m + 0.0002702845253534714 * y + 0.0020200308977307156 * k - 0.7488052167015494) + y * (0.00006834815998235662 * y + 0.00015168452363460973 * k - 0.09751927774728933) - k * (0.0003189131175883281 * k + 0.7364883807733168);\n      data[offset++] = 255 + c * (0.000013598650411385307 * c + 0.00012423956175490851 * m + 0.0004751985097583589 * y - 0.0000036729317476630422 * k - 0.05562186980264034) + m * (0.00016141380598724676 * m + 0.0009692239130725186 * y + 0.0007782692450036253 * k - 0.44015232367526463) + y * (5.068882914068769e-7 * y + 0.0017778369011375071 * k - 0.7591454649749609) - k * (0.0003435319965105553 * k + 0.7063770186160144);\n    }\n    return data.subarray(0, offset);\n  }\n  _convertCmykToRgba(data) {\n    for (let i = 0, length = data.length; i < length; i += 4) {\n      const c = data[i];\n      const m = data[i + 1];\n      const y = data[i + 2];\n      const k = data[i + 3];\n      data[i] = 255 + c * (-0.00006747147073602441 * c + 0.0008379262121013727 * m + 0.0002894718188643294 * y + 0.003264231057537806 * k - 1.1185611867203937) + m * (0.000026374107616089405 * m - 0.00008626949158638572 * y - 0.0002748769067499491 * k - 0.02155688794978967) + y * (-0.00003878099212869363 * y - 0.0003267808279485286 * k + 0.0686742238595345) - k * (0.0003361971776183937 * k + 0.7430659151342254);\n      data[i + 1] = 255 + c * (0.00013596372813588848 * c + 0.000924537132573585 * m + 0.00010567359618683593 * y + 0.0004791864687436512 * k - 0.3109689587515875) + m * (-0.00023545346108370344 * m + 0.0002702845253534714 * y + 0.0020200308977307156 * k - 0.7488052167015494) + y * (0.00006834815998235662 * y + 0.00015168452363460973 * k - 0.09751927774728933) - k * (0.0003189131175883281 * k + 0.7364883807733168);\n      data[i + 2] = 255 + c * (0.000013598650411385307 * c + 0.00012423956175490851 * m + 0.0004751985097583589 * y - 0.0000036729317476630422 * k - 0.05562186980264034) + m * (0.00016141380598724676 * m + 0.0009692239130725186 * y + 0.0007782692450036253 * k - 0.44015232367526463) + y * (5.068882914068769e-7 * y + 0.0017778369011375071 * k - 0.7591454649749609) - k * (0.0003435319965105553 * k + 0.7063770186160144);\n      data[i + 3] = 255;\n    }\n    return data;\n  }\n  getData({\n    width,\n    height,\n    forceRGBA = false,\n    forceRGB = false,\n    isSourcePDF = false\n  }) {\n    if (this.numComponents > 4) {\n      throw new JpegError(\"Unsupported color mode\");\n    }\n    const data = this._getLinearizedBlockData(width, height, isSourcePDF);\n    if (this.numComponents === 1 && (forceRGBA || forceRGB)) {\n      const len = data.length * (forceRGBA ? 4 : 3);\n      const rgbaData = new Uint8ClampedArray(len);\n      let offset = 0;\n      if (forceRGBA) {\n        grayToRGBA(data, new Uint32Array(rgbaData.buffer));\n      } else {\n        for (const grayColor of data) {\n          rgbaData[offset++] = grayColor;\n          rgbaData[offset++] = grayColor;\n          rgbaData[offset++] = grayColor;\n        }\n      }\n      return rgbaData;\n    } else if (this.numComponents === 3 && this._isColorConversionNeeded) {\n      if (forceRGBA) {\n        const rgbaData = new Uint8ClampedArray(data.length / 3 * 4);\n        return this._convertYccToRgba(data, rgbaData);\n      }\n      return this._convertYccToRgb(data);\n    } else if (this.numComponents === 4) {\n      if (this._isColorConversionNeeded) {\n        if (forceRGBA) {\n          return this._convertYcckToRgba(data);\n        }\n        if (forceRGB) {\n          return this._convertYcckToRgb(data);\n        }\n        return this._convertYcckToCmyk(data);\n      } else if (forceRGBA) {\n        return this._convertCmykToRgba(data);\n      } else if (forceRGB) {\n        return this._convertCmykToRgb(data);\n      }\n    }\n    return data;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/jpeg_stream.js\n\n\n\n\nclass JpegStream extends DecodeStream {\n  constructor(stream, maybeLength, params) {\n    let ch;\n    while ((ch = stream.getByte()) !== -1) {\n      if (ch === 0xff) {\n        stream.skip(-1);\n        break;\n      }\n    }\n    super(maybeLength);\n    this.stream = stream;\n    this.dict = stream.dict;\n    this.maybeLength = maybeLength;\n    this.params = params;\n  }\n  get bytes() {\n    return shadow(this, \"bytes\", this.stream.getBytes(this.maybeLength));\n  }\n  ensureBuffer(requested) {}\n  readBlock() {\n    if (this.eof) {\n      return;\n    }\n    const jpegOptions = {\n      decodeTransform: undefined,\n      colorTransform: undefined\n    };\n    const decodeArr = this.dict.getArray(\"D\", \"Decode\");\n    if ((this.forceRGBA || this.forceRGB) && Array.isArray(decodeArr)) {\n      const bitsPerComponent = this.dict.get(\"BPC\", \"BitsPerComponent\") || 8;\n      const decodeArrLength = decodeArr.length;\n      const transform = new Int32Array(decodeArrLength);\n      let transformNeeded = false;\n      const maxValue = (1 << bitsPerComponent) - 1;\n      for (let i = 0; i < decodeArrLength; i += 2) {\n        transform[i] = (decodeArr[i + 1] - decodeArr[i]) * 256 | 0;\n        transform[i + 1] = decodeArr[i] * maxValue | 0;\n        if (transform[i] !== 256 || transform[i + 1] !== 0) {\n          transformNeeded = true;\n        }\n      }\n      if (transformNeeded) {\n        jpegOptions.decodeTransform = transform;\n      }\n    }\n    if (this.params instanceof Dict) {\n      const colorTransform = this.params.get(\"ColorTransform\");\n      if (Number.isInteger(colorTransform)) {\n        jpegOptions.colorTransform = colorTransform;\n      }\n    }\n    const jpegImage = new JpegImage(jpegOptions);\n    jpegImage.parse(this.bytes);\n    const data = jpegImage.getData({\n      width: this.drawWidth,\n      height: this.drawHeight,\n      forceRGBA: this.forceRGBA,\n      forceRGB: this.forceRGB,\n      isSourcePDF: true\n    });\n    this.buffer = data;\n    this.bufferLength = data.length;\n    this.eof = true;\n  }\n}\n\n;// CONCATENATED MODULE: ./external/openjpeg/openjpeg.js\nvar OpenJPEG = (() => {\n  var _scriptDir = \"file:///C:/pdfjs/botio-files-pdfjs/private/d6919bed03c6677/external/openjpeg/openjpeg.js\";\n  return function (moduleArg = {}) {\n    var Module = moduleArg;\n    var readyPromiseResolve, readyPromiseReject;\n    var readyPromise = new Promise((resolve, reject) => {\n      readyPromiseResolve = resolve;\n      readyPromiseReject = reject;\n    });\n    \"use strict\";\n    Module.decode = function (bytes, ignoreColorSpace) {\n      const size = bytes.length;\n      const ptr = Module._malloc(size);\n      Module.HEAPU8.set(bytes, ptr);\n      const ret = Module._jp2_decode(ptr, size, ignoreColorSpace ? 1 : 0);\n      Module._free(ptr);\n      if (ret) {\n        const {\n          errorMessages: errorMessages\n        } = Module;\n        if (errorMessages) {\n          delete Module.errorMessages;\n          return errorMessages;\n        }\n        return \"Unknown error\";\n      }\n      const {\n        imageData: imageData\n      } = Module;\n      Module.imageData = null;\n      return imageData;\n    };\n    var moduleOverrides = Object.assign({}, Module);\n    var arguments_ = [];\n    var thisProgram = \"./this.program\";\n    var quit_ = (status, toThrow) => {\n      throw toThrow;\n    };\n    var ENVIRONMENT_IS_WEB = true;\n    var ENVIRONMENT_IS_WORKER = false;\n    var scriptDirectory = \"\";\n    var read_, readAsync, readBinary;\n    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = self.location.href;\n      } else if (typeof document != \"undefined\" && document.currentScript) {\n        scriptDirectory = document.currentScript.src;\n      }\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      }\n      if (scriptDirectory.startsWith(\"blob:\")) {\n        scriptDirectory = \"\";\n      } else {\n        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\n      }\n      read_ = url => {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", url, false);\n        xhr.send(null);\n        return xhr.responseText;\n      };\n      if (ENVIRONMENT_IS_WORKER) {\n        readBinary = url => {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, false);\n          xhr.responseType = \"arraybuffer\";\n          xhr.send(null);\n          return new Uint8Array(xhr.response);\n        };\n      }\n      readAsync = (url, onload, onerror) => {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", url, true);\n        xhr.responseType = \"arraybuffer\";\n        xhr.onload = () => {\n          if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n            onload(xhr.response);\n            return;\n          }\n          onerror();\n        };\n        xhr.onerror = onerror;\n        xhr.send(null);\n      };\n    } else {}\n    var out = Module[\"print\"] || console.log.bind(console);\n    var err = Module[\"printErr\"] || console.error.bind(console);\n    Object.assign(Module, moduleOverrides);\n    moduleOverrides = null;\n    if (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n    if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n    if (Module[\"quit\"]) quit_ = Module[\"quit\"];\n    var wasmBinary;\n    if (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n    function intArrayFromBase64(s) {\n      var decoded = atob(s);\n      var bytes = new Uint8Array(decoded.length);\n      for (var i = 0; i < decoded.length; ++i) {\n        bytes[i] = decoded.charCodeAt(i);\n      }\n      return bytes;\n    }\n    function tryParseAsDataURI(filename) {\n      if (!isDataURI(filename)) {\n        return;\n      }\n      return intArrayFromBase64(filename.slice(dataURIPrefix.length));\n    }\n    var wasmMemory;\n    var ABORT = false;\n    var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n    function updateMemoryViews() {\n      var b = wasmMemory.buffer;\n      Module[\"HEAP8\"] = HEAP8 = new Int8Array(b);\n      Module[\"HEAP16\"] = HEAP16 = new Int16Array(b);\n      Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(b);\n      Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(b);\n      Module[\"HEAP32\"] = HEAP32 = new Int32Array(b);\n      Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(b);\n      Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(b);\n      Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(b);\n    }\n    var __ATPRERUN__ = [];\n    var __ATINIT__ = [];\n    var __ATPOSTRUN__ = [];\n    var runtimeInitialized = false;\n    function preRun() {\n      if (Module[\"preRun\"]) {\n        if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [Module[\"preRun\"]];\n        while (Module[\"preRun\"].length) {\n          addOnPreRun(Module[\"preRun\"].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n    function initRuntime() {\n      runtimeInitialized = true;\n      callRuntimeCallbacks(__ATINIT__);\n    }\n    function postRun() {\n      if (Module[\"postRun\"]) {\n        if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [Module[\"postRun\"]];\n        while (Module[\"postRun\"].length) {\n          addOnPostRun(Module[\"postRun\"].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null;\n    function addRunDependency(id) {\n      runDependencies++;\n      Module[\"monitorRunDependencies\"]?.(runDependencies);\n    }\n    function removeRunDependency(id) {\n      runDependencies--;\n      Module[\"monitorRunDependencies\"]?.(runDependencies);\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback();\n        }\n      }\n    }\n    var dataURIPrefix = \"data:application/octet-stream;base64,\";\n    var isDataURI = filename => filename.startsWith(dataURIPrefix);\n    var wasmBinaryFile;\n    wasmBinaryFile = \"data:application/octet-stream;base64,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AkAgFSAYIA1BAnRqQRBJckUEQANAIAEgAEECdCIEaiAEIAVq/QACAP0LAgAgAEEEaiIAIBNHDQALIBMiBCAIRg0BCyAEIQAgEQRAA0AgASAAIAJsQQJ0aiAFIABBAnRqKAIANgIAIABBAWohACAGQQFqIgYgEUcNAAsLIAQgCGtBfEsNAANAIAEgACACbEECdGogBSAAQQJ0aigCADYCACABIABBAWoiBCACbEECdGogBSAEQQJ0aigCADYCACABIABBAmoiBCACbEECdGogBSAEQQJ0aigCADYCACABIABBA2oiBCACbEECdGogBSAEQQJ0aigCADYCACAAQQRqIgAgCEcNAAsLIAFBBGohASANQQFqIg0gA0cNAAsMAQsCQAJAAkAgCEEBaw4CAAECCyADQQBMDQJBACECAkAgA0EESQRAIAEhAAwBCyABIANB/P///wdxIgJBAnRqIQADQCABIAZBAnRqIgQgBP0AAgAiIf0bAEECbf0RICH9GwFBAm39HAEgIf0bAkECbf0cAiAh/RsDQQJt/RwD/QsCACAGQQRqIgYgAkcNAAsgAiADRg0DCwNAIAAgACgCAEECbTYCACAAQQRqIQAgAkEBaiICIANHDQALDAILIANBAEwNASAAKAIAIQkgAiAKbEECdCEHA0AgCSABKAIAIAEgB2oiBCgCAEEBakEBdWsiADYCBCAJIAAgBCgCAGoiADYCACABIAA2AgAgASACQQJ0aiAJKAIENgIAIAFBBGohASAGQQFqIgYgA0cNAAsMAQsgCEEDSA0AIANBAEwNACAAKAIAIgUgCCAIQQFxIhRFIgZrQQRrIglBAXYiC0ECdCIHIAEgA0ECdCIAampJIAUgC0EDdGpBDGoiBCABQQRqS3EgBUEEaiAAIAEgCkECdGoiAGogB2pBCGpJIABBCGogBElxciEVIAJBAUcgCEEESXIhFiACQQFGIAlBBUtxIRcgCEH8////B3EhECAIQQNxIREgASAFayEYIAUgCEECdGpBBGshGSAFIAhBAmsiAEECdGohGiALQQFqIhJBfHEiDEEBciETIAxBAXRBAXIhCyACIApsQQJ0IRsgACAGa0ECSSEcIAhBAXZBAWsgAmxBAnQhHQNAIAUgASgCACABIBtqIg8gAkECdGooAgAiCSAPKAIAIgBqQQJqQQJ1ayIHIABqNgIA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aCk9AAkJCSBzdGVwc2l6ZXMgKG0sZSk9AC4AKG51bGwpACglZCwlZCkgACVzfQoACQkgfQoAW0RFVl0gRHVtcCBhbiBpbWFnZV9jb21wX2hlYWRlciBzdHJ1Y3QgewoAW0RFVl0gRHVtcCBhbiBpbWFnZV9oZWFkZXIgc3RydWN0IHsKAEltYWdlIGluZm8gewoACSBkZWZhdWx0IHRpbGUgewoAJXMJIGNvbXBvbmVudCAlZCB7CgAJCSBjb21wICVkIHsKAAkgVGlsZSBpbmRleDogewoACSBNYXJrZXIgbGlzdDogewoAQ29kZXN0cmVhbSBpbmRleCBmcm9tIG1haW4gaGVhZGVyOiB7CgBDb2Rlc3RyZWFtIGluZm8gZnJvbSBtYWluIGhlYWRlcjogewoAU3RyZWFtIGVycm9yIHdoaWxlIHJlYWRpbmcgSlAyIEhlYWRlciBib3gKAEZvdW5kIGEgbWlzcGxhY2VkICclYyVjJWMlYycgYm94IG91dHNpZGUganAyaCBib3gKAE1hbGZvcm1lZCBKUDIgZmlsZSBmb3JtYXQ6IGZpcnN0IGJveCBtdXN0IGJlIEpQRUcgMjAwMCBzaWduYXR1cmUgYm94CgBNYWxmb3JtZWQgSlAyIGZpbGUgZm9ybWF0OiBzZWNvbmQgYm94IG11c3QgYmUgZmlsZSB0eXBlIGJveAoATm90IGVub3VnaCBtZW1vcnkgdG8gaGFuZGxlIGpwZWcyMDAwIGJveAoATm90IGVub3VnaCBtZW1vcnkgd2l0aCBGVFlQIEJveAoAQSBtYXJrZXIgSUQgd2FzIGV4cGVjdGVkICgweGZmLS0pIGluc3RlYWQgb2YgJS44eAoACQkgbWN0PSV4CgAJCQkgY2Jsa3N0eT0lI3gKAAkJCSBjc3R5PSUjeAoACQkgcHJnPSUjeAoASW50ZWdlciBvdmVyZmxvdwoACSB0ZHg9JXUsIHRkeT0ldQoACSB0dz0ldSwgdGg9JXUKAAkgdHgwPSV1LCB0eTA9JXUKAEludmFsaWQgY29tcG9uZW50IGluZGV4OiAldQoAU3RyZWFtIHRvbyBzaG9ydAoATWFya2VyIGhhbmRsZXIgZnVuY3Rpb24gZmFpbGVkIHRvIHJlYWQgdGhlIG1hcmtlciBzZWdtZW50CgBOb3QgZW5vdWdoIG1lbW9yeSBmb3IgY3VycmVudCBwcmVjaW5jdCBjb2RlYmxvY2sgZWxlbWVudAoARXJyb3IgcmVhZGluZyBTUENvZCBTUENvYyBlbGVtZW50CgBFcnJvciByZWFkaW5nIFNRY2Qgb3IgU1FjYyBlbGVtZW50CgBBIEJQQ0MgaGVhZGVyIGJveCBpcyBhdmFpbGFibGUgYWx0aG91Z2ggQlBDIGdpdmVuIGJ5IHRoZSBJSERSIGJveCAoJWQpIGluZGljYXRlIGNvbXBvbmVudHMgYml0IGRlcHRoIGlzIGNvbnN0YW50CgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IGlsbGVnYWwgdGlsZSBvZmZzZXQKAEludmFsaWQgcHJlY2luY3QKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGhhbmRsZSBiYW5kIHByZWNpbnRzCgBGYWlsZWQgdG8gZGVjb2RlIGFsbCB1c2VkIGNvbXBvbmVudHMKAFNpemUgb2YgY29kZSBibG9jayBkYXRhIGV4Y2VlZHMgc3lzdGVtIGxpbWl0cwoAU2l6ZSBvZiB0aWxlIGRhdGEgZXhjZWVkcyBzeXN0ZW0gbGltaXRzCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgbXVsdGlwbGUgTUNUIG1hcmtlcnMKAENvcnJ1cHRlZCBQUE0gbWFya2VycwoATm90IGVub3VnaCBtZW1vcnkgZm9yIHRpbGUgcmVzb2x1dGlvbnMKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBtdWx0aXBsZSBjb2xsZWN0aW9ucwoASW52YWxpZCBQQ0xSIGJveC4gUmVwb3J0cyAwIHBhbGV0dGUgY29sdW1ucwoAV2UgZG8gbm90IHN1cHBvcnQgUk9JIGluIGRlY29kaW5nIEhUIGNvZGVibG9ja3MKAENhbm5vdCBoYW5kbGUgYm94IG9mIHVuZGVmaW5lZCBzaXplcwoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIGNvbGxlY3Rpb25zIHdpdGhvdXQgc2FtZSBudW1iZXIgb2YgaW5kaXhlcwoASW52YWxpZCB0aWxlYy0+d2luX3h4eCB2YWx1ZXMKAENhbm5vdCBoYW5kbGUgYm94IG9mIGxlc3MgdGhhbiA4IGJ5dGVzCgBDYW5ub3QgaGFuZGxlIFhMIGJveCBvZiBsZXNzIHRoYW4gMTYgYnl0ZXMKAENvbXBvbmVudCBpbmRleCAldSB1c2VkIHNldmVyYWwgdGltZXMKAEludmFsaWQgUENMUiBib3guIFJlcG9ydHMgJWQgZW50cmllcwoATm90IGVub3VnaCBtZW1vcnkgdG8gY3JlYXRlIFRhZy10cmVlIG5vZGVzCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgbWN0IGRhdGEgd2l0aGluIG11bHRpcGxlIE1DVCByZWNvcmRzCgBDYW5ub3QgZGVjb2RlIHRpbGUsIG1lbW9yeSBlcnJvcgoAb3BqX2oya19hcHBseV9uYl90aWxlX3BhcnRzX2NvcnJlY3Rpb24gZXJyb3IKAFByb2JsZW0gd2l0aCBza2lwcGluZyBKUEVHMjAwMCBib3gsIHN0cmVhbSBlcnJvcgoAUHJvYmxlbSB3aXRoIHJlYWRpbmcgSlBFRzIwMDAgYm94LCBzdHJlYW0gZXJyb3IKAFVua25vd24gbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBhZGQgdGwgbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBhZGQgbWggbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byB0YWtlIGluIGNoYXJnZSBTSVogbWFya2VyCgBFcnJvciByZWFkaW5nIFBQVCBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgUFBUIG1hcmtlcgoARXJyb3IgcmVhZGluZyBTT1QgbWFya2VyCgBFcnJvciByZWFkaW5nIFBMVCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgTUNUIG1hcmtlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVhZCBNQ1QgbWFya2VyCgBOb3QgZW5vdWdoIHNwYWNlIGZvciBleHBlY3RlZCBTT1AgbWFya2VyCgBFeHBlY3RlZCBTT1AgbWFya2VyCgBFcnJvciByZWFkaW5nIE1DTyBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUkdOIG1hcmtlcgoARXJyb3IgcmVhZGluZyBQUE0gbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIFBQTSBtYXJrZXIKAEVycm9yIHJlYWRpbmcgVExNIG1hcmtlcgoARXJyb3IgcmVhZGluZyBQTE0gbWFya2VyCgBOb3QgZW5vdWdoIHNwYWNlIGZvciBleHBlY3RlZCBFUEggbWFya2VyCgBFeHBlY3RlZCBFUEggbWFya2VyCgBFcnJvciByZWFkaW5nIENSRyBtYXJrZXIKAFVua25vd24gcHJvZ3Jlc3Npb24gb3JkZXIgaW4gQ09EIG1hcmtlcgoAVW5rbm93biBTY29kIHZhbHVlIGluIENPRCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgQ09EIG1hcmtlcgoARXJyb3IgcmVhZGluZyBRQ0QgbWFya2VyCgBDcnJvciByZWFkaW5nIENCRCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUE9DIG1hcmtlcgoARXJyb3IgcmVhZGluZyBDT0MgbWFya2VyCgBFcnJvciByZWFkaW5nIFFDQyBtYXJrZXIKAEVycm9yIHJlYWRpbmcgTUNDIG1hcmtlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVhZCBNQ0MgbWFya2VyCgByZXF1aXJlZCBTSVogbWFya2VyIG5vdCBmb3VuZCBpbiBtYWluIGhlYWRlcgoAcmVxdWlyZWQgQ09EIG1hcmtlciBub3QgZm91bmQgaW4gbWFpbiBoZWFkZXIKAHJlcXVpcmVkIFFDRCBtYXJrZXIgbm90IGZvdW5kIGluIG1haW4gaGVhZGVyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBoYW5kbGUganBlZzIwMDAgZmlsZSBoZWFkZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgaGVhZGVyCgBFcnJvciB3aXRoIEpQIFNpZ25hdHVyZSA6IGJhZCBtYWdpYyBudW1iZXIKAEluIFNPVCBtYXJrZXIsIFRQU290ICglZCkgaXMgbm90IHZhbGlkIHJlZ2FyZHMgdG8gdGhlIGN1cnJlbnQgbnVtYmVyIG9mIHRpbGUtcGFydCAoJWQpLCBnaXZpbmcgdXAKAEluIFNPVCBtYXJrZXIsIFRQU290ICglZCkgaXMgbm90IHZhbGlkIHJlZ2FyZHMgdG8gdGhlIHByZXZpb3VzIG51bWJlciBvZiB0aWxlLXBhcnQgKCVkKSwgZ2l2aW5nIHVwCgBJbiBTT1QgbWFya2VyLCBUUFNvdCAoJWQpIGlzIG5vdCB2YWxpZCByZWdhcmRzIHRvIHRoZSBjdXJyZW50IG51bWJlciBvZiB0aWxlLXBhcnQgKGhlYWRlcikgKCVkKSwgZ2l2aW5nIHVwCgB0aWxlcyByZXF1aXJlIGF0IGxlYXN0IG9uZSByZXNvbHV0aW9uCgBNYXJrZXIgaXMgbm90IGNvbXBsaWFudCB3aXRoIGl0cyBwb3NpdGlvbgoAUHJvYmxlbSB3aXRoIHNlZWsgZnVuY3Rpb24KAEVycm9yIHJlYWRpbmcgU1BDb2QgU1BDb2MgZWxlbWVudCwgSW52YWxpZCBjYmxrdy9jYmxraCBjb21iaW5hdGlvbgoASW52YWxpZCBtdWx0aXBsZSBjb21wb25lbnQgdHJhbnNmb3JtYXRpb24KAENhbm5vdCB0YWtlIGluIGNoYXJnZSBjb2xsZWN0aW9ucyBvdGhlciB0aGFuIGFycmF5IGRlY29ycmVsYXRpb24KAFRvbyBsYXJnZSB2YWx1ZSBmb3IgTnBwbQoATm90IGVub3VnaCBieXRlcyB0byByZWFkIE5wcG0KAGJhZCBwbGFjZWQganBlZyBjb2Rlc3RyZWFtCgAJIE1haW4gaGVhZGVyIHN0YXJ0IHBvc2l0aW9uPSVsbGkKCSBNYWluIGhlYWRlciBlbmQgcG9zaXRpb249JWxsaQoATWFya2VyIHNpemUgaW5jb25zaXN0ZW50IHdpdGggc3RyZWFtIGxlbmd0aAoAVGlsZSBwYXJ0IGxlbmd0aCBzaXplIGluY29uc2lzdGVudCB3aXRoIHN0cmVhbSBsZW5ndGgKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBtdWx0aXBsZSBkYXRhIHNwYW5uaW5nCgBXcm9uZyBmbGFnCgBFcnJvciB3aXRoIEZUWVAgc2lnbmF0dXJlIEJveCBzaXplCgBFcnJvciB3aXRoIEpQIHNpZ25hdHVyZSBCb3ggc2l6ZQoASW52YWxpZCBwcmVjaW5jdCBzaXplCgBJbmNvbnNpc3RlbnQgbWFya2VyIHNpemUKAEludmFsaWQgbWFya2VyIHNpemUKAEVycm9yIHdpdGggU0laIG1hcmtlciBzaXplCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBhZGQgYSBuZXcgdmFsaWRhdGlvbiBwcm9jZWR1cmUKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGRlY29kZSB0aWxlCgBGYWlsZWQgdG8gZGVjb2RlIHRoZSBjb2Rlc3RyZWFtIGluIHRoZSBKUDIgZmlsZQoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIGNvbGxlY3Rpb25zIHdpdGggaW5kaXggc2h1ZmZsZQoAQ2Fubm90IGFsbG9jYXRlIFRpZXIgMSBoYW5kbGUKAE5vIGRlY29kZWQgYXJlYSBwYXJhbWV0ZXJzLCBzZXQgdGhlIGRlY29kZWQgYXJlYSB0byB0aGUgd2hvbGUgaW1hZ2UKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGNyZWF0ZSBUYWctdHJlZQoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVpbml0aWFsaXplIHRoZSB0YWcgdHJlZQoARXJyb3IgcmVhZGluZyBTUENvZCBTUENvYyBlbGVtZW50LCBJbnZhbGlkIHRyYW5zZm9ybWF0aW9uIGZvdW5kCgBFcnJvciByZWFkaW5nIFNQQ29kIFNQQ29jIGVsZW1lbnQuIFVuc3VwcG9ydGVkIE1peGVkIEhUIGNvZGUtYmxvY2sgc3R5bGUgZm91bmQKAFRpbGUgWSBjb29yZGluYXRlcyBhcmUgbm90IHN1cHBvcnRlZAoAVGlsZSBYIGNvb3JkaW5hdGVzIGFyZSBub3Qgc3VwcG9ydGVkCgBJbWFnZSBjb29yZGluYXRlcyBhYm92ZSBJTlRfTUFYIGFyZSBub3Qgc3VwcG9ydGVkCgBKUEVHMjAwMCBIZWFkZXIgYm94IG5vdCByZWFkIHlldCwgJyVjJWMlYyVjJyBib3ggd2lsbCBiZSBpZ25vcmVkCgBvcGpfajJrX21lcmdlX3BwdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIFNPVCBtYXJrZXIuIFRpbGUgaW5kZXggYWxsb2NhdGlvbiBmYWlsZWQKAElnbm9yaW5nIGloZHIgYm94LiBGaXJzdCBpaGRyIGJveCBhbHJlYWR5IHJlYWQKAFpwcHQgJXUgYWxyZWFkeSByZWFkCgBacHBtICV1IGFscmVhZHkgcmVhZAoAUFRFUk0gY2hlY2sgZmFpbHVyZTogJWQgc3ludGhldGl6ZWQgMHhGRiBtYXJrZXJzIHJlYWQKAAkJCSBjYmxrdz0yXiVkCgAJCQkgY2Jsa2g9Ml4lZAoACQkJIHFudHN0eT0lZAoAJXMgZHg9JWQsIGR5PSVkCgAJCQkgcm9pc2hpZnQ9JWQKAAkJCSBudW1nYml0cz0lZAoACQkgbnVtbGF5ZXJzPSVkCgAlcyBudW1jb21wcz0lZAoAb3BqX2pwMl9hcHBseV9jZGVmOiBhY249JWQsIG51bWNvbXBzPSVkCgBvcGpfanAyX2FwcGx5X2NkZWY6IGNuPSVkLCBudW1jb21wcz0lZAoACQkJIG51bXJlc29sdXRpb25zPSVkCgAJCSB0eXBlPSUjeCwgcG9zPSVsbGksIGxlbj0lZAoAJXMgc2duZD0lZAoACQkJIHFtZmJpZD0lZAoAJXMgcHJlYz0lZAoACQkgbmIgb2YgdGlsZS1wYXJ0IGluIHRpbGUgWyVkXT0lZAoAJXMgeDE9JWQsIHkxPSVkCgAlcyB4MD0lZCwgeTA9JWQKAEZhaWxlZCB0byBkZWNvZGUgdGlsZSAlZC8lZAoAU2V0dGluZyBkZWNvZGluZyBhcmVhIHRvICVkLCVkLCVkLCVkCgBGYWlsZWQgdG8gZGVjb2RlIGNvbXBvbmVudCAlZAoASW52YWxpZCB2YWx1ZSBmb3IgbnVtcmVzb2x1dGlvbnMgOiAlZCwgbWF4IHZhbHVlIGlzIHNldCBpbiBvcGVuanBlZy5oIGF0ICVkCgBJbnZhbGlkIGNvbXBvbmVudCBudW1iZXI6ICVkLCByZWdhcmRpbmcgdGhlIG51bWJlciBvZiBjb21wb25lbnRzICVkCgBUb28gbWFueSBQT0NzICVkCgBJbnZhbGlkIHRpbGUgbnVtYmVyICVkCgBJbnZhbGlkIHRpbGUgcGFydCBpbmRleCBmb3IgdGlsZSBudW1iZXIgJWQuIEdvdCAlZCwgZXhwZWN0ZWQgJWQKAEVycm9yIHdpdGggU0laIG1hcmtlcjogbnVtYmVyIG9mIGNvbXBvbmVudCBpcyBpbGxlZ2FsIC0+ICVkCgBOb3QgZW5vdWdoIG1lbW9yeSBmb3IgY2llbGFiCgBDYW5ub3QgYWxsb2NhdGUgY2Jsay0+ZGVjb2RlZF9kYXRhCgBGYWlsZWQgdG8gbWVyZ2UgUFBUIGRhdGEKAEZhaWxlZCB0byBtZXJnZSBQUE0gZGF0YQoASW52YWxpZCBudW1iZXIgb2YgbGF5ZXJzIGluIENPRCBtYXJrZXIgOiAlZCBub3QgaW4gcmFuZ2UgWzEtNjU1MzVdCgBTdHJlYW0gdG9vIHNob3J0LCBleHBlY3RlZCBTT1QKAFVuYWJsZSB0byBzZXQgdDEgaGFuZGxlIGFzIFRMUwoAU3RyZWFtIGRvZXMgbm90IGVuZCB3aXRoIEVPQwoAQ2Fubm90IGhhbmRsZSBib3ggc2l6ZXMgaGlnaGVyIHRoYW4gMl4zMgoAb3BqX3BpX25leHRfbHJjcCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcmxjcCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfY3BybCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcGNybCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcnBjbCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3QxX2RlY29kZV9jYmxrKCk6IHVuc3VwcG9ydGVkIGJwbm9fcGx1c19vbmUgPSAlZCA+PSAzMQoARmFpbGVkIHRvIGRlY29kZSB0aWxlIDEvMQoASW5zdWZmaWNpZW50IGRhdGEgZm9yIENNQVAgYm94LgoATmVlZCB0byByZWFkIGEgUENMUiBib3ggYmVmb3JlIHRoZSBDTUFQIGJveC4KAEluc3VmZmljaWVudCBkYXRhIGZvciBDREVGIGJveC4KAE51bWJlciBvZiBjaGFubmVsIGRlc2NyaXB0aW9uIGlzIGVxdWFsIHRvIHplcm8gaW4gQ0RFRiBib3guCgBTdHJlYW0gZXJyb3Igd2hpbGUgcmVhZGluZyBKUDIgSGVhZGVyIGJveDogbm8gJ2loZHInIGJveC4KAE5vbiBjb25mb3JtYW50IGNvZGVzdHJlYW0gVFBzb3Q9PVROc290LgoAU3RyZWFtIGVycm9yIHdoaWxlIHJlYWRpbmcgSlAyIEhlYWRlciBib3g6IGJveCBsZW5ndGggaXMgaW5jb25zaXN0ZW50LgoAQm94IGxlbmd0aCBpcyBpbmNvbnNpc3RlbnQuCgBSZXNvbHV0aW9uIGZhY3RvciBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gcmVzb2x1dGlvbiBpbiB0aGUgY29tcG9uZW50LgoAQ29tcG9uZW50IG1hcHBpbmcgc2VlbXMgd3JvbmcuIFRyeWluZyB0byBjb3JyZWN0LgoASW5jb21wbGV0ZSBjaGFubmVsIGRlZmluaXRpb25zLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gSW52YWxpZCBjb2RlYmxvY2sgbGVuZ3RoIHZhbHVlcy4KAFdlIGRvIG5vdCBzdXBwb3J0IG1vcmUgdGhhbiAzIGNvZGluZyBwYXNzZXMgaW4gYW4gSFQgY29kZWJsb2NrOyBUaGlzIGNvZGVibG9ja3MgaGFzICVkIHBhc3Nlcy4KAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIERlY29kaW5nIHRoaXMgY29kZWJsb2NrIGlzIHN0b3BwZWQuIFRoZXJlIGFyZSAlZCB6ZXJvIGJpdHBsYW5lcyBpbiAlZCBiaXRwbGFuZXMuCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgbXVsdGlwbGUgdHJhbnNmb3JtYXRpb24gc3RhZ2VzLgoAVW5rbm93biBtYXJrZXIgaGFzIGJlZW4gZGV0ZWN0ZWQgYW5kIGdlbmVyYXRlZCBlcnJvci4KAENvZGVjIHByb3ZpZGVkIHRvIHRoZSBvcGpfc2V0X2RlY29kZWRfY29tcG9uZW50cyBmdW5jdGlvbiBpcyBub3QgYSBkZWNvbXByZXNzb3IgaGFuZGxlci4KAENvZGVjIHByb3ZpZGVkIHRvIHRoZSBvcGpfc2V0dXBfZGVjb2RlciBmdW5jdGlvbiBpcyBub3QgYSBkZWNvbXByZXNzb3IgaGFuZGxlci4KAENvZGVjIHByb3ZpZGVkIHRvIHRoZSBvcGpfcmVhZF9oZWFkZXIgZnVuY3Rpb24gaXMgbm90IGEgZGVjb21wcmVzc29yIGhhbmRsZXIuCgBUaWxlcyBkb24ndCBhbGwgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb24uIFNraXAgdGhlIE1DVCBzdGVwLgoATnVtYmVyIG9mIGNvbXBvbmVudHMgKCVkKSBpcyBpbmNvbnNpc3RlbnQgd2l0aCBhIE1DVC4gU2tpcCB0aGUgTUNUIHN0ZXAuCgBKUDIgYm94IHdoaWNoIGFyZSBhZnRlciB0aGUgY29kZXN0cmVhbSB3aWxsIG5vdCBiZSByZWFkIGJ5IHRoaXMgZnVuY3Rpb24uCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBXaGVuIHRoZSBudW1iZXIgb2YgemVybyBwbGFuZXMgYml0cGxhbmVzIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgYml0cGxhbmVzLCBvbmx5IHRoZSBjbGVhbnVwIHBhc3MgbWFrZXMgc2Vuc2UsIGJ1dCB3ZSBoYXZlICVkIHBhc3NlcyBpbiB0aGlzIGNvZGVibG9jay4gVGhlcmVmb3JlLCBvbmx5IHRoZSBjbGVhbnVwIHBhc3Mgd2lsbCBiZSBkZWNvZGVkLiBUaGlzIG1lc3NhZ2Ugd2lsbCBub3QgYmUgZGlzcGxheWVkIGFnYWluLgoASW1hZ2UgaGFzIGxlc3MgY29tcG9uZW50cyB0aGFuIGNvZGVzdHJlYW0uCgBOZWVkIHRvIGRlY29kZSB0aGUgbWFpbiBoZWFkZXIgYmVmb3JlIGJlZ2luIHRvIGRlY29kZSB0aGUgcmVtYWluaW5nIGNvZGVzdHJlYW0uCgBQc290IHZhbHVlIG9mIHRoZSBjdXJyZW50IHRpbGUtcGFydCBpcyBlcXVhbCB0byB6ZXJvLCB3ZSBhc3N1bWluZyBpdCBpcyB0aGUgbGFzdCB0aWxlLXBhcnQgb2YgdGhlIGNvZGVzdHJlYW0uCgBBIG1hbGZvcm1lZCBjb2RlYmxvY2sgdGhhdCBoYXMgbW9yZSB0aGFuIG9uZSBjb2RpbmcgcGFzcywgYnV0IHplcm8gbGVuZ3RoIGZvciAybmQgYW5kIHBvdGVudGlhbGx5IHRoZSAzcmQgcGFzcyBpbiBhbiBIVCBjb2RlYmxvY2suCgAJCQkgdGlsZS1wYXJ0WyVkXTogc3Rhcl9wb3M9JWxsaSwgZW5kX2hlYWRlcj0lbGxpLCBlbmRfcG9zPSVsbGkuCgBUaWxlICV1IGhhcyBUUHNvdCA9PSAwIGFuZCBUTnNvdCA9PSAwLCBidXQgbm8gb3RoZXIgdGlsZS1wYXJ0cyB3ZXJlIGZvdW5kLiBFT0MgaXMgYWxzbyBtaXNzaW5nLgoAQ29tcG9uZW50ICVkIGRvZXNuJ3QgaGF2ZSBhIG1hcHBpbmcuCgBBIGNvbmZvcm1pbmcgSlAyIHJlYWRlciBzaGFsbCBpZ25vcmUgYWxsIENvbG91ciBTcGVjaWZpY2F0aW9uIGJveGVzIGFmdGVyIHRoZSBmaXJzdCwgc28gd2UgaWdub3JlIHRoaXMgb25lLgoAVGhlIHNpZ25hdHVyZSBib3ggbXVzdCBiZSB0aGUgZmlyc3QgYm94IGluIHRoZSBmaWxlLgoAVGhlICBib3ggbXVzdCBiZSB0aGUgZmlyc3QgYm94IGluIHRoZSBmaWxlLgoAVGhlIGZ0eXAgYm94IG11c3QgYmUgdGhlIHNlY29uZCBib3ggaW4gdGhlIGZpbGUuCgBGYWlsZWQgdG8gZGVjb2RlLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gSW5jb3JyZWN0IE1FTCBzZWdtZW50IHNlcXVlbmNlLgoAQ29tcG9uZW50ICVkIGlzIG1hcHBlZCB0d2ljZS4KAE9ubHkgb25lIENNQVAgYm94IGlzIGFsbG93ZWQuCgBhcHBseV9jb2xvcl90cmFuc2Zvcm1zID0gT1BKX1RSVUUgaXMgbm90IHN1cHBvcnRlZC4KAFdlIG5lZWQgYW4gaW1hZ2UgcHJldmlvdXNseSBjcmVhdGVkLgoASUhEUiBib3hfbWlzc2luZy4gUmVxdWlyZWQuCgBKUDJIIGJveCBtaXNzaW5nLiBSZXF1aXJlZC4KAE5vdCBzdXJlIGhvdyB0aGF0IGhhcHBlbmVkLgoATWFpbiBoZWFkZXIgaGFzIGJlZW4gY29ycmVjdGx5IGRlY29kZWQuCgBUaWxlICVkLyVkIGhhcyBiZWVuIGRlY29kZWQuCgBIZWFkZXIgb2YgdGlsZSAlZCAvICVkIGhhcyBiZWVuIHJlYWQuCgBFbXB0eSBTT1QgbWFya2VyIGRldGVjdGVkOiBQc290PSVkLgoARGlyZWN0IHVzZSBhdCAjJWQgaG93ZXZlciBwY29sPSVkLgoASW1wbGVtZW50YXRpb24gbGltaXRhdGlvbjogZm9yIHBhbGV0dGUgbWFwcGluZywgcGNvbFslZF0gc2hvdWxkIGJlIGVxdWFsIHRvICVkLCBidXQgaXMgZXF1YWwgdG8gJWQuCgBJbnZhbGlkIGNvbXBvbmVudC9wYWxldHRlIGluZGV4IGZvciBkaXJlY3QgbWFwcGluZyAlZC4KAEludmFsaWQgdmFsdWUgZm9yIGNtYXBbJWRdLm10eXAgPSAlZC4KAFBzb3QgdmFsdWUgaXMgbm90IGNvcnJlY3QgcmVnYXJkcyB0byB0aGUgSlBFRzIwMDAgbm9ybTogJWQuCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBWTEMgY29kZSBwcm9kdWNlcyBzaWduaWZpY2FudCBzYW1wbGVzIG91dHNpZGUgdGhlIGNvZGVibG9jayBhcmVhLgoAVW5leHBlY3RlZCBPT00uCgAzMiBiaXRzIGFyZSBub3QgZW5vdWdoIHRvIGRlY29kZSB0aGlzIGNvZGVibG9jaywgc2luY2UgdGhlIG51bWJlciBvZiBiaXRwbGFuZSwgJWQsIGlzIGxhcmdlciB0aGFuIDMwLgoAQm90dG9tIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MT0lZCkgc2hvdWxkIGJlID4gMC4KAFJpZ2h0IHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl94MT0lZCkgc2hvdWxkIGJlID4gMC4KAFVwIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MD0lZCkgc2hvdWxkIGJlID49IDAuCgBMZWZ0IHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl94MD0lZCkgc2hvdWxkIGJlID49IDAuCgBFcnJvciByZWFkaW5nIFBQVCBtYXJrZXI6IHBhY2tldCBoZWFkZXIgaGF2ZSBiZWVuIHByZXZpb3VzbHkgZm91bmQgaW4gdGhlIG1haW4gaGVhZGVyIChQUE0gbWFya2VyKS4KAFN0YXJ0IHRvIHJlYWQgajJrIG1haW4gaGVhZGVyICglbGxkKS4KAEJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTE9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFlzaXo9JWQpLgoAVXAgcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kwPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZc2l6PSVkKS4KAFJpZ2h0IHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl94MT0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWHNpej0lZCkuCgBMZWZ0IHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl94MD0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWHNpej0lZCkuCgBCb3R0b20gcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kxPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZT3Npej0lZCkuCgBVcCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTA9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFlPc2l6PSVkKS4KAFJpZ2h0IHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl94MT0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWE9zaXo9JWQpLgoATGVmdCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDA9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhPc2l6PSVkKS4KAFNpemUgeCBvZiB0aGUgZGVjb2RlZCBjb21wb25lbnQgaW1hZ2UgaXMgaW5jb3JyZWN0IChjb21wWyVkXS53PSVkKS4KAFNpemUgeSBvZiB0aGUgZGVjb2RlZCBjb21wb25lbnQgaW1hZ2UgaXMgaW5jb3JyZWN0IChjb21wWyVkXS5oPSVkKS4KAFRpbGUgcmVhZCwgZGVjb2RlZCBhbmQgdXBkYXRlZCBpcyBub3QgdGhlIGRlc2lyZWQgb25lICglZCB2cyAlZCkuCgBJbnZhbGlkIGNvbXBvbmVudCBpbmRleCAlZCAoPj0gJWQpLgoAb3BqX3JlYWRfaGVhZGVyKCkgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgb3BqX3NldF9kZWNvZGVkX2NvbXBvbmVudHMoKS4KAE1lbW9yeSBhbGxvY2F0aW9uIGZhaWx1cmUgaW4gb3BqX2pwMl9hcHBseV9wY2xyKCkuCgBpbWFnZS0+Y29tcHNbJWRdLmRhdGEgPT0gTlVMTCBpbiBvcGpfanAyX2FwcGx5X3BjbHIoKS4KAGludmFsaWQgYm94IHNpemUgJWQgKCV4KQoARmFpbCB0byByZWFkIHRoZSBjdXJyZW50IG1hcmtlciBzZWdtZW50ICglI3gpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IElIRFIgdygldSkgaCgldSkgdnMuIFNJWiB3KCV1KSBoKCV1KQoARXJyb3IgcmVhZGluZyBDT0MgbWFya2VyIChiYWQgbnVtYmVyIG9mIGNvbXBvbmVudHMpCgBJbnZhbGlkIG51bWJlciBvZiB0aWxlcyA6ICV1IHggJXUgKG1heGltdW0gZml4ZWQgYnkganBlZzIwMDAgbm9ybSBpcyA2NTUzNSB0aWxlcykKAEludmFsaWQgbnVtYmVyIG9mIGNvbXBvbmVudHMgKGloZHIpCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBoYW5kbGUgaW1hZ2UgaGVhZGVyIChpaGRyKQoAV3JvbmcgdmFsdWVzIGZvcjogdyglZCkgaCglZCkgbnVtY29tcHMoJWQpIChpaGRyKQoASW52YWxpZCB2YWx1ZXMgZm9yIGNvbXAgPSAlZCA6IGR4PSV1IGR5PSV1IChzaG91bGQgYmUgYmV0d2VlbiAxIGFuZCAyNTUgYWNjb3JkaW5nIHRvIHRoZSBKUEVHMjAwMCBub3JtKQoAQmFkIGltYWdlIGhlYWRlciBib3ggKGJhZCBzaXplKQoAQmFkIENPTFIgaGVhZGVyIGJveCAoYmFkIHNpemUpCgBCYWQgQlBDQyBoZWFkZXIgYm94IChiYWQgc2l6ZSkKAEVycm9yIHdpdGggU0laIG1hcmtlcjogbmVnYXRpdmUgb3IgemVybyBpbWFnZSBzaXplICglbGxkIHggJWxsZCkKAHNraXA6IHNlZ21lbnQgdG9vIGxvbmcgKCVkKSB3aXRoIG1heCAoJWQpIGZvciBjb2RlYmxvY2sgJWQgKHA9JWQsIGI9JWQsIHI9JWQsIGM9JWQpCgByZWFkOiBzZWdtZW50IHRvbyBsb25nICglZCkgd2l0aCBtYXggKCVkKSBmb3IgY29kZWJsb2NrICVkIChwPSVkLCBiPSVkLCByPSVkLCBjPSVkKQoARGVzcGl0ZSBKUDIgQlBDIT0yNTUsIHByZWNpc2lvbiBhbmQvb3Igc2duZCB2YWx1ZXMgZm9yIGNvbXBbJWRdIGlzIGRpZmZlcmVudCB0aGFuIGNvbXBbMF06CiAgICAgICAgWzBdIHByZWMoJWQpIHNnbmQoJWQpIFslZF0gcHJlYyglZCkgc2duZCglZCkKAGJhZCBjb21wb25lbnQgbnVtYmVyIGluIFJHTiAoJWQgd2hlbiB0aGVyZSBhcmUgb25seSAlZCkKAEVycm9yIHdpdGggU0laIG1hcmtlcjogbnVtYmVyIG9mIGNvbXBvbmVudCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSByZW1haW5pbmcgbnVtYmVyIG9mIHBhcmFtZXRlcnMgKCAlZCB2cyAlZCkKAEVycm9yIHdpdGggU0laIG1hcmtlcjogaW52YWxpZCB0aWxlIHNpemUgKHRkeDogJWQsIHRkeTogJWQpCgBCYWQgQ09MUiBoZWFkZXIgYm94IChiYWQgc2l6ZTogJWQpCgBCYWQgQ09MUiBoZWFkZXIgYm94IChDSUVMYWIsIGJhZCBzaXplOiAlZCkKAFBURVJNIGNoZWNrIGZhaWx1cmU6ICVkIHJlbWFpbmluZyBieXRlcyBpbiBjb2RlIGJsb2NrICglZCB1c2VkIC8gJWQpCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBPbmUgb2YgdGhlIGZvbGxvd2luZyBjb25kaXRpb24gaXMgbm90IG1ldDogMiA8PSBTY3VwIDw9IG1pbihMY3VwLCA0MDc5KQoASW52YWxpZCB2YWx1ZXMgZm9yIGNvbXAgPSAlZCA6IHByZWM9JXUgKHNob3VsZCBiZSBiZXR3ZWVuIDEgYW5kIDM4IGFjY29yZGluZyB0byB0aGUgSlBFRzIwMDAgbm9ybS4gT3BlbkpwZWcgb25seSBzdXBwb3J0cyB1cCB0byAzMSkKAEludmFsaWQgYml0IG51bWJlciAlZCBpbiBvcGpfdDJfcmVhZF9wYWNrZXRfaGVhZGVyKCkKAFN0cmVhbSBlcnJvciEKAEVycm9yIG9uIHdyaXRpbmcgc3RyZWFtIQoAU3RyZWFtIHJlYWNoZWQgaXRzIGVuZCAhCgBFeHBlY3RlZCBhIFNPQyBtYXJrZXIgCgBJbnZhbGlkIGJveCBzaXplICVkIGZvciBib3ggJyVjJWMlYyVjJy4gTmVlZCAlZCBieXRlcywgJWQgYnl0ZXMgcmVtYWluaW5nIAoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gRGVjb2RpbmcgdGhpcyBjb2RlYmxvY2sgaXMgc3RvcHBlZC4gVV9xIGlzIGxhcmdlciB0aGFuIHplcm8gYml0cGxhbmVzICsgMSAKAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIERlY29kaW5nIHRoaXMgY29kZWJsb2NrIGlzIHN0b3BwZWQuIFVfcSBpc2xhcmdlciB0aGFuIGJpdHBsYW5lcyArIDEgCgBDT0xSIEJPWCBtZXRoIHZhbHVlIGlzIG5vdCBhIHJlZ3VsYXIgdmFsdWUgKCVkKSwgc28gd2Ugd2lsbCBpZ25vcmUgdGhlIGVudGlyZSBDb2xvdXIgU3BlY2lmaWNhdGlvbiBib3guIAoAV2hpbGUgcmVhZGluZyBDQ1BfUU5UU1RZIGVsZW1lbnQgaW5zaWRlIFFDRCBvciBRQ0MgbWFya2VyIHNlZ21lbnQsIG51bWJlciBvZiBzdWJiYW5kcyAoJWQpIGlzIGdyZWF0ZXIgdG8gT1BKX0oyS19NQVhCQU5EUyAoJWQpLiBTbyB3ZSBsaW1pdCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHN0b3JlZCB0byBPUEpfSjJLX01BWEJBTkRTICglZCkgYW5kIHNraXAgdGhlIHJlc3QuIAoASlAyIElIRFIgYm94OiBjb21wcmVzc2lvbiB0eXBlIGluZGljYXRlIHRoYXQgdGhlIGZpbGUgaXMgbm90IGEgY29uZm9ybWluZyBKUDIgZmlsZSAoJWQpIAoAVGlsZSBpbmRleCBwcm92aWRlZCBieSB0aGUgdXNlciBpcyBpbmNvcnJlY3QgJWQgKG1heCA9ICVkKSAKAEVycm9yIGRlY29kaW5nIGNvbXBvbmVudCAlZC4KVGhlIG51bWJlciBvZiByZXNvbHV0aW9ucyB0byByZW1vdmUgKCVkKSBpcyBncmVhdGVyIG9yIGVxdWFsIHRoYW4gdGhlIG51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4E8AANBPAAABVgAAAQAAAPBPAADATwAAAVQAAAAAAAAAUAAAwFAAAAFUAAABAAAAEFAAANBQAAABSAAAAAAAACBQAADAUAAAAUgAAAEAAAAwUAAA0FAAAAE4AAAAAAAAQFAAAMBQAAABOAAAAQAAAFBQAADQUAAAATAAAAAAAABgUAAAIFEAAAEwAAABAAAAcFAAADBRAAABJAAAAAAAAIBQAABAUQAAASQAAAEAAACQUAAAUFEAAAEcAAAAAAAAoFAAAIBRAAABHAAAAQAAALBQAACQUQAAARYAAAAAAACgUgAAoFEAAAEWAAABAAAAsFIAALBRAAABVgAAAAAAAOBQAADQUAAAAVYAAAEAAADwUAAAwFAAAAFUAAAAAAAAAFEAAMBQAAABVAAAAQAAABBRAADQUAAAAVEAAAAAAAAgUQAA4FAAAAFRAAABAAAAMFEAAPBQAAABSAAAAAAAAEBRAAAAUQAAAUgAAAEAAABQUQAAEFEAAAE4AAAAAAAAYFEAACBRAAABOAAAAQAAAHBRAAAwUQAAATQAAAAAAACAUQAAQFEAAAE0AAABAAAAkFEAAFBRAAABMAAAAAAAAKBRAABgUQAAATAAAAEAAACwUQAAcFEAAAEoAAAAAAAAwFEAAGBRAAABKAAAAQAAANBRAABwUQAAASQAAAAAAADgUQAAgFEAAAEkAAABAAAA8FEAAJBRAAABIgAAAAAAAABSAACgUQAAASIAAAEAAAAQUgAAsFEAAAEcAAAAAAAAIFIAAMBRAAABHAAAAQAAADBSAADQUQAAARgAAAAAAABAUgAA4FEAAAEYAAABAAAAUFIAAPBRAAABFgAAAAAAAGBSAAAAUgAAARYAAAEAAABwUgAAEFIAAAEUAAAAAAAAgFIAACBSAAABFAAAAQAAAJBSAAAwUgAAARIAAAAAAACgUgAAQFIAAAESAAABAAAAsFIAAFBSAAABEQAAAAAAAMBSAABgUgAAAREAAAEAAADQUgAAcFIAAMEKAAAAAAAA4FIAAIBSAADBCgAAAQAAAPBSAACQUgAAwQkAAAAAAAAAUwAAoFIAAMEJAAABAAAAEFMAALBSAAChCAAAAAAAACBTAADAUgAAoQgAAAEAAAAwUwAA0FIAACEFAAAAAAAAQFMAAOBSAAAhBQAAAQAAAFBTAADwUgAAQQQAAAAAAABgUwAAAFMAAEEEAAABAAAAcFMAABBTAAChAgAAAAAAAIBTAAAgUwAAoQIAAAEAAACQUwAAMFMAACECAAAAAAAAoFMAAEBTAAAhAgAAAQAAALBTAABQUwAAQQEAAAAAAADAUwAAYFMAAEEBAAABAAAA0FMAAHBTAAARAQAAAAAAAOBTAACAUwAAEQEAAAEAAADwUwAAkFMAAIUAAAAAAAAAAFQAAKBTAACFAAAAAQAAABBUAACwUwAASQAAAAAAAAAgVAAAwFMAAEkAAAABAAAAMFQAANBTAAAlAAAAAAAAAEBUAADgUwAAJQAAAAEAAABQVAAA8FMAABUAAAAAAAAAYFQAAABUAAAVAAAAAQAAAHBUAAAQVAAACQAAAAAAAACAVAAAIFQAAAkAAAABAAAAkFQAADBUAAAFAAAAAAAAAKBUAABAVAAABQAAAAEAAACwVAAAUFQAAAEAAAAAAAAAoFQAAGBUAAABAAAAAQAAALBUAABwVAAAAVYAAAAAAADAVAAAwFQAAAFWAAABAAAA0FQAANBUAAAAAQMDAQIDAwUGBwcGBgcHAAEDAwECAwMFBgcHBgYHBwUGBwcGBgcHCAgICAgICAgFBgcHBgYHBwgICAgICAgIAQIDAwICAwMGBgcHBgYHBwECAwMCAgMDBgYHBwYGBwcGBgcHBgYHBwgICAgICAgIBgYHBwYGBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAQIDAwICAwMGBgcHBgYHBwECAwMCAgMDBgYHBwYGBwcGBgcHBgYHBwgICAgICAgIBgYHBwYGBwcICAgICAgICAICAwMCAgMDBgYHBwYGBwcCAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAABBQYBAgYGAwMHBwMDBwcAAQUGAQIGBgMDBwcDAwcHAwMHBwMDBwcEBAcHBAQHBwMDBwcDAwcHBAQHBwQEBwcBAgYGAgIGBgMDBwcDAwcHAQIGBgICBgYDAwcHAwMHBwMDBwcDAwcHBAQHBwQEBwcDAwcHAwMHBwQEBwcEBAcHBQYICAYGCAgHBwgIBwcICAUGCAgGBggIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAYGCAgGBggIBwcICAcHCAgGBggIBgYICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgBAgYGAgIGBgMDBwcDAwcHAQIGBgICBgYDAwcHAwMHBwMDBwcDAwcHBAQHBwQEBwcDAwcHAwMHBwQEBwcEBAcHAgIGBgICBgYDAwcHAwMHBwICBgYCAgYGAwMHBwMDBwcDAwcHAwMHBwQEBwcEBAcHAwMHBwMDBwcEBAcHBAQHBwYGCAgGBggIBwcICAcHCAgGBggIBgYICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgGBggIBgYICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIAAEDAwECAwMFBgcHBgYHBwABAwMBAgMDBQYHBwYGBwcFBgcHBgYHBwgICAgICAgIBQYHBwYGBwcICAgICAgICAECAwMCAgMDBgYHBwYGBwcBAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAECAwMCAgMDBgYHBwYGBwcBAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgCAgMDAgIDAwYGBwcGBgcHAgIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgAAwEEAwYEBwEEAgUEBwUHAAMBBAMGBAcBBAIFBAcFBwEEAgUEBwUHAgUCBQUHBQcBBAIFBAcFBwIFAgUFBwUHAwYEBwYIBwgEBwUHBwgHCAMGBAcGCAcIBAcFBwcIBwgEBwUHBwgHCAUHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAEEAgUEBwUHAgUCBQUHBQcBBAIFBAcFBwIFAgUFBwUHAgUCBQUHBQcCBQIFBQcFBwIFAgUFBwUHAgUCBQUHBQcEBwUHBwgHCAUHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIAwYEBwYIBwgEBwUHBwgHCAMGBAcGCAcIBAcFBwcIBwgEBwUHBwgHCAUHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAYIBwgICAgIBwgHCAgICAgGCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgEBwUHBwgHCAUHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAkJCgoJCQoKDAwNCwwMDQsJCQoKCQkKCgwMCw0MDAsNDAwNDQwMCwsMCQ0KCQwKCwwMCwsMDA0NDAkLCgkMCg0JCQoKCQkKCgwMDQsMDA0LCQkKCgkJCgoMDAsNDAwLDQwMDQ0MDAsLDAkNCgkMCgsMDAsLDAwNDQwJCwoJDAoNCgoKCgoKCgoNCw0LDQsNCwoKCQkKCgkJDQsMDA0LDAwNDQ0NCwsLCw0KDQoKCwoLDQ0MDAsLDAwNCgwJCgsJDAoKCQkKCgkJCw0MDAsNDAwKCgoKCgoKCgsNCw0LDQsNCwsMDA0NDAwLCgwJCg0JDAsLCwsNDQ0NCwoLCgoNCg0AQem7AQs3AQABAAEAAQAAAQEAAAEBAAEAAQABAAEAAAAAAQEBAQAAAAAAAQABAAAAAAEBAQEAAAABAAEBAQBBqbwBCzcBAAEAAQABAAABAQAAAQEAAQABAAEAAQAAAAABAQEBAAAAAAABAAEAAAAAAQEBAQAAAAEAAQEBAEHpvAELBwEAAQABAAEAQfm8AQuVAgEAAQABAAEAAAAAAQEBAQAAAAAAAQABAAAAAAEBAQEAAAAAAAEAAQEBAAABAQAAAAEAAQABAAEBAQEBAQEBAQABAAEAAQABAAAAAAEBAQEAAQAAAQEAAQAAAAABAQEBAAEAAQEBAQECAAAABAAAAAQAAAAIAAAAkP8AAAwAAAAYAAAAUv8AABQAAAAZAAAAU/8AABQAAAAaAAAAXv8AABQAAAAbAAAAXP8AABQAAAAcAAAAXf8AABQAAAAdAAAAX/8AABQAAAAeAAAAUf8AAAIAAAAfAAAAVf8AAAQAAAAgAAAAV/8AAAQAAAAhAAAAWP8AABAAAAAiAAAAYP8AAAQAAAAjAAAAYf8AABAAAAAkAAAAkf8AQZi/AQtlY/8AAAQAAAAlAAAAZP8AABQAAAAmAAAAdP8AABQAAAAnAAAAeP8AAAQAAAAoAAAAUP8AAAQAAAApAAAAWf8AAAQAAAAqAAAAdf8AABQAAAArAAAAd/8AABQAAAAsAAAAAAAAABQAQZDAAQs1LQAAAC4AAAAvAAAAMAAAADEAAAAyAAAAMwAAADQAAAAgIFBqNgAAAHB5dGY3AAAAaDJwajgAQdDAAQsycmRoaTkAAABybG9jOgAAAGNjcGI7AAAAcmxjcDwAAABwYW1jPQAAAGZlZGM+AAAAeGIAQZDBAQtBGQALABkZGQAAAAAFAAAAAAAACQAAAAALAAAAAAAAAAAZAAoKGRkZAwoHAAEACQsYAAAJBgsAAAsABhkAAAAZGRkAQeHBAQshDgAAAAAAAAAAGQALDRkZGQANAAACAAkOAAAACQAOAAAOAEGbwgELAQwAQafCAQsVEwAAAAATAAAAAAkMAAAAAAAMAAAMAEHVwgELARAAQeHCAQsVDwAAAAQPAAAAAAkQAAAAAAAQAAAQAEGPwwELARIAQZvDAQseEQAAAAARAAAAAAkSAAAAAAASAAASAAAaAAAAGhoaAEHSwwELDhoAAAAaGhoAAAAAAAAJAEGDxAELARQAQY/EAQsVFwAAAAAXAAAAAAkUAAAAAAAUAAAUAEG9xAELARYAQcnEAQsnFQAAAAAVAAAAAAkWAAAAAAAWAAAWAAAwMTIzNDU2Nzg5QUJDREVGAEHxxAELCGwBAAAAAAAFAEGExQELAWkAQZzFAQsOagAAAGsAAAD4ZwAAAAQAQbTFAQsBAQBBxMUBCwX/////Cg==\";\n    function getBinarySync(file) {\n      if (file == wasmBinaryFile && wasmBinary) {\n        return new Uint8Array(wasmBinary);\n      }\n      var binary = tryParseAsDataURI(file);\n      if (binary) {\n        return binary;\n      }\n      if (readBinary) {\n        return readBinary(file);\n      }\n      throw 'sync fetching of the wasm failed: you can preload it to Module[\"wasmBinary\"] manually, or emcc.py will do that for you when generating HTML (but not JS)';\n    }\n    function instantiateSync(file, info) {\n      var module;\n      var binary = getBinarySync(file);\n      module = new WebAssembly.Module(binary);\n      var instance = new WebAssembly.Instance(module, info);\n      return [instance, module];\n    }\n    function createWasm() {\n      var info = {\n        \"a\": wasmImports\n      };\n      function receiveInstance(instance, module) {\n        wasmExports = instance.exports;\n        wasmMemory = wasmExports[\"i\"];\n        updateMemoryViews();\n        addOnInit(wasmExports[\"j\"]);\n        removeRunDependency(\"wasm-instantiate\");\n        return wasmExports;\n      }\n      addRunDependency(\"wasm-instantiate\");\n      if (Module[\"instantiateWasm\"]) {\n        try {\n          return Module[\"instantiateWasm\"](info, receiveInstance);\n        } catch (e) {\n          err(`Module.instantiateWasm callback failed with error: ${e}`);\n          readyPromiseReject(e);\n        }\n      }\n      var result = instantiateSync(wasmBinaryFile, info);\n      return receiveInstance(result[0]);\n    }\n    var callRuntimeCallbacks = callbacks => {\n      while (callbacks.length > 0) {\n        callbacks.shift()(Module);\n      }\n    };\n    var noExitRuntime = Module[\"noExitRuntime\"] || true;\n    var __emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);\n    var getHeapMax = () => 2147483648;\n    var growMemory = size => {\n      var b = wasmMemory.buffer;\n      var pages = (size - b.byteLength + 65535) / 65536;\n      try {\n        wasmMemory.grow(pages);\n        updateMemoryViews();\n        return 1;\n      } catch (e) {}\n    };\n    var _emscripten_resize_heap = requestedSize => {\n      var oldSize = HEAPU8.length;\n      requestedSize >>>= 0;\n      var maxHeapSize = getHeapMax();\n      if (requestedSize > maxHeapSize) {\n        return false;\n      }\n      var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n        var replacement = growMemory(newSize);\n        if (replacement) {\n          return true;\n        }\n      }\n      return false;\n    };\n    var ENV = {};\n    var getExecutableName = () => thisProgram || \"./this.program\";\n    var getEnvStrings = () => {\n      if (!getEnvStrings.strings) {\n        var lang = (typeof navigator == \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\";\n        var env = {\n          \"USER\": \"web_user\",\n          \"LOGNAME\": \"web_user\",\n          \"PATH\": \"/\",\n          \"PWD\": \"/\",\n          \"HOME\": \"/home/web_user\",\n          \"LANG\": lang,\n          \"_\": getExecutableName()\n        };\n        for (var x in ENV) {\n          if (ENV[x] === undefined) delete env[x];else env[x] = ENV[x];\n        }\n        var strings = [];\n        for (var x in env) {\n          strings.push(`${x}=${env[x]}`);\n        }\n        getEnvStrings.strings = strings;\n      }\n      return getEnvStrings.strings;\n    };\n    var stringToAscii = (str, buffer) => {\n      for (var i = 0; i < str.length; ++i) {\n        HEAP8[buffer++] = str.charCodeAt(i);\n      }\n      HEAP8[buffer] = 0;\n    };\n    var _environ_get = (__environ, environ_buf) => {\n      var bufSize = 0;\n      getEnvStrings().forEach((string, i) => {\n        var ptr = environ_buf + bufSize;\n        HEAPU32[__environ + i * 4 >> 2] = ptr;\n        stringToAscii(string, ptr);\n        bufSize += string.length + 1;\n      });\n      return 0;\n    };\n    var _environ_sizes_get = (penviron_count, penviron_buf_size) => {\n      var strings = getEnvStrings();\n      HEAPU32[penviron_count >> 2] = strings.length;\n      var bufSize = 0;\n      strings.forEach(string => bufSize += string.length + 1);\n      HEAPU32[penviron_buf_size >> 2] = bufSize;\n      return 0;\n    };\n    var printCharBuffers = [null, [], []];\n    var UTF8Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n    var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n      }\n      var str = \"\";\n      while (idx < endPtr) {\n        var u0 = heapOrArray[idx++];\n        if (!(u0 & 128)) {\n          str += String.fromCharCode(u0);\n          continue;\n        }\n        var u1 = heapOrArray[idx++] & 63;\n        if ((u0 & 224) == 192) {\n          str += String.fromCharCode((u0 & 31) << 6 | u1);\n          continue;\n        }\n        var u2 = heapOrArray[idx++] & 63;\n        if ((u0 & 240) == 224) {\n          u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n        } else {\n          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n        }\n        if (u0 < 65536) {\n          str += String.fromCharCode(u0);\n        } else {\n          var ch = u0 - 65536;\n          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n        }\n      }\n      return str;\n    };\n    var printChar = (stream, curr) => {\n      var buffer = printCharBuffers[stream];\n      if (curr === 0 || curr === 10) {\n        (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n        buffer.length = 0;\n      } else {\n        buffer.push(curr);\n      }\n    };\n    var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n    var _fd_write = (fd, iov, iovcnt, pnum) => {\n      var num = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[iov >> 2];\n        var len = HEAPU32[iov + 4 >> 2];\n        iov += 8;\n        for (var j = 0; j < len; j++) {\n          printChar(fd, HEAPU8[ptr + j]);\n        }\n        num += len;\n      }\n      HEAPU32[pnum >> 2] = num;\n      return 0;\n    };\n    function _jsPrintWarning(message_ptr) {\n      const message = UTF8ToString(message_ptr);\n      (Module.warn || console.warn)(`OpenJPEG: ${message}`);\n    }\n    function _setImageData(array_ptr, array_size) {\n      Module.imageData = new Uint8ClampedArray(Module.HEAPU8.subarray(array_ptr, array_ptr + array_size));\n    }\n    function _storeErrorMessage(message_ptr) {\n      const message = UTF8ToString(message_ptr);\n      if (!Module.errorMessages) {\n        Module.errorMessages = message;\n      } else {\n        Module.errorMessages += \"\\n\" + message;\n      }\n    }\n    var wasmImports = {\n      f: __emscripten_memcpy_js,\n      b: _emscripten_resize_heap,\n      c: _environ_get,\n      d: _environ_sizes_get,\n      e: _fd_write,\n      g: _jsPrintWarning,\n      h: _setImageData,\n      a: _storeErrorMessage\n    };\n    var wasmExports = createWasm();\n    var ___wasm_call_ctors = wasmExports[\"j\"];\n    var _malloc = Module[\"_malloc\"] = wasmExports[\"k\"];\n    var _free = Module[\"_free\"] = wasmExports[\"l\"];\n    var _jp2_decode = Module[\"_jp2_decode\"] = wasmExports[\"n\"];\n    var __emscripten_stack_restore = wasmExports[\"_emscripten_stack_restore\"];\n    var __emscripten_stack_alloc = wasmExports[\"_emscripten_stack_alloc\"];\n    var _emscripten_stack_get_current = wasmExports[\"emscripten_stack_get_current\"];\n    var calledRun;\n    dependenciesFulfilled = function runCaller() {\n      if (!calledRun) run();\n      if (!calledRun) dependenciesFulfilled = runCaller;\n    };\n    function run() {\n      if (runDependencies > 0) {\n        return;\n      }\n      preRun();\n      if (runDependencies > 0) {\n        return;\n      }\n      function doRun() {\n        if (calledRun) return;\n        calledRun = true;\n        Module[\"calledRun\"] = true;\n        if (ABORT) return;\n        initRuntime();\n        readyPromiseResolve(Module);\n        if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n        postRun();\n      }\n      if (Module[\"setStatus\"]) {\n        Module[\"setStatus\"](\"Running...\");\n        setTimeout(function () {\n          setTimeout(function () {\n            Module[\"setStatus\"](\"\");\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n    }\n    if (Module[\"preInit\"]) {\n      if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [Module[\"preInit\"]];\n      while (Module[\"preInit\"].length > 0) {\n        Module[\"preInit\"].pop()();\n      }\n    }\n    run();\n    return moduleArg;\n  };\n})();\n/* harmony default export */ const openjpeg = (OpenJPEG);\n;// CONCATENATED MODULE: ./src/core/jpx.js\n\n\n\nclass JpxError extends BaseException {\n  constructor(msg) {\n    super(msg, \"JpxError\");\n  }\n}\nclass JpxImage {\n  static #module = null;\n  static decode(data, ignoreColorSpace = false) {\n    this.#module ||= openjpeg({\n      warn: warn\n    });\n    const imageData = this.#module.decode(data, ignoreColorSpace);\n    if (typeof imageData === \"string\") {\n      throw new JpxError(imageData);\n    }\n    return imageData;\n  }\n  static cleanup() {\n    this.#module = null;\n  }\n  static parseImageProperties(stream) {\n    let newByte = stream.getByte();\n    while (newByte >= 0) {\n      const oldByte = newByte;\n      newByte = stream.getByte();\n      const code = oldByte << 8 | newByte;\n      if (code === 0xff51) {\n        stream.skip(4);\n        const Xsiz = stream.getInt32() >>> 0;\n        const Ysiz = stream.getInt32() >>> 0;\n        const XOsiz = stream.getInt32() >>> 0;\n        const YOsiz = stream.getInt32() >>> 0;\n        stream.skip(16);\n        const Csiz = stream.getUint16();\n        return {\n          width: Xsiz - XOsiz,\n          height: Ysiz - YOsiz,\n          bitsPerComponent: 8,\n          componentsCount: Csiz\n        };\n      }\n    }\n    throw new JpxError(\"No size marker found in JPX stream\");\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/jpx_stream.js\n\n\n\nclass JpxStream extends DecodeStream {\n  constructor(stream, maybeLength, params) {\n    super(maybeLength);\n    this.stream = stream;\n    this.dict = stream.dict;\n    this.maybeLength = maybeLength;\n    this.params = params;\n  }\n  get bytes() {\n    return shadow(this, \"bytes\", this.stream.getBytes(this.maybeLength));\n  }\n  ensureBuffer(requested) {}\n  readBlock(ignoreColorSpace) {\n    if (this.eof) {\n      return;\n    }\n    this.buffer = JpxImage.decode(this.bytes, ignoreColorSpace);\n    this.bufferLength = this.buffer.length;\n    this.eof = true;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/lzw_stream.js\n\nclass LZWStream extends DecodeStream {\n  constructor(str, maybeLength, earlyChange) {\n    super(maybeLength);\n    this.str = str;\n    this.dict = str.dict;\n    this.cachedData = 0;\n    this.bitsCached = 0;\n    const maxLzwDictionarySize = 4096;\n    const lzwState = {\n      earlyChange,\n      codeLength: 9,\n      nextCode: 258,\n      dictionaryValues: new Uint8Array(maxLzwDictionarySize),\n      dictionaryLengths: new Uint16Array(maxLzwDictionarySize),\n      dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),\n      currentSequence: new Uint8Array(maxLzwDictionarySize),\n      currentSequenceLength: 0\n    };\n    for (let i = 0; i < 256; ++i) {\n      lzwState.dictionaryValues[i] = i;\n      lzwState.dictionaryLengths[i] = 1;\n    }\n    this.lzwState = lzwState;\n  }\n  readBits(n) {\n    let bitsCached = this.bitsCached;\n    let cachedData = this.cachedData;\n    while (bitsCached < n) {\n      const c = this.str.getByte();\n      if (c === -1) {\n        this.eof = true;\n        return null;\n      }\n      cachedData = cachedData << 8 | c;\n      bitsCached += 8;\n    }\n    this.bitsCached = bitsCached -= n;\n    this.cachedData = cachedData;\n    this.lastCode = null;\n    return cachedData >>> bitsCached & (1 << n) - 1;\n  }\n  readBlock() {\n    const blockSize = 512,\n      decodedSizeDelta = blockSize;\n    let estimatedDecodedSize = blockSize * 2;\n    let i, j, q;\n    const lzwState = this.lzwState;\n    if (!lzwState) {\n      return;\n    }\n    const earlyChange = lzwState.earlyChange;\n    let nextCode = lzwState.nextCode;\n    const dictionaryValues = lzwState.dictionaryValues;\n    const dictionaryLengths = lzwState.dictionaryLengths;\n    const dictionaryPrevCodes = lzwState.dictionaryPrevCodes;\n    let codeLength = lzwState.codeLength;\n    let prevCode = lzwState.prevCode;\n    const currentSequence = lzwState.currentSequence;\n    let currentSequenceLength = lzwState.currentSequenceLength;\n    let decodedLength = 0;\n    let currentBufferLength = this.bufferLength;\n    let buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);\n    for (i = 0; i < blockSize; i++) {\n      const code = this.readBits(codeLength);\n      const hasPrev = currentSequenceLength > 0;\n      if (code < 256) {\n        currentSequence[0] = code;\n        currentSequenceLength = 1;\n      } else if (code >= 258) {\n        if (code < nextCode) {\n          currentSequenceLength = dictionaryLengths[code];\n          for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {\n            currentSequence[j] = dictionaryValues[q];\n            q = dictionaryPrevCodes[q];\n          }\n        } else {\n          currentSequence[currentSequenceLength++] = currentSequence[0];\n        }\n      } else if (code === 256) {\n        codeLength = 9;\n        nextCode = 258;\n        currentSequenceLength = 0;\n        continue;\n      } else {\n        this.eof = true;\n        delete this.lzwState;\n        break;\n      }\n      if (hasPrev) {\n        dictionaryPrevCodes[nextCode] = prevCode;\n        dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;\n        dictionaryValues[nextCode] = currentSequence[0];\n        nextCode++;\n        codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;\n      }\n      prevCode = code;\n      decodedLength += currentSequenceLength;\n      if (estimatedDecodedSize < decodedLength) {\n        do {\n          estimatedDecodedSize += decodedSizeDelta;\n        } while (estimatedDecodedSize < decodedLength);\n        buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);\n      }\n      for (j = 0; j < currentSequenceLength; j++) {\n        buffer[currentBufferLength++] = currentSequence[j];\n      }\n    }\n    lzwState.nextCode = nextCode;\n    lzwState.codeLength = codeLength;\n    lzwState.prevCode = prevCode;\n    lzwState.currentSequenceLength = currentSequenceLength;\n    this.bufferLength = currentBufferLength;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/predictor_stream.js\n\n\n\nclass PredictorStream extends DecodeStream {\n  constructor(str, maybeLength, params) {\n    super(maybeLength);\n    if (!(params instanceof Dict)) {\n      return str;\n    }\n    const predictor = this.predictor = params.get(\"Predictor\") || 1;\n    if (predictor <= 1) {\n      return str;\n    }\n    if (predictor !== 2 && (predictor < 10 || predictor > 15)) {\n      throw new FormatError(`Unsupported predictor: ${predictor}`);\n    }\n    this.readBlock = predictor === 2 ? this.readBlockTiff : this.readBlockPng;\n    this.str = str;\n    this.dict = str.dict;\n    const colors = this.colors = params.get(\"Colors\") || 1;\n    const bits = this.bits = params.get(\"BPC\", \"BitsPerComponent\") || 8;\n    const columns = this.columns = params.get(\"Columns\") || 1;\n    this.pixBytes = colors * bits + 7 >> 3;\n    this.rowBytes = columns * colors * bits + 7 >> 3;\n    return this;\n  }\n  readBlockTiff() {\n    const rowBytes = this.rowBytes;\n    const bufferLength = this.bufferLength;\n    const buffer = this.ensureBuffer(bufferLength + rowBytes);\n    const bits = this.bits;\n    const colors = this.colors;\n    const rawBytes = this.str.getBytes(rowBytes);\n    this.eof = !rawBytes.length;\n    if (this.eof) {\n      return;\n    }\n    let inbuf = 0,\n      outbuf = 0;\n    let inbits = 0,\n      outbits = 0;\n    let pos = bufferLength;\n    let i;\n    if (bits === 1 && colors === 1) {\n      for (i = 0; i < rowBytes; ++i) {\n        let c = rawBytes[i] ^ inbuf;\n        c ^= c >> 1;\n        c ^= c >> 2;\n        c ^= c >> 4;\n        inbuf = (c & 1) << 7;\n        buffer[pos++] = c;\n      }\n    } else if (bits === 8) {\n      for (i = 0; i < colors; ++i) {\n        buffer[pos++] = rawBytes[i];\n      }\n      for (; i < rowBytes; ++i) {\n        buffer[pos] = buffer[pos - colors] + rawBytes[i];\n        pos++;\n      }\n    } else if (bits === 16) {\n      const bytesPerPixel = colors * 2;\n      for (i = 0; i < bytesPerPixel; ++i) {\n        buffer[pos++] = rawBytes[i];\n      }\n      for (; i < rowBytes; i += 2) {\n        const sum = ((rawBytes[i] & 0xff) << 8) + (rawBytes[i + 1] & 0xff) + ((buffer[pos - bytesPerPixel] & 0xff) << 8) + (buffer[pos - bytesPerPixel + 1] & 0xff);\n        buffer[pos++] = sum >> 8 & 0xff;\n        buffer[pos++] = sum & 0xff;\n      }\n    } else {\n      const compArray = new Uint8Array(colors + 1);\n      const bitMask = (1 << bits) - 1;\n      let j = 0,\n        k = bufferLength;\n      const columns = this.columns;\n      for (i = 0; i < columns; ++i) {\n        for (let kk = 0; kk < colors; ++kk) {\n          if (inbits < bits) {\n            inbuf = inbuf << 8 | rawBytes[j++] & 0xff;\n            inbits += 8;\n          }\n          compArray[kk] = compArray[kk] + (inbuf >> inbits - bits) & bitMask;\n          inbits -= bits;\n          outbuf = outbuf << bits | compArray[kk];\n          outbits += bits;\n          if (outbits >= 8) {\n            buffer[k++] = outbuf >> outbits - 8 & 0xff;\n            outbits -= 8;\n          }\n        }\n      }\n      if (outbits > 0) {\n        buffer[k++] = (outbuf << 8 - outbits) + (inbuf & (1 << 8 - outbits) - 1);\n      }\n    }\n    this.bufferLength += rowBytes;\n  }\n  readBlockPng() {\n    const rowBytes = this.rowBytes;\n    const pixBytes = this.pixBytes;\n    const predictor = this.str.getByte();\n    const rawBytes = this.str.getBytes(rowBytes);\n    this.eof = !rawBytes.length;\n    if (this.eof) {\n      return;\n    }\n    const bufferLength = this.bufferLength;\n    const buffer = this.ensureBuffer(bufferLength + rowBytes);\n    let prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);\n    if (prevRow.length === 0) {\n      prevRow = new Uint8Array(rowBytes);\n    }\n    let i,\n      j = bufferLength,\n      up,\n      c;\n    switch (predictor) {\n      case 0:\n        for (i = 0; i < rowBytes; ++i) {\n          buffer[j++] = rawBytes[i];\n        }\n        break;\n      case 1:\n        for (i = 0; i < pixBytes; ++i) {\n          buffer[j++] = rawBytes[i];\n        }\n        for (; i < rowBytes; ++i) {\n          buffer[j] = buffer[j - pixBytes] + rawBytes[i] & 0xff;\n          j++;\n        }\n        break;\n      case 2:\n        for (i = 0; i < rowBytes; ++i) {\n          buffer[j++] = prevRow[i] + rawBytes[i] & 0xff;\n        }\n        break;\n      case 3:\n        for (i = 0; i < pixBytes; ++i) {\n          buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];\n        }\n        for (; i < rowBytes; ++i) {\n          buffer[j] = (prevRow[i] + buffer[j - pixBytes] >> 1) + rawBytes[i] & 0xff;\n          j++;\n        }\n        break;\n      case 4:\n        for (i = 0; i < pixBytes; ++i) {\n          up = prevRow[i];\n          c = rawBytes[i];\n          buffer[j++] = up + c;\n        }\n        for (; i < rowBytes; ++i) {\n          up = prevRow[i];\n          const upLeft = prevRow[i - pixBytes];\n          const left = buffer[j - pixBytes];\n          const p = left + up - upLeft;\n          let pa = p - left;\n          if (pa < 0) {\n            pa = -pa;\n          }\n          let pb = p - up;\n          if (pb < 0) {\n            pb = -pb;\n          }\n          let pc = p - upLeft;\n          if (pc < 0) {\n            pc = -pc;\n          }\n          c = rawBytes[i];\n          if (pa <= pb && pa <= pc) {\n            buffer[j++] = left + c;\n          } else if (pb <= pc) {\n            buffer[j++] = up + c;\n          } else {\n            buffer[j++] = upLeft + c;\n          }\n        }\n        break;\n      default:\n        throw new FormatError(`Unsupported predictor: ${predictor}`);\n    }\n    this.bufferLength += rowBytes;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/run_length_stream.js\n\nclass RunLengthStream extends DecodeStream {\n  constructor(str, maybeLength) {\n    super(maybeLength);\n    this.str = str;\n    this.dict = str.dict;\n  }\n  readBlock() {\n    const repeatHeader = this.str.getBytes(2);\n    if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {\n      this.eof = true;\n      return;\n    }\n    let buffer;\n    let bufferLength = this.bufferLength;\n    let n = repeatHeader[0];\n    if (n < 128) {\n      buffer = this.ensureBuffer(bufferLength + n + 1);\n      buffer[bufferLength++] = repeatHeader[1];\n      if (n > 0) {\n        const source = this.str.getBytes(n);\n        buffer.set(source, bufferLength);\n        bufferLength += n;\n      }\n    } else {\n      n = 257 - n;\n      const b = repeatHeader[1];\n      buffer = this.ensureBuffer(bufferLength + n + 1);\n      for (let i = 0; i < n; i++) {\n        buffer[bufferLength++] = b;\n      }\n    }\n    this.bufferLength = bufferLength;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/parser.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst MAX_LENGTH_TO_CACHE = 1000;\nfunction getInlineImageCacheKey(bytes) {\n  const strBuf = [],\n    ii = bytes.length;\n  let i = 0;\n  while (i < ii - 1) {\n    strBuf.push(bytes[i++] << 8 | bytes[i++]);\n  }\n  if (i < ii) {\n    strBuf.push(bytes[i]);\n  }\n  return ii + \"_\" + String.fromCharCode.apply(null, strBuf);\n}\nclass Parser {\n  constructor({\n    lexer,\n    xref,\n    allowStreams = false,\n    recoveryMode = false\n  }) {\n    this.lexer = lexer;\n    this.xref = xref;\n    this.allowStreams = allowStreams;\n    this.recoveryMode = recoveryMode;\n    this.imageCache = Object.create(null);\n    this._imageId = 0;\n    this.refill();\n  }\n  refill() {\n    this.buf1 = this.lexer.getObj();\n    this.buf2 = this.lexer.getObj();\n  }\n  shift() {\n    if (this.buf2 instanceof Cmd && this.buf2.cmd === \"ID\") {\n      this.buf1 = this.buf2;\n      this.buf2 = null;\n    } else {\n      this.buf1 = this.buf2;\n      this.buf2 = this.lexer.getObj();\n    }\n  }\n  tryShift() {\n    try {\n      this.shift();\n      return true;\n    } catch (e) {\n      if (e instanceof MissingDataException) {\n        throw e;\n      }\n      return false;\n    }\n  }\n  getObj(cipherTransform = null) {\n    const buf1 = this.buf1;\n    this.shift();\n    if (buf1 instanceof Cmd) {\n      switch (buf1.cmd) {\n        case \"BI\":\n          return this.makeInlineImage(cipherTransform);\n        case \"[\":\n          const array = [];\n          while (!isCmd(this.buf1, \"]\") && this.buf1 !== EOF) {\n            array.push(this.getObj(cipherTransform));\n          }\n          if (this.buf1 === EOF) {\n            if (this.recoveryMode) {\n              return array;\n            }\n            throw new ParserEOFException(\"End of file inside array.\");\n          }\n          this.shift();\n          return array;\n        case \"<<\":\n          const dict = new Dict(this.xref);\n          while (!isCmd(this.buf1, \">>\") && this.buf1 !== EOF) {\n            if (!(this.buf1 instanceof Name)) {\n              info(\"Malformed dictionary: key must be a name object\");\n              this.shift();\n              continue;\n            }\n            const key = this.buf1.name;\n            this.shift();\n            if (this.buf1 === EOF) {\n              break;\n            }\n            dict.set(key, this.getObj(cipherTransform));\n          }\n          if (this.buf1 === EOF) {\n            if (this.recoveryMode) {\n              return dict;\n            }\n            throw new ParserEOFException(\"End of file inside dictionary.\");\n          }\n          if (isCmd(this.buf2, \"stream\")) {\n            return this.allowStreams ? this.makeStream(dict, cipherTransform) : dict;\n          }\n          this.shift();\n          return dict;\n        default:\n          return buf1;\n      }\n    }\n    if (Number.isInteger(buf1)) {\n      if (Number.isInteger(this.buf1) && isCmd(this.buf2, \"R\")) {\n        const ref = Ref.get(buf1, this.buf1);\n        this.shift();\n        this.shift();\n        return ref;\n      }\n      return buf1;\n    }\n    if (typeof buf1 === \"string\") {\n      if (cipherTransform) {\n        return cipherTransform.decryptString(buf1);\n      }\n      return buf1;\n    }\n    return buf1;\n  }\n  findDefaultInlineStreamEnd(stream) {\n    const E = 0x45,\n      I = 0x49,\n      SPACE = 0x20,\n      LF = 0xa,\n      CR = 0xd,\n      NUL = 0x0;\n    const {\n        knownCommands\n      } = this.lexer,\n      startPos = stream.pos,\n      n = 15;\n    let state = 0,\n      ch,\n      maybeEIPos;\n    while ((ch = stream.getByte()) !== -1) {\n      if (state === 0) {\n        state = ch === E ? 1 : 0;\n      } else if (state === 1) {\n        state = ch === I ? 2 : 0;\n      } else {\n        if (ch === SPACE || ch === LF || ch === CR) {\n          maybeEIPos = stream.pos;\n          const followingBytes = stream.peekBytes(n);\n          const ii = followingBytes.length;\n          if (ii === 0) {\n            break;\n          }\n          for (let i = 0; i < ii; i++) {\n            ch = followingBytes[i];\n            if (ch === NUL && followingBytes[i + 1] !== NUL) {\n              continue;\n            }\n            if (ch !== LF && ch !== CR && (ch < SPACE || ch > 0x7f)) {\n              state = 0;\n              break;\n            }\n          }\n          if (state !== 2) {\n            continue;\n          }\n          if (!knownCommands) {\n            warn(\"findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.\");\n            continue;\n          }\n          const tmpLexer = new Lexer(new Stream(followingBytes.slice()), knownCommands);\n          tmpLexer._hexStringWarn = () => {};\n          let numArgs = 0;\n          while (true) {\n            const nextObj = tmpLexer.getObj();\n            if (nextObj === EOF) {\n              state = 0;\n              break;\n            }\n            if (nextObj instanceof Cmd) {\n              const knownCommand = knownCommands[nextObj.cmd];\n              if (!knownCommand) {\n                state = 0;\n                break;\n              } else if (knownCommand.variableArgs ? numArgs <= knownCommand.numArgs : numArgs === knownCommand.numArgs) {\n                break;\n              }\n              numArgs = 0;\n              continue;\n            }\n            numArgs++;\n          }\n          if (state === 2) {\n            break;\n          }\n        } else {\n          state = 0;\n        }\n      }\n    }\n    if (ch === -1) {\n      warn(\"findDefaultInlineStreamEnd: \" + \"Reached the end of the stream without finding a valid EI marker\");\n      if (maybeEIPos) {\n        warn('... trying to recover by using the last \"EI\" occurrence.');\n        stream.skip(-(stream.pos - maybeEIPos));\n      }\n    }\n    let endOffset = 4;\n    stream.skip(-endOffset);\n    ch = stream.peekByte();\n    stream.skip(endOffset);\n    if (!isWhiteSpace(ch)) {\n      endOffset--;\n    }\n    return stream.pos - endOffset - startPos;\n  }\n  findDCTDecodeInlineStreamEnd(stream) {\n    const startPos = stream.pos;\n    let foundEOI = false,\n      b,\n      markerLength;\n    while ((b = stream.getByte()) !== -1) {\n      if (b !== 0xff) {\n        continue;\n      }\n      switch (stream.getByte()) {\n        case 0x00:\n          break;\n        case 0xff:\n          stream.skip(-1);\n          break;\n        case 0xd9:\n          foundEOI = true;\n          break;\n        case 0xc0:\n        case 0xc1:\n        case 0xc2:\n        case 0xc3:\n        case 0xc5:\n        case 0xc6:\n        case 0xc7:\n        case 0xc9:\n        case 0xca:\n        case 0xcb:\n        case 0xcd:\n        case 0xce:\n        case 0xcf:\n        case 0xc4:\n        case 0xcc:\n        case 0xda:\n        case 0xdb:\n        case 0xdc:\n        case 0xdd:\n        case 0xde:\n        case 0xdf:\n        case 0xe0:\n        case 0xe1:\n        case 0xe2:\n        case 0xe3:\n        case 0xe4:\n        case 0xe5:\n        case 0xe6:\n        case 0xe7:\n        case 0xe8:\n        case 0xe9:\n        case 0xea:\n        case 0xeb:\n        case 0xec:\n        case 0xed:\n        case 0xee:\n        case 0xef:\n        case 0xfe:\n          markerLength = stream.getUint16();\n          if (markerLength > 2) {\n            stream.skip(markerLength - 2);\n          } else {\n            stream.skip(-2);\n          }\n          break;\n      }\n      if (foundEOI) {\n        break;\n      }\n    }\n    const length = stream.pos - startPos;\n    if (b === -1) {\n      warn(\"Inline DCTDecode image stream: \" + \"EOI marker not found, searching for /EI/ instead.\");\n      stream.skip(-length);\n      return this.findDefaultInlineStreamEnd(stream);\n    }\n    this.inlineStreamSkipEI(stream);\n    return length;\n  }\n  findASCII85DecodeInlineStreamEnd(stream) {\n    const TILDE = 0x7e,\n      GT = 0x3e;\n    const startPos = stream.pos;\n    let ch;\n    while ((ch = stream.getByte()) !== -1) {\n      if (ch === TILDE) {\n        const tildePos = stream.pos;\n        ch = stream.peekByte();\n        while (isWhiteSpace(ch)) {\n          stream.skip();\n          ch = stream.peekByte();\n        }\n        if (ch === GT) {\n          stream.skip();\n          break;\n        }\n        if (stream.pos > tildePos) {\n          const maybeEI = stream.peekBytes(2);\n          if (maybeEI[0] === 0x45 && maybeEI[1] === 0x49) {\n            break;\n          }\n        }\n      }\n    }\n    const length = stream.pos - startPos;\n    if (ch === -1) {\n      warn(\"Inline ASCII85Decode image stream: \" + \"EOD marker not found, searching for /EI/ instead.\");\n      stream.skip(-length);\n      return this.findDefaultInlineStreamEnd(stream);\n    }\n    this.inlineStreamSkipEI(stream);\n    return length;\n  }\n  findASCIIHexDecodeInlineStreamEnd(stream) {\n    const GT = 0x3e;\n    const startPos = stream.pos;\n    let ch;\n    while ((ch = stream.getByte()) !== -1) {\n      if (ch === GT) {\n        break;\n      }\n    }\n    const length = stream.pos - startPos;\n    if (ch === -1) {\n      warn(\"Inline ASCIIHexDecode image stream: \" + \"EOD marker not found, searching for /EI/ instead.\");\n      stream.skip(-length);\n      return this.findDefaultInlineStreamEnd(stream);\n    }\n    this.inlineStreamSkipEI(stream);\n    return length;\n  }\n  inlineStreamSkipEI(stream) {\n    const E = 0x45,\n      I = 0x49;\n    let state = 0,\n      ch;\n    while ((ch = stream.getByte()) !== -1) {\n      if (state === 0) {\n        state = ch === E ? 1 : 0;\n      } else if (state === 1) {\n        state = ch === I ? 2 : 0;\n      } else if (state === 2) {\n        break;\n      }\n    }\n  }\n  makeInlineImage(cipherTransform) {\n    const lexer = this.lexer;\n    const stream = lexer.stream;\n    const dictMap = Object.create(null);\n    let dictLength;\n    while (!isCmd(this.buf1, \"ID\") && this.buf1 !== EOF) {\n      if (!(this.buf1 instanceof Name)) {\n        throw new FormatError(\"Dictionary key must be a name object\");\n      }\n      const key = this.buf1.name;\n      this.shift();\n      if (this.buf1 === EOF) {\n        break;\n      }\n      dictMap[key] = this.getObj(cipherTransform);\n    }\n    if (lexer.beginInlineImagePos !== -1) {\n      dictLength = stream.pos - lexer.beginInlineImagePos;\n    }\n    const filter = this.xref.fetchIfRef(dictMap.F || dictMap.Filter);\n    let filterName;\n    if (filter instanceof Name) {\n      filterName = filter.name;\n    } else if (Array.isArray(filter)) {\n      const filterZero = this.xref.fetchIfRef(filter[0]);\n      if (filterZero instanceof Name) {\n        filterName = filterZero.name;\n      }\n    }\n    const startPos = stream.pos;\n    let length;\n    switch (filterName) {\n      case \"DCT\":\n      case \"DCTDecode\":\n        length = this.findDCTDecodeInlineStreamEnd(stream);\n        break;\n      case \"A85\":\n      case \"ASCII85Decode\":\n        length = this.findASCII85DecodeInlineStreamEnd(stream);\n        break;\n      case \"AHx\":\n      case \"ASCIIHexDecode\":\n        length = this.findASCIIHexDecodeInlineStreamEnd(stream);\n        break;\n      default:\n        length = this.findDefaultInlineStreamEnd(stream);\n    }\n    let cacheKey;\n    if (length < MAX_LENGTH_TO_CACHE && dictLength > 0) {\n      const initialStreamPos = stream.pos;\n      stream.pos = lexer.beginInlineImagePos;\n      cacheKey = getInlineImageCacheKey(stream.getBytes(dictLength + length));\n      stream.pos = initialStreamPos;\n      const cacheEntry = this.imageCache[cacheKey];\n      if (cacheEntry !== undefined) {\n        this.buf2 = Cmd.get(\"EI\");\n        this.shift();\n        cacheEntry.reset();\n        return cacheEntry;\n      }\n    }\n    const dict = new Dict(this.xref);\n    for (const key in dictMap) {\n      dict.set(key, dictMap[key]);\n    }\n    let imageStream = stream.makeSubStream(startPos, length, dict);\n    if (cipherTransform) {\n      imageStream = cipherTransform.createStream(imageStream, length);\n    }\n    imageStream = this.filter(imageStream, dict, length);\n    imageStream.dict = dict;\n    if (cacheKey !== undefined) {\n      imageStream.cacheKey = `inline_img_${++this._imageId}`;\n      this.imageCache[cacheKey] = imageStream;\n    }\n    this.buf2 = Cmd.get(\"EI\");\n    this.shift();\n    return imageStream;\n  }\n  _findStreamLength(startPos, signature) {\n    const {\n      stream\n    } = this.lexer;\n    stream.pos = startPos;\n    const SCAN_BLOCK_LENGTH = 2048;\n    const signatureLength = signature.length;\n    while (stream.pos < stream.end) {\n      const scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);\n      const scanLength = scanBytes.length - signatureLength;\n      if (scanLength <= 0) {\n        break;\n      }\n      let pos = 0;\n      while (pos < scanLength) {\n        let j = 0;\n        while (j < signatureLength && scanBytes[pos + j] === signature[j]) {\n          j++;\n        }\n        if (j >= signatureLength) {\n          stream.pos += pos;\n          return stream.pos - startPos;\n        }\n        pos++;\n      }\n      stream.pos += scanLength;\n    }\n    return -1;\n  }\n  makeStream(dict, cipherTransform) {\n    const lexer = this.lexer;\n    let stream = lexer.stream;\n    lexer.skipToNextLine();\n    const startPos = stream.pos - 1;\n    let length = dict.get(\"Length\");\n    if (!Number.isInteger(length)) {\n      info(`Bad length \"${length && length.toString()}\" in stream.`);\n      length = 0;\n    }\n    stream.pos = startPos + length;\n    lexer.nextChar();\n    if (this.tryShift() && isCmd(this.buf2, \"endstream\")) {\n      this.shift();\n    } else {\n      const ENDSTREAM_SIGNATURE = new Uint8Array([0x65, 0x6e, 0x64, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d]);\n      let actualLength = this._findStreamLength(startPos, ENDSTREAM_SIGNATURE);\n      if (actualLength < 0) {\n        const MAX_TRUNCATION = 1;\n        for (let i = 1; i <= MAX_TRUNCATION; i++) {\n          const end = ENDSTREAM_SIGNATURE.length - i;\n          const TRUNCATED_SIGNATURE = ENDSTREAM_SIGNATURE.slice(0, end);\n          const maybeLength = this._findStreamLength(startPos, TRUNCATED_SIGNATURE);\n          if (maybeLength >= 0) {\n            const lastByte = stream.peekBytes(end + 1)[end];\n            if (!isWhiteSpace(lastByte)) {\n              break;\n            }\n            info(`Found \"${bytesToString(TRUNCATED_SIGNATURE)}\" when ` + \"searching for endstream command.\");\n            actualLength = maybeLength;\n            break;\n          }\n        }\n        if (actualLength < 0) {\n          throw new FormatError(\"Missing endstream command.\");\n        }\n      }\n      length = actualLength;\n      lexer.nextChar();\n      this.shift();\n      this.shift();\n    }\n    this.shift();\n    stream = stream.makeSubStream(startPos, length, dict);\n    if (cipherTransform) {\n      stream = cipherTransform.createStream(stream, length);\n    }\n    stream = this.filter(stream, dict, length);\n    stream.dict = dict;\n    return stream;\n  }\n  filter(stream, dict, length) {\n    let filter = dict.get(\"F\", \"Filter\");\n    let params = dict.get(\"DP\", \"DecodeParms\");\n    if (filter instanceof Name) {\n      if (Array.isArray(params)) {\n        warn(\"/DecodeParms should not be an Array, when /Filter is a Name.\");\n      }\n      return this.makeFilter(stream, filter.name, length, params);\n    }\n    let maybeLength = length;\n    if (Array.isArray(filter)) {\n      const filterArray = filter;\n      const paramsArray = params;\n      for (let i = 0, ii = filterArray.length; i < ii; ++i) {\n        filter = this.xref.fetchIfRef(filterArray[i]);\n        if (!(filter instanceof Name)) {\n          throw new FormatError(`Bad filter name \"${filter}\"`);\n        }\n        params = null;\n        if (Array.isArray(paramsArray) && i in paramsArray) {\n          params = this.xref.fetchIfRef(paramsArray[i]);\n        }\n        stream = this.makeFilter(stream, filter.name, maybeLength, params);\n        maybeLength = null;\n      }\n    }\n    return stream;\n  }\n  makeFilter(stream, name, maybeLength, params) {\n    if (maybeLength === 0) {\n      warn(`Empty \"${name}\" stream.`);\n      return new NullStream();\n    }\n    try {\n      switch (name) {\n        case \"Fl\":\n        case \"FlateDecode\":\n          if (params) {\n            return new PredictorStream(new FlateStream(stream, maybeLength), maybeLength, params);\n          }\n          return new FlateStream(stream, maybeLength);\n        case \"LZW\":\n        case \"LZWDecode\":\n          let earlyChange = 1;\n          if (params) {\n            if (params.has(\"EarlyChange\")) {\n              earlyChange = params.get(\"EarlyChange\");\n            }\n            return new PredictorStream(new LZWStream(stream, maybeLength, earlyChange), maybeLength, params);\n          }\n          return new LZWStream(stream, maybeLength, earlyChange);\n        case \"DCT\":\n        case \"DCTDecode\":\n          return new JpegStream(stream, maybeLength, params);\n        case \"JPX\":\n        case \"JPXDecode\":\n          return new JpxStream(stream, maybeLength, params);\n        case \"A85\":\n        case \"ASCII85Decode\":\n          return new Ascii85Stream(stream, maybeLength);\n        case \"AHx\":\n        case \"ASCIIHexDecode\":\n          return new AsciiHexStream(stream, maybeLength);\n        case \"CCF\":\n        case \"CCITTFaxDecode\":\n          return new CCITTFaxStream(stream, maybeLength, params);\n        case \"RL\":\n        case \"RunLengthDecode\":\n          return new RunLengthStream(stream, maybeLength);\n        case \"JBIG2Decode\":\n          return new Jbig2Stream(stream, maybeLength, params);\n      }\n      warn(`Filter \"${name}\" is not supported.`);\n      return stream;\n    } catch (ex) {\n      if (ex instanceof MissingDataException) {\n        throw ex;\n      }\n      warn(`Invalid stream: \"${ex}\"`);\n      return new NullStream();\n    }\n  }\n}\nconst specialChars = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\nfunction toHexDigit(ch) {\n  if (ch >= 0x30 && ch <= 0x39) {\n    return ch & 0x0f;\n  }\n  if (ch >= 0x41 && ch <= 0x46 || ch >= 0x61 && ch <= 0x66) {\n    return (ch & 0x0f) + 9;\n  }\n  return -1;\n}\nclass Lexer {\n  constructor(stream, knownCommands = null) {\n    this.stream = stream;\n    this.nextChar();\n    this.strBuf = [];\n    this.knownCommands = knownCommands;\n    this._hexStringNumWarn = 0;\n    this.beginInlineImagePos = -1;\n  }\n  nextChar() {\n    return this.currentChar = this.stream.getByte();\n  }\n  peekChar() {\n    return this.stream.peekByte();\n  }\n  getNumber() {\n    let ch = this.currentChar;\n    let eNotation = false;\n    let divideBy = 0;\n    let sign = 1;\n    if (ch === 0x2d) {\n      sign = -1;\n      ch = this.nextChar();\n      if (ch === 0x2d) {\n        ch = this.nextChar();\n      }\n    } else if (ch === 0x2b) {\n      ch = this.nextChar();\n    }\n    if (ch === 0x0a || ch === 0x0d) {\n      do {\n        ch = this.nextChar();\n      } while (ch === 0x0a || ch === 0x0d);\n    }\n    if (ch === 0x2e) {\n      divideBy = 10;\n      ch = this.nextChar();\n    }\n    if (ch < 0x30 || ch > 0x39) {\n      const msg = `Invalid number: ${String.fromCharCode(ch)} (charCode ${ch})`;\n      if (isWhiteSpace(ch) || ch === -1) {\n        info(`Lexer.getNumber - \"${msg}\".`);\n        return 0;\n      }\n      throw new FormatError(msg);\n    }\n    let baseValue = ch - 0x30;\n    let powerValue = 0;\n    let powerValueSign = 1;\n    while ((ch = this.nextChar()) >= 0) {\n      if (ch >= 0x30 && ch <= 0x39) {\n        const currentDigit = ch - 0x30;\n        if (eNotation) {\n          powerValue = powerValue * 10 + currentDigit;\n        } else {\n          if (divideBy !== 0) {\n            divideBy *= 10;\n          }\n          baseValue = baseValue * 10 + currentDigit;\n        }\n      } else if (ch === 0x2e) {\n        if (divideBy === 0) {\n          divideBy = 1;\n        } else {\n          break;\n        }\n      } else if (ch === 0x2d) {\n        warn(\"Badly formatted number: minus sign in the middle\");\n      } else if (ch === 0x45 || ch === 0x65) {\n        ch = this.peekChar();\n        if (ch === 0x2b || ch === 0x2d) {\n          powerValueSign = ch === 0x2d ? -1 : 1;\n          this.nextChar();\n        } else if (ch < 0x30 || ch > 0x39) {\n          break;\n        }\n        eNotation = true;\n      } else {\n        break;\n      }\n    }\n    if (divideBy !== 0) {\n      baseValue /= divideBy;\n    }\n    if (eNotation) {\n      baseValue *= 10 ** (powerValueSign * powerValue);\n    }\n    return sign * baseValue;\n  }\n  getString() {\n    let numParen = 1;\n    let done = false;\n    const strBuf = this.strBuf;\n    strBuf.length = 0;\n    let ch = this.nextChar();\n    while (true) {\n      let charBuffered = false;\n      switch (ch | 0) {\n        case -1:\n          warn(\"Unterminated string\");\n          done = true;\n          break;\n        case 0x28:\n          ++numParen;\n          strBuf.push(\"(\");\n          break;\n        case 0x29:\n          if (--numParen === 0) {\n            this.nextChar();\n            done = true;\n          } else {\n            strBuf.push(\")\");\n          }\n          break;\n        case 0x5c:\n          ch = this.nextChar();\n          switch (ch) {\n            case -1:\n              warn(\"Unterminated string\");\n              done = true;\n              break;\n            case 0x6e:\n              strBuf.push(\"\\n\");\n              break;\n            case 0x72:\n              strBuf.push(\"\\r\");\n              break;\n            case 0x74:\n              strBuf.push(\"\\t\");\n              break;\n            case 0x62:\n              strBuf.push(\"\\b\");\n              break;\n            case 0x66:\n              strBuf.push(\"\\f\");\n              break;\n            case 0x5c:\n            case 0x28:\n            case 0x29:\n              strBuf.push(String.fromCharCode(ch));\n              break;\n            case 0x30:\n            case 0x31:\n            case 0x32:\n            case 0x33:\n            case 0x34:\n            case 0x35:\n            case 0x36:\n            case 0x37:\n              let x = ch & 0x0f;\n              ch = this.nextChar();\n              charBuffered = true;\n              if (ch >= 0x30 && ch <= 0x37) {\n                x = (x << 3) + (ch & 0x0f);\n                ch = this.nextChar();\n                if (ch >= 0x30 && ch <= 0x37) {\n                  charBuffered = false;\n                  x = (x << 3) + (ch & 0x0f);\n                }\n              }\n              strBuf.push(String.fromCharCode(x));\n              break;\n            case 0x0d:\n              if (this.peekChar() === 0x0a) {\n                this.nextChar();\n              }\n              break;\n            case 0x0a:\n              break;\n            default:\n              strBuf.push(String.fromCharCode(ch));\n              break;\n          }\n          break;\n        default:\n          strBuf.push(String.fromCharCode(ch));\n          break;\n      }\n      if (done) {\n        break;\n      }\n      if (!charBuffered) {\n        ch = this.nextChar();\n      }\n    }\n    return strBuf.join(\"\");\n  }\n  getName() {\n    let ch, previousCh;\n    const strBuf = this.strBuf;\n    strBuf.length = 0;\n    while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {\n      if (ch === 0x23) {\n        ch = this.nextChar();\n        if (specialChars[ch]) {\n          warn(\"Lexer_getName: \" + \"NUMBER SIGN (#) should be followed by a hexadecimal number.\");\n          strBuf.push(\"#\");\n          break;\n        }\n        const x = toHexDigit(ch);\n        if (x !== -1) {\n          previousCh = ch;\n          ch = this.nextChar();\n          const x2 = toHexDigit(ch);\n          if (x2 === -1) {\n            warn(`Lexer_getName: Illegal digit (${String.fromCharCode(ch)}) ` + \"in hexadecimal number.\");\n            strBuf.push(\"#\", String.fromCharCode(previousCh));\n            if (specialChars[ch]) {\n              break;\n            }\n            strBuf.push(String.fromCharCode(ch));\n            continue;\n          }\n          strBuf.push(String.fromCharCode(x << 4 | x2));\n        } else {\n          strBuf.push(\"#\", String.fromCharCode(ch));\n        }\n      } else {\n        strBuf.push(String.fromCharCode(ch));\n      }\n    }\n    if (strBuf.length > 127) {\n      warn(`Name token is longer than allowed by the spec: ${strBuf.length}`);\n    }\n    return Name.get(strBuf.join(\"\"));\n  }\n  _hexStringWarn(ch) {\n    const MAX_HEX_STRING_NUM_WARN = 5;\n    if (this._hexStringNumWarn++ === MAX_HEX_STRING_NUM_WARN) {\n      warn(\"getHexString - ignoring additional invalid characters.\");\n      return;\n    }\n    if (this._hexStringNumWarn > MAX_HEX_STRING_NUM_WARN) {\n      return;\n    }\n    warn(`getHexString - ignoring invalid character: ${ch}`);\n  }\n  getHexString() {\n    const strBuf = this.strBuf;\n    strBuf.length = 0;\n    let ch = this.currentChar;\n    let isFirstHex = true;\n    let firstDigit, secondDigit;\n    this._hexStringNumWarn = 0;\n    while (true) {\n      if (ch < 0) {\n        warn(\"Unterminated hex string\");\n        break;\n      } else if (ch === 0x3e) {\n        this.nextChar();\n        break;\n      } else if (specialChars[ch] === 1) {\n        ch = this.nextChar();\n        continue;\n      } else {\n        if (isFirstHex) {\n          firstDigit = toHexDigit(ch);\n          if (firstDigit === -1) {\n            this._hexStringWarn(ch);\n            ch = this.nextChar();\n            continue;\n          }\n        } else {\n          secondDigit = toHexDigit(ch);\n          if (secondDigit === -1) {\n            this._hexStringWarn(ch);\n            ch = this.nextChar();\n            continue;\n          }\n          strBuf.push(String.fromCharCode(firstDigit << 4 | secondDigit));\n        }\n        isFirstHex = !isFirstHex;\n        ch = this.nextChar();\n      }\n    }\n    return strBuf.join(\"\");\n  }\n  getObj() {\n    let comment = false;\n    let ch = this.currentChar;\n    while (true) {\n      if (ch < 0) {\n        return EOF;\n      }\n      if (comment) {\n        if (ch === 0x0a || ch === 0x0d) {\n          comment = false;\n        }\n      } else if (ch === 0x25) {\n        comment = true;\n      } else if (specialChars[ch] !== 1) {\n        break;\n      }\n      ch = this.nextChar();\n    }\n    switch (ch | 0) {\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x2b:\n      case 0x2d:\n      case 0x2e:\n        return this.getNumber();\n      case 0x28:\n        return this.getString();\n      case 0x2f:\n        return this.getName();\n      case 0x5b:\n        this.nextChar();\n        return Cmd.get(\"[\");\n      case 0x5d:\n        this.nextChar();\n        return Cmd.get(\"]\");\n      case 0x3c:\n        ch = this.nextChar();\n        if (ch === 0x3c) {\n          this.nextChar();\n          return Cmd.get(\"<<\");\n        }\n        return this.getHexString();\n      case 0x3e:\n        ch = this.nextChar();\n        if (ch === 0x3e) {\n          this.nextChar();\n          return Cmd.get(\">>\");\n        }\n        return Cmd.get(\">\");\n      case 0x7b:\n        this.nextChar();\n        return Cmd.get(\"{\");\n      case 0x7d:\n        this.nextChar();\n        return Cmd.get(\"}\");\n      case 0x29:\n        this.nextChar();\n        throw new FormatError(`Illegal character: ${ch}`);\n    }\n    let str = String.fromCharCode(ch);\n    if (ch < 0x20 || ch > 0x7f) {\n      const nextCh = this.peekChar();\n      if (nextCh >= 0x20 && nextCh <= 0x7f) {\n        this.nextChar();\n        return Cmd.get(str);\n      }\n    }\n    const knownCommands = this.knownCommands;\n    let knownCommandFound = knownCommands?.[str] !== undefined;\n    while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {\n      const possibleCommand = str + String.fromCharCode(ch);\n      if (knownCommandFound && knownCommands[possibleCommand] === undefined) {\n        break;\n      }\n      if (str.length === 128) {\n        throw new FormatError(`Command token too long: ${str.length}`);\n      }\n      str = possibleCommand;\n      knownCommandFound = knownCommands?.[str] !== undefined;\n    }\n    if (str === \"true\") {\n      return true;\n    }\n    if (str === \"false\") {\n      return false;\n    }\n    if (str === \"null\") {\n      return null;\n    }\n    if (str === \"BI\") {\n      this.beginInlineImagePos = this.stream.pos;\n    }\n    return Cmd.get(str);\n  }\n  skipToNextLine() {\n    let ch = this.currentChar;\n    while (ch >= 0) {\n      if (ch === 0x0d) {\n        ch = this.nextChar();\n        if (ch === 0x0a) {\n          this.nextChar();\n        }\n        break;\n      } else if (ch === 0x0a) {\n        this.nextChar();\n        break;\n      }\n      ch = this.nextChar();\n    }\n  }\n}\nclass Linearization {\n  static create(stream) {\n    function getInt(linDict, name, allowZeroValue = false) {\n      const obj = linDict.get(name);\n      if (Number.isInteger(obj) && (allowZeroValue ? obj >= 0 : obj > 0)) {\n        return obj;\n      }\n      throw new Error(`The \"${name}\" parameter in the linearization ` + \"dictionary is invalid.\");\n    }\n    function getHints(linDict) {\n      const hints = linDict.get(\"H\");\n      let hintsLength;\n      if (Array.isArray(hints) && ((hintsLength = hints.length) === 2 || hintsLength === 4)) {\n        for (let index = 0; index < hintsLength; index++) {\n          const hint = hints[index];\n          if (!(Number.isInteger(hint) && hint > 0)) {\n            throw new Error(`Hint (${index}) in the linearization dictionary is invalid.`);\n          }\n        }\n        return hints;\n      }\n      throw new Error(\"Hint array in the linearization dictionary is invalid.\");\n    }\n    const parser = new Parser({\n      lexer: new Lexer(stream),\n      xref: null\n    });\n    const obj1 = parser.getObj();\n    const obj2 = parser.getObj();\n    const obj3 = parser.getObj();\n    const linDict = parser.getObj();\n    let obj, length;\n    if (!(Number.isInteger(obj1) && Number.isInteger(obj2) && isCmd(obj3, \"obj\") && linDict instanceof Dict && typeof (obj = linDict.get(\"Linearized\")) === \"number\" && obj > 0)) {\n      return null;\n    } else if ((length = getInt(linDict, \"L\")) !== stream.length) {\n      throw new Error('The \"L\" parameter in the linearization dictionary ' + \"does not equal the stream length.\");\n    }\n    return {\n      length,\n      hints: getHints(linDict),\n      objectNumberFirst: getInt(linDict, \"O\"),\n      endFirst: getInt(linDict, \"E\"),\n      numPages: getInt(linDict, \"N\"),\n      mainXRefEntriesOffset: getInt(linDict, \"T\"),\n      pageFirst: linDict.has(\"P\") ? getInt(linDict, \"P\", true) : 0\n    };\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/cmap.js\n\n\n\n\n\n\n\nconst BUILT_IN_CMAPS = [\"Adobe-GB1-UCS2\", \"Adobe-CNS1-UCS2\", \"Adobe-Japan1-UCS2\", \"Adobe-Korea1-UCS2\", \"78-EUC-H\", \"78-EUC-V\", \"78-H\", \"78-RKSJ-H\", \"78-RKSJ-V\", \"78-V\", \"78ms-RKSJ-H\", \"78ms-RKSJ-V\", \"83pv-RKSJ-H\", \"90ms-RKSJ-H\", \"90ms-RKSJ-V\", \"90msp-RKSJ-H\", \"90msp-RKSJ-V\", \"90pv-RKSJ-H\", \"90pv-RKSJ-V\", \"Add-H\", \"Add-RKSJ-H\", \"Add-RKSJ-V\", \"Add-V\", \"Adobe-CNS1-0\", \"Adobe-CNS1-1\", \"Adobe-CNS1-2\", \"Adobe-CNS1-3\", \"Adobe-CNS1-4\", \"Adobe-CNS1-5\", \"Adobe-CNS1-6\", \"Adobe-GB1-0\", \"Adobe-GB1-1\", \"Adobe-GB1-2\", \"Adobe-GB1-3\", \"Adobe-GB1-4\", \"Adobe-GB1-5\", \"Adobe-Japan1-0\", \"Adobe-Japan1-1\", \"Adobe-Japan1-2\", \"Adobe-Japan1-3\", \"Adobe-Japan1-4\", \"Adobe-Japan1-5\", \"Adobe-Japan1-6\", \"Adobe-Korea1-0\", \"Adobe-Korea1-1\", \"Adobe-Korea1-2\", \"B5-H\", \"B5-V\", \"B5pc-H\", \"B5pc-V\", \"CNS-EUC-H\", \"CNS-EUC-V\", \"CNS1-H\", \"CNS1-V\", \"CNS2-H\", \"CNS2-V\", \"ETHK-B5-H\", \"ETHK-B5-V\", \"ETen-B5-H\", \"ETen-B5-V\", \"ETenms-B5-H\", \"ETenms-B5-V\", \"EUC-H\", \"EUC-V\", \"Ext-H\", \"Ext-RKSJ-H\", \"Ext-RKSJ-V\", \"Ext-V\", \"GB-EUC-H\", \"GB-EUC-V\", \"GB-H\", \"GB-V\", \"GBK-EUC-H\", \"GBK-EUC-V\", \"GBK2K-H\", \"GBK2K-V\", \"GBKp-EUC-H\", \"GBKp-EUC-V\", \"GBT-EUC-H\", \"GBT-EUC-V\", \"GBT-H\", \"GBT-V\", \"GBTpc-EUC-H\", \"GBTpc-EUC-V\", \"GBpc-EUC-H\", \"GBpc-EUC-V\", \"H\", \"HKdla-B5-H\", \"HKdla-B5-V\", \"HKdlb-B5-H\", \"HKdlb-B5-V\", \"HKgccs-B5-H\", \"HKgccs-B5-V\", \"HKm314-B5-H\", \"HKm314-B5-V\", \"HKm471-B5-H\", \"HKm471-B5-V\", \"HKscs-B5-H\", \"HKscs-B5-V\", \"Hankaku\", \"Hiragana\", \"KSC-EUC-H\", \"KSC-EUC-V\", \"KSC-H\", \"KSC-Johab-H\", \"KSC-Johab-V\", \"KSC-V\", \"KSCms-UHC-H\", \"KSCms-UHC-HW-H\", \"KSCms-UHC-HW-V\", \"KSCms-UHC-V\", \"KSCpc-EUC-H\", \"KSCpc-EUC-V\", \"Katakana\", \"NWP-H\", \"NWP-V\", \"RKSJ-H\", \"RKSJ-V\", \"Roman\", \"UniCNS-UCS2-H\", \"UniCNS-UCS2-V\", \"UniCNS-UTF16-H\", \"UniCNS-UTF16-V\", \"UniCNS-UTF32-H\", \"UniCNS-UTF32-V\", \"UniCNS-UTF8-H\", \"UniCNS-UTF8-V\", \"UniGB-UCS2-H\", \"UniGB-UCS2-V\", \"UniGB-UTF16-H\", \"UniGB-UTF16-V\", \"UniGB-UTF32-H\", \"UniGB-UTF32-V\", \"UniGB-UTF8-H\", \"UniGB-UTF8-V\", \"UniJIS-UCS2-H\", \"UniJIS-UCS2-HW-H\", \"UniJIS-UCS2-HW-V\", \"UniJIS-UCS2-V\", \"UniJIS-UTF16-H\", \"UniJIS-UTF16-V\", \"UniJIS-UTF32-H\", \"UniJIS-UTF32-V\", \"UniJIS-UTF8-H\", \"UniJIS-UTF8-V\", \"UniJIS2004-UTF16-H\", \"UniJIS2004-UTF16-V\", \"UniJIS2004-UTF32-H\", \"UniJIS2004-UTF32-V\", \"UniJIS2004-UTF8-H\", \"UniJIS2004-UTF8-V\", \"UniJISPro-UCS2-HW-V\", \"UniJISPro-UCS2-V\", \"UniJISPro-UTF8-V\", \"UniJISX0213-UTF32-H\", \"UniJISX0213-UTF32-V\", \"UniJISX02132004-UTF32-H\", \"UniJISX02132004-UTF32-V\", \"UniKS-UCS2-H\", \"UniKS-UCS2-V\", \"UniKS-UTF16-H\", \"UniKS-UTF16-V\", \"UniKS-UTF32-H\", \"UniKS-UTF32-V\", \"UniKS-UTF8-H\", \"UniKS-UTF8-V\", \"V\", \"WP-Symbol\"];\nconst MAX_MAP_RANGE = 2 ** 24 - 1;\nclass CMap {\n  constructor(builtInCMap = false) {\n    this.codespaceRanges = [[], [], [], []];\n    this.numCodespaceRanges = 0;\n    this._map = [];\n    this.name = \"\";\n    this.vertical = false;\n    this.useCMap = null;\n    this.builtInCMap = builtInCMap;\n  }\n  addCodespaceRange(n, low, high) {\n    this.codespaceRanges[n - 1].push(low, high);\n    this.numCodespaceRanges++;\n  }\n  mapCidRange(low, high, dstLow) {\n    if (high - low > MAX_MAP_RANGE) {\n      throw new Error(\"mapCidRange - ignoring data above MAX_MAP_RANGE.\");\n    }\n    while (low <= high) {\n      this._map[low++] = dstLow++;\n    }\n  }\n  mapBfRange(low, high, dstLow) {\n    if (high - low > MAX_MAP_RANGE) {\n      throw new Error(\"mapBfRange - ignoring data above MAX_MAP_RANGE.\");\n    }\n    const lastByte = dstLow.length - 1;\n    while (low <= high) {\n      this._map[low++] = dstLow;\n      const nextCharCode = dstLow.charCodeAt(lastByte) + 1;\n      if (nextCharCode > 0xff) {\n        dstLow = dstLow.substring(0, lastByte - 1) + String.fromCharCode(dstLow.charCodeAt(lastByte - 1) + 1) + \"\\x00\";\n        continue;\n      }\n      dstLow = dstLow.substring(0, lastByte) + String.fromCharCode(nextCharCode);\n    }\n  }\n  mapBfRangeToArray(low, high, array) {\n    if (high - low > MAX_MAP_RANGE) {\n      throw new Error(\"mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.\");\n    }\n    const ii = array.length;\n    let i = 0;\n    while (low <= high && i < ii) {\n      this._map[low] = array[i++];\n      ++low;\n    }\n  }\n  mapOne(src, dst) {\n    this._map[src] = dst;\n  }\n  lookup(code) {\n    return this._map[code];\n  }\n  contains(code) {\n    return this._map[code] !== undefined;\n  }\n  forEach(callback) {\n    const map = this._map;\n    const length = map.length;\n    if (length <= 0x10000) {\n      for (let i = 0; i < length; i++) {\n        if (map[i] !== undefined) {\n          callback(i, map[i]);\n        }\n      }\n    } else {\n      for (const i in map) {\n        callback(i, map[i]);\n      }\n    }\n  }\n  charCodeOf(value) {\n    const map = this._map;\n    if (map.length <= 0x10000) {\n      return map.indexOf(value);\n    }\n    for (const charCode in map) {\n      if (map[charCode] === value) {\n        return charCode | 0;\n      }\n    }\n    return -1;\n  }\n  getMap() {\n    return this._map;\n  }\n  readCharCode(str, offset, out) {\n    let c = 0;\n    const codespaceRanges = this.codespaceRanges;\n    for (let n = 0, nn = codespaceRanges.length; n < nn; n++) {\n      c = (c << 8 | str.charCodeAt(offset + n)) >>> 0;\n      const codespaceRange = codespaceRanges[n];\n      for (let k = 0, kk = codespaceRange.length; k < kk;) {\n        const low = codespaceRange[k++];\n        const high = codespaceRange[k++];\n        if (c >= low && c <= high) {\n          out.charcode = c;\n          out.length = n + 1;\n          return;\n        }\n      }\n    }\n    out.charcode = 0;\n    out.length = 1;\n  }\n  getCharCodeLength(charCode) {\n    const codespaceRanges = this.codespaceRanges;\n    for (let n = 0, nn = codespaceRanges.length; n < nn; n++) {\n      const codespaceRange = codespaceRanges[n];\n      for (let k = 0, kk = codespaceRange.length; k < kk;) {\n        const low = codespaceRange[k++];\n        const high = codespaceRange[k++];\n        if (charCode >= low && charCode <= high) {\n          return n + 1;\n        }\n      }\n    }\n    return 1;\n  }\n  get length() {\n    return this._map.length;\n  }\n  get isIdentityCMap() {\n    if (!(this.name === \"Identity-H\" || this.name === \"Identity-V\")) {\n      return false;\n    }\n    if (this._map.length !== 0x10000) {\n      return false;\n    }\n    for (let i = 0; i < 0x10000; i++) {\n      if (this._map[i] !== i) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nclass IdentityCMap extends CMap {\n  constructor(vertical, n) {\n    super();\n    this.vertical = vertical;\n    this.addCodespaceRange(n, 0, 0xffff);\n  }\n  mapCidRange(low, high, dstLow) {\n    unreachable(\"should not call mapCidRange\");\n  }\n  mapBfRange(low, high, dstLow) {\n    unreachable(\"should not call mapBfRange\");\n  }\n  mapBfRangeToArray(low, high, array) {\n    unreachable(\"should not call mapBfRangeToArray\");\n  }\n  mapOne(src, dst) {\n    unreachable(\"should not call mapCidOne\");\n  }\n  lookup(code) {\n    return Number.isInteger(code) && code <= 0xffff ? code : undefined;\n  }\n  contains(code) {\n    return Number.isInteger(code) && code <= 0xffff;\n  }\n  forEach(callback) {\n    for (let i = 0; i <= 0xffff; i++) {\n      callback(i, i);\n    }\n  }\n  charCodeOf(value) {\n    return Number.isInteger(value) && value <= 0xffff ? value : -1;\n  }\n  getMap() {\n    const map = new Array(0x10000);\n    for (let i = 0; i <= 0xffff; i++) {\n      map[i] = i;\n    }\n    return map;\n  }\n  get length() {\n    return 0x10000;\n  }\n  get isIdentityCMap() {\n    unreachable(\"should not access .isIdentityCMap\");\n  }\n}\nfunction strToInt(str) {\n  let a = 0;\n  for (let i = 0; i < str.length; i++) {\n    a = a << 8 | str.charCodeAt(i);\n  }\n  return a >>> 0;\n}\nfunction expectString(obj) {\n  if (typeof obj !== \"string\") {\n    throw new FormatError(\"Malformed CMap: expected string.\");\n  }\n}\nfunction expectInt(obj) {\n  if (!Number.isInteger(obj)) {\n    throw new FormatError(\"Malformed CMap: expected int.\");\n  }\n}\nfunction parseBfChar(cMap, lexer) {\n  while (true) {\n    let obj = lexer.getObj();\n    if (obj === EOF) {\n      break;\n    }\n    if (isCmd(obj, \"endbfchar\")) {\n      return;\n    }\n    expectString(obj);\n    const src = strToInt(obj);\n    obj = lexer.getObj();\n    expectString(obj);\n    const dst = obj;\n    cMap.mapOne(src, dst);\n  }\n}\nfunction parseBfRange(cMap, lexer) {\n  while (true) {\n    let obj = lexer.getObj();\n    if (obj === EOF) {\n      break;\n    }\n    if (isCmd(obj, \"endbfrange\")) {\n      return;\n    }\n    expectString(obj);\n    const low = strToInt(obj);\n    obj = lexer.getObj();\n    expectString(obj);\n    const high = strToInt(obj);\n    obj = lexer.getObj();\n    if (Number.isInteger(obj) || typeof obj === \"string\") {\n      const dstLow = Number.isInteger(obj) ? String.fromCharCode(obj) : obj;\n      cMap.mapBfRange(low, high, dstLow);\n    } else if (isCmd(obj, \"[\")) {\n      obj = lexer.getObj();\n      const array = [];\n      while (!isCmd(obj, \"]\") && obj !== EOF) {\n        array.push(obj);\n        obj = lexer.getObj();\n      }\n      cMap.mapBfRangeToArray(low, high, array);\n    } else {\n      break;\n    }\n  }\n  throw new FormatError(\"Invalid bf range.\");\n}\nfunction parseCidChar(cMap, lexer) {\n  while (true) {\n    let obj = lexer.getObj();\n    if (obj === EOF) {\n      break;\n    }\n    if (isCmd(obj, \"endcidchar\")) {\n      return;\n    }\n    expectString(obj);\n    const src = strToInt(obj);\n    obj = lexer.getObj();\n    expectInt(obj);\n    const dst = obj;\n    cMap.mapOne(src, dst);\n  }\n}\nfunction parseCidRange(cMap, lexer) {\n  while (true) {\n    let obj = lexer.getObj();\n    if (obj === EOF) {\n      break;\n    }\n    if (isCmd(obj, \"endcidrange\")) {\n      return;\n    }\n    expectString(obj);\n    const low = strToInt(obj);\n    obj = lexer.getObj();\n    expectString(obj);\n    const high = strToInt(obj);\n    obj = lexer.getObj();\n    expectInt(obj);\n    const dstLow = obj;\n    cMap.mapCidRange(low, high, dstLow);\n  }\n}\nfunction parseCodespaceRange(cMap, lexer) {\n  while (true) {\n    let obj = lexer.getObj();\n    if (obj === EOF) {\n      break;\n    }\n    if (isCmd(obj, \"endcodespacerange\")) {\n      return;\n    }\n    if (typeof obj !== \"string\") {\n      break;\n    }\n    const low = strToInt(obj);\n    obj = lexer.getObj();\n    if (typeof obj !== \"string\") {\n      break;\n    }\n    const high = strToInt(obj);\n    cMap.addCodespaceRange(obj.length, low, high);\n  }\n  throw new FormatError(\"Invalid codespace range.\");\n}\nfunction parseWMode(cMap, lexer) {\n  const obj = lexer.getObj();\n  if (Number.isInteger(obj)) {\n    cMap.vertical = !!obj;\n  }\n}\nfunction parseCMapName(cMap, lexer) {\n  const obj = lexer.getObj();\n  if (obj instanceof Name) {\n    cMap.name = obj.name;\n  }\n}\nasync function parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap) {\n  let previous, embeddedUseCMap;\n  objLoop: while (true) {\n    try {\n      const obj = lexer.getObj();\n      if (obj === EOF) {\n        break;\n      } else if (obj instanceof Name) {\n        if (obj.name === \"WMode\") {\n          parseWMode(cMap, lexer);\n        } else if (obj.name === \"CMapName\") {\n          parseCMapName(cMap, lexer);\n        }\n        previous = obj;\n      } else if (obj instanceof Cmd) {\n        switch (obj.cmd) {\n          case \"endcmap\":\n            break objLoop;\n          case \"usecmap\":\n            if (previous instanceof Name) {\n              embeddedUseCMap = previous.name;\n            }\n            break;\n          case \"begincodespacerange\":\n            parseCodespaceRange(cMap, lexer);\n            break;\n          case \"beginbfchar\":\n            parseBfChar(cMap, lexer);\n            break;\n          case \"begincidchar\":\n            parseCidChar(cMap, lexer);\n            break;\n          case \"beginbfrange\":\n            parseBfRange(cMap, lexer);\n            break;\n          case \"begincidrange\":\n            parseCidRange(cMap, lexer);\n            break;\n        }\n      }\n    } catch (ex) {\n      if (ex instanceof MissingDataException) {\n        throw ex;\n      }\n      warn(\"Invalid cMap data: \" + ex);\n      continue;\n    }\n  }\n  if (!useCMap && embeddedUseCMap) {\n    useCMap = embeddedUseCMap;\n  }\n  if (useCMap) {\n    return extendCMap(cMap, fetchBuiltInCMap, useCMap);\n  }\n  return cMap;\n}\nasync function extendCMap(cMap, fetchBuiltInCMap, useCMap) {\n  cMap.useCMap = await createBuiltInCMap(useCMap, fetchBuiltInCMap);\n  if (cMap.numCodespaceRanges === 0) {\n    const useCodespaceRanges = cMap.useCMap.codespaceRanges;\n    for (let i = 0; i < useCodespaceRanges.length; i++) {\n      cMap.codespaceRanges[i] = useCodespaceRanges[i].slice();\n    }\n    cMap.numCodespaceRanges = cMap.useCMap.numCodespaceRanges;\n  }\n  cMap.useCMap.forEach(function (key, value) {\n    if (!cMap.contains(key)) {\n      cMap.mapOne(key, cMap.useCMap.lookup(key));\n    }\n  });\n  return cMap;\n}\nasync function createBuiltInCMap(name, fetchBuiltInCMap) {\n  if (name === \"Identity-H\") {\n    return new IdentityCMap(false, 2);\n  } else if (name === \"Identity-V\") {\n    return new IdentityCMap(true, 2);\n  }\n  if (!BUILT_IN_CMAPS.includes(name)) {\n    throw new Error(\"Unknown CMap name: \" + name);\n  }\n  if (!fetchBuiltInCMap) {\n    throw new Error(\"Built-in CMap parameters are not provided.\");\n  }\n  const {\n    cMapData,\n    compressionType\n  } = await fetchBuiltInCMap(name);\n  const cMap = new CMap(true);\n  if (compressionType === CMapCompressionType.BINARY) {\n    return new BinaryCMapReader().process(cMapData, cMap, useCMap => extendCMap(cMap, fetchBuiltInCMap, useCMap));\n  }\n  if (compressionType === CMapCompressionType.NONE) {\n    const lexer = new Lexer(new Stream(cMapData));\n    return parseCMap(cMap, lexer, fetchBuiltInCMap, null);\n  }\n  throw new Error(`Invalid CMap \"compressionType\" value: ${compressionType}`);\n}\nclass CMapFactory {\n  static async create({\n    encoding,\n    fetchBuiltInCMap,\n    useCMap\n  }) {\n    if (encoding instanceof Name) {\n      return createBuiltInCMap(encoding.name, fetchBuiltInCMap);\n    } else if (encoding instanceof BaseStream) {\n      const parsedCMap = await parseCMap(new CMap(), new Lexer(encoding), fetchBuiltInCMap, useCMap);\n      if (parsedCMap.isIdentityCMap) {\n        return createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap);\n      }\n      return parsedCMap;\n    }\n    throw new Error(\"Encoding required.\");\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/charsets.js\nconst ISOAdobeCharset = [\".notdef\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\", \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\", \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\", \"quoteleft\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\", \"asciitilde\", \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\", \"florin\", \"section\", \"currency\", \"quotesingle\", \"quotedblleft\", \"guillemotleft\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"endash\", \"dagger\", \"daggerdbl\", \"periodcentered\", \"paragraph\", \"bullet\", \"quotesinglbase\", \"quotedblbase\", \"quotedblright\", \"guillemotright\", \"ellipsis\", \"perthousand\", \"questiondown\", \"grave\", \"acute\", \"circumflex\", \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"dieresis\", \"ring\", \"cedilla\", \"hungarumlaut\", \"ogonek\", \"caron\", \"emdash\", \"AE\", \"ordfeminine\", \"Lslash\", \"Oslash\", \"OE\", \"ordmasculine\", \"ae\", \"dotlessi\", \"lslash\", \"oslash\", \"oe\", \"germandbls\", \"onesuperior\", \"logicalnot\", \"mu\", \"trademark\", \"Eth\", \"onehalf\", \"plusminus\", \"Thorn\", \"onequarter\", \"divide\", \"brokenbar\", \"degree\", \"thorn\", \"threequarters\", \"twosuperior\", \"registered\", \"minus\", \"eth\", \"multiply\", \"threesuperior\", \"copyright\", \"Aacute\", \"Acircumflex\", \"Adieresis\", \"Agrave\", \"Aring\", \"Atilde\", \"Ccedilla\", \"Eacute\", \"Ecircumflex\", \"Edieresis\", \"Egrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\", \"Igrave\", \"Ntilde\", \"Oacute\", \"Ocircumflex\", \"Odieresis\", \"Ograve\", \"Otilde\", \"Scaron\", \"Uacute\", \"Ucircumflex\", \"Udieresis\", \"Ugrave\", \"Yacute\", \"Ydieresis\", \"Zcaron\", \"aacute\", \"acircumflex\", \"adieresis\", \"agrave\", \"aring\", \"atilde\", \"ccedilla\", \"eacute\", \"ecircumflex\", \"edieresis\", \"egrave\", \"iacute\", \"icircumflex\", \"idieresis\", \"igrave\", \"ntilde\", \"oacute\", \"ocircumflex\", \"odieresis\", \"ograve\", \"otilde\", \"scaron\", \"uacute\", \"ucircumflex\", \"udieresis\", \"ugrave\", \"yacute\", \"ydieresis\", \"zcaron\"];\nconst ExpertCharset = [\".notdef\", \"space\", \"exclamsmall\", \"Hungarumlautsmall\", \"dollaroldstyle\", \"dollarsuperior\", \"ampersandsmall\", \"Acutesmall\", \"parenleftsuperior\", \"parenrightsuperior\", \"twodotenleader\", \"onedotenleader\", \"comma\", \"hyphen\", \"period\", \"fraction\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\", \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\", \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"colon\", \"semicolon\", \"commasuperior\", \"threequartersemdash\", \"periodsuperior\", \"questionsmall\", \"asuperior\", \"bsuperior\", \"centsuperior\", \"dsuperior\", \"esuperior\", \"isuperior\", \"lsuperior\", \"msuperior\", \"nsuperior\", \"osuperior\", \"rsuperior\", \"ssuperior\", \"tsuperior\", \"ff\", \"fi\", \"fl\", \"ffi\", \"ffl\", \"parenleftinferior\", \"parenrightinferior\", \"Circumflexsmall\", \"hyphensuperior\", \"Gravesmall\", \"Asmall\", \"Bsmall\", \"Csmall\", \"Dsmall\", \"Esmall\", \"Fsmall\", \"Gsmall\", \"Hsmall\", \"Ismall\", \"Jsmall\", \"Ksmall\", \"Lsmall\", \"Msmall\", \"Nsmall\", \"Osmall\", \"Psmall\", \"Qsmall\", \"Rsmall\", \"Ssmall\", \"Tsmall\", \"Usmall\", \"Vsmall\", \"Wsmall\", \"Xsmall\", \"Ysmall\", \"Zsmall\", \"colonmonetary\", \"onefitted\", \"rupiah\", \"Tildesmall\", \"exclamdownsmall\", \"centoldstyle\", \"Lslashsmall\", \"Scaronsmall\", \"Zcaronsmall\", \"Dieresissmall\", \"Brevesmall\", \"Caronsmall\", \"Dotaccentsmall\", \"Macronsmall\", \"figuredash\", \"hypheninferior\", \"Ogoneksmall\", \"Ringsmall\", \"Cedillasmall\", \"onequarter\", \"onehalf\", \"threequarters\", \"questiondownsmall\", \"oneeighth\", \"threeeighths\", \"fiveeighths\", \"seveneighths\", \"onethird\", \"twothirds\", \"zerosuperior\", \"onesuperior\", \"twosuperior\", \"threesuperior\", \"foursuperior\", \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"eightsuperior\", \"ninesuperior\", \"zeroinferior\", \"oneinferior\", \"twoinferior\", \"threeinferior\", \"fourinferior\", \"fiveinferior\", \"sixinferior\", \"seveninferior\", \"eightinferior\", \"nineinferior\", \"centinferior\", \"dollarinferior\", \"periodinferior\", \"commainferior\", \"Agravesmall\", \"Aacutesmall\", \"Acircumflexsmall\", \"Atildesmall\", \"Adieresissmall\", \"Aringsmall\", \"AEsmall\", \"Ccedillasmall\", \"Egravesmall\", \"Eacutesmall\", \"Ecircumflexsmall\", \"Edieresissmall\", \"Igravesmall\", \"Iacutesmall\", \"Icircumflexsmall\", \"Idieresissmall\", \"Ethsmall\", \"Ntildesmall\", \"Ogravesmall\", \"Oacutesmall\", \"Ocircumflexsmall\", \"Otildesmall\", \"Odieresissmall\", \"OEsmall\", \"Oslashsmall\", \"Ugravesmall\", \"Uacutesmall\", \"Ucircumflexsmall\", \"Udieresissmall\", \"Yacutesmall\", \"Thornsmall\", \"Ydieresissmall\"];\nconst ExpertSubsetCharset = [\".notdef\", \"space\", \"dollaroldstyle\", \"dollarsuperior\", \"parenleftsuperior\", \"parenrightsuperior\", \"twodotenleader\", \"onedotenleader\", \"comma\", \"hyphen\", \"period\", \"fraction\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\", \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\", \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"colon\", \"semicolon\", \"commasuperior\", \"threequartersemdash\", \"periodsuperior\", \"asuperior\", \"bsuperior\", \"centsuperior\", \"dsuperior\", \"esuperior\", \"isuperior\", \"lsuperior\", \"msuperior\", \"nsuperior\", \"osuperior\", \"rsuperior\", \"ssuperior\", \"tsuperior\", \"ff\", \"fi\", \"fl\", \"ffi\", \"ffl\", \"parenleftinferior\", \"parenrightinferior\", \"hyphensuperior\", \"colonmonetary\", \"onefitted\", \"rupiah\", \"centoldstyle\", \"figuredash\", \"hypheninferior\", \"onequarter\", \"onehalf\", \"threequarters\", \"oneeighth\", \"threeeighths\", \"fiveeighths\", \"seveneighths\", \"onethird\", \"twothirds\", \"zerosuperior\", \"onesuperior\", \"twosuperior\", \"threesuperior\", \"foursuperior\", \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"eightsuperior\", \"ninesuperior\", \"zeroinferior\", \"oneinferior\", \"twoinferior\", \"threeinferior\", \"fourinferior\", \"fiveinferior\", \"sixinferior\", \"seveninferior\", \"eightinferior\", \"nineinferior\", \"centinferior\", \"dollarinferior\", \"periodinferior\", \"commainferior\"];\n\n;// CONCATENATED MODULE: ./src/core/encodings.js\nconst ExpertEncoding = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"space\", \"exclamsmall\", \"Hungarumlautsmall\", \"\", \"dollaroldstyle\", \"dollarsuperior\", \"ampersandsmall\", \"Acutesmall\", \"parenleftsuperior\", \"parenrightsuperior\", \"twodotenleader\", \"onedotenleader\", \"comma\", \"hyphen\", \"period\", \"fraction\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\", \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\", \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"colon\", \"semicolon\", \"commasuperior\", \"threequartersemdash\", \"periodsuperior\", \"questionsmall\", \"\", \"asuperior\", \"bsuperior\", \"centsuperior\", \"dsuperior\", \"esuperior\", \"\", \"\", \"\", \"isuperior\", \"\", \"\", \"lsuperior\", \"msuperior\", \"nsuperior\", \"osuperior\", \"\", \"\", \"rsuperior\", \"ssuperior\", \"tsuperior\", \"\", \"ff\", \"fi\", \"fl\", \"ffi\", \"ffl\", \"parenleftinferior\", \"\", \"parenrightinferior\", \"Circumflexsmall\", \"hyphensuperior\", \"Gravesmall\", \"Asmall\", \"Bsmall\", \"Csmall\", \"Dsmall\", \"Esmall\", \"Fsmall\", \"Gsmall\", \"Hsmall\", \"Ismall\", \"Jsmall\", \"Ksmall\", \"Lsmall\", \"Msmall\", \"Nsmall\", \"Osmall\", \"Psmall\", \"Qsmall\", \"Rsmall\", \"Ssmall\", \"Tsmall\", \"Usmall\", \"Vsmall\", \"Wsmall\", \"Xsmall\", \"Ysmall\", \"Zsmall\", \"colonmonetary\", \"onefitted\", \"rupiah\", \"Tildesmall\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"exclamdownsmall\", \"centoldstyle\", \"Lslashsmall\", \"\", \"\", \"Scaronsmall\", \"Zcaronsmall\", \"Dieresissmall\", \"Brevesmall\", \"Caronsmall\", \"\", \"Dotaccentsmall\", \"\", \"\", \"Macronsmall\", \"\", \"\", \"figuredash\", \"hypheninferior\", \"\", \"\", \"Ogoneksmall\", \"Ringsmall\", \"Cedillasmall\", \"\", \"\", \"\", \"onequarter\", \"onehalf\", \"threequarters\", \"questiondownsmall\", \"oneeighth\", \"threeeighths\", \"fiveeighths\", \"seveneighths\", \"onethird\", \"twothirds\", \"\", \"\", \"zerosuperior\", \"onesuperior\", \"twosuperior\", \"threesuperior\", \"foursuperior\", \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"eightsuperior\", \"ninesuperior\", \"zeroinferior\", \"oneinferior\", \"twoinferior\", \"threeinferior\", \"fourinferior\", \"fiveinferior\", \"sixinferior\", \"seveninferior\", \"eightinferior\", \"nineinferior\", \"centinferior\", \"dollarinferior\", \"periodinferior\", \"commainferior\", \"Agravesmall\", \"Aacutesmall\", \"Acircumflexsmall\", \"Atildesmall\", \"Adieresissmall\", \"Aringsmall\", \"AEsmall\", \"Ccedillasmall\", \"Egravesmall\", \"Eacutesmall\", \"Ecircumflexsmall\", \"Edieresissmall\", \"Igravesmall\", \"Iacutesmall\", \"Icircumflexsmall\", \"Idieresissmall\", \"Ethsmall\", \"Ntildesmall\", \"Ogravesmall\", \"Oacutesmall\", \"Ocircumflexsmall\", \"Otildesmall\", \"Odieresissmall\", \"OEsmall\", \"Oslashsmall\", \"Ugravesmall\", \"Uacutesmall\", \"Ucircumflexsmall\", \"Udieresissmall\", \"Yacutesmall\", \"Thornsmall\", \"Ydieresissmall\"];\nconst MacExpertEncoding = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"space\", \"exclamsmall\", \"Hungarumlautsmall\", \"centoldstyle\", \"dollaroldstyle\", \"dollarsuperior\", \"ampersandsmall\", \"Acutesmall\", \"parenleftsuperior\", \"parenrightsuperior\", \"twodotenleader\", \"onedotenleader\", \"comma\", \"hyphen\", \"period\", \"fraction\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\", \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\", \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"colon\", \"semicolon\", \"\", \"threequartersemdash\", \"\", \"questionsmall\", \"\", \"\", \"\", \"\", \"Ethsmall\", \"\", \"\", \"onequarter\", \"onehalf\", \"threequarters\", \"oneeighth\", \"threeeighths\", \"fiveeighths\", \"seveneighths\", \"onethird\", \"twothirds\", \"\", \"\", \"\", \"\", \"\", \"\", \"ff\", \"fi\", \"fl\", \"ffi\", \"ffl\", \"parenleftinferior\", \"\", \"parenrightinferior\", \"Circumflexsmall\", \"hypheninferior\", \"Gravesmall\", \"Asmall\", \"Bsmall\", \"Csmall\", \"Dsmall\", \"Esmall\", \"Fsmall\", \"Gsmall\", \"Hsmall\", \"Ismall\", \"Jsmall\", \"Ksmall\", \"Lsmall\", \"Msmall\", \"Nsmall\", \"Osmall\", \"Psmall\", \"Qsmall\", \"Rsmall\", \"Ssmall\", \"Tsmall\", \"Usmall\", \"Vsmall\", \"Wsmall\", \"Xsmall\", \"Ysmall\", \"Zsmall\", \"colonmonetary\", \"onefitted\", \"rupiah\", \"Tildesmall\", \"\", \"\", \"asuperior\", \"centsuperior\", \"\", \"\", \"\", \"\", \"Aacutesmall\", \"Agravesmall\", \"Acircumflexsmall\", \"Adieresissmall\", \"Atildesmall\", \"Aringsmall\", \"Ccedillasmall\", \"Eacutesmall\", \"Egravesmall\", \"Ecircumflexsmall\", \"Edieresissmall\", \"Iacutesmall\", \"Igravesmall\", \"Icircumflexsmall\", \"Idieresissmall\", \"Ntildesmall\", \"Oacutesmall\", \"Ogravesmall\", \"Ocircumflexsmall\", \"Odieresissmall\", \"Otildesmall\", \"Uacutesmall\", \"Ugravesmall\", \"Ucircumflexsmall\", \"Udieresissmall\", \"\", \"eightsuperior\", \"fourinferior\", \"threeinferior\", \"sixinferior\", \"eightinferior\", \"seveninferior\", \"Scaronsmall\", \"\", \"centinferior\", \"twoinferior\", \"\", \"Dieresissmall\", \"\", \"Caronsmall\", \"osuperior\", \"fiveinferior\", \"\", \"commainferior\", \"periodinferior\", \"Yacutesmall\", \"\", \"dollarinferior\", \"\", \"\", \"Thornsmall\", \"\", \"nineinferior\", \"zeroinferior\", \"Zcaronsmall\", \"AEsmall\", \"Oslashsmall\", \"questiondownsmall\", \"oneinferior\", \"Lslashsmall\", \"\", \"\", \"\", \"\", \"\", \"\", \"Cedillasmall\", \"\", \"\", \"\", \"\", \"\", \"OEsmall\", \"figuredash\", \"hyphensuperior\", \"\", \"\", \"\", \"\", \"exclamdownsmall\", \"\", \"Ydieresissmall\", \"\", \"onesuperior\", \"twosuperior\", \"threesuperior\", \"foursuperior\", \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"ninesuperior\", \"zerosuperior\", \"\", \"esuperior\", \"rsuperior\", \"tsuperior\", \"\", \"\", \"isuperior\", \"ssuperior\", \"dsuperior\", \"\", \"\", \"\", \"\", \"\", \"lsuperior\", \"Ogoneksmall\", \"Brevesmall\", \"Macronsmall\", \"bsuperior\", \"nsuperior\", \"msuperior\", \"commasuperior\", \"periodsuperior\", \"Dotaccentsmall\", \"Ringsmall\", \"\", \"\", \"\", \"\"];\nconst MacRomanEncoding = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\", \"ampersand\", \"quotesingle\", \"parenleft\", \"parenright\", \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\", \"grave\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\", \"asciitilde\", \"\", \"Adieresis\", \"Aring\", \"Ccedilla\", \"Eacute\", \"Ntilde\", \"Odieresis\", \"Udieresis\", \"aacute\", \"agrave\", \"acircumflex\", \"adieresis\", \"atilde\", \"aring\", \"ccedilla\", \"eacute\", \"egrave\", \"ecircumflex\", \"edieresis\", \"iacute\", \"igrave\", \"icircumflex\", \"idieresis\", \"ntilde\", \"oacute\", \"ograve\", \"ocircumflex\", \"odieresis\", \"otilde\", \"uacute\", \"ugrave\", \"ucircumflex\", \"udieresis\", \"dagger\", \"degree\", \"cent\", \"sterling\", \"section\", \"bullet\", \"paragraph\", \"germandbls\", \"registered\", \"copyright\", \"trademark\", \"acute\", \"dieresis\", \"notequal\", \"AE\", \"Oslash\", \"infinity\", \"plusminus\", \"lessequal\", \"greaterequal\", \"yen\", \"mu\", \"partialdiff\", \"summation\", \"product\", \"pi\", \"integral\", \"ordfeminine\", \"ordmasculine\", \"Omega\", \"ae\", \"oslash\", \"questiondown\", \"exclamdown\", \"logicalnot\", \"radical\", \"florin\", \"approxequal\", \"Delta\", \"guillemotleft\", \"guillemotright\", \"ellipsis\", \"space\", \"Agrave\", \"Atilde\", \"Otilde\", \"OE\", \"oe\", \"endash\", \"emdash\", \"quotedblleft\", \"quotedblright\", \"quoteleft\", \"quoteright\", \"divide\", \"lozenge\", \"ydieresis\", \"Ydieresis\", \"fraction\", \"currency\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"daggerdbl\", \"periodcentered\", \"quotesinglbase\", \"quotedblbase\", \"perthousand\", \"Acircumflex\", \"Ecircumflex\", \"Aacute\", \"Edieresis\", \"Egrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\", \"Igrave\", \"Oacute\", \"Ocircumflex\", \"apple\", \"Ograve\", \"Uacute\", \"Ucircumflex\", \"Ugrave\", \"dotlessi\", \"circumflex\", \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"ring\", \"cedilla\", \"hungarumlaut\", \"ogonek\", \"caron\"];\nconst StandardEncoding = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\", \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\", \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\", \"quoteleft\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\", \"asciitilde\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\", \"florin\", \"section\", \"currency\", \"quotesingle\", \"quotedblleft\", \"guillemotleft\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"\", \"endash\", \"dagger\", \"daggerdbl\", \"periodcentered\", \"\", \"paragraph\", \"bullet\", \"quotesinglbase\", \"quotedblbase\", \"quotedblright\", \"guillemotright\", \"ellipsis\", \"perthousand\", \"\", \"questiondown\", \"\", \"grave\", \"acute\", \"circumflex\", \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"dieresis\", \"\", \"ring\", \"cedilla\", \"\", \"hungarumlaut\", \"ogonek\", \"caron\", \"emdash\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"AE\", \"\", \"ordfeminine\", \"\", \"\", \"\", \"\", \"Lslash\", \"Oslash\", \"OE\", \"ordmasculine\", \"\", \"\", \"\", \"\", \"\", \"ae\", \"\", \"\", \"\", \"dotlessi\", \"\", \"\", \"lslash\", \"oslash\", \"oe\", \"germandbls\", \"\", \"\", \"\", \"\"];\nconst WinAnsiEncoding = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\", \"ampersand\", \"quotesingle\", \"parenleft\", \"parenright\", \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\", \"grave\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\", \"asciitilde\", \"bullet\", \"Euro\", \"bullet\", \"quotesinglbase\", \"florin\", \"quotedblbase\", \"ellipsis\", \"dagger\", \"daggerdbl\", \"circumflex\", \"perthousand\", \"Scaron\", \"guilsinglleft\", \"OE\", \"bullet\", \"Zcaron\", \"bullet\", \"bullet\", \"quoteleft\", \"quoteright\", \"quotedblleft\", \"quotedblright\", \"bullet\", \"endash\", \"emdash\", \"tilde\", \"trademark\", \"scaron\", \"guilsinglright\", \"oe\", \"bullet\", \"zcaron\", \"Ydieresis\", \"space\", \"exclamdown\", \"cent\", \"sterling\", \"currency\", \"yen\", \"brokenbar\", \"section\", \"dieresis\", \"copyright\", \"ordfeminine\", \"guillemotleft\", \"logicalnot\", \"hyphen\", \"registered\", \"macron\", \"degree\", \"plusminus\", \"twosuperior\", \"threesuperior\", \"acute\", \"mu\", \"paragraph\", \"periodcentered\", \"cedilla\", \"onesuperior\", \"ordmasculine\", \"guillemotright\", \"onequarter\", \"onehalf\", \"threequarters\", \"questiondown\", \"Agrave\", \"Aacute\", \"Acircumflex\", \"Atilde\", \"Adieresis\", \"Aring\", \"AE\", \"Ccedilla\", \"Egrave\", \"Eacute\", \"Ecircumflex\", \"Edieresis\", \"Igrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\", \"Eth\", \"Ntilde\", \"Ograve\", \"Oacute\", \"Ocircumflex\", \"Otilde\", \"Odieresis\", \"multiply\", \"Oslash\", \"Ugrave\", \"Uacute\", \"Ucircumflex\", \"Udieresis\", \"Yacute\", \"Thorn\", \"germandbls\", \"agrave\", \"aacute\", \"acircumflex\", \"atilde\", \"adieresis\", \"aring\", \"ae\", \"ccedilla\", \"egrave\", \"eacute\", \"ecircumflex\", \"edieresis\", \"igrave\", \"iacute\", \"icircumflex\", \"idieresis\", \"eth\", \"ntilde\", \"ograve\", \"oacute\", \"ocircumflex\", \"otilde\", \"odieresis\", \"divide\", \"oslash\", \"ugrave\", \"uacute\", \"ucircumflex\", \"udieresis\", \"yacute\", \"thorn\", \"ydieresis\"];\nconst SymbolSetEncoding = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"space\", \"exclam\", \"universal\", \"numbersign\", \"existential\", \"percent\", \"ampersand\", \"suchthat\", \"parenleft\", \"parenright\", \"asteriskmath\", \"plus\", \"comma\", \"minus\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"congruent\", \"Alpha\", \"Beta\", \"Chi\", \"Delta\", \"Epsilon\", \"Phi\", \"Gamma\", \"Eta\", \"Iota\", \"theta1\", \"Kappa\", \"Lambda\", \"Mu\", \"Nu\", \"Omicron\", \"Pi\", \"Theta\", \"Rho\", \"Sigma\", \"Tau\", \"Upsilon\", \"sigma1\", \"Omega\", \"Xi\", \"Psi\", \"Zeta\", \"bracketleft\", \"therefore\", \"bracketright\", \"perpendicular\", \"underscore\", \"radicalex\", \"alpha\", \"beta\", \"chi\", \"delta\", \"epsilon\", \"phi\", \"gamma\", \"eta\", \"iota\", \"phi1\", \"kappa\", \"lambda\", \"mu\", \"nu\", \"omicron\", \"pi\", \"theta\", \"rho\", \"sigma\", \"tau\", \"upsilon\", \"omega1\", \"omega\", \"xi\", \"psi\", \"zeta\", \"braceleft\", \"bar\", \"braceright\", \"similar\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"Euro\", \"Upsilon1\", \"minute\", \"lessequal\", \"fraction\", \"infinity\", \"florin\", \"club\", \"diamond\", \"heart\", \"spade\", \"arrowboth\", \"arrowleft\", \"arrowup\", \"arrowright\", \"arrowdown\", \"degree\", \"plusminus\", \"second\", \"greaterequal\", \"multiply\", \"proportional\", \"partialdiff\", \"bullet\", \"divide\", \"notequal\", \"equivalence\", \"approxequal\", \"ellipsis\", \"arrowvertex\", \"arrowhorizex\", \"carriagereturn\", \"aleph\", \"Ifraktur\", \"Rfraktur\", \"weierstrass\", \"circlemultiply\", \"circleplus\", \"emptyset\", \"intersection\", \"union\", \"propersuperset\", \"reflexsuperset\", \"notsubset\", \"propersubset\", \"reflexsubset\", \"element\", \"notelement\", \"angle\", \"gradient\", \"registerserif\", \"copyrightserif\", \"trademarkserif\", \"product\", \"radical\", \"dotmath\", \"logicalnot\", \"logicaland\", \"logicalor\", \"arrowdblboth\", \"arrowdblleft\", \"arrowdblup\", \"arrowdblright\", \"arrowdbldown\", \"lozenge\", \"angleleft\", \"registersans\", \"copyrightsans\", \"trademarksans\", \"summation\", \"parenlefttp\", \"parenleftex\", \"parenleftbt\", \"bracketlefttp\", \"bracketleftex\", \"bracketleftbt\", \"bracelefttp\", \"braceleftmid\", \"braceleftbt\", \"braceex\", \"\", \"angleright\", \"integral\", \"integraltp\", \"integralex\", \"integralbt\", \"parenrighttp\", \"parenrightex\", \"parenrightbt\", \"bracketrighttp\", \"bracketrightex\", \"bracketrightbt\", \"bracerighttp\", \"bracerightmid\", \"bracerightbt\", \"\"];\nconst ZapfDingbatsEncoding = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"space\", \"a1\", \"a2\", \"a202\", \"a3\", \"a4\", \"a5\", \"a119\", \"a118\", \"a117\", \"a11\", \"a12\", \"a13\", \"a14\", \"a15\", \"a16\", \"a105\", \"a17\", \"a18\", \"a19\", \"a20\", \"a21\", \"a22\", \"a23\", \"a24\", \"a25\", \"a26\", \"a27\", \"a28\", \"a6\", \"a7\", \"a8\", \"a9\", \"a10\", \"a29\", \"a30\", \"a31\", \"a32\", \"a33\", \"a34\", \"a35\", \"a36\", \"a37\", \"a38\", \"a39\", \"a40\", \"a41\", \"a42\", \"a43\", \"a44\", \"a45\", \"a46\", \"a47\", \"a48\", \"a49\", \"a50\", \"a51\", \"a52\", \"a53\", \"a54\", \"a55\", \"a56\", \"a57\", \"a58\", \"a59\", \"a60\", \"a61\", \"a62\", \"a63\", \"a64\", \"a65\", \"a66\", \"a67\", \"a68\", \"a69\", \"a70\", \"a71\", \"a72\", \"a73\", \"a74\", \"a203\", \"a75\", \"a204\", \"a76\", \"a77\", \"a78\", \"a79\", \"a81\", \"a82\", \"a83\", \"a84\", \"a97\", \"a98\", \"a99\", \"a100\", \"\", \"a89\", \"a90\", \"a93\", \"a94\", \"a91\", \"a92\", \"a205\", \"a85\", \"a206\", \"a86\", \"a87\", \"a88\", \"a95\", \"a96\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"a101\", \"a102\", \"a103\", \"a104\", \"a106\", \"a107\", \"a108\", \"a112\", \"a111\", \"a110\", \"a109\", \"a120\", \"a121\", \"a122\", \"a123\", \"a124\", \"a125\", \"a126\", \"a127\", \"a128\", \"a129\", \"a130\", \"a131\", \"a132\", \"a133\", \"a134\", \"a135\", \"a136\", \"a137\", \"a138\", \"a139\", \"a140\", \"a141\", \"a142\", \"a143\", \"a144\", \"a145\", \"a146\", \"a147\", \"a148\", \"a149\", \"a150\", \"a151\", \"a152\", \"a153\", \"a154\", \"a155\", \"a156\", \"a157\", \"a158\", \"a159\", \"a160\", \"a161\", \"a163\", \"a164\", \"a196\", \"a165\", \"a192\", \"a166\", \"a167\", \"a168\", \"a169\", \"a170\", \"a171\", \"a172\", \"a173\", \"a162\", \"a174\", \"a175\", \"a176\", \"a177\", \"a178\", \"a179\", \"a193\", \"a180\", \"a199\", \"a181\", \"a200\", \"a182\", \"\", \"a201\", \"a183\", \"a184\", \"a197\", \"a185\", \"a194\", \"a198\", \"a186\", \"a195\", \"a187\", \"a188\", \"a189\", \"a190\", \"a191\", \"\"];\nfunction getEncoding(encodingName) {\n  switch (encodingName) {\n    case \"WinAnsiEncoding\":\n      return WinAnsiEncoding;\n    case \"StandardEncoding\":\n      return StandardEncoding;\n    case \"MacRomanEncoding\":\n      return MacRomanEncoding;\n    case \"SymbolSetEncoding\":\n      return SymbolSetEncoding;\n    case \"ZapfDingbatsEncoding\":\n      return ZapfDingbatsEncoding;\n    case \"ExpertEncoding\":\n      return ExpertEncoding;\n    case \"MacExpertEncoding\":\n      return MacExpertEncoding;\n    default:\n      return null;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/cff_parser.js\n\n\n\nconst MAX_SUBR_NESTING = 10;\nconst CFFStandardStrings = [\".notdef\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\", \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\", \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\", \"quoteleft\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\", \"asciitilde\", \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\", \"florin\", \"section\", \"currency\", \"quotesingle\", \"quotedblleft\", \"guillemotleft\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"endash\", \"dagger\", \"daggerdbl\", \"periodcentered\", \"paragraph\", \"bullet\", \"quotesinglbase\", \"quotedblbase\", \"quotedblright\", \"guillemotright\", \"ellipsis\", \"perthousand\", \"questiondown\", \"grave\", \"acute\", \"circumflex\", \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"dieresis\", \"ring\", \"cedilla\", \"hungarumlaut\", \"ogonek\", \"caron\", \"emdash\", \"AE\", \"ordfeminine\", \"Lslash\", \"Oslash\", \"OE\", \"ordmasculine\", \"ae\", \"dotlessi\", \"lslash\", \"oslash\", \"oe\", \"germandbls\", \"onesuperior\", \"logicalnot\", \"mu\", \"trademark\", \"Eth\", \"onehalf\", \"plusminus\", \"Thorn\", \"onequarter\", \"divide\", \"brokenbar\", \"degree\", \"thorn\", \"threequarters\", \"twosuperior\", \"registered\", \"minus\", \"eth\", \"multiply\", \"threesuperior\", \"copyright\", \"Aacute\", \"Acircumflex\", \"Adieresis\", \"Agrave\", \"Aring\", \"Atilde\", \"Ccedilla\", \"Eacute\", \"Ecircumflex\", \"Edieresis\", \"Egrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\", \"Igrave\", \"Ntilde\", \"Oacute\", \"Ocircumflex\", \"Odieresis\", \"Ograve\", \"Otilde\", \"Scaron\", \"Uacute\", \"Ucircumflex\", \"Udieresis\", \"Ugrave\", \"Yacute\", \"Ydieresis\", \"Zcaron\", \"aacute\", \"acircumflex\", \"adieresis\", \"agrave\", \"aring\", \"atilde\", \"ccedilla\", \"eacute\", \"ecircumflex\", \"edieresis\", \"egrave\", \"iacute\", \"icircumflex\", \"idieresis\", \"igrave\", \"ntilde\", \"oacute\", \"ocircumflex\", \"odieresis\", \"ograve\", \"otilde\", \"scaron\", \"uacute\", \"ucircumflex\", \"udieresis\", \"ugrave\", \"yacute\", \"ydieresis\", \"zcaron\", \"exclamsmall\", \"Hungarumlautsmall\", \"dollaroldstyle\", \"dollarsuperior\", \"ampersandsmall\", \"Acutesmall\", \"parenleftsuperior\", \"parenrightsuperior\", \"twodotenleader\", \"onedotenleader\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\", \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\", \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"commasuperior\", \"threequartersemdash\", \"periodsuperior\", \"questionsmall\", \"asuperior\", \"bsuperior\", \"centsuperior\", \"dsuperior\", \"esuperior\", \"isuperior\", \"lsuperior\", \"msuperior\", \"nsuperior\", \"osuperior\", \"rsuperior\", \"ssuperior\", \"tsuperior\", \"ff\", \"ffi\", \"ffl\", \"parenleftinferior\", \"parenrightinferior\", \"Circumflexsmall\", \"hyphensuperior\", \"Gravesmall\", \"Asmall\", \"Bsmall\", \"Csmall\", \"Dsmall\", \"Esmall\", \"Fsmall\", \"Gsmall\", \"Hsmall\", \"Ismall\", \"Jsmall\", \"Ksmall\", \"Lsmall\", \"Msmall\", \"Nsmall\", \"Osmall\", \"Psmall\", \"Qsmall\", \"Rsmall\", \"Ssmall\", \"Tsmall\", \"Usmall\", \"Vsmall\", \"Wsmall\", \"Xsmall\", \"Ysmall\", \"Zsmall\", \"colonmonetary\", \"onefitted\", \"rupiah\", \"Tildesmall\", \"exclamdownsmall\", \"centoldstyle\", \"Lslashsmall\", \"Scaronsmall\", \"Zcaronsmall\", \"Dieresissmall\", \"Brevesmall\", \"Caronsmall\", \"Dotaccentsmall\", \"Macronsmall\", \"figuredash\", \"hypheninferior\", \"Ogoneksmall\", \"Ringsmall\", \"Cedillasmall\", \"questiondownsmall\", \"oneeighth\", \"threeeighths\", \"fiveeighths\", \"seveneighths\", \"onethird\", \"twothirds\", \"zerosuperior\", \"foursuperior\", \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"eightsuperior\", \"ninesuperior\", \"zeroinferior\", \"oneinferior\", \"twoinferior\", \"threeinferior\", \"fourinferior\", \"fiveinferior\", \"sixinferior\", \"seveninferior\", \"eightinferior\", \"nineinferior\", \"centinferior\", \"dollarinferior\", \"periodinferior\", \"commainferior\", \"Agravesmall\", \"Aacutesmall\", \"Acircumflexsmall\", \"Atildesmall\", \"Adieresissmall\", \"Aringsmall\", \"AEsmall\", \"Ccedillasmall\", \"Egravesmall\", \"Eacutesmall\", \"Ecircumflexsmall\", \"Edieresissmall\", \"Igravesmall\", \"Iacutesmall\", \"Icircumflexsmall\", \"Idieresissmall\", \"Ethsmall\", \"Ntildesmall\", \"Ogravesmall\", \"Oacutesmall\", \"Ocircumflexsmall\", \"Otildesmall\", \"Odieresissmall\", \"OEsmall\", \"Oslashsmall\", \"Ugravesmall\", \"Uacutesmall\", \"Ucircumflexsmall\", \"Udieresissmall\", \"Yacutesmall\", \"Thornsmall\", \"Ydieresissmall\", \"001.000\", \"001.001\", \"001.002\", \"001.003\", \"Black\", \"Bold\", \"Book\", \"Light\", \"Medium\", \"Regular\", \"Roman\", \"Semibold\"];\nconst NUM_STANDARD_CFF_STRINGS = 391;\nconst CharstringValidationData = [null, {\n  id: \"hstem\",\n  min: 2,\n  stackClearing: true,\n  stem: true\n}, null, {\n  id: \"vstem\",\n  min: 2,\n  stackClearing: true,\n  stem: true\n}, {\n  id: \"vmoveto\",\n  min: 1,\n  stackClearing: true\n}, {\n  id: \"rlineto\",\n  min: 2,\n  resetStack: true\n}, {\n  id: \"hlineto\",\n  min: 1,\n  resetStack: true\n}, {\n  id: \"vlineto\",\n  min: 1,\n  resetStack: true\n}, {\n  id: \"rrcurveto\",\n  min: 6,\n  resetStack: true\n}, null, {\n  id: \"callsubr\",\n  min: 1,\n  undefStack: true\n}, {\n  id: \"return\",\n  min: 0,\n  undefStack: true\n}, null, null, {\n  id: \"endchar\",\n  min: 0,\n  stackClearing: true\n}, null, null, null, {\n  id: \"hstemhm\",\n  min: 2,\n  stackClearing: true,\n  stem: true\n}, {\n  id: \"hintmask\",\n  min: 0,\n  stackClearing: true\n}, {\n  id: \"cntrmask\",\n  min: 0,\n  stackClearing: true\n}, {\n  id: \"rmoveto\",\n  min: 2,\n  stackClearing: true\n}, {\n  id: \"hmoveto\",\n  min: 1,\n  stackClearing: true\n}, {\n  id: \"vstemhm\",\n  min: 2,\n  stackClearing: true,\n  stem: true\n}, {\n  id: \"rcurveline\",\n  min: 8,\n  resetStack: true\n}, {\n  id: \"rlinecurve\",\n  min: 8,\n  resetStack: true\n}, {\n  id: \"vvcurveto\",\n  min: 4,\n  resetStack: true\n}, {\n  id: \"hhcurveto\",\n  min: 4,\n  resetStack: true\n}, null, {\n  id: \"callgsubr\",\n  min: 1,\n  undefStack: true\n}, {\n  id: \"vhcurveto\",\n  min: 4,\n  resetStack: true\n}, {\n  id: \"hvcurveto\",\n  min: 4,\n  resetStack: true\n}];\nconst CharstringValidationData12 = [null, null, null, {\n  id: \"and\",\n  min: 2,\n  stackDelta: -1\n}, {\n  id: \"or\",\n  min: 2,\n  stackDelta: -1\n}, {\n  id: \"not\",\n  min: 1,\n  stackDelta: 0\n}, null, null, null, {\n  id: \"abs\",\n  min: 1,\n  stackDelta: 0\n}, {\n  id: \"add\",\n  min: 2,\n  stackDelta: -1,\n  stackFn(stack, index) {\n    stack[index - 2] = stack[index - 2] + stack[index - 1];\n  }\n}, {\n  id: \"sub\",\n  min: 2,\n  stackDelta: -1,\n  stackFn(stack, index) {\n    stack[index - 2] = stack[index - 2] - stack[index - 1];\n  }\n}, {\n  id: \"div\",\n  min: 2,\n  stackDelta: -1,\n  stackFn(stack, index) {\n    stack[index - 2] = stack[index - 2] / stack[index - 1];\n  }\n}, null, {\n  id: \"neg\",\n  min: 1,\n  stackDelta: 0,\n  stackFn(stack, index) {\n    stack[index - 1] = -stack[index - 1];\n  }\n}, {\n  id: \"eq\",\n  min: 2,\n  stackDelta: -1\n}, null, null, {\n  id: \"drop\",\n  min: 1,\n  stackDelta: -1\n}, null, {\n  id: \"put\",\n  min: 2,\n  stackDelta: -2\n}, {\n  id: \"get\",\n  min: 1,\n  stackDelta: 0\n}, {\n  id: \"ifelse\",\n  min: 4,\n  stackDelta: -3\n}, {\n  id: \"random\",\n  min: 0,\n  stackDelta: 1\n}, {\n  id: \"mul\",\n  min: 2,\n  stackDelta: -1,\n  stackFn(stack, index) {\n    stack[index - 2] = stack[index - 2] * stack[index - 1];\n  }\n}, null, {\n  id: \"sqrt\",\n  min: 1,\n  stackDelta: 0\n}, {\n  id: \"dup\",\n  min: 1,\n  stackDelta: 1\n}, {\n  id: \"exch\",\n  min: 2,\n  stackDelta: 0\n}, {\n  id: \"index\",\n  min: 2,\n  stackDelta: 0\n}, {\n  id: \"roll\",\n  min: 3,\n  stackDelta: -2\n}, null, null, null, {\n  id: \"hflex\",\n  min: 7,\n  resetStack: true\n}, {\n  id: \"flex\",\n  min: 13,\n  resetStack: true\n}, {\n  id: \"hflex1\",\n  min: 9,\n  resetStack: true\n}, {\n  id: \"flex1\",\n  min: 11,\n  resetStack: true\n}];\nclass CFFParser {\n  constructor(file, properties, seacAnalysisEnabled) {\n    this.bytes = file.getBytes();\n    this.properties = properties;\n    this.seacAnalysisEnabled = !!seacAnalysisEnabled;\n  }\n  parse() {\n    const properties = this.properties;\n    const cff = new CFF();\n    this.cff = cff;\n    const header = this.parseHeader();\n    const nameIndex = this.parseIndex(header.endPos);\n    const topDictIndex = this.parseIndex(nameIndex.endPos);\n    const stringIndex = this.parseIndex(topDictIndex.endPos);\n    const globalSubrIndex = this.parseIndex(stringIndex.endPos);\n    const topDictParsed = this.parseDict(topDictIndex.obj.get(0));\n    const topDict = this.createDict(CFFTopDict, topDictParsed, cff.strings);\n    cff.header = header.obj;\n    cff.names = this.parseNameIndex(nameIndex.obj);\n    cff.strings = this.parseStringIndex(stringIndex.obj);\n    cff.topDict = topDict;\n    cff.globalSubrIndex = globalSubrIndex.obj;\n    this.parsePrivateDict(cff.topDict);\n    cff.isCIDFont = topDict.hasName(\"ROS\");\n    const charStringOffset = topDict.getByName(\"CharStrings\");\n    const charStringIndex = this.parseIndex(charStringOffset).obj;\n    const fontMatrix = topDict.getByName(\"FontMatrix\");\n    if (fontMatrix) {\n      properties.fontMatrix = fontMatrix;\n    }\n    const fontBBox = topDict.getByName(\"FontBBox\");\n    if (fontBBox) {\n      properties.ascent = Math.max(fontBBox[3], fontBBox[1]);\n      properties.descent = Math.min(fontBBox[1], fontBBox[3]);\n      properties.ascentScaled = true;\n    }\n    let charset, encoding;\n    if (cff.isCIDFont) {\n      const fdArrayIndex = this.parseIndex(topDict.getByName(\"FDArray\")).obj;\n      for (let i = 0, ii = fdArrayIndex.count; i < ii; ++i) {\n        const dictRaw = fdArrayIndex.get(i);\n        const fontDict = this.createDict(CFFTopDict, this.parseDict(dictRaw), cff.strings);\n        this.parsePrivateDict(fontDict);\n        cff.fdArray.push(fontDict);\n      }\n      encoding = null;\n      charset = this.parseCharsets(topDict.getByName(\"charset\"), charStringIndex.count, cff.strings, true);\n      cff.fdSelect = this.parseFDSelect(topDict.getByName(\"FDSelect\"), charStringIndex.count);\n    } else {\n      charset = this.parseCharsets(topDict.getByName(\"charset\"), charStringIndex.count, cff.strings, false);\n      encoding = this.parseEncoding(topDict.getByName(\"Encoding\"), properties, cff.strings, charset.charset);\n    }\n    cff.charset = charset;\n    cff.encoding = encoding;\n    const charStringsAndSeacs = this.parseCharStrings({\n      charStrings: charStringIndex,\n      localSubrIndex: topDict.privateDict.subrsIndex,\n      globalSubrIndex: globalSubrIndex.obj,\n      fdSelect: cff.fdSelect,\n      fdArray: cff.fdArray,\n      privateDict: topDict.privateDict\n    });\n    cff.charStrings = charStringsAndSeacs.charStrings;\n    cff.seacs = charStringsAndSeacs.seacs;\n    cff.widths = charStringsAndSeacs.widths;\n    return cff;\n  }\n  parseHeader() {\n    let bytes = this.bytes;\n    const bytesLength = bytes.length;\n    let offset = 0;\n    while (offset < bytesLength && bytes[offset] !== 1) {\n      ++offset;\n    }\n    if (offset >= bytesLength) {\n      throw new FormatError(\"Invalid CFF header\");\n    }\n    if (offset !== 0) {\n      info(\"cff data is shifted\");\n      bytes = bytes.subarray(offset);\n      this.bytes = bytes;\n    }\n    const major = bytes[0];\n    const minor = bytes[1];\n    const hdrSize = bytes[2];\n    const offSize = bytes[3];\n    const header = new CFFHeader(major, minor, hdrSize, offSize);\n    return {\n      obj: header,\n      endPos: hdrSize\n    };\n  }\n  parseDict(dict) {\n    let pos = 0;\n    function parseOperand() {\n      let value = dict[pos++];\n      if (value === 30) {\n        return parseFloatOperand();\n      } else if (value === 28) {\n        value = dict[pos++];\n        value = (value << 24 | dict[pos++] << 16) >> 16;\n        return value;\n      } else if (value === 29) {\n        value = dict[pos++];\n        value = value << 8 | dict[pos++];\n        value = value << 8 | dict[pos++];\n        value = value << 8 | dict[pos++];\n        return value;\n      } else if (value >= 32 && value <= 246) {\n        return value - 139;\n      } else if (value >= 247 && value <= 250) {\n        return (value - 247) * 256 + dict[pos++] + 108;\n      } else if (value >= 251 && value <= 254) {\n        return -((value - 251) * 256) - dict[pos++] - 108;\n      }\n      warn('CFFParser_parseDict: \"' + value + '\" is a reserved command.');\n      return NaN;\n    }\n    function parseFloatOperand() {\n      let str = \"\";\n      const eof = 15;\n      const lookup = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \".\", \"E\", \"E-\", null, \"-\"];\n      const length = dict.length;\n      while (pos < length) {\n        const b = dict[pos++];\n        const b1 = b >> 4;\n        const b2 = b & 15;\n        if (b1 === eof) {\n          break;\n        }\n        str += lookup[b1];\n        if (b2 === eof) {\n          break;\n        }\n        str += lookup[b2];\n      }\n      return parseFloat(str);\n    }\n    let operands = [];\n    const entries = [];\n    pos = 0;\n    const end = dict.length;\n    while (pos < end) {\n      let b = dict[pos];\n      if (b <= 21) {\n        if (b === 12) {\n          b = b << 8 | dict[++pos];\n        }\n        entries.push([b, operands]);\n        operands = [];\n        ++pos;\n      } else {\n        operands.push(parseOperand());\n      }\n    }\n    return entries;\n  }\n  parseIndex(pos) {\n    const cffIndex = new CFFIndex();\n    const bytes = this.bytes;\n    const count = bytes[pos++] << 8 | bytes[pos++];\n    const offsets = [];\n    let end = pos;\n    let i, ii;\n    if (count !== 0) {\n      const offsetSize = bytes[pos++];\n      const startPos = pos + (count + 1) * offsetSize - 1;\n      for (i = 0, ii = count + 1; i < ii; ++i) {\n        let offset = 0;\n        for (let j = 0; j < offsetSize; ++j) {\n          offset <<= 8;\n          offset += bytes[pos++];\n        }\n        offsets.push(startPos + offset);\n      }\n      end = offsets[count];\n    }\n    for (i = 0, ii = offsets.length - 1; i < ii; ++i) {\n      const offsetStart = offsets[i];\n      const offsetEnd = offsets[i + 1];\n      cffIndex.add(bytes.subarray(offsetStart, offsetEnd));\n    }\n    return {\n      obj: cffIndex,\n      endPos: end\n    };\n  }\n  parseNameIndex(index) {\n    const names = [];\n    for (let i = 0, ii = index.count; i < ii; ++i) {\n      const name = index.get(i);\n      names.push(bytesToString(name));\n    }\n    return names;\n  }\n  parseStringIndex(index) {\n    const strings = new CFFStrings();\n    for (let i = 0, ii = index.count; i < ii; ++i) {\n      const data = index.get(i);\n      strings.add(bytesToString(data));\n    }\n    return strings;\n  }\n  createDict(Type, dict, strings) {\n    const cffDict = new Type(strings);\n    for (const [key, value] of dict) {\n      cffDict.setByKey(key, value);\n    }\n    return cffDict;\n  }\n  parseCharString(state, data, localSubrIndex, globalSubrIndex) {\n    if (!data || state.callDepth > MAX_SUBR_NESTING) {\n      return false;\n    }\n    let stackSize = state.stackSize;\n    const stack = state.stack;\n    let length = data.length;\n    for (let j = 0; j < length;) {\n      const value = data[j++];\n      let validationCommand = null;\n      if (value === 12) {\n        const q = data[j++];\n        if (q === 0) {\n          data[j - 2] = 139;\n          data[j - 1] = 22;\n          stackSize = 0;\n        } else {\n          validationCommand = CharstringValidationData12[q];\n        }\n      } else if (value === 28) {\n        stack[stackSize] = (data[j] << 24 | data[j + 1] << 16) >> 16;\n        j += 2;\n        stackSize++;\n      } else if (value === 14) {\n        if (stackSize >= 4) {\n          stackSize -= 4;\n          if (this.seacAnalysisEnabled) {\n            state.seac = stack.slice(stackSize, stackSize + 4);\n            return false;\n          }\n        }\n        validationCommand = CharstringValidationData[value];\n      } else if (value >= 32 && value <= 246) {\n        stack[stackSize] = value - 139;\n        stackSize++;\n      } else if (value >= 247 && value <= 254) {\n        stack[stackSize] = value < 251 ? (value - 247 << 8) + data[j] + 108 : -(value - 251 << 8) - data[j] - 108;\n        j++;\n        stackSize++;\n      } else if (value === 255) {\n        stack[stackSize] = (data[j] << 24 | data[j + 1] << 16 | data[j + 2] << 8 | data[j + 3]) / 65536;\n        j += 4;\n        stackSize++;\n      } else if (value === 19 || value === 20) {\n        state.hints += stackSize >> 1;\n        if (state.hints === 0) {\n          data.copyWithin(j - 1, j, -1);\n          j -= 1;\n          length -= 1;\n          continue;\n        }\n        j += state.hints + 7 >> 3;\n        stackSize %= 2;\n        validationCommand = CharstringValidationData[value];\n      } else if (value === 10 || value === 29) {\n        const subrsIndex = value === 10 ? localSubrIndex : globalSubrIndex;\n        if (!subrsIndex) {\n          validationCommand = CharstringValidationData[value];\n          warn(\"Missing subrsIndex for \" + validationCommand.id);\n          return false;\n        }\n        let bias = 32768;\n        if (subrsIndex.count < 1240) {\n          bias = 107;\n        } else if (subrsIndex.count < 33900) {\n          bias = 1131;\n        }\n        const subrNumber = stack[--stackSize] + bias;\n        if (subrNumber < 0 || subrNumber >= subrsIndex.count || isNaN(subrNumber)) {\n          validationCommand = CharstringValidationData[value];\n          warn(\"Out of bounds subrIndex for \" + validationCommand.id);\n          return false;\n        }\n        state.stackSize = stackSize;\n        state.callDepth++;\n        const valid = this.parseCharString(state, subrsIndex.get(subrNumber), localSubrIndex, globalSubrIndex);\n        if (!valid) {\n          return false;\n        }\n        state.callDepth--;\n        stackSize = state.stackSize;\n        continue;\n      } else if (value === 11) {\n        state.stackSize = stackSize;\n        return true;\n      } else if (value === 0 && j === data.length) {\n        data[j - 1] = 14;\n        validationCommand = CharstringValidationData[14];\n      } else if (value === 9) {\n        data.copyWithin(j - 1, j, -1);\n        j -= 1;\n        length -= 1;\n        continue;\n      } else {\n        validationCommand = CharstringValidationData[value];\n      }\n      if (validationCommand) {\n        if (validationCommand.stem) {\n          state.hints += stackSize >> 1;\n          if (value === 3 || value === 23) {\n            state.hasVStems = true;\n          } else if (state.hasVStems && (value === 1 || value === 18)) {\n            warn(\"CFF stem hints are in wrong order\");\n            data[j - 1] = value === 1 ? 3 : 23;\n          }\n        }\n        if (\"min\" in validationCommand) {\n          if (!state.undefStack && stackSize < validationCommand.min) {\n            warn(\"Not enough parameters for \" + validationCommand.id + \"; actual: \" + stackSize + \", expected: \" + validationCommand.min);\n            if (stackSize === 0) {\n              data[j - 1] = 14;\n              return true;\n            }\n            return false;\n          }\n        }\n        if (state.firstStackClearing && validationCommand.stackClearing) {\n          state.firstStackClearing = false;\n          stackSize -= validationCommand.min;\n          if (stackSize >= 2 && validationCommand.stem) {\n            stackSize %= 2;\n          } else if (stackSize > 1) {\n            warn(\"Found too many parameters for stack-clearing command\");\n          }\n          if (stackSize > 0) {\n            state.width = stack[stackSize - 1];\n          }\n        }\n        if (\"stackDelta\" in validationCommand) {\n          if (\"stackFn\" in validationCommand) {\n            validationCommand.stackFn(stack, stackSize);\n          }\n          stackSize += validationCommand.stackDelta;\n        } else if (validationCommand.stackClearing) {\n          stackSize = 0;\n        } else if (validationCommand.resetStack) {\n          stackSize = 0;\n          state.undefStack = false;\n        } else if (validationCommand.undefStack) {\n          stackSize = 0;\n          state.undefStack = true;\n          state.firstStackClearing = false;\n        }\n      }\n    }\n    if (length < data.length) {\n      data.fill(14, length);\n    }\n    state.stackSize = stackSize;\n    return true;\n  }\n  parseCharStrings({\n    charStrings,\n    localSubrIndex,\n    globalSubrIndex,\n    fdSelect,\n    fdArray,\n    privateDict\n  }) {\n    const seacs = [];\n    const widths = [];\n    const count = charStrings.count;\n    for (let i = 0; i < count; i++) {\n      const charstring = charStrings.get(i);\n      const state = {\n        callDepth: 0,\n        stackSize: 0,\n        stack: [],\n        undefStack: true,\n        hints: 0,\n        firstStackClearing: true,\n        seac: null,\n        width: null,\n        hasVStems: false\n      };\n      let valid = true;\n      let localSubrToUse = null;\n      let privateDictToUse = privateDict;\n      if (fdSelect && fdArray.length) {\n        const fdIndex = fdSelect.getFDIndex(i);\n        if (fdIndex === -1) {\n          warn(\"Glyph index is not in fd select.\");\n          valid = false;\n        }\n        if (fdIndex >= fdArray.length) {\n          warn(\"Invalid fd index for glyph index.\");\n          valid = false;\n        }\n        if (valid) {\n          privateDictToUse = fdArray[fdIndex].privateDict;\n          localSubrToUse = privateDictToUse.subrsIndex;\n        }\n      } else if (localSubrIndex) {\n        localSubrToUse = localSubrIndex;\n      }\n      if (valid) {\n        valid = this.parseCharString(state, charstring, localSubrToUse, globalSubrIndex);\n      }\n      if (state.width !== null) {\n        const nominalWidth = privateDictToUse.getByName(\"nominalWidthX\");\n        widths[i] = nominalWidth + state.width;\n      } else {\n        const defaultWidth = privateDictToUse.getByName(\"defaultWidthX\");\n        widths[i] = defaultWidth;\n      }\n      if (state.seac !== null) {\n        seacs[i] = state.seac;\n      }\n      if (!valid) {\n        charStrings.set(i, new Uint8Array([14]));\n      }\n    }\n    return {\n      charStrings,\n      seacs,\n      widths\n    };\n  }\n  emptyPrivateDictionary(parentDict) {\n    const privateDict = this.createDict(CFFPrivateDict, [], parentDict.strings);\n    parentDict.setByKey(18, [0, 0]);\n    parentDict.privateDict = privateDict;\n  }\n  parsePrivateDict(parentDict) {\n    if (!parentDict.hasName(\"Private\")) {\n      this.emptyPrivateDictionary(parentDict);\n      return;\n    }\n    const privateOffset = parentDict.getByName(\"Private\");\n    if (!Array.isArray(privateOffset) || privateOffset.length !== 2) {\n      parentDict.removeByName(\"Private\");\n      return;\n    }\n    const size = privateOffset[0];\n    const offset = privateOffset[1];\n    if (size === 0 || offset >= this.bytes.length) {\n      this.emptyPrivateDictionary(parentDict);\n      return;\n    }\n    const privateDictEnd = offset + size;\n    const dictData = this.bytes.subarray(offset, privateDictEnd);\n    const dict = this.parseDict(dictData);\n    const privateDict = this.createDict(CFFPrivateDict, dict, parentDict.strings);\n    parentDict.privateDict = privateDict;\n    if (privateDict.getByName(\"ExpansionFactor\") === 0) {\n      privateDict.setByName(\"ExpansionFactor\", 0.06);\n    }\n    if (!privateDict.getByName(\"Subrs\")) {\n      return;\n    }\n    const subrsOffset = privateDict.getByName(\"Subrs\");\n    const relativeOffset = offset + subrsOffset;\n    if (subrsOffset === 0 || relativeOffset >= this.bytes.length) {\n      this.emptyPrivateDictionary(parentDict);\n      return;\n    }\n    const subrsIndex = this.parseIndex(relativeOffset);\n    privateDict.subrsIndex = subrsIndex.obj;\n  }\n  parseCharsets(pos, length, strings, cid) {\n    if (pos === 0) {\n      return new CFFCharset(true, CFFCharsetPredefinedTypes.ISO_ADOBE, ISOAdobeCharset);\n    } else if (pos === 1) {\n      return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT, ExpertCharset);\n    } else if (pos === 2) {\n      return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT_SUBSET, ExpertSubsetCharset);\n    }\n    const bytes = this.bytes;\n    const start = pos;\n    const format = bytes[pos++];\n    const charset = [cid ? 0 : \".notdef\"];\n    let id, count, i;\n    length -= 1;\n    switch (format) {\n      case 0:\n        for (i = 0; i < length; i++) {\n          id = bytes[pos++] << 8 | bytes[pos++];\n          charset.push(cid ? id : strings.get(id));\n        }\n        break;\n      case 1:\n        while (charset.length <= length) {\n          id = bytes[pos++] << 8 | bytes[pos++];\n          count = bytes[pos++];\n          for (i = 0; i <= count; i++) {\n            charset.push(cid ? id++ : strings.get(id++));\n          }\n        }\n        break;\n      case 2:\n        while (charset.length <= length) {\n          id = bytes[pos++] << 8 | bytes[pos++];\n          count = bytes[pos++] << 8 | bytes[pos++];\n          for (i = 0; i <= count; i++) {\n            charset.push(cid ? id++ : strings.get(id++));\n          }\n        }\n        break;\n      default:\n        throw new FormatError(\"Unknown charset format\");\n    }\n    const end = pos;\n    const raw = bytes.subarray(start, end);\n    return new CFFCharset(false, format, charset, raw);\n  }\n  parseEncoding(pos, properties, strings, charset) {\n    const encoding = Object.create(null);\n    const bytes = this.bytes;\n    let predefined = false;\n    let format, i, ii;\n    let raw = null;\n    function readSupplement() {\n      const supplementsCount = bytes[pos++];\n      for (i = 0; i < supplementsCount; i++) {\n        const code = bytes[pos++];\n        const sid = (bytes[pos++] << 8) + (bytes[pos++] & 0xff);\n        encoding[code] = charset.indexOf(strings.get(sid));\n      }\n    }\n    if (pos === 0 || pos === 1) {\n      predefined = true;\n      format = pos;\n      const baseEncoding = pos ? ExpertEncoding : StandardEncoding;\n      for (i = 0, ii = charset.length; i < ii; i++) {\n        const index = baseEncoding.indexOf(charset[i]);\n        if (index !== -1) {\n          encoding[index] = i;\n        }\n      }\n    } else {\n      const dataStart = pos;\n      format = bytes[pos++];\n      switch (format & 0x7f) {\n        case 0:\n          const glyphsCount = bytes[pos++];\n          for (i = 1; i <= glyphsCount; i++) {\n            encoding[bytes[pos++]] = i;\n          }\n          break;\n        case 1:\n          const rangesCount = bytes[pos++];\n          let gid = 1;\n          for (i = 0; i < rangesCount; i++) {\n            const start = bytes[pos++];\n            const left = bytes[pos++];\n            for (let j = start; j <= start + left; j++) {\n              encoding[j] = gid++;\n            }\n          }\n          break;\n        default:\n          throw new FormatError(`Unknown encoding format: ${format} in CFF`);\n      }\n      const dataEnd = pos;\n      if (format & 0x80) {\n        bytes[dataStart] &= 0x7f;\n        readSupplement();\n      }\n      raw = bytes.subarray(dataStart, dataEnd);\n    }\n    format &= 0x7f;\n    return new CFFEncoding(predefined, format, encoding, raw);\n  }\n  parseFDSelect(pos, length) {\n    const bytes = this.bytes;\n    const format = bytes[pos++];\n    const fdSelect = [];\n    let i;\n    switch (format) {\n      case 0:\n        for (i = 0; i < length; ++i) {\n          const id = bytes[pos++];\n          fdSelect.push(id);\n        }\n        break;\n      case 3:\n        const rangesCount = bytes[pos++] << 8 | bytes[pos++];\n        for (i = 0; i < rangesCount; ++i) {\n          let first = bytes[pos++] << 8 | bytes[pos++];\n          if (i === 0 && first !== 0) {\n            warn(\"parseFDSelect: The first range must have a first GID of 0\" + \" -- trying to recover.\");\n            first = 0;\n          }\n          const fdIndex = bytes[pos++];\n          const next = bytes[pos] << 8 | bytes[pos + 1];\n          for (let j = first; j < next; ++j) {\n            fdSelect.push(fdIndex);\n          }\n        }\n        pos += 2;\n        break;\n      default:\n        throw new FormatError(`parseFDSelect: Unknown format \"${format}\".`);\n    }\n    if (fdSelect.length !== length) {\n      throw new FormatError(\"parseFDSelect: Invalid font data.\");\n    }\n    return new CFFFDSelect(format, fdSelect);\n  }\n}\nclass CFF {\n  constructor() {\n    this.header = null;\n    this.names = [];\n    this.topDict = null;\n    this.strings = new CFFStrings();\n    this.globalSubrIndex = null;\n    this.encoding = null;\n    this.charset = null;\n    this.charStrings = null;\n    this.fdArray = [];\n    this.fdSelect = null;\n    this.isCIDFont = false;\n  }\n  duplicateFirstGlyph() {\n    if (this.charStrings.count >= 65535) {\n      warn(\"Not enough space in charstrings to duplicate first glyph.\");\n      return;\n    }\n    const glyphZero = this.charStrings.get(0);\n    this.charStrings.add(glyphZero);\n    if (this.isCIDFont) {\n      this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);\n    }\n  }\n  hasGlyphId(id) {\n    if (id < 0 || id >= this.charStrings.count) {\n      return false;\n    }\n    const glyph = this.charStrings.get(id);\n    return glyph.length > 0;\n  }\n}\nclass CFFHeader {\n  constructor(major, minor, hdrSize, offSize) {\n    this.major = major;\n    this.minor = minor;\n    this.hdrSize = hdrSize;\n    this.offSize = offSize;\n  }\n}\nclass CFFStrings {\n  constructor() {\n    this.strings = [];\n  }\n  get(index) {\n    if (index >= 0 && index <= NUM_STANDARD_CFF_STRINGS - 1) {\n      return CFFStandardStrings[index];\n    }\n    if (index - NUM_STANDARD_CFF_STRINGS <= this.strings.length) {\n      return this.strings[index - NUM_STANDARD_CFF_STRINGS];\n    }\n    return CFFStandardStrings[0];\n  }\n  getSID(str) {\n    let index = CFFStandardStrings.indexOf(str);\n    if (index !== -1) {\n      return index;\n    }\n    index = this.strings.indexOf(str);\n    if (index !== -1) {\n      return index + NUM_STANDARD_CFF_STRINGS;\n    }\n    return -1;\n  }\n  add(value) {\n    this.strings.push(value);\n  }\n  get count() {\n    return this.strings.length;\n  }\n}\nclass CFFIndex {\n  constructor() {\n    this.objects = [];\n    this.length = 0;\n  }\n  add(data) {\n    this.length += data.length;\n    this.objects.push(data);\n  }\n  set(index, data) {\n    this.length += data.length - this.objects[index].length;\n    this.objects[index] = data;\n  }\n  get(index) {\n    return this.objects[index];\n  }\n  get count() {\n    return this.objects.length;\n  }\n}\nclass CFFDict {\n  constructor(tables, strings) {\n    this.keyToNameMap = tables.keyToNameMap;\n    this.nameToKeyMap = tables.nameToKeyMap;\n    this.defaults = tables.defaults;\n    this.types = tables.types;\n    this.opcodes = tables.opcodes;\n    this.order = tables.order;\n    this.strings = strings;\n    this.values = Object.create(null);\n  }\n  setByKey(key, value) {\n    if (!(key in this.keyToNameMap)) {\n      return false;\n    }\n    if (value.length === 0) {\n      return true;\n    }\n    for (const val of value) {\n      if (isNaN(val)) {\n        warn(`Invalid CFFDict value: \"${value}\" for key \"${key}\".`);\n        return true;\n      }\n    }\n    const type = this.types[key];\n    if (type === \"num\" || type === \"sid\" || type === \"offset\") {\n      value = value[0];\n    }\n    this.values[key] = value;\n    return true;\n  }\n  setByName(name, value) {\n    if (!(name in this.nameToKeyMap)) {\n      throw new FormatError(`Invalid dictionary name \"${name}\"`);\n    }\n    this.values[this.nameToKeyMap[name]] = value;\n  }\n  hasName(name) {\n    return this.nameToKeyMap[name] in this.values;\n  }\n  getByName(name) {\n    if (!(name in this.nameToKeyMap)) {\n      throw new FormatError(`Invalid dictionary name ${name}\"`);\n    }\n    const key = this.nameToKeyMap[name];\n    if (!(key in this.values)) {\n      return this.defaults[key];\n    }\n    return this.values[key];\n  }\n  removeByName(name) {\n    delete this.values[this.nameToKeyMap[name]];\n  }\n  static createTables(layout) {\n    const tables = {\n      keyToNameMap: {},\n      nameToKeyMap: {},\n      defaults: {},\n      types: {},\n      opcodes: {},\n      order: []\n    };\n    for (const entry of layout) {\n      const key = Array.isArray(entry[0]) ? (entry[0][0] << 8) + entry[0][1] : entry[0];\n      tables.keyToNameMap[key] = entry[1];\n      tables.nameToKeyMap[entry[1]] = key;\n      tables.types[key] = entry[2];\n      tables.defaults[key] = entry[3];\n      tables.opcodes[key] = Array.isArray(entry[0]) ? entry[0] : [entry[0]];\n      tables.order.push(key);\n    }\n    return tables;\n  }\n}\nconst CFFTopDictLayout = [[[12, 30], \"ROS\", [\"sid\", \"sid\", \"num\"], null], [[12, 20], \"SyntheticBase\", \"num\", null], [0, \"version\", \"sid\", null], [1, \"Notice\", \"sid\", null], [[12, 0], \"Copyright\", \"sid\", null], [2, \"FullName\", \"sid\", null], [3, \"FamilyName\", \"sid\", null], [4, \"Weight\", \"sid\", null], [[12, 1], \"isFixedPitch\", \"num\", 0], [[12, 2], \"ItalicAngle\", \"num\", 0], [[12, 3], \"UnderlinePosition\", \"num\", -100], [[12, 4], \"UnderlineThickness\", \"num\", 50], [[12, 5], \"PaintType\", \"num\", 0], [[12, 6], \"CharstringType\", \"num\", 2], [[12, 7], \"FontMatrix\", [\"num\", \"num\", \"num\", \"num\", \"num\", \"num\"], [0.001, 0, 0, 0.001, 0, 0]], [13, \"UniqueID\", \"num\", null], [5, \"FontBBox\", [\"num\", \"num\", \"num\", \"num\"], [0, 0, 0, 0]], [[12, 8], \"StrokeWidth\", \"num\", 0], [14, \"XUID\", \"array\", null], [15, \"charset\", \"offset\", 0], [16, \"Encoding\", \"offset\", 0], [17, \"CharStrings\", \"offset\", 0], [18, \"Private\", [\"offset\", \"offset\"], null], [[12, 21], \"PostScript\", \"sid\", null], [[12, 22], \"BaseFontName\", \"sid\", null], [[12, 23], \"BaseFontBlend\", \"delta\", null], [[12, 31], \"CIDFontVersion\", \"num\", 0], [[12, 32], \"CIDFontRevision\", \"num\", 0], [[12, 33], \"CIDFontType\", \"num\", 0], [[12, 34], \"CIDCount\", \"num\", 8720], [[12, 35], \"UIDBase\", \"num\", null], [[12, 37], \"FDSelect\", \"offset\", null], [[12, 36], \"FDArray\", \"offset\", null], [[12, 38], \"FontName\", \"sid\", null]];\nclass CFFTopDict extends CFFDict {\n  static get tables() {\n    return shadow(this, \"tables\", this.createTables(CFFTopDictLayout));\n  }\n  constructor(strings) {\n    super(CFFTopDict.tables, strings);\n    this.privateDict = null;\n  }\n}\nconst CFFPrivateDictLayout = [[6, \"BlueValues\", \"delta\", null], [7, \"OtherBlues\", \"delta\", null], [8, \"FamilyBlues\", \"delta\", null], [9, \"FamilyOtherBlues\", \"delta\", null], [[12, 9], \"BlueScale\", \"num\", 0.039625], [[12, 10], \"BlueShift\", \"num\", 7], [[12, 11], \"BlueFuzz\", \"num\", 1], [10, \"StdHW\", \"num\", null], [11, \"StdVW\", \"num\", null], [[12, 12], \"StemSnapH\", \"delta\", null], [[12, 13], \"StemSnapV\", \"delta\", null], [[12, 14], \"ForceBold\", \"num\", 0], [[12, 17], \"LanguageGroup\", \"num\", 0], [[12, 18], \"ExpansionFactor\", \"num\", 0.06], [[12, 19], \"initialRandomSeed\", \"num\", 0], [20, \"defaultWidthX\", \"num\", 0], [21, \"nominalWidthX\", \"num\", 0], [19, \"Subrs\", \"offset\", null]];\nclass CFFPrivateDict extends CFFDict {\n  static get tables() {\n    return shadow(this, \"tables\", this.createTables(CFFPrivateDictLayout));\n  }\n  constructor(strings) {\n    super(CFFPrivateDict.tables, strings);\n    this.subrsIndex = null;\n  }\n}\nconst CFFCharsetPredefinedTypes = {\n  ISO_ADOBE: 0,\n  EXPERT: 1,\n  EXPERT_SUBSET: 2\n};\nclass CFFCharset {\n  constructor(predefined, format, charset, raw) {\n    this.predefined = predefined;\n    this.format = format;\n    this.charset = charset;\n    this.raw = raw;\n  }\n}\nclass CFFEncoding {\n  constructor(predefined, format, encoding, raw) {\n    this.predefined = predefined;\n    this.format = format;\n    this.encoding = encoding;\n    this.raw = raw;\n  }\n}\nclass CFFFDSelect {\n  constructor(format, fdSelect) {\n    this.format = format;\n    this.fdSelect = fdSelect;\n  }\n  getFDIndex(glyphIndex) {\n    if (glyphIndex < 0 || glyphIndex >= this.fdSelect.length) {\n      return -1;\n    }\n    return this.fdSelect[glyphIndex];\n  }\n}\nclass CFFOffsetTracker {\n  constructor() {\n    this.offsets = Object.create(null);\n  }\n  isTracking(key) {\n    return key in this.offsets;\n  }\n  track(key, location) {\n    if (key in this.offsets) {\n      throw new FormatError(`Already tracking location of ${key}`);\n    }\n    this.offsets[key] = location;\n  }\n  offset(value) {\n    for (const key in this.offsets) {\n      this.offsets[key] += value;\n    }\n  }\n  setEntryLocation(key, values, output) {\n    if (!(key in this.offsets)) {\n      throw new FormatError(`Not tracking location of ${key}`);\n    }\n    const data = output.data;\n    const dataOffset = this.offsets[key];\n    const size = 5;\n    for (let i = 0, ii = values.length; i < ii; ++i) {\n      const offset0 = i * size + dataOffset;\n      const offset1 = offset0 + 1;\n      const offset2 = offset0 + 2;\n      const offset3 = offset0 + 3;\n      const offset4 = offset0 + 4;\n      if (data[offset0] !== 0x1d || data[offset1] !== 0 || data[offset2] !== 0 || data[offset3] !== 0 || data[offset4] !== 0) {\n        throw new FormatError(\"writing to an offset that is not empty\");\n      }\n      const value = values[i];\n      data[offset0] = 0x1d;\n      data[offset1] = value >> 24 & 0xff;\n      data[offset2] = value >> 16 & 0xff;\n      data[offset3] = value >> 8 & 0xff;\n      data[offset4] = value & 0xff;\n    }\n  }\n}\nclass CFFCompiler {\n  constructor(cff) {\n    this.cff = cff;\n  }\n  compile() {\n    const cff = this.cff;\n    const output = {\n      data: [],\n      length: 0,\n      add(data) {\n        try {\n          this.data.push(...data);\n        } catch {\n          this.data = this.data.concat(data);\n        }\n        this.length = this.data.length;\n      }\n    };\n    const header = this.compileHeader(cff.header);\n    output.add(header);\n    const nameIndex = this.compileNameIndex(cff.names);\n    output.add(nameIndex);\n    if (cff.isCIDFont) {\n      if (cff.topDict.hasName(\"FontMatrix\")) {\n        const base = cff.topDict.getByName(\"FontMatrix\");\n        cff.topDict.removeByName(\"FontMatrix\");\n        for (const subDict of cff.fdArray) {\n          let matrix = base.slice(0);\n          if (subDict.hasName(\"FontMatrix\")) {\n            matrix = Util.transform(matrix, subDict.getByName(\"FontMatrix\"));\n          }\n          subDict.setByName(\"FontMatrix\", matrix);\n        }\n      }\n    }\n    const xuid = cff.topDict.getByName(\"XUID\");\n    if (xuid?.length > 16) {\n      cff.topDict.removeByName(\"XUID\");\n    }\n    cff.topDict.setByName(\"charset\", 0);\n    let compiled = this.compileTopDicts([cff.topDict], output.length, cff.isCIDFont);\n    output.add(compiled.output);\n    const topDictTracker = compiled.trackers[0];\n    const stringIndex = this.compileStringIndex(cff.strings.strings);\n    output.add(stringIndex);\n    const globalSubrIndex = this.compileIndex(cff.globalSubrIndex);\n    output.add(globalSubrIndex);\n    if (cff.encoding && cff.topDict.hasName(\"Encoding\")) {\n      if (cff.encoding.predefined) {\n        topDictTracker.setEntryLocation(\"Encoding\", [cff.encoding.format], output);\n      } else {\n        const encoding = this.compileEncoding(cff.encoding);\n        topDictTracker.setEntryLocation(\"Encoding\", [output.length], output);\n        output.add(encoding);\n      }\n    }\n    const charset = this.compileCharset(cff.charset, cff.charStrings.count, cff.strings, cff.isCIDFont);\n    topDictTracker.setEntryLocation(\"charset\", [output.length], output);\n    output.add(charset);\n    const charStrings = this.compileCharStrings(cff.charStrings);\n    topDictTracker.setEntryLocation(\"CharStrings\", [output.length], output);\n    output.add(charStrings);\n    if (cff.isCIDFont) {\n      topDictTracker.setEntryLocation(\"FDSelect\", [output.length], output);\n      const fdSelect = this.compileFDSelect(cff.fdSelect);\n      output.add(fdSelect);\n      compiled = this.compileTopDicts(cff.fdArray, output.length, true);\n      topDictTracker.setEntryLocation(\"FDArray\", [output.length], output);\n      output.add(compiled.output);\n      const fontDictTrackers = compiled.trackers;\n      this.compilePrivateDicts(cff.fdArray, fontDictTrackers, output);\n    }\n    this.compilePrivateDicts([cff.topDict], [topDictTracker], output);\n    output.add([0]);\n    return output.data;\n  }\n  encodeNumber(value) {\n    if (Number.isInteger(value)) {\n      return this.encodeInteger(value);\n    }\n    return this.encodeFloat(value);\n  }\n  static get EncodeFloatRegExp() {\n    return shadow(this, \"EncodeFloatRegExp\", /\\.(\\d*?)(?:9{5,20}|0{5,20})\\d{0,2}(?:e(.+)|$)/);\n  }\n  encodeFloat(num) {\n    let value = num.toString();\n    const m = CFFCompiler.EncodeFloatRegExp.exec(value);\n    if (m) {\n      const epsilon = parseFloat(\"1e\" + ((m[2] ? +m[2] : 0) + m[1].length));\n      value = (Math.round(num * epsilon) / epsilon).toString();\n    }\n    let nibbles = \"\";\n    let i, ii;\n    for (i = 0, ii = value.length; i < ii; ++i) {\n      const a = value[i];\n      if (a === \"e\") {\n        nibbles += value[++i] === \"-\" ? \"c\" : \"b\";\n      } else if (a === \".\") {\n        nibbles += \"a\";\n      } else if (a === \"-\") {\n        nibbles += \"e\";\n      } else {\n        nibbles += a;\n      }\n    }\n    nibbles += nibbles.length & 1 ? \"f\" : \"ff\";\n    const out = [30];\n    for (i = 0, ii = nibbles.length; i < ii; i += 2) {\n      out.push(parseInt(nibbles.substring(i, i + 2), 16));\n    }\n    return out;\n  }\n  encodeInteger(value) {\n    let code;\n    if (value >= -107 && value <= 107) {\n      code = [value + 139];\n    } else if (value >= 108 && value <= 1131) {\n      value -= 108;\n      code = [(value >> 8) + 247, value & 0xff];\n    } else if (value >= -1131 && value <= -108) {\n      value = -value - 108;\n      code = [(value >> 8) + 251, value & 0xff];\n    } else if (value >= -32768 && value <= 32767) {\n      code = [0x1c, value >> 8 & 0xff, value & 0xff];\n    } else {\n      code = [0x1d, value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff];\n    }\n    return code;\n  }\n  compileHeader(header) {\n    return [header.major, header.minor, 4, header.offSize];\n  }\n  compileNameIndex(names) {\n    const nameIndex = new CFFIndex();\n    for (const name of names) {\n      const length = Math.min(name.length, 127);\n      let sanitizedName = new Array(length);\n      for (let j = 0; j < length; j++) {\n        let char = name[j];\n        if (char < \"!\" || char > \"~\" || char === \"[\" || char === \"]\" || char === \"(\" || char === \")\" || char === \"{\" || char === \"}\" || char === \"<\" || char === \">\" || char === \"/\" || char === \"%\") {\n          char = \"_\";\n        }\n        sanitizedName[j] = char;\n      }\n      sanitizedName = sanitizedName.join(\"\");\n      if (sanitizedName === \"\") {\n        sanitizedName = \"Bad_Font_Name\";\n      }\n      nameIndex.add(stringToBytes(sanitizedName));\n    }\n    return this.compileIndex(nameIndex);\n  }\n  compileTopDicts(dicts, length, removeCidKeys) {\n    const fontDictTrackers = [];\n    let fdArrayIndex = new CFFIndex();\n    for (const fontDict of dicts) {\n      if (removeCidKeys) {\n        fontDict.removeByName(\"CIDFontVersion\");\n        fontDict.removeByName(\"CIDFontRevision\");\n        fontDict.removeByName(\"CIDFontType\");\n        fontDict.removeByName(\"CIDCount\");\n        fontDict.removeByName(\"UIDBase\");\n      }\n      const fontDictTracker = new CFFOffsetTracker();\n      const fontDictData = this.compileDict(fontDict, fontDictTracker);\n      fontDictTrackers.push(fontDictTracker);\n      fdArrayIndex.add(fontDictData);\n      fontDictTracker.offset(length);\n    }\n    fdArrayIndex = this.compileIndex(fdArrayIndex, fontDictTrackers);\n    return {\n      trackers: fontDictTrackers,\n      output: fdArrayIndex\n    };\n  }\n  compilePrivateDicts(dicts, trackers, output) {\n    for (let i = 0, ii = dicts.length; i < ii; ++i) {\n      const fontDict = dicts[i];\n      const privateDict = fontDict.privateDict;\n      if (!privateDict || !fontDict.hasName(\"Private\")) {\n        throw new FormatError(\"There must be a private dictionary.\");\n      }\n      const privateDictTracker = new CFFOffsetTracker();\n      const privateDictData = this.compileDict(privateDict, privateDictTracker);\n      let outputLength = output.length;\n      privateDictTracker.offset(outputLength);\n      if (!privateDictData.length) {\n        outputLength = 0;\n      }\n      trackers[i].setEntryLocation(\"Private\", [privateDictData.length, outputLength], output);\n      output.add(privateDictData);\n      if (privateDict.subrsIndex && privateDict.hasName(\"Subrs\")) {\n        const subrs = this.compileIndex(privateDict.subrsIndex);\n        privateDictTracker.setEntryLocation(\"Subrs\", [privateDictData.length], output);\n        output.add(subrs);\n      }\n    }\n  }\n  compileDict(dict, offsetTracker) {\n    const out = [];\n    for (const key of dict.order) {\n      if (!(key in dict.values)) {\n        continue;\n      }\n      let values = dict.values[key];\n      let types = dict.types[key];\n      if (!Array.isArray(types)) {\n        types = [types];\n      }\n      if (!Array.isArray(values)) {\n        values = [values];\n      }\n      if (values.length === 0) {\n        continue;\n      }\n      for (let j = 0, jj = types.length; j < jj; ++j) {\n        const type = types[j];\n        const value = values[j];\n        switch (type) {\n          case \"num\":\n          case \"sid\":\n            out.push(...this.encodeNumber(value));\n            break;\n          case \"offset\":\n            const name = dict.keyToNameMap[key];\n            if (!offsetTracker.isTracking(name)) {\n              offsetTracker.track(name, out.length);\n            }\n            out.push(0x1d, 0, 0, 0, 0);\n            break;\n          case \"array\":\n          case \"delta\":\n            out.push(...this.encodeNumber(value));\n            for (let k = 1, kk = values.length; k < kk; ++k) {\n              out.push(...this.encodeNumber(values[k]));\n            }\n            break;\n          default:\n            throw new FormatError(`Unknown data type of ${type}`);\n        }\n      }\n      out.push(...dict.opcodes[key]);\n    }\n    return out;\n  }\n  compileStringIndex(strings) {\n    const stringIndex = new CFFIndex();\n    for (const string of strings) {\n      stringIndex.add(stringToBytes(string));\n    }\n    return this.compileIndex(stringIndex);\n  }\n  compileCharStrings(charStrings) {\n    const charStringsIndex = new CFFIndex();\n    for (let i = 0; i < charStrings.count; i++) {\n      const glyph = charStrings.get(i);\n      if (glyph.length === 0) {\n        charStringsIndex.add(new Uint8Array([0x8b, 0x0e]));\n        continue;\n      }\n      charStringsIndex.add(glyph);\n    }\n    return this.compileIndex(charStringsIndex);\n  }\n  compileCharset(charset, numGlyphs, strings, isCIDFont) {\n    let out;\n    const numGlyphsLessNotDef = numGlyphs - 1;\n    if (isCIDFont) {\n      out = new Uint8Array([2, 0, 0, numGlyphsLessNotDef >> 8 & 0xff, numGlyphsLessNotDef & 0xff]);\n    } else {\n      const length = 1 + numGlyphsLessNotDef * 2;\n      out = new Uint8Array(length);\n      out[0] = 0;\n      let charsetIndex = 0;\n      const numCharsets = charset.charset.length;\n      let warned = false;\n      for (let i = 1; i < out.length; i += 2) {\n        let sid = 0;\n        if (charsetIndex < numCharsets) {\n          const name = charset.charset[charsetIndex++];\n          sid = strings.getSID(name);\n          if (sid === -1) {\n            sid = 0;\n            if (!warned) {\n              warned = true;\n              warn(`Couldn't find ${name} in CFF strings`);\n            }\n          }\n        }\n        out[i] = sid >> 8 & 0xff;\n        out[i + 1] = sid & 0xff;\n      }\n    }\n    return this.compileTypedArray(out);\n  }\n  compileEncoding(encoding) {\n    return this.compileTypedArray(encoding.raw);\n  }\n  compileFDSelect(fdSelect) {\n    const format = fdSelect.format;\n    let out, i;\n    switch (format) {\n      case 0:\n        out = new Uint8Array(1 + fdSelect.fdSelect.length);\n        out[0] = format;\n        for (i = 0; i < fdSelect.fdSelect.length; i++) {\n          out[i + 1] = fdSelect.fdSelect[i];\n        }\n        break;\n      case 3:\n        const start = 0;\n        let lastFD = fdSelect.fdSelect[0];\n        const ranges = [format, 0, 0, start >> 8 & 0xff, start & 0xff, lastFD];\n        for (i = 1; i < fdSelect.fdSelect.length; i++) {\n          const currentFD = fdSelect.fdSelect[i];\n          if (currentFD !== lastFD) {\n            ranges.push(i >> 8 & 0xff, i & 0xff, currentFD);\n            lastFD = currentFD;\n          }\n        }\n        const numRanges = (ranges.length - 3) / 3;\n        ranges[1] = numRanges >> 8 & 0xff;\n        ranges[2] = numRanges & 0xff;\n        ranges.push(i >> 8 & 0xff, i & 0xff);\n        out = new Uint8Array(ranges);\n        break;\n    }\n    return this.compileTypedArray(out);\n  }\n  compileTypedArray(data) {\n    return Array.from(data);\n  }\n  compileIndex(index, trackers = []) {\n    const objects = index.objects;\n    const count = objects.length;\n    if (count === 0) {\n      return [0, 0];\n    }\n    const data = [count >> 8 & 0xff, count & 0xff];\n    let lastOffset = 1,\n      i;\n    for (i = 0; i < count; ++i) {\n      lastOffset += objects[i].length;\n    }\n    let offsetSize;\n    if (lastOffset < 0x100) {\n      offsetSize = 1;\n    } else if (lastOffset < 0x10000) {\n      offsetSize = 2;\n    } else if (lastOffset < 0x1000000) {\n      offsetSize = 3;\n    } else {\n      offsetSize = 4;\n    }\n    data.push(offsetSize);\n    let relativeOffset = 1;\n    for (i = 0; i < count + 1; i++) {\n      if (offsetSize === 1) {\n        data.push(relativeOffset & 0xff);\n      } else if (offsetSize === 2) {\n        data.push(relativeOffset >> 8 & 0xff, relativeOffset & 0xff);\n      } else if (offsetSize === 3) {\n        data.push(relativeOffset >> 16 & 0xff, relativeOffset >> 8 & 0xff, relativeOffset & 0xff);\n      } else {\n        data.push(relativeOffset >>> 24 & 0xff, relativeOffset >> 16 & 0xff, relativeOffset >> 8 & 0xff, relativeOffset & 0xff);\n      }\n      if (objects[i]) {\n        relativeOffset += objects[i].length;\n      }\n    }\n    for (i = 0; i < count; i++) {\n      if (trackers[i]) {\n        trackers[i].offset(data.length);\n      }\n      data.push(...objects[i]);\n    }\n    return data;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/glyphlist.js\n\nconst getGlyphsUnicode = getLookupTableFactory(function (t) {\n  t.A = 0x0041;\n  t.AE = 0x00c6;\n  t.AEacute = 0x01fc;\n  t.AEmacron = 0x01e2;\n  t.AEsmall = 0xf7e6;\n  t.Aacute = 0x00c1;\n  t.Aacutesmall = 0xf7e1;\n  t.Abreve = 0x0102;\n  t.Abreveacute = 0x1eae;\n  t.Abrevecyrillic = 0x04d0;\n  t.Abrevedotbelow = 0x1eb6;\n  t.Abrevegrave = 0x1eb0;\n  t.Abrevehookabove = 0x1eb2;\n  t.Abrevetilde = 0x1eb4;\n  t.Acaron = 0x01cd;\n  t.Acircle = 0x24b6;\n  t.Acircumflex = 0x00c2;\n  t.Acircumflexacute = 0x1ea4;\n  t.Acircumflexdotbelow = 0x1eac;\n  t.Acircumflexgrave = 0x1ea6;\n  t.Acircumflexhookabove = 0x1ea8;\n  t.Acircumflexsmall = 0xf7e2;\n  t.Acircumflextilde = 0x1eaa;\n  t.Acute = 0xf6c9;\n  t.Acutesmall = 0xf7b4;\n  t.Acyrillic = 0x0410;\n  t.Adblgrave = 0x0200;\n  t.Adieresis = 0x00c4;\n  t.Adieresiscyrillic = 0x04d2;\n  t.Adieresismacron = 0x01de;\n  t.Adieresissmall = 0xf7e4;\n  t.Adotbelow = 0x1ea0;\n  t.Adotmacron = 0x01e0;\n  t.Agrave = 0x00c0;\n  t.Agravesmall = 0xf7e0;\n  t.Ahookabove = 0x1ea2;\n  t.Aiecyrillic = 0x04d4;\n  t.Ainvertedbreve = 0x0202;\n  t.Alpha = 0x0391;\n  t.Alphatonos = 0x0386;\n  t.Amacron = 0x0100;\n  t.Amonospace = 0xff21;\n  t.Aogonek = 0x0104;\n  t.Aring = 0x00c5;\n  t.Aringacute = 0x01fa;\n  t.Aringbelow = 0x1e00;\n  t.Aringsmall = 0xf7e5;\n  t.Asmall = 0xf761;\n  t.Atilde = 0x00c3;\n  t.Atildesmall = 0xf7e3;\n  t.Aybarmenian = 0x0531;\n  t.B = 0x0042;\n  t.Bcircle = 0x24b7;\n  t.Bdotaccent = 0x1e02;\n  t.Bdotbelow = 0x1e04;\n  t.Becyrillic = 0x0411;\n  t.Benarmenian = 0x0532;\n  t.Beta = 0x0392;\n  t.Bhook = 0x0181;\n  t.Blinebelow = 0x1e06;\n  t.Bmonospace = 0xff22;\n  t.Brevesmall = 0xf6f4;\n  t.Bsmall = 0xf762;\n  t.Btopbar = 0x0182;\n  t.C = 0x0043;\n  t.Caarmenian = 0x053e;\n  t.Cacute = 0x0106;\n  t.Caron = 0xf6ca;\n  t.Caronsmall = 0xf6f5;\n  t.Ccaron = 0x010c;\n  t.Ccedilla = 0x00c7;\n  t.Ccedillaacute = 0x1e08;\n  t.Ccedillasmall = 0xf7e7;\n  t.Ccircle = 0x24b8;\n  t.Ccircumflex = 0x0108;\n  t.Cdot = 0x010a;\n  t.Cdotaccent = 0x010a;\n  t.Cedillasmall = 0xf7b8;\n  t.Chaarmenian = 0x0549;\n  t.Cheabkhasiancyrillic = 0x04bc;\n  t.Checyrillic = 0x0427;\n  t.Chedescenderabkhasiancyrillic = 0x04be;\n  t.Chedescendercyrillic = 0x04b6;\n  t.Chedieresiscyrillic = 0x04f4;\n  t.Cheharmenian = 0x0543;\n  t.Chekhakassiancyrillic = 0x04cb;\n  t.Cheverticalstrokecyrillic = 0x04b8;\n  t.Chi = 0x03a7;\n  t.Chook = 0x0187;\n  t.Circumflexsmall = 0xf6f6;\n  t.Cmonospace = 0xff23;\n  t.Coarmenian = 0x0551;\n  t.Csmall = 0xf763;\n  t.D = 0x0044;\n  t.DZ = 0x01f1;\n  t.DZcaron = 0x01c4;\n  t.Daarmenian = 0x0534;\n  t.Dafrican = 0x0189;\n  t.Dcaron = 0x010e;\n  t.Dcedilla = 0x1e10;\n  t.Dcircle = 0x24b9;\n  t.Dcircumflexbelow = 0x1e12;\n  t.Dcroat = 0x0110;\n  t.Ddotaccent = 0x1e0a;\n  t.Ddotbelow = 0x1e0c;\n  t.Decyrillic = 0x0414;\n  t.Deicoptic = 0x03ee;\n  t.Delta = 0x2206;\n  t.Deltagreek = 0x0394;\n  t.Dhook = 0x018a;\n  t.Dieresis = 0xf6cb;\n  t.DieresisAcute = 0xf6cc;\n  t.DieresisGrave = 0xf6cd;\n  t.Dieresissmall = 0xf7a8;\n  t.Digammagreek = 0x03dc;\n  t.Djecyrillic = 0x0402;\n  t.Dlinebelow = 0x1e0e;\n  t.Dmonospace = 0xff24;\n  t.Dotaccentsmall = 0xf6f7;\n  t.Dslash = 0x0110;\n  t.Dsmall = 0xf764;\n  t.Dtopbar = 0x018b;\n  t.Dz = 0x01f2;\n  t.Dzcaron = 0x01c5;\n  t.Dzeabkhasiancyrillic = 0x04e0;\n  t.Dzecyrillic = 0x0405;\n  t.Dzhecyrillic = 0x040f;\n  t.E = 0x0045;\n  t.Eacute = 0x00c9;\n  t.Eacutesmall = 0xf7e9;\n  t.Ebreve = 0x0114;\n  t.Ecaron = 0x011a;\n  t.Ecedillabreve = 0x1e1c;\n  t.Echarmenian = 0x0535;\n  t.Ecircle = 0x24ba;\n  t.Ecircumflex = 0x00ca;\n  t.Ecircumflexacute = 0x1ebe;\n  t.Ecircumflexbelow = 0x1e18;\n  t.Ecircumflexdotbelow = 0x1ec6;\n  t.Ecircumflexgrave = 0x1ec0;\n  t.Ecircumflexhookabove = 0x1ec2;\n  t.Ecircumflexsmall = 0xf7ea;\n  t.Ecircumflextilde = 0x1ec4;\n  t.Ecyrillic = 0x0404;\n  t.Edblgrave = 0x0204;\n  t.Edieresis = 0x00cb;\n  t.Edieresissmall = 0xf7eb;\n  t.Edot = 0x0116;\n  t.Edotaccent = 0x0116;\n  t.Edotbelow = 0x1eb8;\n  t.Efcyrillic = 0x0424;\n  t.Egrave = 0x00c8;\n  t.Egravesmall = 0xf7e8;\n  t.Eharmenian = 0x0537;\n  t.Ehookabove = 0x1eba;\n  t.Eightroman = 0x2167;\n  t.Einvertedbreve = 0x0206;\n  t.Eiotifiedcyrillic = 0x0464;\n  t.Elcyrillic = 0x041b;\n  t.Elevenroman = 0x216a;\n  t.Emacron = 0x0112;\n  t.Emacronacute = 0x1e16;\n  t.Emacrongrave = 0x1e14;\n  t.Emcyrillic = 0x041c;\n  t.Emonospace = 0xff25;\n  t.Encyrillic = 0x041d;\n  t.Endescendercyrillic = 0x04a2;\n  t.Eng = 0x014a;\n  t.Enghecyrillic = 0x04a4;\n  t.Enhookcyrillic = 0x04c7;\n  t.Eogonek = 0x0118;\n  t.Eopen = 0x0190;\n  t.Epsilon = 0x0395;\n  t.Epsilontonos = 0x0388;\n  t.Ercyrillic = 0x0420;\n  t.Ereversed = 0x018e;\n  t.Ereversedcyrillic = 0x042d;\n  t.Escyrillic = 0x0421;\n  t.Esdescendercyrillic = 0x04aa;\n  t.Esh = 0x01a9;\n  t.Esmall = 0xf765;\n  t.Eta = 0x0397;\n  t.Etarmenian = 0x0538;\n  t.Etatonos = 0x0389;\n  t.Eth = 0x00d0;\n  t.Ethsmall = 0xf7f0;\n  t.Etilde = 0x1ebc;\n  t.Etildebelow = 0x1e1a;\n  t.Euro = 0x20ac;\n  t.Ezh = 0x01b7;\n  t.Ezhcaron = 0x01ee;\n  t.Ezhreversed = 0x01b8;\n  t.F = 0x0046;\n  t.Fcircle = 0x24bb;\n  t.Fdotaccent = 0x1e1e;\n  t.Feharmenian = 0x0556;\n  t.Feicoptic = 0x03e4;\n  t.Fhook = 0x0191;\n  t.Fitacyrillic = 0x0472;\n  t.Fiveroman = 0x2164;\n  t.Fmonospace = 0xff26;\n  t.Fourroman = 0x2163;\n  t.Fsmall = 0xf766;\n  t.G = 0x0047;\n  t.GBsquare = 0x3387;\n  t.Gacute = 0x01f4;\n  t.Gamma = 0x0393;\n  t.Gammaafrican = 0x0194;\n  t.Gangiacoptic = 0x03ea;\n  t.Gbreve = 0x011e;\n  t.Gcaron = 0x01e6;\n  t.Gcedilla = 0x0122;\n  t.Gcircle = 0x24bc;\n  t.Gcircumflex = 0x011c;\n  t.Gcommaaccent = 0x0122;\n  t.Gdot = 0x0120;\n  t.Gdotaccent = 0x0120;\n  t.Gecyrillic = 0x0413;\n  t.Ghadarmenian = 0x0542;\n  t.Ghemiddlehookcyrillic = 0x0494;\n  t.Ghestrokecyrillic = 0x0492;\n  t.Gheupturncyrillic = 0x0490;\n  t.Ghook = 0x0193;\n  t.Gimarmenian = 0x0533;\n  t.Gjecyrillic = 0x0403;\n  t.Gmacron = 0x1e20;\n  t.Gmonospace = 0xff27;\n  t.Grave = 0xf6ce;\n  t.Gravesmall = 0xf760;\n  t.Gsmall = 0xf767;\n  t.Gsmallhook = 0x029b;\n  t.Gstroke = 0x01e4;\n  t.H = 0x0048;\n  t.H18533 = 0x25cf;\n  t.H18543 = 0x25aa;\n  t.H18551 = 0x25ab;\n  t.H22073 = 0x25a1;\n  t.HPsquare = 0x33cb;\n  t.Haabkhasiancyrillic = 0x04a8;\n  t.Hadescendercyrillic = 0x04b2;\n  t.Hardsigncyrillic = 0x042a;\n  t.Hbar = 0x0126;\n  t.Hbrevebelow = 0x1e2a;\n  t.Hcedilla = 0x1e28;\n  t.Hcircle = 0x24bd;\n  t.Hcircumflex = 0x0124;\n  t.Hdieresis = 0x1e26;\n  t.Hdotaccent = 0x1e22;\n  t.Hdotbelow = 0x1e24;\n  t.Hmonospace = 0xff28;\n  t.Hoarmenian = 0x0540;\n  t.Horicoptic = 0x03e8;\n  t.Hsmall = 0xf768;\n  t.Hungarumlaut = 0xf6cf;\n  t.Hungarumlautsmall = 0xf6f8;\n  t.Hzsquare = 0x3390;\n  t.I = 0x0049;\n  t.IAcyrillic = 0x042f;\n  t.IJ = 0x0132;\n  t.IUcyrillic = 0x042e;\n  t.Iacute = 0x00cd;\n  t.Iacutesmall = 0xf7ed;\n  t.Ibreve = 0x012c;\n  t.Icaron = 0x01cf;\n  t.Icircle = 0x24be;\n  t.Icircumflex = 0x00ce;\n  t.Icircumflexsmall = 0xf7ee;\n  t.Icyrillic = 0x0406;\n  t.Idblgrave = 0x0208;\n  t.Idieresis = 0x00cf;\n  t.Idieresisacute = 0x1e2e;\n  t.Idieresiscyrillic = 0x04e4;\n  t.Idieresissmall = 0xf7ef;\n  t.Idot = 0x0130;\n  t.Idotaccent = 0x0130;\n  t.Idotbelow = 0x1eca;\n  t.Iebrevecyrillic = 0x04d6;\n  t.Iecyrillic = 0x0415;\n  t.Ifraktur = 0x2111;\n  t.Igrave = 0x00cc;\n  t.Igravesmall = 0xf7ec;\n  t.Ihookabove = 0x1ec8;\n  t.Iicyrillic = 0x0418;\n  t.Iinvertedbreve = 0x020a;\n  t.Iishortcyrillic = 0x0419;\n  t.Imacron = 0x012a;\n  t.Imacroncyrillic = 0x04e2;\n  t.Imonospace = 0xff29;\n  t.Iniarmenian = 0x053b;\n  t.Iocyrillic = 0x0401;\n  t.Iogonek = 0x012e;\n  t.Iota = 0x0399;\n  t.Iotaafrican = 0x0196;\n  t.Iotadieresis = 0x03aa;\n  t.Iotatonos = 0x038a;\n  t.Ismall = 0xf769;\n  t.Istroke = 0x0197;\n  t.Itilde = 0x0128;\n  t.Itildebelow = 0x1e2c;\n  t.Izhitsacyrillic = 0x0474;\n  t.Izhitsadblgravecyrillic = 0x0476;\n  t.J = 0x004a;\n  t.Jaarmenian = 0x0541;\n  t.Jcircle = 0x24bf;\n  t.Jcircumflex = 0x0134;\n  t.Jecyrillic = 0x0408;\n  t.Jheharmenian = 0x054b;\n  t.Jmonospace = 0xff2a;\n  t.Jsmall = 0xf76a;\n  t.K = 0x004b;\n  t.KBsquare = 0x3385;\n  t.KKsquare = 0x33cd;\n  t.Kabashkircyrillic = 0x04a0;\n  t.Kacute = 0x1e30;\n  t.Kacyrillic = 0x041a;\n  t.Kadescendercyrillic = 0x049a;\n  t.Kahookcyrillic = 0x04c3;\n  t.Kappa = 0x039a;\n  t.Kastrokecyrillic = 0x049e;\n  t.Kaverticalstrokecyrillic = 0x049c;\n  t.Kcaron = 0x01e8;\n  t.Kcedilla = 0x0136;\n  t.Kcircle = 0x24c0;\n  t.Kcommaaccent = 0x0136;\n  t.Kdotbelow = 0x1e32;\n  t.Keharmenian = 0x0554;\n  t.Kenarmenian = 0x053f;\n  t.Khacyrillic = 0x0425;\n  t.Kheicoptic = 0x03e6;\n  t.Khook = 0x0198;\n  t.Kjecyrillic = 0x040c;\n  t.Klinebelow = 0x1e34;\n  t.Kmonospace = 0xff2b;\n  t.Koppacyrillic = 0x0480;\n  t.Koppagreek = 0x03de;\n  t.Ksicyrillic = 0x046e;\n  t.Ksmall = 0xf76b;\n  t.L = 0x004c;\n  t.LJ = 0x01c7;\n  t.LL = 0xf6bf;\n  t.Lacute = 0x0139;\n  t.Lambda = 0x039b;\n  t.Lcaron = 0x013d;\n  t.Lcedilla = 0x013b;\n  t.Lcircle = 0x24c1;\n  t.Lcircumflexbelow = 0x1e3c;\n  t.Lcommaaccent = 0x013b;\n  t.Ldot = 0x013f;\n  t.Ldotaccent = 0x013f;\n  t.Ldotbelow = 0x1e36;\n  t.Ldotbelowmacron = 0x1e38;\n  t.Liwnarmenian = 0x053c;\n  t.Lj = 0x01c8;\n  t.Ljecyrillic = 0x0409;\n  t.Llinebelow = 0x1e3a;\n  t.Lmonospace = 0xff2c;\n  t.Lslash = 0x0141;\n  t.Lslashsmall = 0xf6f9;\n  t.Lsmall = 0xf76c;\n  t.M = 0x004d;\n  t.MBsquare = 0x3386;\n  t.Macron = 0xf6d0;\n  t.Macronsmall = 0xf7af;\n  t.Macute = 0x1e3e;\n  t.Mcircle = 0x24c2;\n  t.Mdotaccent = 0x1e40;\n  t.Mdotbelow = 0x1e42;\n  t.Menarmenian = 0x0544;\n  t.Mmonospace = 0xff2d;\n  t.Msmall = 0xf76d;\n  t.Mturned = 0x019c;\n  t.Mu = 0x039c;\n  t.N = 0x004e;\n  t.NJ = 0x01ca;\n  t.Nacute = 0x0143;\n  t.Ncaron = 0x0147;\n  t.Ncedilla = 0x0145;\n  t.Ncircle = 0x24c3;\n  t.Ncircumflexbelow = 0x1e4a;\n  t.Ncommaaccent = 0x0145;\n  t.Ndotaccent = 0x1e44;\n  t.Ndotbelow = 0x1e46;\n  t.Nhookleft = 0x019d;\n  t.Nineroman = 0x2168;\n  t.Nj = 0x01cb;\n  t.Njecyrillic = 0x040a;\n  t.Nlinebelow = 0x1e48;\n  t.Nmonospace = 0xff2e;\n  t.Nowarmenian = 0x0546;\n  t.Nsmall = 0xf76e;\n  t.Ntilde = 0x00d1;\n  t.Ntildesmall = 0xf7f1;\n  t.Nu = 0x039d;\n  t.O = 0x004f;\n  t.OE = 0x0152;\n  t.OEsmall = 0xf6fa;\n  t.Oacute = 0x00d3;\n  t.Oacutesmall = 0xf7f3;\n  t.Obarredcyrillic = 0x04e8;\n  t.Obarreddieresiscyrillic = 0x04ea;\n  t.Obreve = 0x014e;\n  t.Ocaron = 0x01d1;\n  t.Ocenteredtilde = 0x019f;\n  t.Ocircle = 0x24c4;\n  t.Ocircumflex = 0x00d4;\n  t.Ocircumflexacute = 0x1ed0;\n  t.Ocircumflexdotbelow = 0x1ed8;\n  t.Ocircumflexgrave = 0x1ed2;\n  t.Ocircumflexhookabove = 0x1ed4;\n  t.Ocircumflexsmall = 0xf7f4;\n  t.Ocircumflextilde = 0x1ed6;\n  t.Ocyrillic = 0x041e;\n  t.Odblacute = 0x0150;\n  t.Odblgrave = 0x020c;\n  t.Odieresis = 0x00d6;\n  t.Odieresiscyrillic = 0x04e6;\n  t.Odieresissmall = 0xf7f6;\n  t.Odotbelow = 0x1ecc;\n  t.Ogoneksmall = 0xf6fb;\n  t.Ograve = 0x00d2;\n  t.Ogravesmall = 0xf7f2;\n  t.Oharmenian = 0x0555;\n  t.Ohm = 0x2126;\n  t.Ohookabove = 0x1ece;\n  t.Ohorn = 0x01a0;\n  t.Ohornacute = 0x1eda;\n  t.Ohorndotbelow = 0x1ee2;\n  t.Ohorngrave = 0x1edc;\n  t.Ohornhookabove = 0x1ede;\n  t.Ohorntilde = 0x1ee0;\n  t.Ohungarumlaut = 0x0150;\n  t.Oi = 0x01a2;\n  t.Oinvertedbreve = 0x020e;\n  t.Omacron = 0x014c;\n  t.Omacronacute = 0x1e52;\n  t.Omacrongrave = 0x1e50;\n  t.Omega = 0x2126;\n  t.Omegacyrillic = 0x0460;\n  t.Omegagreek = 0x03a9;\n  t.Omegaroundcyrillic = 0x047a;\n  t.Omegatitlocyrillic = 0x047c;\n  t.Omegatonos = 0x038f;\n  t.Omicron = 0x039f;\n  t.Omicrontonos = 0x038c;\n  t.Omonospace = 0xff2f;\n  t.Oneroman = 0x2160;\n  t.Oogonek = 0x01ea;\n  t.Oogonekmacron = 0x01ec;\n  t.Oopen = 0x0186;\n  t.Oslash = 0x00d8;\n  t.Oslashacute = 0x01fe;\n  t.Oslashsmall = 0xf7f8;\n  t.Osmall = 0xf76f;\n  t.Ostrokeacute = 0x01fe;\n  t.Otcyrillic = 0x047e;\n  t.Otilde = 0x00d5;\n  t.Otildeacute = 0x1e4c;\n  t.Otildedieresis = 0x1e4e;\n  t.Otildesmall = 0xf7f5;\n  t.P = 0x0050;\n  t.Pacute = 0x1e54;\n  t.Pcircle = 0x24c5;\n  t.Pdotaccent = 0x1e56;\n  t.Pecyrillic = 0x041f;\n  t.Peharmenian = 0x054a;\n  t.Pemiddlehookcyrillic = 0x04a6;\n  t.Phi = 0x03a6;\n  t.Phook = 0x01a4;\n  t.Pi = 0x03a0;\n  t.Piwrarmenian = 0x0553;\n  t.Pmonospace = 0xff30;\n  t.Psi = 0x03a8;\n  t.Psicyrillic = 0x0470;\n  t.Psmall = 0xf770;\n  t.Q = 0x0051;\n  t.Qcircle = 0x24c6;\n  t.Qmonospace = 0xff31;\n  t.Qsmall = 0xf771;\n  t.R = 0x0052;\n  t.Raarmenian = 0x054c;\n  t.Racute = 0x0154;\n  t.Rcaron = 0x0158;\n  t.Rcedilla = 0x0156;\n  t.Rcircle = 0x24c7;\n  t.Rcommaaccent = 0x0156;\n  t.Rdblgrave = 0x0210;\n  t.Rdotaccent = 0x1e58;\n  t.Rdotbelow = 0x1e5a;\n  t.Rdotbelowmacron = 0x1e5c;\n  t.Reharmenian = 0x0550;\n  t.Rfraktur = 0x211c;\n  t.Rho = 0x03a1;\n  t.Ringsmall = 0xf6fc;\n  t.Rinvertedbreve = 0x0212;\n  t.Rlinebelow = 0x1e5e;\n  t.Rmonospace = 0xff32;\n  t.Rsmall = 0xf772;\n  t.Rsmallinverted = 0x0281;\n  t.Rsmallinvertedsuperior = 0x02b6;\n  t.S = 0x0053;\n  t.SF010000 = 0x250c;\n  t.SF020000 = 0x2514;\n  t.SF030000 = 0x2510;\n  t.SF040000 = 0x2518;\n  t.SF050000 = 0x253c;\n  t.SF060000 = 0x252c;\n  t.SF070000 = 0x2534;\n  t.SF080000 = 0x251c;\n  t.SF090000 = 0x2524;\n  t.SF100000 = 0x2500;\n  t.SF110000 = 0x2502;\n  t.SF190000 = 0x2561;\n  t.SF200000 = 0x2562;\n  t.SF210000 = 0x2556;\n  t.SF220000 = 0x2555;\n  t.SF230000 = 0x2563;\n  t.SF240000 = 0x2551;\n  t.SF250000 = 0x2557;\n  t.SF260000 = 0x255d;\n  t.SF270000 = 0x255c;\n  t.SF280000 = 0x255b;\n  t.SF360000 = 0x255e;\n  t.SF370000 = 0x255f;\n  t.SF380000 = 0x255a;\n  t.SF390000 = 0x2554;\n  t.SF400000 = 0x2569;\n  t.SF410000 = 0x2566;\n  t.SF420000 = 0x2560;\n  t.SF430000 = 0x2550;\n  t.SF440000 = 0x256c;\n  t.SF450000 = 0x2567;\n  t.SF460000 = 0x2568;\n  t.SF470000 = 0x2564;\n  t.SF480000 = 0x2565;\n  t.SF490000 = 0x2559;\n  t.SF500000 = 0x2558;\n  t.SF510000 = 0x2552;\n  t.SF520000 = 0x2553;\n  t.SF530000 = 0x256b;\n  t.SF540000 = 0x256a;\n  t.Sacute = 0x015a;\n  t.Sacutedotaccent = 0x1e64;\n  t.Sampigreek = 0x03e0;\n  t.Scaron = 0x0160;\n  t.Scarondotaccent = 0x1e66;\n  t.Scaronsmall = 0xf6fd;\n  t.Scedilla = 0x015e;\n  t.Schwa = 0x018f;\n  t.Schwacyrillic = 0x04d8;\n  t.Schwadieresiscyrillic = 0x04da;\n  t.Scircle = 0x24c8;\n  t.Scircumflex = 0x015c;\n  t.Scommaaccent = 0x0218;\n  t.Sdotaccent = 0x1e60;\n  t.Sdotbelow = 0x1e62;\n  t.Sdotbelowdotaccent = 0x1e68;\n  t.Seharmenian = 0x054d;\n  t.Sevenroman = 0x2166;\n  t.Shaarmenian = 0x0547;\n  t.Shacyrillic = 0x0428;\n  t.Shchacyrillic = 0x0429;\n  t.Sheicoptic = 0x03e2;\n  t.Shhacyrillic = 0x04ba;\n  t.Shimacoptic = 0x03ec;\n  t.Sigma = 0x03a3;\n  t.Sixroman = 0x2165;\n  t.Smonospace = 0xff33;\n  t.Softsigncyrillic = 0x042c;\n  t.Ssmall = 0xf773;\n  t.Stigmagreek = 0x03da;\n  t.T = 0x0054;\n  t.Tau = 0x03a4;\n  t.Tbar = 0x0166;\n  t.Tcaron = 0x0164;\n  t.Tcedilla = 0x0162;\n  t.Tcircle = 0x24c9;\n  t.Tcircumflexbelow = 0x1e70;\n  t.Tcommaaccent = 0x0162;\n  t.Tdotaccent = 0x1e6a;\n  t.Tdotbelow = 0x1e6c;\n  t.Tecyrillic = 0x0422;\n  t.Tedescendercyrillic = 0x04ac;\n  t.Tenroman = 0x2169;\n  t.Tetsecyrillic = 0x04b4;\n  t.Theta = 0x0398;\n  t.Thook = 0x01ac;\n  t.Thorn = 0x00de;\n  t.Thornsmall = 0xf7fe;\n  t.Threeroman = 0x2162;\n  t.Tildesmall = 0xf6fe;\n  t.Tiwnarmenian = 0x054f;\n  t.Tlinebelow = 0x1e6e;\n  t.Tmonospace = 0xff34;\n  t.Toarmenian = 0x0539;\n  t.Tonefive = 0x01bc;\n  t.Tonesix = 0x0184;\n  t.Tonetwo = 0x01a7;\n  t.Tretroflexhook = 0x01ae;\n  t.Tsecyrillic = 0x0426;\n  t.Tshecyrillic = 0x040b;\n  t.Tsmall = 0xf774;\n  t.Twelveroman = 0x216b;\n  t.Tworoman = 0x2161;\n  t.U = 0x0055;\n  t.Uacute = 0x00da;\n  t.Uacutesmall = 0xf7fa;\n  t.Ubreve = 0x016c;\n  t.Ucaron = 0x01d3;\n  t.Ucircle = 0x24ca;\n  t.Ucircumflex = 0x00db;\n  t.Ucircumflexbelow = 0x1e76;\n  t.Ucircumflexsmall = 0xf7fb;\n  t.Ucyrillic = 0x0423;\n  t.Udblacute = 0x0170;\n  t.Udblgrave = 0x0214;\n  t.Udieresis = 0x00dc;\n  t.Udieresisacute = 0x01d7;\n  t.Udieresisbelow = 0x1e72;\n  t.Udieresiscaron = 0x01d9;\n  t.Udieresiscyrillic = 0x04f0;\n  t.Udieresisgrave = 0x01db;\n  t.Udieresismacron = 0x01d5;\n  t.Udieresissmall = 0xf7fc;\n  t.Udotbelow = 0x1ee4;\n  t.Ugrave = 0x00d9;\n  t.Ugravesmall = 0xf7f9;\n  t.Uhookabove = 0x1ee6;\n  t.Uhorn = 0x01af;\n  t.Uhornacute = 0x1ee8;\n  t.Uhorndotbelow = 0x1ef0;\n  t.Uhorngrave = 0x1eea;\n  t.Uhornhookabove = 0x1eec;\n  t.Uhorntilde = 0x1eee;\n  t.Uhungarumlaut = 0x0170;\n  t.Uhungarumlautcyrillic = 0x04f2;\n  t.Uinvertedbreve = 0x0216;\n  t.Ukcyrillic = 0x0478;\n  t.Umacron = 0x016a;\n  t.Umacroncyrillic = 0x04ee;\n  t.Umacrondieresis = 0x1e7a;\n  t.Umonospace = 0xff35;\n  t.Uogonek = 0x0172;\n  t.Upsilon = 0x03a5;\n  t.Upsilon1 = 0x03d2;\n  t.Upsilonacutehooksymbolgreek = 0x03d3;\n  t.Upsilonafrican = 0x01b1;\n  t.Upsilondieresis = 0x03ab;\n  t.Upsilondieresishooksymbolgreek = 0x03d4;\n  t.Upsilonhooksymbol = 0x03d2;\n  t.Upsilontonos = 0x038e;\n  t.Uring = 0x016e;\n  t.Ushortcyrillic = 0x040e;\n  t.Usmall = 0xf775;\n  t.Ustraightcyrillic = 0x04ae;\n  t.Ustraightstrokecyrillic = 0x04b0;\n  t.Utilde = 0x0168;\n  t.Utildeacute = 0x1e78;\n  t.Utildebelow = 0x1e74;\n  t.V = 0x0056;\n  t.Vcircle = 0x24cb;\n  t.Vdotbelow = 0x1e7e;\n  t.Vecyrillic = 0x0412;\n  t.Vewarmenian = 0x054e;\n  t.Vhook = 0x01b2;\n  t.Vmonospace = 0xff36;\n  t.Voarmenian = 0x0548;\n  t.Vsmall = 0xf776;\n  t.Vtilde = 0x1e7c;\n  t.W = 0x0057;\n  t.Wacute = 0x1e82;\n  t.Wcircle = 0x24cc;\n  t.Wcircumflex = 0x0174;\n  t.Wdieresis = 0x1e84;\n  t.Wdotaccent = 0x1e86;\n  t.Wdotbelow = 0x1e88;\n  t.Wgrave = 0x1e80;\n  t.Wmonospace = 0xff37;\n  t.Wsmall = 0xf777;\n  t.X = 0x0058;\n  t.Xcircle = 0x24cd;\n  t.Xdieresis = 0x1e8c;\n  t.Xdotaccent = 0x1e8a;\n  t.Xeharmenian = 0x053d;\n  t.Xi = 0x039e;\n  t.Xmonospace = 0xff38;\n  t.Xsmall = 0xf778;\n  t.Y = 0x0059;\n  t.Yacute = 0x00dd;\n  t.Yacutesmall = 0xf7fd;\n  t.Yatcyrillic = 0x0462;\n  t.Ycircle = 0x24ce;\n  t.Ycircumflex = 0x0176;\n  t.Ydieresis = 0x0178;\n  t.Ydieresissmall = 0xf7ff;\n  t.Ydotaccent = 0x1e8e;\n  t.Ydotbelow = 0x1ef4;\n  t.Yericyrillic = 0x042b;\n  t.Yerudieresiscyrillic = 0x04f8;\n  t.Ygrave = 0x1ef2;\n  t.Yhook = 0x01b3;\n  t.Yhookabove = 0x1ef6;\n  t.Yiarmenian = 0x0545;\n  t.Yicyrillic = 0x0407;\n  t.Yiwnarmenian = 0x0552;\n  t.Ymonospace = 0xff39;\n  t.Ysmall = 0xf779;\n  t.Ytilde = 0x1ef8;\n  t.Yusbigcyrillic = 0x046a;\n  t.Yusbigiotifiedcyrillic = 0x046c;\n  t.Yuslittlecyrillic = 0x0466;\n  t.Yuslittleiotifiedcyrillic = 0x0468;\n  t.Z = 0x005a;\n  t.Zaarmenian = 0x0536;\n  t.Zacute = 0x0179;\n  t.Zcaron = 0x017d;\n  t.Zcaronsmall = 0xf6ff;\n  t.Zcircle = 0x24cf;\n  t.Zcircumflex = 0x1e90;\n  t.Zdot = 0x017b;\n  t.Zdotaccent = 0x017b;\n  t.Zdotbelow = 0x1e92;\n  t.Zecyrillic = 0x0417;\n  t.Zedescendercyrillic = 0x0498;\n  t.Zedieresiscyrillic = 0x04de;\n  t.Zeta = 0x0396;\n  t.Zhearmenian = 0x053a;\n  t.Zhebrevecyrillic = 0x04c1;\n  t.Zhecyrillic = 0x0416;\n  t.Zhedescendercyrillic = 0x0496;\n  t.Zhedieresiscyrillic = 0x04dc;\n  t.Zlinebelow = 0x1e94;\n  t.Zmonospace = 0xff3a;\n  t.Zsmall = 0xf77a;\n  t.Zstroke = 0x01b5;\n  t.a = 0x0061;\n  t.aabengali = 0x0986;\n  t.aacute = 0x00e1;\n  t.aadeva = 0x0906;\n  t.aagujarati = 0x0a86;\n  t.aagurmukhi = 0x0a06;\n  t.aamatragurmukhi = 0x0a3e;\n  t.aarusquare = 0x3303;\n  t.aavowelsignbengali = 0x09be;\n  t.aavowelsigndeva = 0x093e;\n  t.aavowelsigngujarati = 0x0abe;\n  t.abbreviationmarkarmenian = 0x055f;\n  t.abbreviationsigndeva = 0x0970;\n  t.abengali = 0x0985;\n  t.abopomofo = 0x311a;\n  t.abreve = 0x0103;\n  t.abreveacute = 0x1eaf;\n  t.abrevecyrillic = 0x04d1;\n  t.abrevedotbelow = 0x1eb7;\n  t.abrevegrave = 0x1eb1;\n  t.abrevehookabove = 0x1eb3;\n  t.abrevetilde = 0x1eb5;\n  t.acaron = 0x01ce;\n  t.acircle = 0x24d0;\n  t.acircumflex = 0x00e2;\n  t.acircumflexacute = 0x1ea5;\n  t.acircumflexdotbelow = 0x1ead;\n  t.acircumflexgrave = 0x1ea7;\n  t.acircumflexhookabove = 0x1ea9;\n  t.acircumflextilde = 0x1eab;\n  t.acute = 0x00b4;\n  t.acutebelowcmb = 0x0317;\n  t.acutecmb = 0x0301;\n  t.acutecomb = 0x0301;\n  t.acutedeva = 0x0954;\n  t.acutelowmod = 0x02cf;\n  t.acutetonecmb = 0x0341;\n  t.acyrillic = 0x0430;\n  t.adblgrave = 0x0201;\n  t.addakgurmukhi = 0x0a71;\n  t.adeva = 0x0905;\n  t.adieresis = 0x00e4;\n  t.adieresiscyrillic = 0x04d3;\n  t.adieresismacron = 0x01df;\n  t.adotbelow = 0x1ea1;\n  t.adotmacron = 0x01e1;\n  t.ae = 0x00e6;\n  t.aeacute = 0x01fd;\n  t.aekorean = 0x3150;\n  t.aemacron = 0x01e3;\n  t.afii00208 = 0x2015;\n  t.afii08941 = 0x20a4;\n  t.afii10017 = 0x0410;\n  t.afii10018 = 0x0411;\n  t.afii10019 = 0x0412;\n  t.afii10020 = 0x0413;\n  t.afii10021 = 0x0414;\n  t.afii10022 = 0x0415;\n  t.afii10023 = 0x0401;\n  t.afii10024 = 0x0416;\n  t.afii10025 = 0x0417;\n  t.afii10026 = 0x0418;\n  t.afii10027 = 0x0419;\n  t.afii10028 = 0x041a;\n  t.afii10029 = 0x041b;\n  t.afii10030 = 0x041c;\n  t.afii10031 = 0x041d;\n  t.afii10032 = 0x041e;\n  t.afii10033 = 0x041f;\n  t.afii10034 = 0x0420;\n  t.afii10035 = 0x0421;\n  t.afii10036 = 0x0422;\n  t.afii10037 = 0x0423;\n  t.afii10038 = 0x0424;\n  t.afii10039 = 0x0425;\n  t.afii10040 = 0x0426;\n  t.afii10041 = 0x0427;\n  t.afii10042 = 0x0428;\n  t.afii10043 = 0x0429;\n  t.afii10044 = 0x042a;\n  t.afii10045 = 0x042b;\n  t.afii10046 = 0x042c;\n  t.afii10047 = 0x042d;\n  t.afii10048 = 0x042e;\n  t.afii10049 = 0x042f;\n  t.afii10050 = 0x0490;\n  t.afii10051 = 0x0402;\n  t.afii10052 = 0x0403;\n  t.afii10053 = 0x0404;\n  t.afii10054 = 0x0405;\n  t.afii10055 = 0x0406;\n  t.afii10056 = 0x0407;\n  t.afii10057 = 0x0408;\n  t.afii10058 = 0x0409;\n  t.afii10059 = 0x040a;\n  t.afii10060 = 0x040b;\n  t.afii10061 = 0x040c;\n  t.afii10062 = 0x040e;\n  t.afii10063 = 0xf6c4;\n  t.afii10064 = 0xf6c5;\n  t.afii10065 = 0x0430;\n  t.afii10066 = 0x0431;\n  t.afii10067 = 0x0432;\n  t.afii10068 = 0x0433;\n  t.afii10069 = 0x0434;\n  t.afii10070 = 0x0435;\n  t.afii10071 = 0x0451;\n  t.afii10072 = 0x0436;\n  t.afii10073 = 0x0437;\n  t.afii10074 = 0x0438;\n  t.afii10075 = 0x0439;\n  t.afii10076 = 0x043a;\n  t.afii10077 = 0x043b;\n  t.afii10078 = 0x043c;\n  t.afii10079 = 0x043d;\n  t.afii10080 = 0x043e;\n  t.afii10081 = 0x043f;\n  t.afii10082 = 0x0440;\n  t.afii10083 = 0x0441;\n  t.afii10084 = 0x0442;\n  t.afii10085 = 0x0443;\n  t.afii10086 = 0x0444;\n  t.afii10087 = 0x0445;\n  t.afii10088 = 0x0446;\n  t.afii10089 = 0x0447;\n  t.afii10090 = 0x0448;\n  t.afii10091 = 0x0449;\n  t.afii10092 = 0x044a;\n  t.afii10093 = 0x044b;\n  t.afii10094 = 0x044c;\n  t.afii10095 = 0x044d;\n  t.afii10096 = 0x044e;\n  t.afii10097 = 0x044f;\n  t.afii10098 = 0x0491;\n  t.afii10099 = 0x0452;\n  t.afii10100 = 0x0453;\n  t.afii10101 = 0x0454;\n  t.afii10102 = 0x0455;\n  t.afii10103 = 0x0456;\n  t.afii10104 = 0x0457;\n  t.afii10105 = 0x0458;\n  t.afii10106 = 0x0459;\n  t.afii10107 = 0x045a;\n  t.afii10108 = 0x045b;\n  t.afii10109 = 0x045c;\n  t.afii10110 = 0x045e;\n  t.afii10145 = 0x040f;\n  t.afii10146 = 0x0462;\n  t.afii10147 = 0x0472;\n  t.afii10148 = 0x0474;\n  t.afii10192 = 0xf6c6;\n  t.afii10193 = 0x045f;\n  t.afii10194 = 0x0463;\n  t.afii10195 = 0x0473;\n  t.afii10196 = 0x0475;\n  t.afii10831 = 0xf6c7;\n  t.afii10832 = 0xf6c8;\n  t.afii10846 = 0x04d9;\n  t.afii299 = 0x200e;\n  t.afii300 = 0x200f;\n  t.afii301 = 0x200d;\n  t.afii57381 = 0x066a;\n  t.afii57388 = 0x060c;\n  t.afii57392 = 0x0660;\n  t.afii57393 = 0x0661;\n  t.afii57394 = 0x0662;\n  t.afii57395 = 0x0663;\n  t.afii57396 = 0x0664;\n  t.afii57397 = 0x0665;\n  t.afii57398 = 0x0666;\n  t.afii57399 = 0x0667;\n  t.afii57400 = 0x0668;\n  t.afii57401 = 0x0669;\n  t.afii57403 = 0x061b;\n  t.afii57407 = 0x061f;\n  t.afii57409 = 0x0621;\n  t.afii57410 = 0x0622;\n  t.afii57411 = 0x0623;\n  t.afii57412 = 0x0624;\n  t.afii57413 = 0x0625;\n  t.afii57414 = 0x0626;\n  t.afii57415 = 0x0627;\n  t.afii57416 = 0x0628;\n  t.afii57417 = 0x0629;\n  t.afii57418 = 0x062a;\n  t.afii57419 = 0x062b;\n  t.afii57420 = 0x062c;\n  t.afii57421 = 0x062d;\n  t.afii57422 = 0x062e;\n  t.afii57423 = 0x062f;\n  t.afii57424 = 0x0630;\n  t.afii57425 = 0x0631;\n  t.afii57426 = 0x0632;\n  t.afii57427 = 0x0633;\n  t.afii57428 = 0x0634;\n  t.afii57429 = 0x0635;\n  t.afii57430 = 0x0636;\n  t.afii57431 = 0x0637;\n  t.afii57432 = 0x0638;\n  t.afii57433 = 0x0639;\n  t.afii57434 = 0x063a;\n  t.afii57440 = 0x0640;\n  t.afii57441 = 0x0641;\n  t.afii57442 = 0x0642;\n  t.afii57443 = 0x0643;\n  t.afii57444 = 0x0644;\n  t.afii57445 = 0x0645;\n  t.afii57446 = 0x0646;\n  t.afii57448 = 0x0648;\n  t.afii57449 = 0x0649;\n  t.afii57450 = 0x064a;\n  t.afii57451 = 0x064b;\n  t.afii57452 = 0x064c;\n  t.afii57453 = 0x064d;\n  t.afii57454 = 0x064e;\n  t.afii57455 = 0x064f;\n  t.afii57456 = 0x0650;\n  t.afii57457 = 0x0651;\n  t.afii57458 = 0x0652;\n  t.afii57470 = 0x0647;\n  t.afii57505 = 0x06a4;\n  t.afii57506 = 0x067e;\n  t.afii57507 = 0x0686;\n  t.afii57508 = 0x0698;\n  t.afii57509 = 0x06af;\n  t.afii57511 = 0x0679;\n  t.afii57512 = 0x0688;\n  t.afii57513 = 0x0691;\n  t.afii57514 = 0x06ba;\n  t.afii57519 = 0x06d2;\n  t.afii57534 = 0x06d5;\n  t.afii57636 = 0x20aa;\n  t.afii57645 = 0x05be;\n  t.afii57658 = 0x05c3;\n  t.afii57664 = 0x05d0;\n  t.afii57665 = 0x05d1;\n  t.afii57666 = 0x05d2;\n  t.afii57667 = 0x05d3;\n  t.afii57668 = 0x05d4;\n  t.afii57669 = 0x05d5;\n  t.afii57670 = 0x05d6;\n  t.afii57671 = 0x05d7;\n  t.afii57672 = 0x05d8;\n  t.afii57673 = 0x05d9;\n  t.afii57674 = 0x05da;\n  t.afii57675 = 0x05db;\n  t.afii57676 = 0x05dc;\n  t.afii57677 = 0x05dd;\n  t.afii57678 = 0x05de;\n  t.afii57679 = 0x05df;\n  t.afii57680 = 0x05e0;\n  t.afii57681 = 0x05e1;\n  t.afii57682 = 0x05e2;\n  t.afii57683 = 0x05e3;\n  t.afii57684 = 0x05e4;\n  t.afii57685 = 0x05e5;\n  t.afii57686 = 0x05e6;\n  t.afii57687 = 0x05e7;\n  t.afii57688 = 0x05e8;\n  t.afii57689 = 0x05e9;\n  t.afii57690 = 0x05ea;\n  t.afii57694 = 0xfb2a;\n  t.afii57695 = 0xfb2b;\n  t.afii57700 = 0xfb4b;\n  t.afii57705 = 0xfb1f;\n  t.afii57716 = 0x05f0;\n  t.afii57717 = 0x05f1;\n  t.afii57718 = 0x05f2;\n  t.afii57723 = 0xfb35;\n  t.afii57793 = 0x05b4;\n  t.afii57794 = 0x05b5;\n  t.afii57795 = 0x05b6;\n  t.afii57796 = 0x05bb;\n  t.afii57797 = 0x05b8;\n  t.afii57798 = 0x05b7;\n  t.afii57799 = 0x05b0;\n  t.afii57800 = 0x05b2;\n  t.afii57801 = 0x05b1;\n  t.afii57802 = 0x05b3;\n  t.afii57803 = 0x05c2;\n  t.afii57804 = 0x05c1;\n  t.afii57806 = 0x05b9;\n  t.afii57807 = 0x05bc;\n  t.afii57839 = 0x05bd;\n  t.afii57841 = 0x05bf;\n  t.afii57842 = 0x05c0;\n  t.afii57929 = 0x02bc;\n  t.afii61248 = 0x2105;\n  t.afii61289 = 0x2113;\n  t.afii61352 = 0x2116;\n  t.afii61573 = 0x202c;\n  t.afii61574 = 0x202d;\n  t.afii61575 = 0x202e;\n  t.afii61664 = 0x200c;\n  t.afii63167 = 0x066d;\n  t.afii64937 = 0x02bd;\n  t.agrave = 0x00e0;\n  t.agujarati = 0x0a85;\n  t.agurmukhi = 0x0a05;\n  t.ahiragana = 0x3042;\n  t.ahookabove = 0x1ea3;\n  t.aibengali = 0x0990;\n  t.aibopomofo = 0x311e;\n  t.aideva = 0x0910;\n  t.aiecyrillic = 0x04d5;\n  t.aigujarati = 0x0a90;\n  t.aigurmukhi = 0x0a10;\n  t.aimatragurmukhi = 0x0a48;\n  t.ainarabic = 0x0639;\n  t.ainfinalarabic = 0xfeca;\n  t.aininitialarabic = 0xfecb;\n  t.ainmedialarabic = 0xfecc;\n  t.ainvertedbreve = 0x0203;\n  t.aivowelsignbengali = 0x09c8;\n  t.aivowelsigndeva = 0x0948;\n  t.aivowelsigngujarati = 0x0ac8;\n  t.akatakana = 0x30a2;\n  t.akatakanahalfwidth = 0xff71;\n  t.akorean = 0x314f;\n  t.alef = 0x05d0;\n  t.alefarabic = 0x0627;\n  t.alefdageshhebrew = 0xfb30;\n  t.aleffinalarabic = 0xfe8e;\n  t.alefhamzaabovearabic = 0x0623;\n  t.alefhamzaabovefinalarabic = 0xfe84;\n  t.alefhamzabelowarabic = 0x0625;\n  t.alefhamzabelowfinalarabic = 0xfe88;\n  t.alefhebrew = 0x05d0;\n  t.aleflamedhebrew = 0xfb4f;\n  t.alefmaddaabovearabic = 0x0622;\n  t.alefmaddaabovefinalarabic = 0xfe82;\n  t.alefmaksuraarabic = 0x0649;\n  t.alefmaksurafinalarabic = 0xfef0;\n  t.alefmaksurainitialarabic = 0xfef3;\n  t.alefmaksuramedialarabic = 0xfef4;\n  t.alefpatahhebrew = 0xfb2e;\n  t.alefqamatshebrew = 0xfb2f;\n  t.aleph = 0x2135;\n  t.allequal = 0x224c;\n  t.alpha = 0x03b1;\n  t.alphatonos = 0x03ac;\n  t.amacron = 0x0101;\n  t.amonospace = 0xff41;\n  t.ampersand = 0x0026;\n  t.ampersandmonospace = 0xff06;\n  t.ampersandsmall = 0xf726;\n  t.amsquare = 0x33c2;\n  t.anbopomofo = 0x3122;\n  t.angbopomofo = 0x3124;\n  t.angbracketleft = 0x3008;\n  t.angbracketright = 0x3009;\n  t.angkhankhuthai = 0x0e5a;\n  t.angle = 0x2220;\n  t.anglebracketleft = 0x3008;\n  t.anglebracketleftvertical = 0xfe3f;\n  t.anglebracketright = 0x3009;\n  t.anglebracketrightvertical = 0xfe40;\n  t.angleleft = 0x2329;\n  t.angleright = 0x232a;\n  t.angstrom = 0x212b;\n  t.anoteleia = 0x0387;\n  t.anudattadeva = 0x0952;\n  t.anusvarabengali = 0x0982;\n  t.anusvaradeva = 0x0902;\n  t.anusvaragujarati = 0x0a82;\n  t.aogonek = 0x0105;\n  t.apaatosquare = 0x3300;\n  t.aparen = 0x249c;\n  t.apostrophearmenian = 0x055a;\n  t.apostrophemod = 0x02bc;\n  t.apple = 0xf8ff;\n  t.approaches = 0x2250;\n  t.approxequal = 0x2248;\n  t.approxequalorimage = 0x2252;\n  t.approximatelyequal = 0x2245;\n  t.araeaekorean = 0x318e;\n  t.araeakorean = 0x318d;\n  t.arc = 0x2312;\n  t.arighthalfring = 0x1e9a;\n  t.aring = 0x00e5;\n  t.aringacute = 0x01fb;\n  t.aringbelow = 0x1e01;\n  t.arrowboth = 0x2194;\n  t.arrowdashdown = 0x21e3;\n  t.arrowdashleft = 0x21e0;\n  t.arrowdashright = 0x21e2;\n  t.arrowdashup = 0x21e1;\n  t.arrowdblboth = 0x21d4;\n  t.arrowdbldown = 0x21d3;\n  t.arrowdblleft = 0x21d0;\n  t.arrowdblright = 0x21d2;\n  t.arrowdblup = 0x21d1;\n  t.arrowdown = 0x2193;\n  t.arrowdownleft = 0x2199;\n  t.arrowdownright = 0x2198;\n  t.arrowdownwhite = 0x21e9;\n  t.arrowheaddownmod = 0x02c5;\n  t.arrowheadleftmod = 0x02c2;\n  t.arrowheadrightmod = 0x02c3;\n  t.arrowheadupmod = 0x02c4;\n  t.arrowhorizex = 0xf8e7;\n  t.arrowleft = 0x2190;\n  t.arrowleftdbl = 0x21d0;\n  t.arrowleftdblstroke = 0x21cd;\n  t.arrowleftoverright = 0x21c6;\n  t.arrowleftwhite = 0x21e6;\n  t.arrowright = 0x2192;\n  t.arrowrightdblstroke = 0x21cf;\n  t.arrowrightheavy = 0x279e;\n  t.arrowrightoverleft = 0x21c4;\n  t.arrowrightwhite = 0x21e8;\n  t.arrowtableft = 0x21e4;\n  t.arrowtabright = 0x21e5;\n  t.arrowup = 0x2191;\n  t.arrowupdn = 0x2195;\n  t.arrowupdnbse = 0x21a8;\n  t.arrowupdownbase = 0x21a8;\n  t.arrowupleft = 0x2196;\n  t.arrowupleftofdown = 0x21c5;\n  t.arrowupright = 0x2197;\n  t.arrowupwhite = 0x21e7;\n  t.arrowvertex = 0xf8e6;\n  t.asciicircum = 0x005e;\n  t.asciicircummonospace = 0xff3e;\n  t.asciitilde = 0x007e;\n  t.asciitildemonospace = 0xff5e;\n  t.ascript = 0x0251;\n  t.ascriptturned = 0x0252;\n  t.asmallhiragana = 0x3041;\n  t.asmallkatakana = 0x30a1;\n  t.asmallkatakanahalfwidth = 0xff67;\n  t.asterisk = 0x002a;\n  t.asteriskaltonearabic = 0x066d;\n  t.asteriskarabic = 0x066d;\n  t.asteriskmath = 0x2217;\n  t.asteriskmonospace = 0xff0a;\n  t.asterisksmall = 0xfe61;\n  t.asterism = 0x2042;\n  t.asuperior = 0xf6e9;\n  t.asymptoticallyequal = 0x2243;\n  t.at = 0x0040;\n  t.atilde = 0x00e3;\n  t.atmonospace = 0xff20;\n  t.atsmall = 0xfe6b;\n  t.aturned = 0x0250;\n  t.aubengali = 0x0994;\n  t.aubopomofo = 0x3120;\n  t.audeva = 0x0914;\n  t.augujarati = 0x0a94;\n  t.augurmukhi = 0x0a14;\n  t.aulengthmarkbengali = 0x09d7;\n  t.aumatragurmukhi = 0x0a4c;\n  t.auvowelsignbengali = 0x09cc;\n  t.auvowelsigndeva = 0x094c;\n  t.auvowelsigngujarati = 0x0acc;\n  t.avagrahadeva = 0x093d;\n  t.aybarmenian = 0x0561;\n  t.ayin = 0x05e2;\n  t.ayinaltonehebrew = 0xfb20;\n  t.ayinhebrew = 0x05e2;\n  t.b = 0x0062;\n  t.babengali = 0x09ac;\n  t.backslash = 0x005c;\n  t.backslashmonospace = 0xff3c;\n  t.badeva = 0x092c;\n  t.bagujarati = 0x0aac;\n  t.bagurmukhi = 0x0a2c;\n  t.bahiragana = 0x3070;\n  t.bahtthai = 0x0e3f;\n  t.bakatakana = 0x30d0;\n  t.bar = 0x007c;\n  t.barmonospace = 0xff5c;\n  t.bbopomofo = 0x3105;\n  t.bcircle = 0x24d1;\n  t.bdotaccent = 0x1e03;\n  t.bdotbelow = 0x1e05;\n  t.beamedsixteenthnotes = 0x266c;\n  t.because = 0x2235;\n  t.becyrillic = 0x0431;\n  t.beharabic = 0x0628;\n  t.behfinalarabic = 0xfe90;\n  t.behinitialarabic = 0xfe91;\n  t.behiragana = 0x3079;\n  t.behmedialarabic = 0xfe92;\n  t.behmeeminitialarabic = 0xfc9f;\n  t.behmeemisolatedarabic = 0xfc08;\n  t.behnoonfinalarabic = 0xfc6d;\n  t.bekatakana = 0x30d9;\n  t.benarmenian = 0x0562;\n  t.bet = 0x05d1;\n  t.beta = 0x03b2;\n  t.betasymbolgreek = 0x03d0;\n  t.betdagesh = 0xfb31;\n  t.betdageshhebrew = 0xfb31;\n  t.bethebrew = 0x05d1;\n  t.betrafehebrew = 0xfb4c;\n  t.bhabengali = 0x09ad;\n  t.bhadeva = 0x092d;\n  t.bhagujarati = 0x0aad;\n  t.bhagurmukhi = 0x0a2d;\n  t.bhook = 0x0253;\n  t.bihiragana = 0x3073;\n  t.bikatakana = 0x30d3;\n  t.bilabialclick = 0x0298;\n  t.bindigurmukhi = 0x0a02;\n  t.birusquare = 0x3331;\n  t.blackcircle = 0x25cf;\n  t.blackdiamond = 0x25c6;\n  t.blackdownpointingtriangle = 0x25bc;\n  t.blackleftpointingpointer = 0x25c4;\n  t.blackleftpointingtriangle = 0x25c0;\n  t.blacklenticularbracketleft = 0x3010;\n  t.blacklenticularbracketleftvertical = 0xfe3b;\n  t.blacklenticularbracketright = 0x3011;\n  t.blacklenticularbracketrightvertical = 0xfe3c;\n  t.blacklowerlefttriangle = 0x25e3;\n  t.blacklowerrighttriangle = 0x25e2;\n  t.blackrectangle = 0x25ac;\n  t.blackrightpointingpointer = 0x25ba;\n  t.blackrightpointingtriangle = 0x25b6;\n  t.blacksmallsquare = 0x25aa;\n  t.blacksmilingface = 0x263b;\n  t.blacksquare = 0x25a0;\n  t.blackstar = 0x2605;\n  t.blackupperlefttriangle = 0x25e4;\n  t.blackupperrighttriangle = 0x25e5;\n  t.blackuppointingsmalltriangle = 0x25b4;\n  t.blackuppointingtriangle = 0x25b2;\n  t.blank = 0x2423;\n  t.blinebelow = 0x1e07;\n  t.block = 0x2588;\n  t.bmonospace = 0xff42;\n  t.bobaimaithai = 0x0e1a;\n  t.bohiragana = 0x307c;\n  t.bokatakana = 0x30dc;\n  t.bparen = 0x249d;\n  t.bqsquare = 0x33c3;\n  t.braceex = 0xf8f4;\n  t.braceleft = 0x007b;\n  t.braceleftbt = 0xf8f3;\n  t.braceleftmid = 0xf8f2;\n  t.braceleftmonospace = 0xff5b;\n  t.braceleftsmall = 0xfe5b;\n  t.bracelefttp = 0xf8f1;\n  t.braceleftvertical = 0xfe37;\n  t.braceright = 0x007d;\n  t.bracerightbt = 0xf8fe;\n  t.bracerightmid = 0xf8fd;\n  t.bracerightmonospace = 0xff5d;\n  t.bracerightsmall = 0xfe5c;\n  t.bracerighttp = 0xf8fc;\n  t.bracerightvertical = 0xfe38;\n  t.bracketleft = 0x005b;\n  t.bracketleftbt = 0xf8f0;\n  t.bracketleftex = 0xf8ef;\n  t.bracketleftmonospace = 0xff3b;\n  t.bracketlefttp = 0xf8ee;\n  t.bracketright = 0x005d;\n  t.bracketrightbt = 0xf8fb;\n  t.bracketrightex = 0xf8fa;\n  t.bracketrightmonospace = 0xff3d;\n  t.bracketrighttp = 0xf8f9;\n  t.breve = 0x02d8;\n  t.brevebelowcmb = 0x032e;\n  t.brevecmb = 0x0306;\n  t.breveinvertedbelowcmb = 0x032f;\n  t.breveinvertedcmb = 0x0311;\n  t.breveinverteddoublecmb = 0x0361;\n  t.bridgebelowcmb = 0x032a;\n  t.bridgeinvertedbelowcmb = 0x033a;\n  t.brokenbar = 0x00a6;\n  t.bstroke = 0x0180;\n  t.bsuperior = 0xf6ea;\n  t.btopbar = 0x0183;\n  t.buhiragana = 0x3076;\n  t.bukatakana = 0x30d6;\n  t.bullet = 0x2022;\n  t.bulletinverse = 0x25d8;\n  t.bulletoperator = 0x2219;\n  t.bullseye = 0x25ce;\n  t.c = 0x0063;\n  t.caarmenian = 0x056e;\n  t.cabengali = 0x099a;\n  t.cacute = 0x0107;\n  t.cadeva = 0x091a;\n  t.cagujarati = 0x0a9a;\n  t.cagurmukhi = 0x0a1a;\n  t.calsquare = 0x3388;\n  t.candrabindubengali = 0x0981;\n  t.candrabinducmb = 0x0310;\n  t.candrabindudeva = 0x0901;\n  t.candrabindugujarati = 0x0a81;\n  t.capslock = 0x21ea;\n  t.careof = 0x2105;\n  t.caron = 0x02c7;\n  t.caronbelowcmb = 0x032c;\n  t.caroncmb = 0x030c;\n  t.carriagereturn = 0x21b5;\n  t.cbopomofo = 0x3118;\n  t.ccaron = 0x010d;\n  t.ccedilla = 0x00e7;\n  t.ccedillaacute = 0x1e09;\n  t.ccircle = 0x24d2;\n  t.ccircumflex = 0x0109;\n  t.ccurl = 0x0255;\n  t.cdot = 0x010b;\n  t.cdotaccent = 0x010b;\n  t.cdsquare = 0x33c5;\n  t.cedilla = 0x00b8;\n  t.cedillacmb = 0x0327;\n  t.cent = 0x00a2;\n  t.centigrade = 0x2103;\n  t.centinferior = 0xf6df;\n  t.centmonospace = 0xffe0;\n  t.centoldstyle = 0xf7a2;\n  t.centsuperior = 0xf6e0;\n  t.chaarmenian = 0x0579;\n  t.chabengali = 0x099b;\n  t.chadeva = 0x091b;\n  t.chagujarati = 0x0a9b;\n  t.chagurmukhi = 0x0a1b;\n  t.chbopomofo = 0x3114;\n  t.cheabkhasiancyrillic = 0x04bd;\n  t.checkmark = 0x2713;\n  t.checyrillic = 0x0447;\n  t.chedescenderabkhasiancyrillic = 0x04bf;\n  t.chedescendercyrillic = 0x04b7;\n  t.chedieresiscyrillic = 0x04f5;\n  t.cheharmenian = 0x0573;\n  t.chekhakassiancyrillic = 0x04cc;\n  t.cheverticalstrokecyrillic = 0x04b9;\n  t.chi = 0x03c7;\n  t.chieuchacirclekorean = 0x3277;\n  t.chieuchaparenkorean = 0x3217;\n  t.chieuchcirclekorean = 0x3269;\n  t.chieuchkorean = 0x314a;\n  t.chieuchparenkorean = 0x3209;\n  t.chochangthai = 0x0e0a;\n  t.chochanthai = 0x0e08;\n  t.chochingthai = 0x0e09;\n  t.chochoethai = 0x0e0c;\n  t.chook = 0x0188;\n  t.cieucacirclekorean = 0x3276;\n  t.cieucaparenkorean = 0x3216;\n  t.cieuccirclekorean = 0x3268;\n  t.cieuckorean = 0x3148;\n  t.cieucparenkorean = 0x3208;\n  t.cieucuparenkorean = 0x321c;\n  t.circle = 0x25cb;\n  t.circlecopyrt = 0x00a9;\n  t.circlemultiply = 0x2297;\n  t.circleot = 0x2299;\n  t.circleplus = 0x2295;\n  t.circlepostalmark = 0x3036;\n  t.circlewithlefthalfblack = 0x25d0;\n  t.circlewithrighthalfblack = 0x25d1;\n  t.circumflex = 0x02c6;\n  t.circumflexbelowcmb = 0x032d;\n  t.circumflexcmb = 0x0302;\n  t.clear = 0x2327;\n  t.clickalveolar = 0x01c2;\n  t.clickdental = 0x01c0;\n  t.clicklateral = 0x01c1;\n  t.clickretroflex = 0x01c3;\n  t.club = 0x2663;\n  t.clubsuitblack = 0x2663;\n  t.clubsuitwhite = 0x2667;\n  t.cmcubedsquare = 0x33a4;\n  t.cmonospace = 0xff43;\n  t.cmsquaredsquare = 0x33a0;\n  t.coarmenian = 0x0581;\n  t.colon = 0x003a;\n  t.colonmonetary = 0x20a1;\n  t.colonmonospace = 0xff1a;\n  t.colonsign = 0x20a1;\n  t.colonsmall = 0xfe55;\n  t.colontriangularhalfmod = 0x02d1;\n  t.colontriangularmod = 0x02d0;\n  t.comma = 0x002c;\n  t.commaabovecmb = 0x0313;\n  t.commaaboverightcmb = 0x0315;\n  t.commaaccent = 0xf6c3;\n  t.commaarabic = 0x060c;\n  t.commaarmenian = 0x055d;\n  t.commainferior = 0xf6e1;\n  t.commamonospace = 0xff0c;\n  t.commareversedabovecmb = 0x0314;\n  t.commareversedmod = 0x02bd;\n  t.commasmall = 0xfe50;\n  t.commasuperior = 0xf6e2;\n  t.commaturnedabovecmb = 0x0312;\n  t.commaturnedmod = 0x02bb;\n  t.compass = 0x263c;\n  t.congruent = 0x2245;\n  t.contourintegral = 0x222e;\n  t.control = 0x2303;\n  t.controlACK = 0x0006;\n  t.controlBEL = 0x0007;\n  t.controlBS = 0x0008;\n  t.controlCAN = 0x0018;\n  t.controlCR = 0x000d;\n  t.controlDC1 = 0x0011;\n  t.controlDC2 = 0x0012;\n  t.controlDC3 = 0x0013;\n  t.controlDC4 = 0x0014;\n  t.controlDEL = 0x007f;\n  t.controlDLE = 0x0010;\n  t.controlEM = 0x0019;\n  t.controlENQ = 0x0005;\n  t.controlEOT = 0x0004;\n  t.controlESC = 0x001b;\n  t.controlETB = 0x0017;\n  t.controlETX = 0x0003;\n  t.controlFF = 0x000c;\n  t.controlFS = 0x001c;\n  t.controlGS = 0x001d;\n  t.controlHT = 0x0009;\n  t.controlLF = 0x000a;\n  t.controlNAK = 0x0015;\n  t.controlNULL = 0x0000;\n  t.controlRS = 0x001e;\n  t.controlSI = 0x000f;\n  t.controlSO = 0x000e;\n  t.controlSOT = 0x0002;\n  t.controlSTX = 0x0001;\n  t.controlSUB = 0x001a;\n  t.controlSYN = 0x0016;\n  t.controlUS = 0x001f;\n  t.controlVT = 0x000b;\n  t.copyright = 0x00a9;\n  t.copyrightsans = 0xf8e9;\n  t.copyrightserif = 0xf6d9;\n  t.cornerbracketleft = 0x300c;\n  t.cornerbracketlefthalfwidth = 0xff62;\n  t.cornerbracketleftvertical = 0xfe41;\n  t.cornerbracketright = 0x300d;\n  t.cornerbracketrighthalfwidth = 0xff63;\n  t.cornerbracketrightvertical = 0xfe42;\n  t.corporationsquare = 0x337f;\n  t.cosquare = 0x33c7;\n  t.coverkgsquare = 0x33c6;\n  t.cparen = 0x249e;\n  t.cruzeiro = 0x20a2;\n  t.cstretched = 0x0297;\n  t.curlyand = 0x22cf;\n  t.curlyor = 0x22ce;\n  t.currency = 0x00a4;\n  t.cyrBreve = 0xf6d1;\n  t.cyrFlex = 0xf6d2;\n  t.cyrbreve = 0xf6d4;\n  t.cyrflex = 0xf6d5;\n  t.d = 0x0064;\n  t.daarmenian = 0x0564;\n  t.dabengali = 0x09a6;\n  t.dadarabic = 0x0636;\n  t.dadeva = 0x0926;\n  t.dadfinalarabic = 0xfebe;\n  t.dadinitialarabic = 0xfebf;\n  t.dadmedialarabic = 0xfec0;\n  t.dagesh = 0x05bc;\n  t.dageshhebrew = 0x05bc;\n  t.dagger = 0x2020;\n  t.daggerdbl = 0x2021;\n  t.dagujarati = 0x0aa6;\n  t.dagurmukhi = 0x0a26;\n  t.dahiragana = 0x3060;\n  t.dakatakana = 0x30c0;\n  t.dalarabic = 0x062f;\n  t.dalet = 0x05d3;\n  t.daletdagesh = 0xfb33;\n  t.daletdageshhebrew = 0xfb33;\n  t.dalethebrew = 0x05d3;\n  t.dalfinalarabic = 0xfeaa;\n  t.dammaarabic = 0x064f;\n  t.dammalowarabic = 0x064f;\n  t.dammatanaltonearabic = 0x064c;\n  t.dammatanarabic = 0x064c;\n  t.danda = 0x0964;\n  t.dargahebrew = 0x05a7;\n  t.dargalefthebrew = 0x05a7;\n  t.dasiapneumatacyrilliccmb = 0x0485;\n  t.dblGrave = 0xf6d3;\n  t.dblanglebracketleft = 0x300a;\n  t.dblanglebracketleftvertical = 0xfe3d;\n  t.dblanglebracketright = 0x300b;\n  t.dblanglebracketrightvertical = 0xfe3e;\n  t.dblarchinvertedbelowcmb = 0x032b;\n  t.dblarrowleft = 0x21d4;\n  t.dblarrowright = 0x21d2;\n  t.dbldanda = 0x0965;\n  t.dblgrave = 0xf6d6;\n  t.dblgravecmb = 0x030f;\n  t.dblintegral = 0x222c;\n  t.dbllowline = 0x2017;\n  t.dbllowlinecmb = 0x0333;\n  t.dbloverlinecmb = 0x033f;\n  t.dblprimemod = 0x02ba;\n  t.dblverticalbar = 0x2016;\n  t.dblverticallineabovecmb = 0x030e;\n  t.dbopomofo = 0x3109;\n  t.dbsquare = 0x33c8;\n  t.dcaron = 0x010f;\n  t.dcedilla = 0x1e11;\n  t.dcircle = 0x24d3;\n  t.dcircumflexbelow = 0x1e13;\n  t.dcroat = 0x0111;\n  t.ddabengali = 0x09a1;\n  t.ddadeva = 0x0921;\n  t.ddagujarati = 0x0aa1;\n  t.ddagurmukhi = 0x0a21;\n  t.ddalarabic = 0x0688;\n  t.ddalfinalarabic = 0xfb89;\n  t.dddhadeva = 0x095c;\n  t.ddhabengali = 0x09a2;\n  t.ddhadeva = 0x0922;\n  t.ddhagujarati = 0x0aa2;\n  t.ddhagurmukhi = 0x0a22;\n  t.ddotaccent = 0x1e0b;\n  t.ddotbelow = 0x1e0d;\n  t.decimalseparatorarabic = 0x066b;\n  t.decimalseparatorpersian = 0x066b;\n  t.decyrillic = 0x0434;\n  t.degree = 0x00b0;\n  t.dehihebrew = 0x05ad;\n  t.dehiragana = 0x3067;\n  t.deicoptic = 0x03ef;\n  t.dekatakana = 0x30c7;\n  t.deleteleft = 0x232b;\n  t.deleteright = 0x2326;\n  t.delta = 0x03b4;\n  t.deltaturned = 0x018d;\n  t.denominatorminusonenumeratorbengali = 0x09f8;\n  t.dezh = 0x02a4;\n  t.dhabengali = 0x09a7;\n  t.dhadeva = 0x0927;\n  t.dhagujarati = 0x0aa7;\n  t.dhagurmukhi = 0x0a27;\n  t.dhook = 0x0257;\n  t.dialytikatonos = 0x0385;\n  t.dialytikatonoscmb = 0x0344;\n  t.diamond = 0x2666;\n  t.diamondsuitwhite = 0x2662;\n  t.dieresis = 0x00a8;\n  t.dieresisacute = 0xf6d7;\n  t.dieresisbelowcmb = 0x0324;\n  t.dieresiscmb = 0x0308;\n  t.dieresisgrave = 0xf6d8;\n  t.dieresistonos = 0x0385;\n  t.dihiragana = 0x3062;\n  t.dikatakana = 0x30c2;\n  t.dittomark = 0x3003;\n  t.divide = 0x00f7;\n  t.divides = 0x2223;\n  t.divisionslash = 0x2215;\n  t.djecyrillic = 0x0452;\n  t.dkshade = 0x2593;\n  t.dlinebelow = 0x1e0f;\n  t.dlsquare = 0x3397;\n  t.dmacron = 0x0111;\n  t.dmonospace = 0xff44;\n  t.dnblock = 0x2584;\n  t.dochadathai = 0x0e0e;\n  t.dodekthai = 0x0e14;\n  t.dohiragana = 0x3069;\n  t.dokatakana = 0x30c9;\n  t.dollar = 0x0024;\n  t.dollarinferior = 0xf6e3;\n  t.dollarmonospace = 0xff04;\n  t.dollaroldstyle = 0xf724;\n  t.dollarsmall = 0xfe69;\n  t.dollarsuperior = 0xf6e4;\n  t.dong = 0x20ab;\n  t.dorusquare = 0x3326;\n  t.dotaccent = 0x02d9;\n  t.dotaccentcmb = 0x0307;\n  t.dotbelowcmb = 0x0323;\n  t.dotbelowcomb = 0x0323;\n  t.dotkatakana = 0x30fb;\n  t.dotlessi = 0x0131;\n  t.dotlessj = 0xf6be;\n  t.dotlessjstrokehook = 0x0284;\n  t.dotmath = 0x22c5;\n  t.dottedcircle = 0x25cc;\n  t.doubleyodpatah = 0xfb1f;\n  t.doubleyodpatahhebrew = 0xfb1f;\n  t.downtackbelowcmb = 0x031e;\n  t.downtackmod = 0x02d5;\n  t.dparen = 0x249f;\n  t.dsuperior = 0xf6eb;\n  t.dtail = 0x0256;\n  t.dtopbar = 0x018c;\n  t.duhiragana = 0x3065;\n  t.dukatakana = 0x30c5;\n  t.dz = 0x01f3;\n  t.dzaltone = 0x02a3;\n  t.dzcaron = 0x01c6;\n  t.dzcurl = 0x02a5;\n  t.dzeabkhasiancyrillic = 0x04e1;\n  t.dzecyrillic = 0x0455;\n  t.dzhecyrillic = 0x045f;\n  t.e = 0x0065;\n  t.eacute = 0x00e9;\n  t.earth = 0x2641;\n  t.ebengali = 0x098f;\n  t.ebopomofo = 0x311c;\n  t.ebreve = 0x0115;\n  t.ecandradeva = 0x090d;\n  t.ecandragujarati = 0x0a8d;\n  t.ecandravowelsigndeva = 0x0945;\n  t.ecandravowelsigngujarati = 0x0ac5;\n  t.ecaron = 0x011b;\n  t.ecedillabreve = 0x1e1d;\n  t.echarmenian = 0x0565;\n  t.echyiwnarmenian = 0x0587;\n  t.ecircle = 0x24d4;\n  t.ecircumflex = 0x00ea;\n  t.ecircumflexacute = 0x1ebf;\n  t.ecircumflexbelow = 0x1e19;\n  t.ecircumflexdotbelow = 0x1ec7;\n  t.ecircumflexgrave = 0x1ec1;\n  t.ecircumflexhookabove = 0x1ec3;\n  t.ecircumflextilde = 0x1ec5;\n  t.ecyrillic = 0x0454;\n  t.edblgrave = 0x0205;\n  t.edeva = 0x090f;\n  t.edieresis = 0x00eb;\n  t.edot = 0x0117;\n  t.edotaccent = 0x0117;\n  t.edotbelow = 0x1eb9;\n  t.eegurmukhi = 0x0a0f;\n  t.eematragurmukhi = 0x0a47;\n  t.efcyrillic = 0x0444;\n  t.egrave = 0x00e8;\n  t.egujarati = 0x0a8f;\n  t.eharmenian = 0x0567;\n  t.ehbopomofo = 0x311d;\n  t.ehiragana = 0x3048;\n  t.ehookabove = 0x1ebb;\n  t.eibopomofo = 0x311f;\n  t.eight = 0x0038;\n  t.eightarabic = 0x0668;\n  t.eightbengali = 0x09ee;\n  t.eightcircle = 0x2467;\n  t.eightcircleinversesansserif = 0x2791;\n  t.eightdeva = 0x096e;\n  t.eighteencircle = 0x2471;\n  t.eighteenparen = 0x2485;\n  t.eighteenperiod = 0x2499;\n  t.eightgujarati = 0x0aee;\n  t.eightgurmukhi = 0x0a6e;\n  t.eighthackarabic = 0x0668;\n  t.eighthangzhou = 0x3028;\n  t.eighthnotebeamed = 0x266b;\n  t.eightideographicparen = 0x3227;\n  t.eightinferior = 0x2088;\n  t.eightmonospace = 0xff18;\n  t.eightoldstyle = 0xf738;\n  t.eightparen = 0x247b;\n  t.eightperiod = 0x248f;\n  t.eightpersian = 0x06f8;\n  t.eightroman = 0x2177;\n  t.eightsuperior = 0x2078;\n  t.eightthai = 0x0e58;\n  t.einvertedbreve = 0x0207;\n  t.eiotifiedcyrillic = 0x0465;\n  t.ekatakana = 0x30a8;\n  t.ekatakanahalfwidth = 0xff74;\n  t.ekonkargurmukhi = 0x0a74;\n  t.ekorean = 0x3154;\n  t.elcyrillic = 0x043b;\n  t.element = 0x2208;\n  t.elevencircle = 0x246a;\n  t.elevenparen = 0x247e;\n  t.elevenperiod = 0x2492;\n  t.elevenroman = 0x217a;\n  t.ellipsis = 0x2026;\n  t.ellipsisvertical = 0x22ee;\n  t.emacron = 0x0113;\n  t.emacronacute = 0x1e17;\n  t.emacrongrave = 0x1e15;\n  t.emcyrillic = 0x043c;\n  t.emdash = 0x2014;\n  t.emdashvertical = 0xfe31;\n  t.emonospace = 0xff45;\n  t.emphasismarkarmenian = 0x055b;\n  t.emptyset = 0x2205;\n  t.enbopomofo = 0x3123;\n  t.encyrillic = 0x043d;\n  t.endash = 0x2013;\n  t.endashvertical = 0xfe32;\n  t.endescendercyrillic = 0x04a3;\n  t.eng = 0x014b;\n  t.engbopomofo = 0x3125;\n  t.enghecyrillic = 0x04a5;\n  t.enhookcyrillic = 0x04c8;\n  t.enspace = 0x2002;\n  t.eogonek = 0x0119;\n  t.eokorean = 0x3153;\n  t.eopen = 0x025b;\n  t.eopenclosed = 0x029a;\n  t.eopenreversed = 0x025c;\n  t.eopenreversedclosed = 0x025e;\n  t.eopenreversedhook = 0x025d;\n  t.eparen = 0x24a0;\n  t.epsilon = 0x03b5;\n  t.epsilontonos = 0x03ad;\n  t.equal = 0x003d;\n  t.equalmonospace = 0xff1d;\n  t.equalsmall = 0xfe66;\n  t.equalsuperior = 0x207c;\n  t.equivalence = 0x2261;\n  t.erbopomofo = 0x3126;\n  t.ercyrillic = 0x0440;\n  t.ereversed = 0x0258;\n  t.ereversedcyrillic = 0x044d;\n  t.escyrillic = 0x0441;\n  t.esdescendercyrillic = 0x04ab;\n  t.esh = 0x0283;\n  t.eshcurl = 0x0286;\n  t.eshortdeva = 0x090e;\n  t.eshortvowelsigndeva = 0x0946;\n  t.eshreversedloop = 0x01aa;\n  t.eshsquatreversed = 0x0285;\n  t.esmallhiragana = 0x3047;\n  t.esmallkatakana = 0x30a7;\n  t.esmallkatakanahalfwidth = 0xff6a;\n  t.estimated = 0x212e;\n  t.esuperior = 0xf6ec;\n  t.eta = 0x03b7;\n  t.etarmenian = 0x0568;\n  t.etatonos = 0x03ae;\n  t.eth = 0x00f0;\n  t.etilde = 0x1ebd;\n  t.etildebelow = 0x1e1b;\n  t.etnahtafoukhhebrew = 0x0591;\n  t.etnahtafoukhlefthebrew = 0x0591;\n  t.etnahtahebrew = 0x0591;\n  t.etnahtalefthebrew = 0x0591;\n  t.eturned = 0x01dd;\n  t.eukorean = 0x3161;\n  t.euro = 0x20ac;\n  t.evowelsignbengali = 0x09c7;\n  t.evowelsigndeva = 0x0947;\n  t.evowelsigngujarati = 0x0ac7;\n  t.exclam = 0x0021;\n  t.exclamarmenian = 0x055c;\n  t.exclamdbl = 0x203c;\n  t.exclamdown = 0x00a1;\n  t.exclamdownsmall = 0xf7a1;\n  t.exclammonospace = 0xff01;\n  t.exclamsmall = 0xf721;\n  t.existential = 0x2203;\n  t.ezh = 0x0292;\n  t.ezhcaron = 0x01ef;\n  t.ezhcurl = 0x0293;\n  t.ezhreversed = 0x01b9;\n  t.ezhtail = 0x01ba;\n  t.f = 0x0066;\n  t.fadeva = 0x095e;\n  t.fagurmukhi = 0x0a5e;\n  t.fahrenheit = 0x2109;\n  t.fathaarabic = 0x064e;\n  t.fathalowarabic = 0x064e;\n  t.fathatanarabic = 0x064b;\n  t.fbopomofo = 0x3108;\n  t.fcircle = 0x24d5;\n  t.fdotaccent = 0x1e1f;\n  t.feharabic = 0x0641;\n  t.feharmenian = 0x0586;\n  t.fehfinalarabic = 0xfed2;\n  t.fehinitialarabic = 0xfed3;\n  t.fehmedialarabic = 0xfed4;\n  t.feicoptic = 0x03e5;\n  t.female = 0x2640;\n  t.ff = 0xfb00;\n  t.f_f = 0xfb00;\n  t.ffi = 0xfb03;\n  t.f_f_i = 0xfb03;\n  t.ffl = 0xfb04;\n  t.f_f_l = 0xfb04;\n  t.fi = 0xfb01;\n  t.f_i = 0xfb01;\n  t.fifteencircle = 0x246e;\n  t.fifteenparen = 0x2482;\n  t.fifteenperiod = 0x2496;\n  t.figuredash = 0x2012;\n  t.filledbox = 0x25a0;\n  t.filledrect = 0x25ac;\n  t.finalkaf = 0x05da;\n  t.finalkafdagesh = 0xfb3a;\n  t.finalkafdageshhebrew = 0xfb3a;\n  t.finalkafhebrew = 0x05da;\n  t.finalmem = 0x05dd;\n  t.finalmemhebrew = 0x05dd;\n  t.finalnun = 0x05df;\n  t.finalnunhebrew = 0x05df;\n  t.finalpe = 0x05e3;\n  t.finalpehebrew = 0x05e3;\n  t.finaltsadi = 0x05e5;\n  t.finaltsadihebrew = 0x05e5;\n  t.firsttonechinese = 0x02c9;\n  t.fisheye = 0x25c9;\n  t.fitacyrillic = 0x0473;\n  t.five = 0x0035;\n  t.fivearabic = 0x0665;\n  t.fivebengali = 0x09eb;\n  t.fivecircle = 0x2464;\n  t.fivecircleinversesansserif = 0x278e;\n  t.fivedeva = 0x096b;\n  t.fiveeighths = 0x215d;\n  t.fivegujarati = 0x0aeb;\n  t.fivegurmukhi = 0x0a6b;\n  t.fivehackarabic = 0x0665;\n  t.fivehangzhou = 0x3025;\n  t.fiveideographicparen = 0x3224;\n  t.fiveinferior = 0x2085;\n  t.fivemonospace = 0xff15;\n  t.fiveoldstyle = 0xf735;\n  t.fiveparen = 0x2478;\n  t.fiveperiod = 0x248c;\n  t.fivepersian = 0x06f5;\n  t.fiveroman = 0x2174;\n  t.fivesuperior = 0x2075;\n  t.fivethai = 0x0e55;\n  t.fl = 0xfb02;\n  t.f_l = 0xfb02;\n  t.florin = 0x0192;\n  t.fmonospace = 0xff46;\n  t.fmsquare = 0x3399;\n  t.fofanthai = 0x0e1f;\n  t.fofathai = 0x0e1d;\n  t.fongmanthai = 0x0e4f;\n  t.forall = 0x2200;\n  t.four = 0x0034;\n  t.fourarabic = 0x0664;\n  t.fourbengali = 0x09ea;\n  t.fourcircle = 0x2463;\n  t.fourcircleinversesansserif = 0x278d;\n  t.fourdeva = 0x096a;\n  t.fourgujarati = 0x0aea;\n  t.fourgurmukhi = 0x0a6a;\n  t.fourhackarabic = 0x0664;\n  t.fourhangzhou = 0x3024;\n  t.fourideographicparen = 0x3223;\n  t.fourinferior = 0x2084;\n  t.fourmonospace = 0xff14;\n  t.fournumeratorbengali = 0x09f7;\n  t.fouroldstyle = 0xf734;\n  t.fourparen = 0x2477;\n  t.fourperiod = 0x248b;\n  t.fourpersian = 0x06f4;\n  t.fourroman = 0x2173;\n  t.foursuperior = 0x2074;\n  t.fourteencircle = 0x246d;\n  t.fourteenparen = 0x2481;\n  t.fourteenperiod = 0x2495;\n  t.fourthai = 0x0e54;\n  t.fourthtonechinese = 0x02cb;\n  t.fparen = 0x24a1;\n  t.fraction = 0x2044;\n  t.franc = 0x20a3;\n  t.g = 0x0067;\n  t.gabengali = 0x0997;\n  t.gacute = 0x01f5;\n  t.gadeva = 0x0917;\n  t.gafarabic = 0x06af;\n  t.gaffinalarabic = 0xfb93;\n  t.gafinitialarabic = 0xfb94;\n  t.gafmedialarabic = 0xfb95;\n  t.gagujarati = 0x0a97;\n  t.gagurmukhi = 0x0a17;\n  t.gahiragana = 0x304c;\n  t.gakatakana = 0x30ac;\n  t.gamma = 0x03b3;\n  t.gammalatinsmall = 0x0263;\n  t.gammasuperior = 0x02e0;\n  t.gangiacoptic = 0x03eb;\n  t.gbopomofo = 0x310d;\n  t.gbreve = 0x011f;\n  t.gcaron = 0x01e7;\n  t.gcedilla = 0x0123;\n  t.gcircle = 0x24d6;\n  t.gcircumflex = 0x011d;\n  t.gcommaaccent = 0x0123;\n  t.gdot = 0x0121;\n  t.gdotaccent = 0x0121;\n  t.gecyrillic = 0x0433;\n  t.gehiragana = 0x3052;\n  t.gekatakana = 0x30b2;\n  t.geometricallyequal = 0x2251;\n  t.gereshaccenthebrew = 0x059c;\n  t.gereshhebrew = 0x05f3;\n  t.gereshmuqdamhebrew = 0x059d;\n  t.germandbls = 0x00df;\n  t.gershayimaccenthebrew = 0x059e;\n  t.gershayimhebrew = 0x05f4;\n  t.getamark = 0x3013;\n  t.ghabengali = 0x0998;\n  t.ghadarmenian = 0x0572;\n  t.ghadeva = 0x0918;\n  t.ghagujarati = 0x0a98;\n  t.ghagurmukhi = 0x0a18;\n  t.ghainarabic = 0x063a;\n  t.ghainfinalarabic = 0xfece;\n  t.ghaininitialarabic = 0xfecf;\n  t.ghainmedialarabic = 0xfed0;\n  t.ghemiddlehookcyrillic = 0x0495;\n  t.ghestrokecyrillic = 0x0493;\n  t.gheupturncyrillic = 0x0491;\n  t.ghhadeva = 0x095a;\n  t.ghhagurmukhi = 0x0a5a;\n  t.ghook = 0x0260;\n  t.ghzsquare = 0x3393;\n  t.gihiragana = 0x304e;\n  t.gikatakana = 0x30ae;\n  t.gimarmenian = 0x0563;\n  t.gimel = 0x05d2;\n  t.gimeldagesh = 0xfb32;\n  t.gimeldageshhebrew = 0xfb32;\n  t.gimelhebrew = 0x05d2;\n  t.gjecyrillic = 0x0453;\n  t.glottalinvertedstroke = 0x01be;\n  t.glottalstop = 0x0294;\n  t.glottalstopinverted = 0x0296;\n  t.glottalstopmod = 0x02c0;\n  t.glottalstopreversed = 0x0295;\n  t.glottalstopreversedmod = 0x02c1;\n  t.glottalstopreversedsuperior = 0x02e4;\n  t.glottalstopstroke = 0x02a1;\n  t.glottalstopstrokereversed = 0x02a2;\n  t.gmacron = 0x1e21;\n  t.gmonospace = 0xff47;\n  t.gohiragana = 0x3054;\n  t.gokatakana = 0x30b4;\n  t.gparen = 0x24a2;\n  t.gpasquare = 0x33ac;\n  t.gradient = 0x2207;\n  t.grave = 0x0060;\n  t.gravebelowcmb = 0x0316;\n  t.gravecmb = 0x0300;\n  t.gravecomb = 0x0300;\n  t.gravedeva = 0x0953;\n  t.gravelowmod = 0x02ce;\n  t.gravemonospace = 0xff40;\n  t.gravetonecmb = 0x0340;\n  t.greater = 0x003e;\n  t.greaterequal = 0x2265;\n  t.greaterequalorless = 0x22db;\n  t.greatermonospace = 0xff1e;\n  t.greaterorequivalent = 0x2273;\n  t.greaterorless = 0x2277;\n  t.greateroverequal = 0x2267;\n  t.greatersmall = 0xfe65;\n  t.gscript = 0x0261;\n  t.gstroke = 0x01e5;\n  t.guhiragana = 0x3050;\n  t.guillemotleft = 0x00ab;\n  t.guillemotright = 0x00bb;\n  t.guilsinglleft = 0x2039;\n  t.guilsinglright = 0x203a;\n  t.gukatakana = 0x30b0;\n  t.guramusquare = 0x3318;\n  t.gysquare = 0x33c9;\n  t.h = 0x0068;\n  t.haabkhasiancyrillic = 0x04a9;\n  t.haaltonearabic = 0x06c1;\n  t.habengali = 0x09b9;\n  t.hadescendercyrillic = 0x04b3;\n  t.hadeva = 0x0939;\n  t.hagujarati = 0x0ab9;\n  t.hagurmukhi = 0x0a39;\n  t.haharabic = 0x062d;\n  t.hahfinalarabic = 0xfea2;\n  t.hahinitialarabic = 0xfea3;\n  t.hahiragana = 0x306f;\n  t.hahmedialarabic = 0xfea4;\n  t.haitusquare = 0x332a;\n  t.hakatakana = 0x30cf;\n  t.hakatakanahalfwidth = 0xff8a;\n  t.halantgurmukhi = 0x0a4d;\n  t.hamzaarabic = 0x0621;\n  t.hamzalowarabic = 0x0621;\n  t.hangulfiller = 0x3164;\n  t.hardsigncyrillic = 0x044a;\n  t.harpoonleftbarbup = 0x21bc;\n  t.harpoonrightbarbup = 0x21c0;\n  t.hasquare = 0x33ca;\n  t.hatafpatah = 0x05b2;\n  t.hatafpatah16 = 0x05b2;\n  t.hatafpatah23 = 0x05b2;\n  t.hatafpatah2f = 0x05b2;\n  t.hatafpatahhebrew = 0x05b2;\n  t.hatafpatahnarrowhebrew = 0x05b2;\n  t.hatafpatahquarterhebrew = 0x05b2;\n  t.hatafpatahwidehebrew = 0x05b2;\n  t.hatafqamats = 0x05b3;\n  t.hatafqamats1b = 0x05b3;\n  t.hatafqamats28 = 0x05b3;\n  t.hatafqamats34 = 0x05b3;\n  t.hatafqamatshebrew = 0x05b3;\n  t.hatafqamatsnarrowhebrew = 0x05b3;\n  t.hatafqamatsquarterhebrew = 0x05b3;\n  t.hatafqamatswidehebrew = 0x05b3;\n  t.hatafsegol = 0x05b1;\n  t.hatafsegol17 = 0x05b1;\n  t.hatafsegol24 = 0x05b1;\n  t.hatafsegol30 = 0x05b1;\n  t.hatafsegolhebrew = 0x05b1;\n  t.hatafsegolnarrowhebrew = 0x05b1;\n  t.hatafsegolquarterhebrew = 0x05b1;\n  t.hatafsegolwidehebrew = 0x05b1;\n  t.hbar = 0x0127;\n  t.hbopomofo = 0x310f;\n  t.hbrevebelow = 0x1e2b;\n  t.hcedilla = 0x1e29;\n  t.hcircle = 0x24d7;\n  t.hcircumflex = 0x0125;\n  t.hdieresis = 0x1e27;\n  t.hdotaccent = 0x1e23;\n  t.hdotbelow = 0x1e25;\n  t.he = 0x05d4;\n  t.heart = 0x2665;\n  t.heartsuitblack = 0x2665;\n  t.heartsuitwhite = 0x2661;\n  t.hedagesh = 0xfb34;\n  t.hedageshhebrew = 0xfb34;\n  t.hehaltonearabic = 0x06c1;\n  t.heharabic = 0x0647;\n  t.hehebrew = 0x05d4;\n  t.hehfinalaltonearabic = 0xfba7;\n  t.hehfinalalttwoarabic = 0xfeea;\n  t.hehfinalarabic = 0xfeea;\n  t.hehhamzaabovefinalarabic = 0xfba5;\n  t.hehhamzaaboveisolatedarabic = 0xfba4;\n  t.hehinitialaltonearabic = 0xfba8;\n  t.hehinitialarabic = 0xfeeb;\n  t.hehiragana = 0x3078;\n  t.hehmedialaltonearabic = 0xfba9;\n  t.hehmedialarabic = 0xfeec;\n  t.heiseierasquare = 0x337b;\n  t.hekatakana = 0x30d8;\n  t.hekatakanahalfwidth = 0xff8d;\n  t.hekutaarusquare = 0x3336;\n  t.henghook = 0x0267;\n  t.herutusquare = 0x3339;\n  t.het = 0x05d7;\n  t.hethebrew = 0x05d7;\n  t.hhook = 0x0266;\n  t.hhooksuperior = 0x02b1;\n  t.hieuhacirclekorean = 0x327b;\n  t.hieuhaparenkorean = 0x321b;\n  t.hieuhcirclekorean = 0x326d;\n  t.hieuhkorean = 0x314e;\n  t.hieuhparenkorean = 0x320d;\n  t.hihiragana = 0x3072;\n  t.hikatakana = 0x30d2;\n  t.hikatakanahalfwidth = 0xff8b;\n  t.hiriq = 0x05b4;\n  t.hiriq14 = 0x05b4;\n  t.hiriq21 = 0x05b4;\n  t.hiriq2d = 0x05b4;\n  t.hiriqhebrew = 0x05b4;\n  t.hiriqnarrowhebrew = 0x05b4;\n  t.hiriqquarterhebrew = 0x05b4;\n  t.hiriqwidehebrew = 0x05b4;\n  t.hlinebelow = 0x1e96;\n  t.hmonospace = 0xff48;\n  t.hoarmenian = 0x0570;\n  t.hohipthai = 0x0e2b;\n  t.hohiragana = 0x307b;\n  t.hokatakana = 0x30db;\n  t.hokatakanahalfwidth = 0xff8e;\n  t.holam = 0x05b9;\n  t.holam19 = 0x05b9;\n  t.holam26 = 0x05b9;\n  t.holam32 = 0x05b9;\n  t.holamhebrew = 0x05b9;\n  t.holamnarrowhebrew = 0x05b9;\n  t.holamquarterhebrew = 0x05b9;\n  t.holamwidehebrew = 0x05b9;\n  t.honokhukthai = 0x0e2e;\n  t.hookabovecomb = 0x0309;\n  t.hookcmb = 0x0309;\n  t.hookpalatalizedbelowcmb = 0x0321;\n  t.hookretroflexbelowcmb = 0x0322;\n  t.hoonsquare = 0x3342;\n  t.horicoptic = 0x03e9;\n  t.horizontalbar = 0x2015;\n  t.horncmb = 0x031b;\n  t.hotsprings = 0x2668;\n  t.house = 0x2302;\n  t.hparen = 0x24a3;\n  t.hsuperior = 0x02b0;\n  t.hturned = 0x0265;\n  t.huhiragana = 0x3075;\n  t.huiitosquare = 0x3333;\n  t.hukatakana = 0x30d5;\n  t.hukatakanahalfwidth = 0xff8c;\n  t.hungarumlaut = 0x02dd;\n  t.hungarumlautcmb = 0x030b;\n  t.hv = 0x0195;\n  t.hyphen = 0x002d;\n  t.hypheninferior = 0xf6e5;\n  t.hyphenmonospace = 0xff0d;\n  t.hyphensmall = 0xfe63;\n  t.hyphensuperior = 0xf6e6;\n  t.hyphentwo = 0x2010;\n  t.i = 0x0069;\n  t.iacute = 0x00ed;\n  t.iacyrillic = 0x044f;\n  t.ibengali = 0x0987;\n  t.ibopomofo = 0x3127;\n  t.ibreve = 0x012d;\n  t.icaron = 0x01d0;\n  t.icircle = 0x24d8;\n  t.icircumflex = 0x00ee;\n  t.icyrillic = 0x0456;\n  t.idblgrave = 0x0209;\n  t.ideographearthcircle = 0x328f;\n  t.ideographfirecircle = 0x328b;\n  t.ideographicallianceparen = 0x323f;\n  t.ideographiccallparen = 0x323a;\n  t.ideographiccentrecircle = 0x32a5;\n  t.ideographicclose = 0x3006;\n  t.ideographiccomma = 0x3001;\n  t.ideographiccommaleft = 0xff64;\n  t.ideographiccongratulationparen = 0x3237;\n  t.ideographiccorrectcircle = 0x32a3;\n  t.ideographicearthparen = 0x322f;\n  t.ideographicenterpriseparen = 0x323d;\n  t.ideographicexcellentcircle = 0x329d;\n  t.ideographicfestivalparen = 0x3240;\n  t.ideographicfinancialcircle = 0x3296;\n  t.ideographicfinancialparen = 0x3236;\n  t.ideographicfireparen = 0x322b;\n  t.ideographichaveparen = 0x3232;\n  t.ideographichighcircle = 0x32a4;\n  t.ideographiciterationmark = 0x3005;\n  t.ideographiclaborcircle = 0x3298;\n  t.ideographiclaborparen = 0x3238;\n  t.ideographicleftcircle = 0x32a7;\n  t.ideographiclowcircle = 0x32a6;\n  t.ideographicmedicinecircle = 0x32a9;\n  t.ideographicmetalparen = 0x322e;\n  t.ideographicmoonparen = 0x322a;\n  t.ideographicnameparen = 0x3234;\n  t.ideographicperiod = 0x3002;\n  t.ideographicprintcircle = 0x329e;\n  t.ideographicreachparen = 0x3243;\n  t.ideographicrepresentparen = 0x3239;\n  t.ideographicresourceparen = 0x323e;\n  t.ideographicrightcircle = 0x32a8;\n  t.ideographicsecretcircle = 0x3299;\n  t.ideographicselfparen = 0x3242;\n  t.ideographicsocietyparen = 0x3233;\n  t.ideographicspace = 0x3000;\n  t.ideographicspecialparen = 0x3235;\n  t.ideographicstockparen = 0x3231;\n  t.ideographicstudyparen = 0x323b;\n  t.ideographicsunparen = 0x3230;\n  t.ideographicsuperviseparen = 0x323c;\n  t.ideographicwaterparen = 0x322c;\n  t.ideographicwoodparen = 0x322d;\n  t.ideographiczero = 0x3007;\n  t.ideographmetalcircle = 0x328e;\n  t.ideographmooncircle = 0x328a;\n  t.ideographnamecircle = 0x3294;\n  t.ideographsuncircle = 0x3290;\n  t.ideographwatercircle = 0x328c;\n  t.ideographwoodcircle = 0x328d;\n  t.ideva = 0x0907;\n  t.idieresis = 0x00ef;\n  t.idieresisacute = 0x1e2f;\n  t.idieresiscyrillic = 0x04e5;\n  t.idotbelow = 0x1ecb;\n  t.iebrevecyrillic = 0x04d7;\n  t.iecyrillic = 0x0435;\n  t.ieungacirclekorean = 0x3275;\n  t.ieungaparenkorean = 0x3215;\n  t.ieungcirclekorean = 0x3267;\n  t.ieungkorean = 0x3147;\n  t.ieungparenkorean = 0x3207;\n  t.igrave = 0x00ec;\n  t.igujarati = 0x0a87;\n  t.igurmukhi = 0x0a07;\n  t.ihiragana = 0x3044;\n  t.ihookabove = 0x1ec9;\n  t.iibengali = 0x0988;\n  t.iicyrillic = 0x0438;\n  t.iideva = 0x0908;\n  t.iigujarati = 0x0a88;\n  t.iigurmukhi = 0x0a08;\n  t.iimatragurmukhi = 0x0a40;\n  t.iinvertedbreve = 0x020b;\n  t.iishortcyrillic = 0x0439;\n  t.iivowelsignbengali = 0x09c0;\n  t.iivowelsigndeva = 0x0940;\n  t.iivowelsigngujarati = 0x0ac0;\n  t.ij = 0x0133;\n  t.ikatakana = 0x30a4;\n  t.ikatakanahalfwidth = 0xff72;\n  t.ikorean = 0x3163;\n  t.ilde = 0x02dc;\n  t.iluyhebrew = 0x05ac;\n  t.imacron = 0x012b;\n  t.imacroncyrillic = 0x04e3;\n  t.imageorapproximatelyequal = 0x2253;\n  t.imatragurmukhi = 0x0a3f;\n  t.imonospace = 0xff49;\n  t.increment = 0x2206;\n  t.infinity = 0x221e;\n  t.iniarmenian = 0x056b;\n  t.integral = 0x222b;\n  t.integralbottom = 0x2321;\n  t.integralbt = 0x2321;\n  t.integralex = 0xf8f5;\n  t.integraltop = 0x2320;\n  t.integraltp = 0x2320;\n  t.intersection = 0x2229;\n  t.intisquare = 0x3305;\n  t.invbullet = 0x25d8;\n  t.invcircle = 0x25d9;\n  t.invsmileface = 0x263b;\n  t.iocyrillic = 0x0451;\n  t.iogonek = 0x012f;\n  t.iota = 0x03b9;\n  t.iotadieresis = 0x03ca;\n  t.iotadieresistonos = 0x0390;\n  t.iotalatin = 0x0269;\n  t.iotatonos = 0x03af;\n  t.iparen = 0x24a4;\n  t.irigurmukhi = 0x0a72;\n  t.ismallhiragana = 0x3043;\n  t.ismallkatakana = 0x30a3;\n  t.ismallkatakanahalfwidth = 0xff68;\n  t.issharbengali = 0x09fa;\n  t.istroke = 0x0268;\n  t.isuperior = 0xf6ed;\n  t.iterationhiragana = 0x309d;\n  t.iterationkatakana = 0x30fd;\n  t.itilde = 0x0129;\n  t.itildebelow = 0x1e2d;\n  t.iubopomofo = 0x3129;\n  t.iucyrillic = 0x044e;\n  t.ivowelsignbengali = 0x09bf;\n  t.ivowelsigndeva = 0x093f;\n  t.ivowelsigngujarati = 0x0abf;\n  t.izhitsacyrillic = 0x0475;\n  t.izhitsadblgravecyrillic = 0x0477;\n  t.j = 0x006a;\n  t.jaarmenian = 0x0571;\n  t.jabengali = 0x099c;\n  t.jadeva = 0x091c;\n  t.jagujarati = 0x0a9c;\n  t.jagurmukhi = 0x0a1c;\n  t.jbopomofo = 0x3110;\n  t.jcaron = 0x01f0;\n  t.jcircle = 0x24d9;\n  t.jcircumflex = 0x0135;\n  t.jcrossedtail = 0x029d;\n  t.jdotlessstroke = 0x025f;\n  t.jecyrillic = 0x0458;\n  t.jeemarabic = 0x062c;\n  t.jeemfinalarabic = 0xfe9e;\n  t.jeeminitialarabic = 0xfe9f;\n  t.jeemmedialarabic = 0xfea0;\n  t.jeharabic = 0x0698;\n  t.jehfinalarabic = 0xfb8b;\n  t.jhabengali = 0x099d;\n  t.jhadeva = 0x091d;\n  t.jhagujarati = 0x0a9d;\n  t.jhagurmukhi = 0x0a1d;\n  t.jheharmenian = 0x057b;\n  t.jis = 0x3004;\n  t.jmonospace = 0xff4a;\n  t.jparen = 0x24a5;\n  t.jsuperior = 0x02b2;\n  t.k = 0x006b;\n  t.kabashkircyrillic = 0x04a1;\n  t.kabengali = 0x0995;\n  t.kacute = 0x1e31;\n  t.kacyrillic = 0x043a;\n  t.kadescendercyrillic = 0x049b;\n  t.kadeva = 0x0915;\n  t.kaf = 0x05db;\n  t.kafarabic = 0x0643;\n  t.kafdagesh = 0xfb3b;\n  t.kafdageshhebrew = 0xfb3b;\n  t.kaffinalarabic = 0xfeda;\n  t.kafhebrew = 0x05db;\n  t.kafinitialarabic = 0xfedb;\n  t.kafmedialarabic = 0xfedc;\n  t.kafrafehebrew = 0xfb4d;\n  t.kagujarati = 0x0a95;\n  t.kagurmukhi = 0x0a15;\n  t.kahiragana = 0x304b;\n  t.kahookcyrillic = 0x04c4;\n  t.kakatakana = 0x30ab;\n  t.kakatakanahalfwidth = 0xff76;\n  t.kappa = 0x03ba;\n  t.kappasymbolgreek = 0x03f0;\n  t.kapyeounmieumkorean = 0x3171;\n  t.kapyeounphieuphkorean = 0x3184;\n  t.kapyeounpieupkorean = 0x3178;\n  t.kapyeounssangpieupkorean = 0x3179;\n  t.karoriisquare = 0x330d;\n  t.kashidaautoarabic = 0x0640;\n  t.kashidaautonosidebearingarabic = 0x0640;\n  t.kasmallkatakana = 0x30f5;\n  t.kasquare = 0x3384;\n  t.kasraarabic = 0x0650;\n  t.kasratanarabic = 0x064d;\n  t.kastrokecyrillic = 0x049f;\n  t.katahiraprolongmarkhalfwidth = 0xff70;\n  t.kaverticalstrokecyrillic = 0x049d;\n  t.kbopomofo = 0x310e;\n  t.kcalsquare = 0x3389;\n  t.kcaron = 0x01e9;\n  t.kcedilla = 0x0137;\n  t.kcircle = 0x24da;\n  t.kcommaaccent = 0x0137;\n  t.kdotbelow = 0x1e33;\n  t.keharmenian = 0x0584;\n  t.kehiragana = 0x3051;\n  t.kekatakana = 0x30b1;\n  t.kekatakanahalfwidth = 0xff79;\n  t.kenarmenian = 0x056f;\n  t.kesmallkatakana = 0x30f6;\n  t.kgreenlandic = 0x0138;\n  t.khabengali = 0x0996;\n  t.khacyrillic = 0x0445;\n  t.khadeva = 0x0916;\n  t.khagujarati = 0x0a96;\n  t.khagurmukhi = 0x0a16;\n  t.khaharabic = 0x062e;\n  t.khahfinalarabic = 0xfea6;\n  t.khahinitialarabic = 0xfea7;\n  t.khahmedialarabic = 0xfea8;\n  t.kheicoptic = 0x03e7;\n  t.khhadeva = 0x0959;\n  t.khhagurmukhi = 0x0a59;\n  t.khieukhacirclekorean = 0x3278;\n  t.khieukhaparenkorean = 0x3218;\n  t.khieukhcirclekorean = 0x326a;\n  t.khieukhkorean = 0x314b;\n  t.khieukhparenkorean = 0x320a;\n  t.khokhaithai = 0x0e02;\n  t.khokhonthai = 0x0e05;\n  t.khokhuatthai = 0x0e03;\n  t.khokhwaithai = 0x0e04;\n  t.khomutthai = 0x0e5b;\n  t.khook = 0x0199;\n  t.khorakhangthai = 0x0e06;\n  t.khzsquare = 0x3391;\n  t.kihiragana = 0x304d;\n  t.kikatakana = 0x30ad;\n  t.kikatakanahalfwidth = 0xff77;\n  t.kiroguramusquare = 0x3315;\n  t.kiromeetorusquare = 0x3316;\n  t.kirosquare = 0x3314;\n  t.kiyeokacirclekorean = 0x326e;\n  t.kiyeokaparenkorean = 0x320e;\n  t.kiyeokcirclekorean = 0x3260;\n  t.kiyeokkorean = 0x3131;\n  t.kiyeokparenkorean = 0x3200;\n  t.kiyeoksioskorean = 0x3133;\n  t.kjecyrillic = 0x045c;\n  t.klinebelow = 0x1e35;\n  t.klsquare = 0x3398;\n  t.kmcubedsquare = 0x33a6;\n  t.kmonospace = 0xff4b;\n  t.kmsquaredsquare = 0x33a2;\n  t.kohiragana = 0x3053;\n  t.kohmsquare = 0x33c0;\n  t.kokaithai = 0x0e01;\n  t.kokatakana = 0x30b3;\n  t.kokatakanahalfwidth = 0xff7a;\n  t.kooposquare = 0x331e;\n  t.koppacyrillic = 0x0481;\n  t.koreanstandardsymbol = 0x327f;\n  t.koroniscmb = 0x0343;\n  t.kparen = 0x24a6;\n  t.kpasquare = 0x33aa;\n  t.ksicyrillic = 0x046f;\n  t.ktsquare = 0x33cf;\n  t.kturned = 0x029e;\n  t.kuhiragana = 0x304f;\n  t.kukatakana = 0x30af;\n  t.kukatakanahalfwidth = 0xff78;\n  t.kvsquare = 0x33b8;\n  t.kwsquare = 0x33be;\n  t.l = 0x006c;\n  t.labengali = 0x09b2;\n  t.lacute = 0x013a;\n  t.ladeva = 0x0932;\n  t.lagujarati = 0x0ab2;\n  t.lagurmukhi = 0x0a32;\n  t.lakkhangyaothai = 0x0e45;\n  t.lamaleffinalarabic = 0xfefc;\n  t.lamalefhamzaabovefinalarabic = 0xfef8;\n  t.lamalefhamzaaboveisolatedarabic = 0xfef7;\n  t.lamalefhamzabelowfinalarabic = 0xfefa;\n  t.lamalefhamzabelowisolatedarabic = 0xfef9;\n  t.lamalefisolatedarabic = 0xfefb;\n  t.lamalefmaddaabovefinalarabic = 0xfef6;\n  t.lamalefmaddaaboveisolatedarabic = 0xfef5;\n  t.lamarabic = 0x0644;\n  t.lambda = 0x03bb;\n  t.lambdastroke = 0x019b;\n  t.lamed = 0x05dc;\n  t.lameddagesh = 0xfb3c;\n  t.lameddageshhebrew = 0xfb3c;\n  t.lamedhebrew = 0x05dc;\n  t.lamfinalarabic = 0xfede;\n  t.lamhahinitialarabic = 0xfcca;\n  t.laminitialarabic = 0xfedf;\n  t.lamjeeminitialarabic = 0xfcc9;\n  t.lamkhahinitialarabic = 0xfccb;\n  t.lamlamhehisolatedarabic = 0xfdf2;\n  t.lammedialarabic = 0xfee0;\n  t.lammeemhahinitialarabic = 0xfd88;\n  t.lammeeminitialarabic = 0xfccc;\n  t.largecircle = 0x25ef;\n  t.lbar = 0x019a;\n  t.lbelt = 0x026c;\n  t.lbopomofo = 0x310c;\n  t.lcaron = 0x013e;\n  t.lcedilla = 0x013c;\n  t.lcircle = 0x24db;\n  t.lcircumflexbelow = 0x1e3d;\n  t.lcommaaccent = 0x013c;\n  t.ldot = 0x0140;\n  t.ldotaccent = 0x0140;\n  t.ldotbelow = 0x1e37;\n  t.ldotbelowmacron = 0x1e39;\n  t.leftangleabovecmb = 0x031a;\n  t.lefttackbelowcmb = 0x0318;\n  t.less = 0x003c;\n  t.lessequal = 0x2264;\n  t.lessequalorgreater = 0x22da;\n  t.lessmonospace = 0xff1c;\n  t.lessorequivalent = 0x2272;\n  t.lessorgreater = 0x2276;\n  t.lessoverequal = 0x2266;\n  t.lesssmall = 0xfe64;\n  t.lezh = 0x026e;\n  t.lfblock = 0x258c;\n  t.lhookretroflex = 0x026d;\n  t.lira = 0x20a4;\n  t.liwnarmenian = 0x056c;\n  t.lj = 0x01c9;\n  t.ljecyrillic = 0x0459;\n  t.ll = 0xf6c0;\n  t.lladeva = 0x0933;\n  t.llagujarati = 0x0ab3;\n  t.llinebelow = 0x1e3b;\n  t.llladeva = 0x0934;\n  t.llvocalicbengali = 0x09e1;\n  t.llvocalicdeva = 0x0961;\n  t.llvocalicvowelsignbengali = 0x09e3;\n  t.llvocalicvowelsigndeva = 0x0963;\n  t.lmiddletilde = 0x026b;\n  t.lmonospace = 0xff4c;\n  t.lmsquare = 0x33d0;\n  t.lochulathai = 0x0e2c;\n  t.logicaland = 0x2227;\n  t.logicalnot = 0x00ac;\n  t.logicalnotreversed = 0x2310;\n  t.logicalor = 0x2228;\n  t.lolingthai = 0x0e25;\n  t.longs = 0x017f;\n  t.lowlinecenterline = 0xfe4e;\n  t.lowlinecmb = 0x0332;\n  t.lowlinedashed = 0xfe4d;\n  t.lozenge = 0x25ca;\n  t.lparen = 0x24a7;\n  t.lslash = 0x0142;\n  t.lsquare = 0x2113;\n  t.lsuperior = 0xf6ee;\n  t.ltshade = 0x2591;\n  t.luthai = 0x0e26;\n  t.lvocalicbengali = 0x098c;\n  t.lvocalicdeva = 0x090c;\n  t.lvocalicvowelsignbengali = 0x09e2;\n  t.lvocalicvowelsigndeva = 0x0962;\n  t.lxsquare = 0x33d3;\n  t.m = 0x006d;\n  t.mabengali = 0x09ae;\n  t.macron = 0x00af;\n  t.macronbelowcmb = 0x0331;\n  t.macroncmb = 0x0304;\n  t.macronlowmod = 0x02cd;\n  t.macronmonospace = 0xffe3;\n  t.macute = 0x1e3f;\n  t.madeva = 0x092e;\n  t.magujarati = 0x0aae;\n  t.magurmukhi = 0x0a2e;\n  t.mahapakhhebrew = 0x05a4;\n  t.mahapakhlefthebrew = 0x05a4;\n  t.mahiragana = 0x307e;\n  t.maichattawalowleftthai = 0xf895;\n  t.maichattawalowrightthai = 0xf894;\n  t.maichattawathai = 0x0e4b;\n  t.maichattawaupperleftthai = 0xf893;\n  t.maieklowleftthai = 0xf88c;\n  t.maieklowrightthai = 0xf88b;\n  t.maiekthai = 0x0e48;\n  t.maiekupperleftthai = 0xf88a;\n  t.maihanakatleftthai = 0xf884;\n  t.maihanakatthai = 0x0e31;\n  t.maitaikhuleftthai = 0xf889;\n  t.maitaikhuthai = 0x0e47;\n  t.maitholowleftthai = 0xf88f;\n  t.maitholowrightthai = 0xf88e;\n  t.maithothai = 0x0e49;\n  t.maithoupperleftthai = 0xf88d;\n  t.maitrilowleftthai = 0xf892;\n  t.maitrilowrightthai = 0xf891;\n  t.maitrithai = 0x0e4a;\n  t.maitriupperleftthai = 0xf890;\n  t.maiyamokthai = 0x0e46;\n  t.makatakana = 0x30de;\n  t.makatakanahalfwidth = 0xff8f;\n  t.male = 0x2642;\n  t.mansyonsquare = 0x3347;\n  t.maqafhebrew = 0x05be;\n  t.mars = 0x2642;\n  t.masoracirclehebrew = 0x05af;\n  t.masquare = 0x3383;\n  t.mbopomofo = 0x3107;\n  t.mbsquare = 0x33d4;\n  t.mcircle = 0x24dc;\n  t.mcubedsquare = 0x33a5;\n  t.mdotaccent = 0x1e41;\n  t.mdotbelow = 0x1e43;\n  t.meemarabic = 0x0645;\n  t.meemfinalarabic = 0xfee2;\n  t.meeminitialarabic = 0xfee3;\n  t.meemmedialarabic = 0xfee4;\n  t.meemmeeminitialarabic = 0xfcd1;\n  t.meemmeemisolatedarabic = 0xfc48;\n  t.meetorusquare = 0x334d;\n  t.mehiragana = 0x3081;\n  t.meizierasquare = 0x337e;\n  t.mekatakana = 0x30e1;\n  t.mekatakanahalfwidth = 0xff92;\n  t.mem = 0x05de;\n  t.memdagesh = 0xfb3e;\n  t.memdageshhebrew = 0xfb3e;\n  t.memhebrew = 0x05de;\n  t.menarmenian = 0x0574;\n  t.merkhahebrew = 0x05a5;\n  t.merkhakefulahebrew = 0x05a6;\n  t.merkhakefulalefthebrew = 0x05a6;\n  t.merkhalefthebrew = 0x05a5;\n  t.mhook = 0x0271;\n  t.mhzsquare = 0x3392;\n  t.middledotkatakanahalfwidth = 0xff65;\n  t.middot = 0x00b7;\n  t.mieumacirclekorean = 0x3272;\n  t.mieumaparenkorean = 0x3212;\n  t.mieumcirclekorean = 0x3264;\n  t.mieumkorean = 0x3141;\n  t.mieumpansioskorean = 0x3170;\n  t.mieumparenkorean = 0x3204;\n  t.mieumpieupkorean = 0x316e;\n  t.mieumsioskorean = 0x316f;\n  t.mihiragana = 0x307f;\n  t.mikatakana = 0x30df;\n  t.mikatakanahalfwidth = 0xff90;\n  t.minus = 0x2212;\n  t.minusbelowcmb = 0x0320;\n  t.minuscircle = 0x2296;\n  t.minusmod = 0x02d7;\n  t.minusplus = 0x2213;\n  t.minute = 0x2032;\n  t.miribaarusquare = 0x334a;\n  t.mirisquare = 0x3349;\n  t.mlonglegturned = 0x0270;\n  t.mlsquare = 0x3396;\n  t.mmcubedsquare = 0x33a3;\n  t.mmonospace = 0xff4d;\n  t.mmsquaredsquare = 0x339f;\n  t.mohiragana = 0x3082;\n  t.mohmsquare = 0x33c1;\n  t.mokatakana = 0x30e2;\n  t.mokatakanahalfwidth = 0xff93;\n  t.molsquare = 0x33d6;\n  t.momathai = 0x0e21;\n  t.moverssquare = 0x33a7;\n  t.moverssquaredsquare = 0x33a8;\n  t.mparen = 0x24a8;\n  t.mpasquare = 0x33ab;\n  t.mssquare = 0x33b3;\n  t.msuperior = 0xf6ef;\n  t.mturned = 0x026f;\n  t.mu = 0x00b5;\n  t.mu1 = 0x00b5;\n  t.muasquare = 0x3382;\n  t.muchgreater = 0x226b;\n  t.muchless = 0x226a;\n  t.mufsquare = 0x338c;\n  t.mugreek = 0x03bc;\n  t.mugsquare = 0x338d;\n  t.muhiragana = 0x3080;\n  t.mukatakana = 0x30e0;\n  t.mukatakanahalfwidth = 0xff91;\n  t.mulsquare = 0x3395;\n  t.multiply = 0x00d7;\n  t.mumsquare = 0x339b;\n  t.munahhebrew = 0x05a3;\n  t.munahlefthebrew = 0x05a3;\n  t.musicalnote = 0x266a;\n  t.musicalnotedbl = 0x266b;\n  t.musicflatsign = 0x266d;\n  t.musicsharpsign = 0x266f;\n  t.mussquare = 0x33b2;\n  t.muvsquare = 0x33b6;\n  t.muwsquare = 0x33bc;\n  t.mvmegasquare = 0x33b9;\n  t.mvsquare = 0x33b7;\n  t.mwmegasquare = 0x33bf;\n  t.mwsquare = 0x33bd;\n  t.n = 0x006e;\n  t.nabengali = 0x09a8;\n  t.nabla = 0x2207;\n  t.nacute = 0x0144;\n  t.nadeva = 0x0928;\n  t.nagujarati = 0x0aa8;\n  t.nagurmukhi = 0x0a28;\n  t.nahiragana = 0x306a;\n  t.nakatakana = 0x30ca;\n  t.nakatakanahalfwidth = 0xff85;\n  t.napostrophe = 0x0149;\n  t.nasquare = 0x3381;\n  t.nbopomofo = 0x310b;\n  t.nbspace = 0x00a0;\n  t.ncaron = 0x0148;\n  t.ncedilla = 0x0146;\n  t.ncircle = 0x24dd;\n  t.ncircumflexbelow = 0x1e4b;\n  t.ncommaaccent = 0x0146;\n  t.ndotaccent = 0x1e45;\n  t.ndotbelow = 0x1e47;\n  t.nehiragana = 0x306d;\n  t.nekatakana = 0x30cd;\n  t.nekatakanahalfwidth = 0xff88;\n  t.newsheqelsign = 0x20aa;\n  t.nfsquare = 0x338b;\n  t.ngabengali = 0x0999;\n  t.ngadeva = 0x0919;\n  t.ngagujarati = 0x0a99;\n  t.ngagurmukhi = 0x0a19;\n  t.ngonguthai = 0x0e07;\n  t.nhiragana = 0x3093;\n  t.nhookleft = 0x0272;\n  t.nhookretroflex = 0x0273;\n  t.nieunacirclekorean = 0x326f;\n  t.nieunaparenkorean = 0x320f;\n  t.nieuncieuckorean = 0x3135;\n  t.nieuncirclekorean = 0x3261;\n  t.nieunhieuhkorean = 0x3136;\n  t.nieunkorean = 0x3134;\n  t.nieunpansioskorean = 0x3168;\n  t.nieunparenkorean = 0x3201;\n  t.nieunsioskorean = 0x3167;\n  t.nieuntikeutkorean = 0x3166;\n  t.nihiragana = 0x306b;\n  t.nikatakana = 0x30cb;\n  t.nikatakanahalfwidth = 0xff86;\n  t.nikhahitleftthai = 0xf899;\n  t.nikhahitthai = 0x0e4d;\n  t.nine = 0x0039;\n  t.ninearabic = 0x0669;\n  t.ninebengali = 0x09ef;\n  t.ninecircle = 0x2468;\n  t.ninecircleinversesansserif = 0x2792;\n  t.ninedeva = 0x096f;\n  t.ninegujarati = 0x0aef;\n  t.ninegurmukhi = 0x0a6f;\n  t.ninehackarabic = 0x0669;\n  t.ninehangzhou = 0x3029;\n  t.nineideographicparen = 0x3228;\n  t.nineinferior = 0x2089;\n  t.ninemonospace = 0xff19;\n  t.nineoldstyle = 0xf739;\n  t.nineparen = 0x247c;\n  t.nineperiod = 0x2490;\n  t.ninepersian = 0x06f9;\n  t.nineroman = 0x2178;\n  t.ninesuperior = 0x2079;\n  t.nineteencircle = 0x2472;\n  t.nineteenparen = 0x2486;\n  t.nineteenperiod = 0x249a;\n  t.ninethai = 0x0e59;\n  t.nj = 0x01cc;\n  t.njecyrillic = 0x045a;\n  t.nkatakana = 0x30f3;\n  t.nkatakanahalfwidth = 0xff9d;\n  t.nlegrightlong = 0x019e;\n  t.nlinebelow = 0x1e49;\n  t.nmonospace = 0xff4e;\n  t.nmsquare = 0x339a;\n  t.nnabengali = 0x09a3;\n  t.nnadeva = 0x0923;\n  t.nnagujarati = 0x0aa3;\n  t.nnagurmukhi = 0x0a23;\n  t.nnnadeva = 0x0929;\n  t.nohiragana = 0x306e;\n  t.nokatakana = 0x30ce;\n  t.nokatakanahalfwidth = 0xff89;\n  t.nonbreakingspace = 0x00a0;\n  t.nonenthai = 0x0e13;\n  t.nonuthai = 0x0e19;\n  t.noonarabic = 0x0646;\n  t.noonfinalarabic = 0xfee6;\n  t.noonghunnaarabic = 0x06ba;\n  t.noonghunnafinalarabic = 0xfb9f;\n  t.nooninitialarabic = 0xfee7;\n  t.noonjeeminitialarabic = 0xfcd2;\n  t.noonjeemisolatedarabic = 0xfc4b;\n  t.noonmedialarabic = 0xfee8;\n  t.noonmeeminitialarabic = 0xfcd5;\n  t.noonmeemisolatedarabic = 0xfc4e;\n  t.noonnoonfinalarabic = 0xfc8d;\n  t.notcontains = 0x220c;\n  t.notelement = 0x2209;\n  t.notelementof = 0x2209;\n  t.notequal = 0x2260;\n  t.notgreater = 0x226f;\n  t.notgreaternorequal = 0x2271;\n  t.notgreaternorless = 0x2279;\n  t.notidentical = 0x2262;\n  t.notless = 0x226e;\n  t.notlessnorequal = 0x2270;\n  t.notparallel = 0x2226;\n  t.notprecedes = 0x2280;\n  t.notsubset = 0x2284;\n  t.notsucceeds = 0x2281;\n  t.notsuperset = 0x2285;\n  t.nowarmenian = 0x0576;\n  t.nparen = 0x24a9;\n  t.nssquare = 0x33b1;\n  t.nsuperior = 0x207f;\n  t.ntilde = 0x00f1;\n  t.nu = 0x03bd;\n  t.nuhiragana = 0x306c;\n  t.nukatakana = 0x30cc;\n  t.nukatakanahalfwidth = 0xff87;\n  t.nuktabengali = 0x09bc;\n  t.nuktadeva = 0x093c;\n  t.nuktagujarati = 0x0abc;\n  t.nuktagurmukhi = 0x0a3c;\n  t.numbersign = 0x0023;\n  t.numbersignmonospace = 0xff03;\n  t.numbersignsmall = 0xfe5f;\n  t.numeralsigngreek = 0x0374;\n  t.numeralsignlowergreek = 0x0375;\n  t.numero = 0x2116;\n  t.nun = 0x05e0;\n  t.nundagesh = 0xfb40;\n  t.nundageshhebrew = 0xfb40;\n  t.nunhebrew = 0x05e0;\n  t.nvsquare = 0x33b5;\n  t.nwsquare = 0x33bb;\n  t.nyabengali = 0x099e;\n  t.nyadeva = 0x091e;\n  t.nyagujarati = 0x0a9e;\n  t.nyagurmukhi = 0x0a1e;\n  t.o = 0x006f;\n  t.oacute = 0x00f3;\n  t.oangthai = 0x0e2d;\n  t.obarred = 0x0275;\n  t.obarredcyrillic = 0x04e9;\n  t.obarreddieresiscyrillic = 0x04eb;\n  t.obengali = 0x0993;\n  t.obopomofo = 0x311b;\n  t.obreve = 0x014f;\n  t.ocandradeva = 0x0911;\n  t.ocandragujarati = 0x0a91;\n  t.ocandravowelsigndeva = 0x0949;\n  t.ocandravowelsigngujarati = 0x0ac9;\n  t.ocaron = 0x01d2;\n  t.ocircle = 0x24de;\n  t.ocircumflex = 0x00f4;\n  t.ocircumflexacute = 0x1ed1;\n  t.ocircumflexdotbelow = 0x1ed9;\n  t.ocircumflexgrave = 0x1ed3;\n  t.ocircumflexhookabove = 0x1ed5;\n  t.ocircumflextilde = 0x1ed7;\n  t.ocyrillic = 0x043e;\n  t.odblacute = 0x0151;\n  t.odblgrave = 0x020d;\n  t.odeva = 0x0913;\n  t.odieresis = 0x00f6;\n  t.odieresiscyrillic = 0x04e7;\n  t.odotbelow = 0x1ecd;\n  t.oe = 0x0153;\n  t.oekorean = 0x315a;\n  t.ogonek = 0x02db;\n  t.ogonekcmb = 0x0328;\n  t.ograve = 0x00f2;\n  t.ogujarati = 0x0a93;\n  t.oharmenian = 0x0585;\n  t.ohiragana = 0x304a;\n  t.ohookabove = 0x1ecf;\n  t.ohorn = 0x01a1;\n  t.ohornacute = 0x1edb;\n  t.ohorndotbelow = 0x1ee3;\n  t.ohorngrave = 0x1edd;\n  t.ohornhookabove = 0x1edf;\n  t.ohorntilde = 0x1ee1;\n  t.ohungarumlaut = 0x0151;\n  t.oi = 0x01a3;\n  t.oinvertedbreve = 0x020f;\n  t.okatakana = 0x30aa;\n  t.okatakanahalfwidth = 0xff75;\n  t.okorean = 0x3157;\n  t.olehebrew = 0x05ab;\n  t.omacron = 0x014d;\n  t.omacronacute = 0x1e53;\n  t.omacrongrave = 0x1e51;\n  t.omdeva = 0x0950;\n  t.omega = 0x03c9;\n  t.omega1 = 0x03d6;\n  t.omegacyrillic = 0x0461;\n  t.omegalatinclosed = 0x0277;\n  t.omegaroundcyrillic = 0x047b;\n  t.omegatitlocyrillic = 0x047d;\n  t.omegatonos = 0x03ce;\n  t.omgujarati = 0x0ad0;\n  t.omicron = 0x03bf;\n  t.omicrontonos = 0x03cc;\n  t.omonospace = 0xff4f;\n  t.one = 0x0031;\n  t.onearabic = 0x0661;\n  t.onebengali = 0x09e7;\n  t.onecircle = 0x2460;\n  t.onecircleinversesansserif = 0x278a;\n  t.onedeva = 0x0967;\n  t.onedotenleader = 0x2024;\n  t.oneeighth = 0x215b;\n  t.onefitted = 0xf6dc;\n  t.onegujarati = 0x0ae7;\n  t.onegurmukhi = 0x0a67;\n  t.onehackarabic = 0x0661;\n  t.onehalf = 0x00bd;\n  t.onehangzhou = 0x3021;\n  t.oneideographicparen = 0x3220;\n  t.oneinferior = 0x2081;\n  t.onemonospace = 0xff11;\n  t.onenumeratorbengali = 0x09f4;\n  t.oneoldstyle = 0xf731;\n  t.oneparen = 0x2474;\n  t.oneperiod = 0x2488;\n  t.onepersian = 0x06f1;\n  t.onequarter = 0x00bc;\n  t.oneroman = 0x2170;\n  t.onesuperior = 0x00b9;\n  t.onethai = 0x0e51;\n  t.onethird = 0x2153;\n  t.oogonek = 0x01eb;\n  t.oogonekmacron = 0x01ed;\n  t.oogurmukhi = 0x0a13;\n  t.oomatragurmukhi = 0x0a4b;\n  t.oopen = 0x0254;\n  t.oparen = 0x24aa;\n  t.openbullet = 0x25e6;\n  t.option = 0x2325;\n  t.ordfeminine = 0x00aa;\n  t.ordmasculine = 0x00ba;\n  t.orthogonal = 0x221f;\n  t.oshortdeva = 0x0912;\n  t.oshortvowelsigndeva = 0x094a;\n  t.oslash = 0x00f8;\n  t.oslashacute = 0x01ff;\n  t.osmallhiragana = 0x3049;\n  t.osmallkatakana = 0x30a9;\n  t.osmallkatakanahalfwidth = 0xff6b;\n  t.ostrokeacute = 0x01ff;\n  t.osuperior = 0xf6f0;\n  t.otcyrillic = 0x047f;\n  t.otilde = 0x00f5;\n  t.otildeacute = 0x1e4d;\n  t.otildedieresis = 0x1e4f;\n  t.oubopomofo = 0x3121;\n  t.overline = 0x203e;\n  t.overlinecenterline = 0xfe4a;\n  t.overlinecmb = 0x0305;\n  t.overlinedashed = 0xfe49;\n  t.overlinedblwavy = 0xfe4c;\n  t.overlinewavy = 0xfe4b;\n  t.overscore = 0x00af;\n  t.ovowelsignbengali = 0x09cb;\n  t.ovowelsigndeva = 0x094b;\n  t.ovowelsigngujarati = 0x0acb;\n  t.p = 0x0070;\n  t.paampssquare = 0x3380;\n  t.paasentosquare = 0x332b;\n  t.pabengali = 0x09aa;\n  t.pacute = 0x1e55;\n  t.padeva = 0x092a;\n  t.pagedown = 0x21df;\n  t.pageup = 0x21de;\n  t.pagujarati = 0x0aaa;\n  t.pagurmukhi = 0x0a2a;\n  t.pahiragana = 0x3071;\n  t.paiyannoithai = 0x0e2f;\n  t.pakatakana = 0x30d1;\n  t.palatalizationcyrilliccmb = 0x0484;\n  t.palochkacyrillic = 0x04c0;\n  t.pansioskorean = 0x317f;\n  t.paragraph = 0x00b6;\n  t.parallel = 0x2225;\n  t.parenleft = 0x0028;\n  t.parenleftaltonearabic = 0xfd3e;\n  t.parenleftbt = 0xf8ed;\n  t.parenleftex = 0xf8ec;\n  t.parenleftinferior = 0x208d;\n  t.parenleftmonospace = 0xff08;\n  t.parenleftsmall = 0xfe59;\n  t.parenleftsuperior = 0x207d;\n  t.parenlefttp = 0xf8eb;\n  t.parenleftvertical = 0xfe35;\n  t.parenright = 0x0029;\n  t.parenrightaltonearabic = 0xfd3f;\n  t.parenrightbt = 0xf8f8;\n  t.parenrightex = 0xf8f7;\n  t.parenrightinferior = 0x208e;\n  t.parenrightmonospace = 0xff09;\n  t.parenrightsmall = 0xfe5a;\n  t.parenrightsuperior = 0x207e;\n  t.parenrighttp = 0xf8f6;\n  t.parenrightvertical = 0xfe36;\n  t.partialdiff = 0x2202;\n  t.paseqhebrew = 0x05c0;\n  t.pashtahebrew = 0x0599;\n  t.pasquare = 0x33a9;\n  t.patah = 0x05b7;\n  t.patah11 = 0x05b7;\n  t.patah1d = 0x05b7;\n  t.patah2a = 0x05b7;\n  t.patahhebrew = 0x05b7;\n  t.patahnarrowhebrew = 0x05b7;\n  t.patahquarterhebrew = 0x05b7;\n  t.patahwidehebrew = 0x05b7;\n  t.pazerhebrew = 0x05a1;\n  t.pbopomofo = 0x3106;\n  t.pcircle = 0x24df;\n  t.pdotaccent = 0x1e57;\n  t.pe = 0x05e4;\n  t.pecyrillic = 0x043f;\n  t.pedagesh = 0xfb44;\n  t.pedageshhebrew = 0xfb44;\n  t.peezisquare = 0x333b;\n  t.pefinaldageshhebrew = 0xfb43;\n  t.peharabic = 0x067e;\n  t.peharmenian = 0x057a;\n  t.pehebrew = 0x05e4;\n  t.pehfinalarabic = 0xfb57;\n  t.pehinitialarabic = 0xfb58;\n  t.pehiragana = 0x307a;\n  t.pehmedialarabic = 0xfb59;\n  t.pekatakana = 0x30da;\n  t.pemiddlehookcyrillic = 0x04a7;\n  t.perafehebrew = 0xfb4e;\n  t.percent = 0x0025;\n  t.percentarabic = 0x066a;\n  t.percentmonospace = 0xff05;\n  t.percentsmall = 0xfe6a;\n  t.period = 0x002e;\n  t.periodarmenian = 0x0589;\n  t.periodcentered = 0x00b7;\n  t.periodhalfwidth = 0xff61;\n  t.periodinferior = 0xf6e7;\n  t.periodmonospace = 0xff0e;\n  t.periodsmall = 0xfe52;\n  t.periodsuperior = 0xf6e8;\n  t.perispomenigreekcmb = 0x0342;\n  t.perpendicular = 0x22a5;\n  t.perthousand = 0x2030;\n  t.peseta = 0x20a7;\n  t.pfsquare = 0x338a;\n  t.phabengali = 0x09ab;\n  t.phadeva = 0x092b;\n  t.phagujarati = 0x0aab;\n  t.phagurmukhi = 0x0a2b;\n  t.phi = 0x03c6;\n  t.phi1 = 0x03d5;\n  t.phieuphacirclekorean = 0x327a;\n  t.phieuphaparenkorean = 0x321a;\n  t.phieuphcirclekorean = 0x326c;\n  t.phieuphkorean = 0x314d;\n  t.phieuphparenkorean = 0x320c;\n  t.philatin = 0x0278;\n  t.phinthuthai = 0x0e3a;\n  t.phisymbolgreek = 0x03d5;\n  t.phook = 0x01a5;\n  t.phophanthai = 0x0e1e;\n  t.phophungthai = 0x0e1c;\n  t.phosamphaothai = 0x0e20;\n  t.pi = 0x03c0;\n  t.pieupacirclekorean = 0x3273;\n  t.pieupaparenkorean = 0x3213;\n  t.pieupcieuckorean = 0x3176;\n  t.pieupcirclekorean = 0x3265;\n  t.pieupkiyeokkorean = 0x3172;\n  t.pieupkorean = 0x3142;\n  t.pieupparenkorean = 0x3205;\n  t.pieupsioskiyeokkorean = 0x3174;\n  t.pieupsioskorean = 0x3144;\n  t.pieupsiostikeutkorean = 0x3175;\n  t.pieupthieuthkorean = 0x3177;\n  t.pieuptikeutkorean = 0x3173;\n  t.pihiragana = 0x3074;\n  t.pikatakana = 0x30d4;\n  t.pisymbolgreek = 0x03d6;\n  t.piwrarmenian = 0x0583;\n  t.planckover2pi = 0x210f;\n  t.planckover2pi1 = 0x210f;\n  t.plus = 0x002b;\n  t.plusbelowcmb = 0x031f;\n  t.pluscircle = 0x2295;\n  t.plusminus = 0x00b1;\n  t.plusmod = 0x02d6;\n  t.plusmonospace = 0xff0b;\n  t.plussmall = 0xfe62;\n  t.plussuperior = 0x207a;\n  t.pmonospace = 0xff50;\n  t.pmsquare = 0x33d8;\n  t.pohiragana = 0x307d;\n  t.pointingindexdownwhite = 0x261f;\n  t.pointingindexleftwhite = 0x261c;\n  t.pointingindexrightwhite = 0x261e;\n  t.pointingindexupwhite = 0x261d;\n  t.pokatakana = 0x30dd;\n  t.poplathai = 0x0e1b;\n  t.postalmark = 0x3012;\n  t.postalmarkface = 0x3020;\n  t.pparen = 0x24ab;\n  t.precedes = 0x227a;\n  t.prescription = 0x211e;\n  t.primemod = 0x02b9;\n  t.primereversed = 0x2035;\n  t.product = 0x220f;\n  t.projective = 0x2305;\n  t.prolongedkana = 0x30fc;\n  t.propellor = 0x2318;\n  t.propersubset = 0x2282;\n  t.propersuperset = 0x2283;\n  t.proportion = 0x2237;\n  t.proportional = 0x221d;\n  t.psi = 0x03c8;\n  t.psicyrillic = 0x0471;\n  t.psilipneumatacyrilliccmb = 0x0486;\n  t.pssquare = 0x33b0;\n  t.puhiragana = 0x3077;\n  t.pukatakana = 0x30d7;\n  t.pvsquare = 0x33b4;\n  t.pwsquare = 0x33ba;\n  t.q = 0x0071;\n  t.qadeva = 0x0958;\n  t.qadmahebrew = 0x05a8;\n  t.qafarabic = 0x0642;\n  t.qaffinalarabic = 0xfed6;\n  t.qafinitialarabic = 0xfed7;\n  t.qafmedialarabic = 0xfed8;\n  t.qamats = 0x05b8;\n  t.qamats10 = 0x05b8;\n  t.qamats1a = 0x05b8;\n  t.qamats1c = 0x05b8;\n  t.qamats27 = 0x05b8;\n  t.qamats29 = 0x05b8;\n  t.qamats33 = 0x05b8;\n  t.qamatsde = 0x05b8;\n  t.qamatshebrew = 0x05b8;\n  t.qamatsnarrowhebrew = 0x05b8;\n  t.qamatsqatanhebrew = 0x05b8;\n  t.qamatsqatannarrowhebrew = 0x05b8;\n  t.qamatsqatanquarterhebrew = 0x05b8;\n  t.qamatsqatanwidehebrew = 0x05b8;\n  t.qamatsquarterhebrew = 0x05b8;\n  t.qamatswidehebrew = 0x05b8;\n  t.qarneyparahebrew = 0x059f;\n  t.qbopomofo = 0x3111;\n  t.qcircle = 0x24e0;\n  t.qhook = 0x02a0;\n  t.qmonospace = 0xff51;\n  t.qof = 0x05e7;\n  t.qofdagesh = 0xfb47;\n  t.qofdageshhebrew = 0xfb47;\n  t.qofhebrew = 0x05e7;\n  t.qparen = 0x24ac;\n  t.quarternote = 0x2669;\n  t.qubuts = 0x05bb;\n  t.qubuts18 = 0x05bb;\n  t.qubuts25 = 0x05bb;\n  t.qubuts31 = 0x05bb;\n  t.qubutshebrew = 0x05bb;\n  t.qubutsnarrowhebrew = 0x05bb;\n  t.qubutsquarterhebrew = 0x05bb;\n  t.qubutswidehebrew = 0x05bb;\n  t.question = 0x003f;\n  t.questionarabic = 0x061f;\n  t.questionarmenian = 0x055e;\n  t.questiondown = 0x00bf;\n  t.questiondownsmall = 0xf7bf;\n  t.questiongreek = 0x037e;\n  t.questionmonospace = 0xff1f;\n  t.questionsmall = 0xf73f;\n  t.quotedbl = 0x0022;\n  t.quotedblbase = 0x201e;\n  t.quotedblleft = 0x201c;\n  t.quotedblmonospace = 0xff02;\n  t.quotedblprime = 0x301e;\n  t.quotedblprimereversed = 0x301d;\n  t.quotedblright = 0x201d;\n  t.quoteleft = 0x2018;\n  t.quoteleftreversed = 0x201b;\n  t.quotereversed = 0x201b;\n  t.quoteright = 0x2019;\n  t.quoterightn = 0x0149;\n  t.quotesinglbase = 0x201a;\n  t.quotesingle = 0x0027;\n  t.quotesinglemonospace = 0xff07;\n  t.r = 0x0072;\n  t.raarmenian = 0x057c;\n  t.rabengali = 0x09b0;\n  t.racute = 0x0155;\n  t.radeva = 0x0930;\n  t.radical = 0x221a;\n  t.radicalex = 0xf8e5;\n  t.radoverssquare = 0x33ae;\n  t.radoverssquaredsquare = 0x33af;\n  t.radsquare = 0x33ad;\n  t.rafe = 0x05bf;\n  t.rafehebrew = 0x05bf;\n  t.ragujarati = 0x0ab0;\n  t.ragurmukhi = 0x0a30;\n  t.rahiragana = 0x3089;\n  t.rakatakana = 0x30e9;\n  t.rakatakanahalfwidth = 0xff97;\n  t.ralowerdiagonalbengali = 0x09f1;\n  t.ramiddlediagonalbengali = 0x09f0;\n  t.ramshorn = 0x0264;\n  t.ratio = 0x2236;\n  t.rbopomofo = 0x3116;\n  t.rcaron = 0x0159;\n  t.rcedilla = 0x0157;\n  t.rcircle = 0x24e1;\n  t.rcommaaccent = 0x0157;\n  t.rdblgrave = 0x0211;\n  t.rdotaccent = 0x1e59;\n  t.rdotbelow = 0x1e5b;\n  t.rdotbelowmacron = 0x1e5d;\n  t.referencemark = 0x203b;\n  t.reflexsubset = 0x2286;\n  t.reflexsuperset = 0x2287;\n  t.registered = 0x00ae;\n  t.registersans = 0xf8e8;\n  t.registerserif = 0xf6da;\n  t.reharabic = 0x0631;\n  t.reharmenian = 0x0580;\n  t.rehfinalarabic = 0xfeae;\n  t.rehiragana = 0x308c;\n  t.rekatakana = 0x30ec;\n  t.rekatakanahalfwidth = 0xff9a;\n  t.resh = 0x05e8;\n  t.reshdageshhebrew = 0xfb48;\n  t.reshhebrew = 0x05e8;\n  t.reversedtilde = 0x223d;\n  t.reviahebrew = 0x0597;\n  t.reviamugrashhebrew = 0x0597;\n  t.revlogicalnot = 0x2310;\n  t.rfishhook = 0x027e;\n  t.rfishhookreversed = 0x027f;\n  t.rhabengali = 0x09dd;\n  t.rhadeva = 0x095d;\n  t.rho = 0x03c1;\n  t.rhook = 0x027d;\n  t.rhookturned = 0x027b;\n  t.rhookturnedsuperior = 0x02b5;\n  t.rhosymbolgreek = 0x03f1;\n  t.rhotichookmod = 0x02de;\n  t.rieulacirclekorean = 0x3271;\n  t.rieulaparenkorean = 0x3211;\n  t.rieulcirclekorean = 0x3263;\n  t.rieulhieuhkorean = 0x3140;\n  t.rieulkiyeokkorean = 0x313a;\n  t.rieulkiyeoksioskorean = 0x3169;\n  t.rieulkorean = 0x3139;\n  t.rieulmieumkorean = 0x313b;\n  t.rieulpansioskorean = 0x316c;\n  t.rieulparenkorean = 0x3203;\n  t.rieulphieuphkorean = 0x313f;\n  t.rieulpieupkorean = 0x313c;\n  t.rieulpieupsioskorean = 0x316b;\n  t.rieulsioskorean = 0x313d;\n  t.rieulthieuthkorean = 0x313e;\n  t.rieultikeutkorean = 0x316a;\n  t.rieulyeorinhieuhkorean = 0x316d;\n  t.rightangle = 0x221f;\n  t.righttackbelowcmb = 0x0319;\n  t.righttriangle = 0x22bf;\n  t.rihiragana = 0x308a;\n  t.rikatakana = 0x30ea;\n  t.rikatakanahalfwidth = 0xff98;\n  t.ring = 0x02da;\n  t.ringbelowcmb = 0x0325;\n  t.ringcmb = 0x030a;\n  t.ringhalfleft = 0x02bf;\n  t.ringhalfleftarmenian = 0x0559;\n  t.ringhalfleftbelowcmb = 0x031c;\n  t.ringhalfleftcentered = 0x02d3;\n  t.ringhalfright = 0x02be;\n  t.ringhalfrightbelowcmb = 0x0339;\n  t.ringhalfrightcentered = 0x02d2;\n  t.rinvertedbreve = 0x0213;\n  t.rittorusquare = 0x3351;\n  t.rlinebelow = 0x1e5f;\n  t.rlongleg = 0x027c;\n  t.rlonglegturned = 0x027a;\n  t.rmonospace = 0xff52;\n  t.rohiragana = 0x308d;\n  t.rokatakana = 0x30ed;\n  t.rokatakanahalfwidth = 0xff9b;\n  t.roruathai = 0x0e23;\n  t.rparen = 0x24ad;\n  t.rrabengali = 0x09dc;\n  t.rradeva = 0x0931;\n  t.rragurmukhi = 0x0a5c;\n  t.rreharabic = 0x0691;\n  t.rrehfinalarabic = 0xfb8d;\n  t.rrvocalicbengali = 0x09e0;\n  t.rrvocalicdeva = 0x0960;\n  t.rrvocalicgujarati = 0x0ae0;\n  t.rrvocalicvowelsignbengali = 0x09c4;\n  t.rrvocalicvowelsigndeva = 0x0944;\n  t.rrvocalicvowelsigngujarati = 0x0ac4;\n  t.rsuperior = 0xf6f1;\n  t.rtblock = 0x2590;\n  t.rturned = 0x0279;\n  t.rturnedsuperior = 0x02b4;\n  t.ruhiragana = 0x308b;\n  t.rukatakana = 0x30eb;\n  t.rukatakanahalfwidth = 0xff99;\n  t.rupeemarkbengali = 0x09f2;\n  t.rupeesignbengali = 0x09f3;\n  t.rupiah = 0xf6dd;\n  t.ruthai = 0x0e24;\n  t.rvocalicbengali = 0x098b;\n  t.rvocalicdeva = 0x090b;\n  t.rvocalicgujarati = 0x0a8b;\n  t.rvocalicvowelsignbengali = 0x09c3;\n  t.rvocalicvowelsigndeva = 0x0943;\n  t.rvocalicvowelsigngujarati = 0x0ac3;\n  t.s = 0x0073;\n  t.sabengali = 0x09b8;\n  t.sacute = 0x015b;\n  t.sacutedotaccent = 0x1e65;\n  t.sadarabic = 0x0635;\n  t.sadeva = 0x0938;\n  t.sadfinalarabic = 0xfeba;\n  t.sadinitialarabic = 0xfebb;\n  t.sadmedialarabic = 0xfebc;\n  t.sagujarati = 0x0ab8;\n  t.sagurmukhi = 0x0a38;\n  t.sahiragana = 0x3055;\n  t.sakatakana = 0x30b5;\n  t.sakatakanahalfwidth = 0xff7b;\n  t.sallallahoualayhewasallamarabic = 0xfdfa;\n  t.samekh = 0x05e1;\n  t.samekhdagesh = 0xfb41;\n  t.samekhdageshhebrew = 0xfb41;\n  t.samekhhebrew = 0x05e1;\n  t.saraaathai = 0x0e32;\n  t.saraaethai = 0x0e41;\n  t.saraaimaimalaithai = 0x0e44;\n  t.saraaimaimuanthai = 0x0e43;\n  t.saraamthai = 0x0e33;\n  t.saraathai = 0x0e30;\n  t.saraethai = 0x0e40;\n  t.saraiileftthai = 0xf886;\n  t.saraiithai = 0x0e35;\n  t.saraileftthai = 0xf885;\n  t.saraithai = 0x0e34;\n  t.saraothai = 0x0e42;\n  t.saraueeleftthai = 0xf888;\n  t.saraueethai = 0x0e37;\n  t.saraueleftthai = 0xf887;\n  t.sarauethai = 0x0e36;\n  t.sarauthai = 0x0e38;\n  t.sarauuthai = 0x0e39;\n  t.sbopomofo = 0x3119;\n  t.scaron = 0x0161;\n  t.scarondotaccent = 0x1e67;\n  t.scedilla = 0x015f;\n  t.schwa = 0x0259;\n  t.schwacyrillic = 0x04d9;\n  t.schwadieresiscyrillic = 0x04db;\n  t.schwahook = 0x025a;\n  t.scircle = 0x24e2;\n  t.scircumflex = 0x015d;\n  t.scommaaccent = 0x0219;\n  t.sdotaccent = 0x1e61;\n  t.sdotbelow = 0x1e63;\n  t.sdotbelowdotaccent = 0x1e69;\n  t.seagullbelowcmb = 0x033c;\n  t.second = 0x2033;\n  t.secondtonechinese = 0x02ca;\n  t.section = 0x00a7;\n  t.seenarabic = 0x0633;\n  t.seenfinalarabic = 0xfeb2;\n  t.seeninitialarabic = 0xfeb3;\n  t.seenmedialarabic = 0xfeb4;\n  t.segol = 0x05b6;\n  t.segol13 = 0x05b6;\n  t.segol1f = 0x05b6;\n  t.segol2c = 0x05b6;\n  t.segolhebrew = 0x05b6;\n  t.segolnarrowhebrew = 0x05b6;\n  t.segolquarterhebrew = 0x05b6;\n  t.segoltahebrew = 0x0592;\n  t.segolwidehebrew = 0x05b6;\n  t.seharmenian = 0x057d;\n  t.sehiragana = 0x305b;\n  t.sekatakana = 0x30bb;\n  t.sekatakanahalfwidth = 0xff7e;\n  t.semicolon = 0x003b;\n  t.semicolonarabic = 0x061b;\n  t.semicolonmonospace = 0xff1b;\n  t.semicolonsmall = 0xfe54;\n  t.semivoicedmarkkana = 0x309c;\n  t.semivoicedmarkkanahalfwidth = 0xff9f;\n  t.sentisquare = 0x3322;\n  t.sentosquare = 0x3323;\n  t.seven = 0x0037;\n  t.sevenarabic = 0x0667;\n  t.sevenbengali = 0x09ed;\n  t.sevencircle = 0x2466;\n  t.sevencircleinversesansserif = 0x2790;\n  t.sevendeva = 0x096d;\n  t.seveneighths = 0x215e;\n  t.sevengujarati = 0x0aed;\n  t.sevengurmukhi = 0x0a6d;\n  t.sevenhackarabic = 0x0667;\n  t.sevenhangzhou = 0x3027;\n  t.sevenideographicparen = 0x3226;\n  t.seveninferior = 0x2087;\n  t.sevenmonospace = 0xff17;\n  t.sevenoldstyle = 0xf737;\n  t.sevenparen = 0x247a;\n  t.sevenperiod = 0x248e;\n  t.sevenpersian = 0x06f7;\n  t.sevenroman = 0x2176;\n  t.sevensuperior = 0x2077;\n  t.seventeencircle = 0x2470;\n  t.seventeenparen = 0x2484;\n  t.seventeenperiod = 0x2498;\n  t.seventhai = 0x0e57;\n  t.sfthyphen = 0x00ad;\n  t.shaarmenian = 0x0577;\n  t.shabengali = 0x09b6;\n  t.shacyrillic = 0x0448;\n  t.shaddaarabic = 0x0651;\n  t.shaddadammaarabic = 0xfc61;\n  t.shaddadammatanarabic = 0xfc5e;\n  t.shaddafathaarabic = 0xfc60;\n  t.shaddakasraarabic = 0xfc62;\n  t.shaddakasratanarabic = 0xfc5f;\n  t.shade = 0x2592;\n  t.shadedark = 0x2593;\n  t.shadelight = 0x2591;\n  t.shademedium = 0x2592;\n  t.shadeva = 0x0936;\n  t.shagujarati = 0x0ab6;\n  t.shagurmukhi = 0x0a36;\n  t.shalshelethebrew = 0x0593;\n  t.shbopomofo = 0x3115;\n  t.shchacyrillic = 0x0449;\n  t.sheenarabic = 0x0634;\n  t.sheenfinalarabic = 0xfeb6;\n  t.sheeninitialarabic = 0xfeb7;\n  t.sheenmedialarabic = 0xfeb8;\n  t.sheicoptic = 0x03e3;\n  t.sheqel = 0x20aa;\n  t.sheqelhebrew = 0x20aa;\n  t.sheva = 0x05b0;\n  t.sheva115 = 0x05b0;\n  t.sheva15 = 0x05b0;\n  t.sheva22 = 0x05b0;\n  t.sheva2e = 0x05b0;\n  t.shevahebrew = 0x05b0;\n  t.shevanarrowhebrew = 0x05b0;\n  t.shevaquarterhebrew = 0x05b0;\n  t.shevawidehebrew = 0x05b0;\n  t.shhacyrillic = 0x04bb;\n  t.shimacoptic = 0x03ed;\n  t.shin = 0x05e9;\n  t.shindagesh = 0xfb49;\n  t.shindageshhebrew = 0xfb49;\n  t.shindageshshindot = 0xfb2c;\n  t.shindageshshindothebrew = 0xfb2c;\n  t.shindageshsindot = 0xfb2d;\n  t.shindageshsindothebrew = 0xfb2d;\n  t.shindothebrew = 0x05c1;\n  t.shinhebrew = 0x05e9;\n  t.shinshindot = 0xfb2a;\n  t.shinshindothebrew = 0xfb2a;\n  t.shinsindot = 0xfb2b;\n  t.shinsindothebrew = 0xfb2b;\n  t.shook = 0x0282;\n  t.sigma = 0x03c3;\n  t.sigma1 = 0x03c2;\n  t.sigmafinal = 0x03c2;\n  t.sigmalunatesymbolgreek = 0x03f2;\n  t.sihiragana = 0x3057;\n  t.sikatakana = 0x30b7;\n  t.sikatakanahalfwidth = 0xff7c;\n  t.siluqhebrew = 0x05bd;\n  t.siluqlefthebrew = 0x05bd;\n  t.similar = 0x223c;\n  t.sindothebrew = 0x05c2;\n  t.siosacirclekorean = 0x3274;\n  t.siosaparenkorean = 0x3214;\n  t.sioscieuckorean = 0x317e;\n  t.sioscirclekorean = 0x3266;\n  t.sioskiyeokkorean = 0x317a;\n  t.sioskorean = 0x3145;\n  t.siosnieunkorean = 0x317b;\n  t.siosparenkorean = 0x3206;\n  t.siospieupkorean = 0x317d;\n  t.siostikeutkorean = 0x317c;\n  t.six = 0x0036;\n  t.sixarabic = 0x0666;\n  t.sixbengali = 0x09ec;\n  t.sixcircle = 0x2465;\n  t.sixcircleinversesansserif = 0x278f;\n  t.sixdeva = 0x096c;\n  t.sixgujarati = 0x0aec;\n  t.sixgurmukhi = 0x0a6c;\n  t.sixhackarabic = 0x0666;\n  t.sixhangzhou = 0x3026;\n  t.sixideographicparen = 0x3225;\n  t.sixinferior = 0x2086;\n  t.sixmonospace = 0xff16;\n  t.sixoldstyle = 0xf736;\n  t.sixparen = 0x2479;\n  t.sixperiod = 0x248d;\n  t.sixpersian = 0x06f6;\n  t.sixroman = 0x2175;\n  t.sixsuperior = 0x2076;\n  t.sixteencircle = 0x246f;\n  t.sixteencurrencydenominatorbengali = 0x09f9;\n  t.sixteenparen = 0x2483;\n  t.sixteenperiod = 0x2497;\n  t.sixthai = 0x0e56;\n  t.slash = 0x002f;\n  t.slashmonospace = 0xff0f;\n  t.slong = 0x017f;\n  t.slongdotaccent = 0x1e9b;\n  t.smileface = 0x263a;\n  t.smonospace = 0xff53;\n  t.sofpasuqhebrew = 0x05c3;\n  t.softhyphen = 0x00ad;\n  t.softsigncyrillic = 0x044c;\n  t.sohiragana = 0x305d;\n  t.sokatakana = 0x30bd;\n  t.sokatakanahalfwidth = 0xff7f;\n  t.soliduslongoverlaycmb = 0x0338;\n  t.solidusshortoverlaycmb = 0x0337;\n  t.sorusithai = 0x0e29;\n  t.sosalathai = 0x0e28;\n  t.sosothai = 0x0e0b;\n  t.sosuathai = 0x0e2a;\n  t.space = 0x0020;\n  t.spacehackarabic = 0x0020;\n  t.spade = 0x2660;\n  t.spadesuitblack = 0x2660;\n  t.spadesuitwhite = 0x2664;\n  t.sparen = 0x24ae;\n  t.squarebelowcmb = 0x033b;\n  t.squarecc = 0x33c4;\n  t.squarecm = 0x339d;\n  t.squarediagonalcrosshatchfill = 0x25a9;\n  t.squarehorizontalfill = 0x25a4;\n  t.squarekg = 0x338f;\n  t.squarekm = 0x339e;\n  t.squarekmcapital = 0x33ce;\n  t.squareln = 0x33d1;\n  t.squarelog = 0x33d2;\n  t.squaremg = 0x338e;\n  t.squaremil = 0x33d5;\n  t.squaremm = 0x339c;\n  t.squaremsquared = 0x33a1;\n  t.squareorthogonalcrosshatchfill = 0x25a6;\n  t.squareupperlefttolowerrightfill = 0x25a7;\n  t.squareupperrighttolowerleftfill = 0x25a8;\n  t.squareverticalfill = 0x25a5;\n  t.squarewhitewithsmallblack = 0x25a3;\n  t.srsquare = 0x33db;\n  t.ssabengali = 0x09b7;\n  t.ssadeva = 0x0937;\n  t.ssagujarati = 0x0ab7;\n  t.ssangcieuckorean = 0x3149;\n  t.ssanghieuhkorean = 0x3185;\n  t.ssangieungkorean = 0x3180;\n  t.ssangkiyeokkorean = 0x3132;\n  t.ssangnieunkorean = 0x3165;\n  t.ssangpieupkorean = 0x3143;\n  t.ssangsioskorean = 0x3146;\n  t.ssangtikeutkorean = 0x3138;\n  t.ssuperior = 0xf6f2;\n  t.sterling = 0x00a3;\n  t.sterlingmonospace = 0xffe1;\n  t.strokelongoverlaycmb = 0x0336;\n  t.strokeshortoverlaycmb = 0x0335;\n  t.subset = 0x2282;\n  t.subsetnotequal = 0x228a;\n  t.subsetorequal = 0x2286;\n  t.succeeds = 0x227b;\n  t.suchthat = 0x220b;\n  t.suhiragana = 0x3059;\n  t.sukatakana = 0x30b9;\n  t.sukatakanahalfwidth = 0xff7d;\n  t.sukunarabic = 0x0652;\n  t.summation = 0x2211;\n  t.sun = 0x263c;\n  t.superset = 0x2283;\n  t.supersetnotequal = 0x228b;\n  t.supersetorequal = 0x2287;\n  t.svsquare = 0x33dc;\n  t.syouwaerasquare = 0x337c;\n  t.t = 0x0074;\n  t.tabengali = 0x09a4;\n  t.tackdown = 0x22a4;\n  t.tackleft = 0x22a3;\n  t.tadeva = 0x0924;\n  t.tagujarati = 0x0aa4;\n  t.tagurmukhi = 0x0a24;\n  t.taharabic = 0x0637;\n  t.tahfinalarabic = 0xfec2;\n  t.tahinitialarabic = 0xfec3;\n  t.tahiragana = 0x305f;\n  t.tahmedialarabic = 0xfec4;\n  t.taisyouerasquare = 0x337d;\n  t.takatakana = 0x30bf;\n  t.takatakanahalfwidth = 0xff80;\n  t.tatweelarabic = 0x0640;\n  t.tau = 0x03c4;\n  t.tav = 0x05ea;\n  t.tavdages = 0xfb4a;\n  t.tavdagesh = 0xfb4a;\n  t.tavdageshhebrew = 0xfb4a;\n  t.tavhebrew = 0x05ea;\n  t.tbar = 0x0167;\n  t.tbopomofo = 0x310a;\n  t.tcaron = 0x0165;\n  t.tccurl = 0x02a8;\n  t.tcedilla = 0x0163;\n  t.tcheharabic = 0x0686;\n  t.tchehfinalarabic = 0xfb7b;\n  t.tchehinitialarabic = 0xfb7c;\n  t.tchehmedialarabic = 0xfb7d;\n  t.tcircle = 0x24e3;\n  t.tcircumflexbelow = 0x1e71;\n  t.tcommaaccent = 0x0163;\n  t.tdieresis = 0x1e97;\n  t.tdotaccent = 0x1e6b;\n  t.tdotbelow = 0x1e6d;\n  t.tecyrillic = 0x0442;\n  t.tedescendercyrillic = 0x04ad;\n  t.teharabic = 0x062a;\n  t.tehfinalarabic = 0xfe96;\n  t.tehhahinitialarabic = 0xfca2;\n  t.tehhahisolatedarabic = 0xfc0c;\n  t.tehinitialarabic = 0xfe97;\n  t.tehiragana = 0x3066;\n  t.tehjeeminitialarabic = 0xfca1;\n  t.tehjeemisolatedarabic = 0xfc0b;\n  t.tehmarbutaarabic = 0x0629;\n  t.tehmarbutafinalarabic = 0xfe94;\n  t.tehmedialarabic = 0xfe98;\n  t.tehmeeminitialarabic = 0xfca4;\n  t.tehmeemisolatedarabic = 0xfc0e;\n  t.tehnoonfinalarabic = 0xfc73;\n  t.tekatakana = 0x30c6;\n  t.tekatakanahalfwidth = 0xff83;\n  t.telephone = 0x2121;\n  t.telephoneblack = 0x260e;\n  t.telishagedolahebrew = 0x05a0;\n  t.telishaqetanahebrew = 0x05a9;\n  t.tencircle = 0x2469;\n  t.tenideographicparen = 0x3229;\n  t.tenparen = 0x247d;\n  t.tenperiod = 0x2491;\n  t.tenroman = 0x2179;\n  t.tesh = 0x02a7;\n  t.tet = 0x05d8;\n  t.tetdagesh = 0xfb38;\n  t.tetdageshhebrew = 0xfb38;\n  t.tethebrew = 0x05d8;\n  t.tetsecyrillic = 0x04b5;\n  t.tevirhebrew = 0x059b;\n  t.tevirlefthebrew = 0x059b;\n  t.thabengali = 0x09a5;\n  t.thadeva = 0x0925;\n  t.thagujarati = 0x0aa5;\n  t.thagurmukhi = 0x0a25;\n  t.thalarabic = 0x0630;\n  t.thalfinalarabic = 0xfeac;\n  t.thanthakhatlowleftthai = 0xf898;\n  t.thanthakhatlowrightthai = 0xf897;\n  t.thanthakhatthai = 0x0e4c;\n  t.thanthakhatupperleftthai = 0xf896;\n  t.theharabic = 0x062b;\n  t.thehfinalarabic = 0xfe9a;\n  t.thehinitialarabic = 0xfe9b;\n  t.thehmedialarabic = 0xfe9c;\n  t.thereexists = 0x2203;\n  t.therefore = 0x2234;\n  t.theta = 0x03b8;\n  t.theta1 = 0x03d1;\n  t.thetasymbolgreek = 0x03d1;\n  t.thieuthacirclekorean = 0x3279;\n  t.thieuthaparenkorean = 0x3219;\n  t.thieuthcirclekorean = 0x326b;\n  t.thieuthkorean = 0x314c;\n  t.thieuthparenkorean = 0x320b;\n  t.thirteencircle = 0x246c;\n  t.thirteenparen = 0x2480;\n  t.thirteenperiod = 0x2494;\n  t.thonangmonthothai = 0x0e11;\n  t.thook = 0x01ad;\n  t.thophuthaothai = 0x0e12;\n  t.thorn = 0x00fe;\n  t.thothahanthai = 0x0e17;\n  t.thothanthai = 0x0e10;\n  t.thothongthai = 0x0e18;\n  t.thothungthai = 0x0e16;\n  t.thousandcyrillic = 0x0482;\n  t.thousandsseparatorarabic = 0x066c;\n  t.thousandsseparatorpersian = 0x066c;\n  t.three = 0x0033;\n  t.threearabic = 0x0663;\n  t.threebengali = 0x09e9;\n  t.threecircle = 0x2462;\n  t.threecircleinversesansserif = 0x278c;\n  t.threedeva = 0x0969;\n  t.threeeighths = 0x215c;\n  t.threegujarati = 0x0ae9;\n  t.threegurmukhi = 0x0a69;\n  t.threehackarabic = 0x0663;\n  t.threehangzhou = 0x3023;\n  t.threeideographicparen = 0x3222;\n  t.threeinferior = 0x2083;\n  t.threemonospace = 0xff13;\n  t.threenumeratorbengali = 0x09f6;\n  t.threeoldstyle = 0xf733;\n  t.threeparen = 0x2476;\n  t.threeperiod = 0x248a;\n  t.threepersian = 0x06f3;\n  t.threequarters = 0x00be;\n  t.threequartersemdash = 0xf6de;\n  t.threeroman = 0x2172;\n  t.threesuperior = 0x00b3;\n  t.threethai = 0x0e53;\n  t.thzsquare = 0x3394;\n  t.tihiragana = 0x3061;\n  t.tikatakana = 0x30c1;\n  t.tikatakanahalfwidth = 0xff81;\n  t.tikeutacirclekorean = 0x3270;\n  t.tikeutaparenkorean = 0x3210;\n  t.tikeutcirclekorean = 0x3262;\n  t.tikeutkorean = 0x3137;\n  t.tikeutparenkorean = 0x3202;\n  t.tilde = 0x02dc;\n  t.tildebelowcmb = 0x0330;\n  t.tildecmb = 0x0303;\n  t.tildecomb = 0x0303;\n  t.tildedoublecmb = 0x0360;\n  t.tildeoperator = 0x223c;\n  t.tildeoverlaycmb = 0x0334;\n  t.tildeverticalcmb = 0x033e;\n  t.timescircle = 0x2297;\n  t.tipehahebrew = 0x0596;\n  t.tipehalefthebrew = 0x0596;\n  t.tippigurmukhi = 0x0a70;\n  t.titlocyrilliccmb = 0x0483;\n  t.tiwnarmenian = 0x057f;\n  t.tlinebelow = 0x1e6f;\n  t.tmonospace = 0xff54;\n  t.toarmenian = 0x0569;\n  t.tohiragana = 0x3068;\n  t.tokatakana = 0x30c8;\n  t.tokatakanahalfwidth = 0xff84;\n  t.tonebarextrahighmod = 0x02e5;\n  t.tonebarextralowmod = 0x02e9;\n  t.tonebarhighmod = 0x02e6;\n  t.tonebarlowmod = 0x02e8;\n  t.tonebarmidmod = 0x02e7;\n  t.tonefive = 0x01bd;\n  t.tonesix = 0x0185;\n  t.tonetwo = 0x01a8;\n  t.tonos = 0x0384;\n  t.tonsquare = 0x3327;\n  t.topatakthai = 0x0e0f;\n  t.tortoiseshellbracketleft = 0x3014;\n  t.tortoiseshellbracketleftsmall = 0xfe5d;\n  t.tortoiseshellbracketleftvertical = 0xfe39;\n  t.tortoiseshellbracketright = 0x3015;\n  t.tortoiseshellbracketrightsmall = 0xfe5e;\n  t.tortoiseshellbracketrightvertical = 0xfe3a;\n  t.totaothai = 0x0e15;\n  t.tpalatalhook = 0x01ab;\n  t.tparen = 0x24af;\n  t.trademark = 0x2122;\n  t.trademarksans = 0xf8ea;\n  t.trademarkserif = 0xf6db;\n  t.tretroflexhook = 0x0288;\n  t.triagdn = 0x25bc;\n  t.triaglf = 0x25c4;\n  t.triagrt = 0x25ba;\n  t.triagup = 0x25b2;\n  t.ts = 0x02a6;\n  t.tsadi = 0x05e6;\n  t.tsadidagesh = 0xfb46;\n  t.tsadidageshhebrew = 0xfb46;\n  t.tsadihebrew = 0x05e6;\n  t.tsecyrillic = 0x0446;\n  t.tsere = 0x05b5;\n  t.tsere12 = 0x05b5;\n  t.tsere1e = 0x05b5;\n  t.tsere2b = 0x05b5;\n  t.tserehebrew = 0x05b5;\n  t.tserenarrowhebrew = 0x05b5;\n  t.tserequarterhebrew = 0x05b5;\n  t.tserewidehebrew = 0x05b5;\n  t.tshecyrillic = 0x045b;\n  t.tsuperior = 0xf6f3;\n  t.ttabengali = 0x099f;\n  t.ttadeva = 0x091f;\n  t.ttagujarati = 0x0a9f;\n  t.ttagurmukhi = 0x0a1f;\n  t.tteharabic = 0x0679;\n  t.ttehfinalarabic = 0xfb67;\n  t.ttehinitialarabic = 0xfb68;\n  t.ttehmedialarabic = 0xfb69;\n  t.tthabengali = 0x09a0;\n  t.tthadeva = 0x0920;\n  t.tthagujarati = 0x0aa0;\n  t.tthagurmukhi = 0x0a20;\n  t.tturned = 0x0287;\n  t.tuhiragana = 0x3064;\n  t.tukatakana = 0x30c4;\n  t.tukatakanahalfwidth = 0xff82;\n  t.tusmallhiragana = 0x3063;\n  t.tusmallkatakana = 0x30c3;\n  t.tusmallkatakanahalfwidth = 0xff6f;\n  t.twelvecircle = 0x246b;\n  t.twelveparen = 0x247f;\n  t.twelveperiod = 0x2493;\n  t.twelveroman = 0x217b;\n  t.twentycircle = 0x2473;\n  t.twentyhangzhou = 0x5344;\n  t.twentyparen = 0x2487;\n  t.twentyperiod = 0x249b;\n  t.two = 0x0032;\n  t.twoarabic = 0x0662;\n  t.twobengali = 0x09e8;\n  t.twocircle = 0x2461;\n  t.twocircleinversesansserif = 0x278b;\n  t.twodeva = 0x0968;\n  t.twodotenleader = 0x2025;\n  t.twodotleader = 0x2025;\n  t.twodotleadervertical = 0xfe30;\n  t.twogujarati = 0x0ae8;\n  t.twogurmukhi = 0x0a68;\n  t.twohackarabic = 0x0662;\n  t.twohangzhou = 0x3022;\n  t.twoideographicparen = 0x3221;\n  t.twoinferior = 0x2082;\n  t.twomonospace = 0xff12;\n  t.twonumeratorbengali = 0x09f5;\n  t.twooldstyle = 0xf732;\n  t.twoparen = 0x2475;\n  t.twoperiod = 0x2489;\n  t.twopersian = 0x06f2;\n  t.tworoman = 0x2171;\n  t.twostroke = 0x01bb;\n  t.twosuperior = 0x00b2;\n  t.twothai = 0x0e52;\n  t.twothirds = 0x2154;\n  t.u = 0x0075;\n  t.uacute = 0x00fa;\n  t.ubar = 0x0289;\n  t.ubengali = 0x0989;\n  t.ubopomofo = 0x3128;\n  t.ubreve = 0x016d;\n  t.ucaron = 0x01d4;\n  t.ucircle = 0x24e4;\n  t.ucircumflex = 0x00fb;\n  t.ucircumflexbelow = 0x1e77;\n  t.ucyrillic = 0x0443;\n  t.udattadeva = 0x0951;\n  t.udblacute = 0x0171;\n  t.udblgrave = 0x0215;\n  t.udeva = 0x0909;\n  t.udieresis = 0x00fc;\n  t.udieresisacute = 0x01d8;\n  t.udieresisbelow = 0x1e73;\n  t.udieresiscaron = 0x01da;\n  t.udieresiscyrillic = 0x04f1;\n  t.udieresisgrave = 0x01dc;\n  t.udieresismacron = 0x01d6;\n  t.udotbelow = 0x1ee5;\n  t.ugrave = 0x00f9;\n  t.ugujarati = 0x0a89;\n  t.ugurmukhi = 0x0a09;\n  t.uhiragana = 0x3046;\n  t.uhookabove = 0x1ee7;\n  t.uhorn = 0x01b0;\n  t.uhornacute = 0x1ee9;\n  t.uhorndotbelow = 0x1ef1;\n  t.uhorngrave = 0x1eeb;\n  t.uhornhookabove = 0x1eed;\n  t.uhorntilde = 0x1eef;\n  t.uhungarumlaut = 0x0171;\n  t.uhungarumlautcyrillic = 0x04f3;\n  t.uinvertedbreve = 0x0217;\n  t.ukatakana = 0x30a6;\n  t.ukatakanahalfwidth = 0xff73;\n  t.ukcyrillic = 0x0479;\n  t.ukorean = 0x315c;\n  t.umacron = 0x016b;\n  t.umacroncyrillic = 0x04ef;\n  t.umacrondieresis = 0x1e7b;\n  t.umatragurmukhi = 0x0a41;\n  t.umonospace = 0xff55;\n  t.underscore = 0x005f;\n  t.underscoredbl = 0x2017;\n  t.underscoremonospace = 0xff3f;\n  t.underscorevertical = 0xfe33;\n  t.underscorewavy = 0xfe4f;\n  t.union = 0x222a;\n  t.universal = 0x2200;\n  t.uogonek = 0x0173;\n  t.uparen = 0x24b0;\n  t.upblock = 0x2580;\n  t.upperdothebrew = 0x05c4;\n  t.upsilon = 0x03c5;\n  t.upsilondieresis = 0x03cb;\n  t.upsilondieresistonos = 0x03b0;\n  t.upsilonlatin = 0x028a;\n  t.upsilontonos = 0x03cd;\n  t.uptackbelowcmb = 0x031d;\n  t.uptackmod = 0x02d4;\n  t.uragurmukhi = 0x0a73;\n  t.uring = 0x016f;\n  t.ushortcyrillic = 0x045e;\n  t.usmallhiragana = 0x3045;\n  t.usmallkatakana = 0x30a5;\n  t.usmallkatakanahalfwidth = 0xff69;\n  t.ustraightcyrillic = 0x04af;\n  t.ustraightstrokecyrillic = 0x04b1;\n  t.utilde = 0x0169;\n  t.utildeacute = 0x1e79;\n  t.utildebelow = 0x1e75;\n  t.uubengali = 0x098a;\n  t.uudeva = 0x090a;\n  t.uugujarati = 0x0a8a;\n  t.uugurmukhi = 0x0a0a;\n  t.uumatragurmukhi = 0x0a42;\n  t.uuvowelsignbengali = 0x09c2;\n  t.uuvowelsigndeva = 0x0942;\n  t.uuvowelsigngujarati = 0x0ac2;\n  t.uvowelsignbengali = 0x09c1;\n  t.uvowelsigndeva = 0x0941;\n  t.uvowelsigngujarati = 0x0ac1;\n  t.v = 0x0076;\n  t.vadeva = 0x0935;\n  t.vagujarati = 0x0ab5;\n  t.vagurmukhi = 0x0a35;\n  t.vakatakana = 0x30f7;\n  t.vav = 0x05d5;\n  t.vavdagesh = 0xfb35;\n  t.vavdagesh65 = 0xfb35;\n  t.vavdageshhebrew = 0xfb35;\n  t.vavhebrew = 0x05d5;\n  t.vavholam = 0xfb4b;\n  t.vavholamhebrew = 0xfb4b;\n  t.vavvavhebrew = 0x05f0;\n  t.vavyodhebrew = 0x05f1;\n  t.vcircle = 0x24e5;\n  t.vdotbelow = 0x1e7f;\n  t.vecyrillic = 0x0432;\n  t.veharabic = 0x06a4;\n  t.vehfinalarabic = 0xfb6b;\n  t.vehinitialarabic = 0xfb6c;\n  t.vehmedialarabic = 0xfb6d;\n  t.vekatakana = 0x30f9;\n  t.venus = 0x2640;\n  t.verticalbar = 0x007c;\n  t.verticallineabovecmb = 0x030d;\n  t.verticallinebelowcmb = 0x0329;\n  t.verticallinelowmod = 0x02cc;\n  t.verticallinemod = 0x02c8;\n  t.vewarmenian = 0x057e;\n  t.vhook = 0x028b;\n  t.vikatakana = 0x30f8;\n  t.viramabengali = 0x09cd;\n  t.viramadeva = 0x094d;\n  t.viramagujarati = 0x0acd;\n  t.visargabengali = 0x0983;\n  t.visargadeva = 0x0903;\n  t.visargagujarati = 0x0a83;\n  t.vmonospace = 0xff56;\n  t.voarmenian = 0x0578;\n  t.voicediterationhiragana = 0x309e;\n  t.voicediterationkatakana = 0x30fe;\n  t.voicedmarkkana = 0x309b;\n  t.voicedmarkkanahalfwidth = 0xff9e;\n  t.vokatakana = 0x30fa;\n  t.vparen = 0x24b1;\n  t.vtilde = 0x1e7d;\n  t.vturned = 0x028c;\n  t.vuhiragana = 0x3094;\n  t.vukatakana = 0x30f4;\n  t.w = 0x0077;\n  t.wacute = 0x1e83;\n  t.waekorean = 0x3159;\n  t.wahiragana = 0x308f;\n  t.wakatakana = 0x30ef;\n  t.wakatakanahalfwidth = 0xff9c;\n  t.wakorean = 0x3158;\n  t.wasmallhiragana = 0x308e;\n  t.wasmallkatakana = 0x30ee;\n  t.wattosquare = 0x3357;\n  t.wavedash = 0x301c;\n  t.wavyunderscorevertical = 0xfe34;\n  t.wawarabic = 0x0648;\n  t.wawfinalarabic = 0xfeee;\n  t.wawhamzaabovearabic = 0x0624;\n  t.wawhamzaabovefinalarabic = 0xfe86;\n  t.wbsquare = 0x33dd;\n  t.wcircle = 0x24e6;\n  t.wcircumflex = 0x0175;\n  t.wdieresis = 0x1e85;\n  t.wdotaccent = 0x1e87;\n  t.wdotbelow = 0x1e89;\n  t.wehiragana = 0x3091;\n  t.weierstrass = 0x2118;\n  t.wekatakana = 0x30f1;\n  t.wekorean = 0x315e;\n  t.weokorean = 0x315d;\n  t.wgrave = 0x1e81;\n  t.whitebullet = 0x25e6;\n  t.whitecircle = 0x25cb;\n  t.whitecircleinverse = 0x25d9;\n  t.whitecornerbracketleft = 0x300e;\n  t.whitecornerbracketleftvertical = 0xfe43;\n  t.whitecornerbracketright = 0x300f;\n  t.whitecornerbracketrightvertical = 0xfe44;\n  t.whitediamond = 0x25c7;\n  t.whitediamondcontainingblacksmalldiamond = 0x25c8;\n  t.whitedownpointingsmalltriangle = 0x25bf;\n  t.whitedownpointingtriangle = 0x25bd;\n  t.whiteleftpointingsmalltriangle = 0x25c3;\n  t.whiteleftpointingtriangle = 0x25c1;\n  t.whitelenticularbracketleft = 0x3016;\n  t.whitelenticularbracketright = 0x3017;\n  t.whiterightpointingsmalltriangle = 0x25b9;\n  t.whiterightpointingtriangle = 0x25b7;\n  t.whitesmallsquare = 0x25ab;\n  t.whitesmilingface = 0x263a;\n  t.whitesquare = 0x25a1;\n  t.whitestar = 0x2606;\n  t.whitetelephone = 0x260f;\n  t.whitetortoiseshellbracketleft = 0x3018;\n  t.whitetortoiseshellbracketright = 0x3019;\n  t.whiteuppointingsmalltriangle = 0x25b5;\n  t.whiteuppointingtriangle = 0x25b3;\n  t.wihiragana = 0x3090;\n  t.wikatakana = 0x30f0;\n  t.wikorean = 0x315f;\n  t.wmonospace = 0xff57;\n  t.wohiragana = 0x3092;\n  t.wokatakana = 0x30f2;\n  t.wokatakanahalfwidth = 0xff66;\n  t.won = 0x20a9;\n  t.wonmonospace = 0xffe6;\n  t.wowaenthai = 0x0e27;\n  t.wparen = 0x24b2;\n  t.wring = 0x1e98;\n  t.wsuperior = 0x02b7;\n  t.wturned = 0x028d;\n  t.wynn = 0x01bf;\n  t.x = 0x0078;\n  t.xabovecmb = 0x033d;\n  t.xbopomofo = 0x3112;\n  t.xcircle = 0x24e7;\n  t.xdieresis = 0x1e8d;\n  t.xdotaccent = 0x1e8b;\n  t.xeharmenian = 0x056d;\n  t.xi = 0x03be;\n  t.xmonospace = 0xff58;\n  t.xparen = 0x24b3;\n  t.xsuperior = 0x02e3;\n  t.y = 0x0079;\n  t.yaadosquare = 0x334e;\n  t.yabengali = 0x09af;\n  t.yacute = 0x00fd;\n  t.yadeva = 0x092f;\n  t.yaekorean = 0x3152;\n  t.yagujarati = 0x0aaf;\n  t.yagurmukhi = 0x0a2f;\n  t.yahiragana = 0x3084;\n  t.yakatakana = 0x30e4;\n  t.yakatakanahalfwidth = 0xff94;\n  t.yakorean = 0x3151;\n  t.yamakkanthai = 0x0e4e;\n  t.yasmallhiragana = 0x3083;\n  t.yasmallkatakana = 0x30e3;\n  t.yasmallkatakanahalfwidth = 0xff6c;\n  t.yatcyrillic = 0x0463;\n  t.ycircle = 0x24e8;\n  t.ycircumflex = 0x0177;\n  t.ydieresis = 0x00ff;\n  t.ydotaccent = 0x1e8f;\n  t.ydotbelow = 0x1ef5;\n  t.yeharabic = 0x064a;\n  t.yehbarreearabic = 0x06d2;\n  t.yehbarreefinalarabic = 0xfbaf;\n  t.yehfinalarabic = 0xfef2;\n  t.yehhamzaabovearabic = 0x0626;\n  t.yehhamzaabovefinalarabic = 0xfe8a;\n  t.yehhamzaaboveinitialarabic = 0xfe8b;\n  t.yehhamzaabovemedialarabic = 0xfe8c;\n  t.yehinitialarabic = 0xfef3;\n  t.yehmedialarabic = 0xfef4;\n  t.yehmeeminitialarabic = 0xfcdd;\n  t.yehmeemisolatedarabic = 0xfc58;\n  t.yehnoonfinalarabic = 0xfc94;\n  t.yehthreedotsbelowarabic = 0x06d1;\n  t.yekorean = 0x3156;\n  t.yen = 0x00a5;\n  t.yenmonospace = 0xffe5;\n  t.yeokorean = 0x3155;\n  t.yeorinhieuhkorean = 0x3186;\n  t.yerahbenyomohebrew = 0x05aa;\n  t.yerahbenyomolefthebrew = 0x05aa;\n  t.yericyrillic = 0x044b;\n  t.yerudieresiscyrillic = 0x04f9;\n  t.yesieungkorean = 0x3181;\n  t.yesieungpansioskorean = 0x3183;\n  t.yesieungsioskorean = 0x3182;\n  t.yetivhebrew = 0x059a;\n  t.ygrave = 0x1ef3;\n  t.yhook = 0x01b4;\n  t.yhookabove = 0x1ef7;\n  t.yiarmenian = 0x0575;\n  t.yicyrillic = 0x0457;\n  t.yikorean = 0x3162;\n  t.yinyang = 0x262f;\n  t.yiwnarmenian = 0x0582;\n  t.ymonospace = 0xff59;\n  t.yod = 0x05d9;\n  t.yoddagesh = 0xfb39;\n  t.yoddageshhebrew = 0xfb39;\n  t.yodhebrew = 0x05d9;\n  t.yodyodhebrew = 0x05f2;\n  t.yodyodpatahhebrew = 0xfb1f;\n  t.yohiragana = 0x3088;\n  t.yoikorean = 0x3189;\n  t.yokatakana = 0x30e8;\n  t.yokatakanahalfwidth = 0xff96;\n  t.yokorean = 0x315b;\n  t.yosmallhiragana = 0x3087;\n  t.yosmallkatakana = 0x30e7;\n  t.yosmallkatakanahalfwidth = 0xff6e;\n  t.yotgreek = 0x03f3;\n  t.yoyaekorean = 0x3188;\n  t.yoyakorean = 0x3187;\n  t.yoyakthai = 0x0e22;\n  t.yoyingthai = 0x0e0d;\n  t.yparen = 0x24b4;\n  t.ypogegrammeni = 0x037a;\n  t.ypogegrammenigreekcmb = 0x0345;\n  t.yr = 0x01a6;\n  t.yring = 0x1e99;\n  t.ysuperior = 0x02b8;\n  t.ytilde = 0x1ef9;\n  t.yturned = 0x028e;\n  t.yuhiragana = 0x3086;\n  t.yuikorean = 0x318c;\n  t.yukatakana = 0x30e6;\n  t.yukatakanahalfwidth = 0xff95;\n  t.yukorean = 0x3160;\n  t.yusbigcyrillic = 0x046b;\n  t.yusbigiotifiedcyrillic = 0x046d;\n  t.yuslittlecyrillic = 0x0467;\n  t.yuslittleiotifiedcyrillic = 0x0469;\n  t.yusmallhiragana = 0x3085;\n  t.yusmallkatakana = 0x30e5;\n  t.yusmallkatakanahalfwidth = 0xff6d;\n  t.yuyekorean = 0x318b;\n  t.yuyeokorean = 0x318a;\n  t.yyabengali = 0x09df;\n  t.yyadeva = 0x095f;\n  t.z = 0x007a;\n  t.zaarmenian = 0x0566;\n  t.zacute = 0x017a;\n  t.zadeva = 0x095b;\n  t.zagurmukhi = 0x0a5b;\n  t.zaharabic = 0x0638;\n  t.zahfinalarabic = 0xfec6;\n  t.zahinitialarabic = 0xfec7;\n  t.zahiragana = 0x3056;\n  t.zahmedialarabic = 0xfec8;\n  t.zainarabic = 0x0632;\n  t.zainfinalarabic = 0xfeb0;\n  t.zakatakana = 0x30b6;\n  t.zaqefgadolhebrew = 0x0595;\n  t.zaqefqatanhebrew = 0x0594;\n  t.zarqahebrew = 0x0598;\n  t.zayin = 0x05d6;\n  t.zayindagesh = 0xfb36;\n  t.zayindageshhebrew = 0xfb36;\n  t.zayinhebrew = 0x05d6;\n  t.zbopomofo = 0x3117;\n  t.zcaron = 0x017e;\n  t.zcircle = 0x24e9;\n  t.zcircumflex = 0x1e91;\n  t.zcurl = 0x0291;\n  t.zdot = 0x017c;\n  t.zdotaccent = 0x017c;\n  t.zdotbelow = 0x1e93;\n  t.zecyrillic = 0x0437;\n  t.zedescendercyrillic = 0x0499;\n  t.zedieresiscyrillic = 0x04df;\n  t.zehiragana = 0x305c;\n  t.zekatakana = 0x30bc;\n  t.zero = 0x0030;\n  t.zeroarabic = 0x0660;\n  t.zerobengali = 0x09e6;\n  t.zerodeva = 0x0966;\n  t.zerogujarati = 0x0ae6;\n  t.zerogurmukhi = 0x0a66;\n  t.zerohackarabic = 0x0660;\n  t.zeroinferior = 0x2080;\n  t.zeromonospace = 0xff10;\n  t.zerooldstyle = 0xf730;\n  t.zeropersian = 0x06f0;\n  t.zerosuperior = 0x2070;\n  t.zerothai = 0x0e50;\n  t.zerowidthjoiner = 0xfeff;\n  t.zerowidthnonjoiner = 0x200c;\n  t.zerowidthspace = 0x200b;\n  t.zeta = 0x03b6;\n  t.zhbopomofo = 0x3113;\n  t.zhearmenian = 0x056a;\n  t.zhebrevecyrillic = 0x04c2;\n  t.zhecyrillic = 0x0436;\n  t.zhedescendercyrillic = 0x0497;\n  t.zhedieresiscyrillic = 0x04dd;\n  t.zihiragana = 0x3058;\n  t.zikatakana = 0x30b8;\n  t.zinorhebrew = 0x05ae;\n  t.zlinebelow = 0x1e95;\n  t.zmonospace = 0xff5a;\n  t.zohiragana = 0x305e;\n  t.zokatakana = 0x30be;\n  t.zparen = 0x24b5;\n  t.zretroflexhook = 0x0290;\n  t.zstroke = 0x01b6;\n  t.zuhiragana = 0x305a;\n  t.zukatakana = 0x30ba;\n  t[\".notdef\"] = 0x0000;\n  t.angbracketleftbig = 0x2329;\n  t.angbracketleftBig = 0x2329;\n  t.angbracketleftbigg = 0x2329;\n  t.angbracketleftBigg = 0x2329;\n  t.angbracketrightBig = 0x232a;\n  t.angbracketrightbig = 0x232a;\n  t.angbracketrightBigg = 0x232a;\n  t.angbracketrightbigg = 0x232a;\n  t.arrowhookleft = 0x21aa;\n  t.arrowhookright = 0x21a9;\n  t.arrowlefttophalf = 0x21bc;\n  t.arrowleftbothalf = 0x21bd;\n  t.arrownortheast = 0x2197;\n  t.arrownorthwest = 0x2196;\n  t.arrowrighttophalf = 0x21c0;\n  t.arrowrightbothalf = 0x21c1;\n  t.arrowsoutheast = 0x2198;\n  t.arrowsouthwest = 0x2199;\n  t.backslashbig = 0x2216;\n  t.backslashBig = 0x2216;\n  t.backslashBigg = 0x2216;\n  t.backslashbigg = 0x2216;\n  t.bardbl = 0x2016;\n  t.bracehtipdownleft = 0xfe37;\n  t.bracehtipdownright = 0xfe37;\n  t.bracehtipupleft = 0xfe38;\n  t.bracehtipupright = 0xfe38;\n  t.braceleftBig = 0x007b;\n  t.braceleftbig = 0x007b;\n  t.braceleftbigg = 0x007b;\n  t.braceleftBigg = 0x007b;\n  t.bracerightBig = 0x007d;\n  t.bracerightbig = 0x007d;\n  t.bracerightbigg = 0x007d;\n  t.bracerightBigg = 0x007d;\n  t.bracketleftbig = 0x005b;\n  t.bracketleftBig = 0x005b;\n  t.bracketleftbigg = 0x005b;\n  t.bracketleftBigg = 0x005b;\n  t.bracketrightBig = 0x005d;\n  t.bracketrightbig = 0x005d;\n  t.bracketrightbigg = 0x005d;\n  t.bracketrightBigg = 0x005d;\n  t.ceilingleftbig = 0x2308;\n  t.ceilingleftBig = 0x2308;\n  t.ceilingleftBigg = 0x2308;\n  t.ceilingleftbigg = 0x2308;\n  t.ceilingrightbig = 0x2309;\n  t.ceilingrightBig = 0x2309;\n  t.ceilingrightbigg = 0x2309;\n  t.ceilingrightBigg = 0x2309;\n  t.circledotdisplay = 0x2299;\n  t.circledottext = 0x2299;\n  t.circlemultiplydisplay = 0x2297;\n  t.circlemultiplytext = 0x2297;\n  t.circleplusdisplay = 0x2295;\n  t.circleplustext = 0x2295;\n  t.contintegraldisplay = 0x222e;\n  t.contintegraltext = 0x222e;\n  t.coproductdisplay = 0x2210;\n  t.coproducttext = 0x2210;\n  t.floorleftBig = 0x230a;\n  t.floorleftbig = 0x230a;\n  t.floorleftbigg = 0x230a;\n  t.floorleftBigg = 0x230a;\n  t.floorrightbig = 0x230b;\n  t.floorrightBig = 0x230b;\n  t.floorrightBigg = 0x230b;\n  t.floorrightbigg = 0x230b;\n  t.hatwide = 0x0302;\n  t.hatwider = 0x0302;\n  t.hatwidest = 0x0302;\n  t.intercal = 0x1d40;\n  t.integraldisplay = 0x222b;\n  t.integraltext = 0x222b;\n  t.intersectiondisplay = 0x22c2;\n  t.intersectiontext = 0x22c2;\n  t.logicalanddisplay = 0x2227;\n  t.logicalandtext = 0x2227;\n  t.logicalordisplay = 0x2228;\n  t.logicalortext = 0x2228;\n  t.parenleftBig = 0x0028;\n  t.parenleftbig = 0x0028;\n  t.parenleftBigg = 0x0028;\n  t.parenleftbigg = 0x0028;\n  t.parenrightBig = 0x0029;\n  t.parenrightbig = 0x0029;\n  t.parenrightBigg = 0x0029;\n  t.parenrightbigg = 0x0029;\n  t.prime = 0x2032;\n  t.productdisplay = 0x220f;\n  t.producttext = 0x220f;\n  t.radicalbig = 0x221a;\n  t.radicalBig = 0x221a;\n  t.radicalBigg = 0x221a;\n  t.radicalbigg = 0x221a;\n  t.radicalbt = 0x221a;\n  t.radicaltp = 0x221a;\n  t.radicalvertex = 0x221a;\n  t.slashbig = 0x002f;\n  t.slashBig = 0x002f;\n  t.slashBigg = 0x002f;\n  t.slashbigg = 0x002f;\n  t.summationdisplay = 0x2211;\n  t.summationtext = 0x2211;\n  t.tildewide = 0x02dc;\n  t.tildewider = 0x02dc;\n  t.tildewidest = 0x02dc;\n  t.uniondisplay = 0x22c3;\n  t.unionmultidisplay = 0x228e;\n  t.unionmultitext = 0x228e;\n  t.unionsqdisplay = 0x2294;\n  t.unionsqtext = 0x2294;\n  t.uniontext = 0x22c3;\n  t.vextenddouble = 0x2225;\n  t.vextendsingle = 0x2223;\n});\nconst getDingbatsGlyphsUnicode = getLookupTableFactory(function (t) {\n  t.space = 0x0020;\n  t.a1 = 0x2701;\n  t.a2 = 0x2702;\n  t.a202 = 0x2703;\n  t.a3 = 0x2704;\n  t.a4 = 0x260e;\n  t.a5 = 0x2706;\n  t.a119 = 0x2707;\n  t.a118 = 0x2708;\n  t.a117 = 0x2709;\n  t.a11 = 0x261b;\n  t.a12 = 0x261e;\n  t.a13 = 0x270c;\n  t.a14 = 0x270d;\n  t.a15 = 0x270e;\n  t.a16 = 0x270f;\n  t.a105 = 0x2710;\n  t.a17 = 0x2711;\n  t.a18 = 0x2712;\n  t.a19 = 0x2713;\n  t.a20 = 0x2714;\n  t.a21 = 0x2715;\n  t.a22 = 0x2716;\n  t.a23 = 0x2717;\n  t.a24 = 0x2718;\n  t.a25 = 0x2719;\n  t.a26 = 0x271a;\n  t.a27 = 0x271b;\n  t.a28 = 0x271c;\n  t.a6 = 0x271d;\n  t.a7 = 0x271e;\n  t.a8 = 0x271f;\n  t.a9 = 0x2720;\n  t.a10 = 0x2721;\n  t.a29 = 0x2722;\n  t.a30 = 0x2723;\n  t.a31 = 0x2724;\n  t.a32 = 0x2725;\n  t.a33 = 0x2726;\n  t.a34 = 0x2727;\n  t.a35 = 0x2605;\n  t.a36 = 0x2729;\n  t.a37 = 0x272a;\n  t.a38 = 0x272b;\n  t.a39 = 0x272c;\n  t.a40 = 0x272d;\n  t.a41 = 0x272e;\n  t.a42 = 0x272f;\n  t.a43 = 0x2730;\n  t.a44 = 0x2731;\n  t.a45 = 0x2732;\n  t.a46 = 0x2733;\n  t.a47 = 0x2734;\n  t.a48 = 0x2735;\n  t.a49 = 0x2736;\n  t.a50 = 0x2737;\n  t.a51 = 0x2738;\n  t.a52 = 0x2739;\n  t.a53 = 0x273a;\n  t.a54 = 0x273b;\n  t.a55 = 0x273c;\n  t.a56 = 0x273d;\n  t.a57 = 0x273e;\n  t.a58 = 0x273f;\n  t.a59 = 0x2740;\n  t.a60 = 0x2741;\n  t.a61 = 0x2742;\n  t.a62 = 0x2743;\n  t.a63 = 0x2744;\n  t.a64 = 0x2745;\n  t.a65 = 0x2746;\n  t.a66 = 0x2747;\n  t.a67 = 0x2748;\n  t.a68 = 0x2749;\n  t.a69 = 0x274a;\n  t.a70 = 0x274b;\n  t.a71 = 0x25cf;\n  t.a72 = 0x274d;\n  t.a73 = 0x25a0;\n  t.a74 = 0x274f;\n  t.a203 = 0x2750;\n  t.a75 = 0x2751;\n  t.a204 = 0x2752;\n  t.a76 = 0x25b2;\n  t.a77 = 0x25bc;\n  t.a78 = 0x25c6;\n  t.a79 = 0x2756;\n  t.a81 = 0x25d7;\n  t.a82 = 0x2758;\n  t.a83 = 0x2759;\n  t.a84 = 0x275a;\n  t.a97 = 0x275b;\n  t.a98 = 0x275c;\n  t.a99 = 0x275d;\n  t.a100 = 0x275e;\n  t.a101 = 0x2761;\n  t.a102 = 0x2762;\n  t.a103 = 0x2763;\n  t.a104 = 0x2764;\n  t.a106 = 0x2765;\n  t.a107 = 0x2766;\n  t.a108 = 0x2767;\n  t.a112 = 0x2663;\n  t.a111 = 0x2666;\n  t.a110 = 0x2665;\n  t.a109 = 0x2660;\n  t.a120 = 0x2460;\n  t.a121 = 0x2461;\n  t.a122 = 0x2462;\n  t.a123 = 0x2463;\n  t.a124 = 0x2464;\n  t.a125 = 0x2465;\n  t.a126 = 0x2466;\n  t.a127 = 0x2467;\n  t.a128 = 0x2468;\n  t.a129 = 0x2469;\n  t.a130 = 0x2776;\n  t.a131 = 0x2777;\n  t.a132 = 0x2778;\n  t.a133 = 0x2779;\n  t.a134 = 0x277a;\n  t.a135 = 0x277b;\n  t.a136 = 0x277c;\n  t.a137 = 0x277d;\n  t.a138 = 0x277e;\n  t.a139 = 0x277f;\n  t.a140 = 0x2780;\n  t.a141 = 0x2781;\n  t.a142 = 0x2782;\n  t.a143 = 0x2783;\n  t.a144 = 0x2784;\n  t.a145 = 0x2785;\n  t.a146 = 0x2786;\n  t.a147 = 0x2787;\n  t.a148 = 0x2788;\n  t.a149 = 0x2789;\n  t.a150 = 0x278a;\n  t.a151 = 0x278b;\n  t.a152 = 0x278c;\n  t.a153 = 0x278d;\n  t.a154 = 0x278e;\n  t.a155 = 0x278f;\n  t.a156 = 0x2790;\n  t.a157 = 0x2791;\n  t.a158 = 0x2792;\n  t.a159 = 0x2793;\n  t.a160 = 0x2794;\n  t.a161 = 0x2192;\n  t.a163 = 0x2194;\n  t.a164 = 0x2195;\n  t.a196 = 0x2798;\n  t.a165 = 0x2799;\n  t.a192 = 0x279a;\n  t.a166 = 0x279b;\n  t.a167 = 0x279c;\n  t.a168 = 0x279d;\n  t.a169 = 0x279e;\n  t.a170 = 0x279f;\n  t.a171 = 0x27a0;\n  t.a172 = 0x27a1;\n  t.a173 = 0x27a2;\n  t.a162 = 0x27a3;\n  t.a174 = 0x27a4;\n  t.a175 = 0x27a5;\n  t.a176 = 0x27a6;\n  t.a177 = 0x27a7;\n  t.a178 = 0x27a8;\n  t.a179 = 0x27a9;\n  t.a193 = 0x27aa;\n  t.a180 = 0x27ab;\n  t.a199 = 0x27ac;\n  t.a181 = 0x27ad;\n  t.a200 = 0x27ae;\n  t.a182 = 0x27af;\n  t.a201 = 0x27b1;\n  t.a183 = 0x27b2;\n  t.a184 = 0x27b3;\n  t.a197 = 0x27b4;\n  t.a185 = 0x27b5;\n  t.a194 = 0x27b6;\n  t.a198 = 0x27b7;\n  t.a186 = 0x27b8;\n  t.a195 = 0x27b9;\n  t.a187 = 0x27ba;\n  t.a188 = 0x27bb;\n  t.a189 = 0x27bc;\n  t.a190 = 0x27bd;\n  t.a191 = 0x27be;\n  t.a89 = 0x2768;\n  t.a90 = 0x2769;\n  t.a93 = 0x276a;\n  t.a94 = 0x276b;\n  t.a91 = 0x276c;\n  t.a92 = 0x276d;\n  t.a205 = 0x276e;\n  t.a85 = 0x276f;\n  t.a206 = 0x2770;\n  t.a86 = 0x2771;\n  t.a87 = 0x2772;\n  t.a88 = 0x2773;\n  t.a95 = 0x2774;\n  t.a96 = 0x2775;\n  t[\".notdef\"] = 0x0000;\n});\n\n;// CONCATENATED MODULE: ./src/core/unicode.js\n\nconst getSpecialPUASymbols = getLookupTableFactory(function (t) {\n  t[63721] = 0x00a9;\n  t[63193] = 0x00a9;\n  t[63720] = 0x00ae;\n  t[63194] = 0x00ae;\n  t[63722] = 0x2122;\n  t[63195] = 0x2122;\n  t[63729] = 0x23a7;\n  t[63730] = 0x23a8;\n  t[63731] = 0x23a9;\n  t[63740] = 0x23ab;\n  t[63741] = 0x23ac;\n  t[63742] = 0x23ad;\n  t[63726] = 0x23a1;\n  t[63727] = 0x23a2;\n  t[63728] = 0x23a3;\n  t[63737] = 0x23a4;\n  t[63738] = 0x23a5;\n  t[63739] = 0x23a6;\n  t[63723] = 0x239b;\n  t[63724] = 0x239c;\n  t[63725] = 0x239d;\n  t[63734] = 0x239e;\n  t[63735] = 0x239f;\n  t[63736] = 0x23a0;\n});\nfunction mapSpecialUnicodeValues(code) {\n  if (code >= 0xfff0 && code <= 0xffff) {\n    return 0;\n  } else if (code >= 0xf600 && code <= 0xf8ff) {\n    return getSpecialPUASymbols()[code] || code;\n  } else if (code === 0x00ad) {\n    return 0x002d;\n  }\n  return code;\n}\nfunction getUnicodeForGlyph(name, glyphsUnicodeMap) {\n  let unicode = glyphsUnicodeMap[name];\n  if (unicode !== undefined) {\n    return unicode;\n  }\n  if (!name) {\n    return -1;\n  }\n  if (name[0] === \"u\") {\n    const nameLen = name.length;\n    let hexStr;\n    if (nameLen === 7 && name[1] === \"n\" && name[2] === \"i\") {\n      hexStr = name.substring(3);\n    } else if (nameLen >= 5 && nameLen <= 7) {\n      hexStr = name.substring(1);\n    } else {\n      return -1;\n    }\n    if (hexStr === hexStr.toUpperCase()) {\n      unicode = parseInt(hexStr, 16);\n      if (unicode >= 0) {\n        return unicode;\n      }\n    }\n  }\n  return -1;\n}\nconst UnicodeRanges = [[0x0000, 0x007f], [0x0080, 0x00ff], [0x0100, 0x017f], [0x0180, 0x024f], [0x0250, 0x02af, 0x1d00, 0x1d7f, 0x1d80, 0x1dbf], [0x02b0, 0x02ff, 0xa700, 0xa71f], [0x0300, 0x036f, 0x1dc0, 0x1dff], [0x0370, 0x03ff], [0x2c80, 0x2cff], [0x0400, 0x04ff, 0x0500, 0x052f, 0x2de0, 0x2dff, 0xa640, 0xa69f], [0x0530, 0x058f], [0x0590, 0x05ff], [0xa500, 0xa63f], [0x0600, 0x06ff, 0x0750, 0x077f], [0x07c0, 0x07ff], [0x0900, 0x097f], [0x0980, 0x09ff], [0x0a00, 0x0a7f], [0x0a80, 0x0aff], [0x0b00, 0x0b7f], [0x0b80, 0x0bff], [0x0c00, 0x0c7f], [0x0c80, 0x0cff], [0x0d00, 0x0d7f], [0x0e00, 0x0e7f], [0x0e80, 0x0eff], [0x10a0, 0x10ff, 0x2d00, 0x2d2f], [0x1b00, 0x1b7f], [0x1100, 0x11ff], [0x1e00, 0x1eff, 0x2c60, 0x2c7f, 0xa720, 0xa7ff], [0x1f00, 0x1fff], [0x2000, 0x206f, 0x2e00, 0x2e7f], [0x2070, 0x209f], [0x20a0, 0x20cf], [0x20d0, 0x20ff], [0x2100, 0x214f], [0x2150, 0x218f], [0x2190, 0x21ff, 0x27f0, 0x27ff, 0x2900, 0x297f, 0x2b00, 0x2bff], [0x2200, 0x22ff, 0x2a00, 0x2aff, 0x27c0, 0x27ef, 0x2980, 0x29ff], [0x2300, 0x23ff], [0x2400, 0x243f], [0x2440, 0x245f], [0x2460, 0x24ff], [0x2500, 0x257f], [0x2580, 0x259f], [0x25a0, 0x25ff], [0x2600, 0x26ff], [0x2700, 0x27bf], [0x3000, 0x303f], [0x3040, 0x309f], [0x30a0, 0x30ff, 0x31f0, 0x31ff], [0x3100, 0x312f, 0x31a0, 0x31bf], [0x3130, 0x318f], [0xa840, 0xa87f], [0x3200, 0x32ff], [0x3300, 0x33ff], [0xac00, 0xd7af], [0xd800, 0xdfff], [0x10900, 0x1091f], [0x4e00, 0x9fff, 0x2e80, 0x2eff, 0x2f00, 0x2fdf, 0x2ff0, 0x2fff, 0x3400, 0x4dbf, 0x20000, 0x2a6df, 0x3190, 0x319f], [0xe000, 0xf8ff], [0x31c0, 0x31ef, 0xf900, 0xfaff, 0x2f800, 0x2fa1f], [0xfb00, 0xfb4f], [0xfb50, 0xfdff], [0xfe20, 0xfe2f], [0xfe10, 0xfe1f], [0xfe50, 0xfe6f], [0xfe70, 0xfeff], [0xff00, 0xffef], [0xfff0, 0xffff], [0x0f00, 0x0fff], [0x0700, 0x074f], [0x0780, 0x07bf], [0x0d80, 0x0dff], [0x1000, 0x109f], [0x1200, 0x137f, 0x1380, 0x139f, 0x2d80, 0x2ddf], [0x13a0, 0x13ff], [0x1400, 0x167f], [0x1680, 0x169f], [0x16a0, 0x16ff], [0x1780, 0x17ff], [0x1800, 0x18af], [0x2800, 0x28ff], [0xa000, 0xa48f], [0x1700, 0x171f, 0x1720, 0x173f, 0x1740, 0x175f, 0x1760, 0x177f], [0x10300, 0x1032f], [0x10330, 0x1034f], [0x10400, 0x1044f], [0x1d000, 0x1d0ff, 0x1d100, 0x1d1ff, 0x1d200, 0x1d24f], [0x1d400, 0x1d7ff], [0xff000, 0xffffd], [0xfe00, 0xfe0f, 0xe0100, 0xe01ef], [0xe0000, 0xe007f], [0x1900, 0x194f], [0x1950, 0x197f], [0x1980, 0x19df], [0x1a00, 0x1a1f], [0x2c00, 0x2c5f], [0x2d30, 0x2d7f], [0x4dc0, 0x4dff], [0xa800, 0xa82f], [0x10000, 0x1007f, 0x10080, 0x100ff, 0x10100, 0x1013f], [0x10140, 0x1018f], [0x10380, 0x1039f], [0x103a0, 0x103df], [0x10450, 0x1047f], [0x10480, 0x104af], [0x10800, 0x1083f], [0x10a00, 0x10a5f], [0x1d300, 0x1d35f], [0x12000, 0x123ff, 0x12400, 0x1247f], [0x1d360, 0x1d37f], [0x1b80, 0x1bbf], [0x1c00, 0x1c4f], [0x1c50, 0x1c7f], [0xa880, 0xa8df], [0xa900, 0xa92f], [0xa930, 0xa95f], [0xaa00, 0xaa5f], [0x10190, 0x101cf], [0x101d0, 0x101ff], [0x102a0, 0x102df, 0x10280, 0x1029f, 0x10920, 0x1093f], [0x1f030, 0x1f09f, 0x1f000, 0x1f02f]];\nfunction getUnicodeRangeFor(value, lastPosition = -1) {\n  if (lastPosition !== -1) {\n    const range = UnicodeRanges[lastPosition];\n    for (let i = 0, ii = range.length; i < ii; i += 2) {\n      if (value >= range[i] && value <= range[i + 1]) {\n        return lastPosition;\n      }\n    }\n  }\n  for (let i = 0, ii = UnicodeRanges.length; i < ii; i++) {\n    const range = UnicodeRanges[i];\n    for (let j = 0, jj = range.length; j < jj; j += 2) {\n      if (value >= range[j] && value <= range[j + 1]) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\nconst SpecialCharRegExp = new RegExp(\"^(\\\\s)|(\\\\p{Mn})|(\\\\p{Cf})$\", \"u\");\nconst CategoryCache = new Map();\nfunction getCharUnicodeCategory(char) {\n  const cachedCategory = CategoryCache.get(char);\n  if (cachedCategory) {\n    return cachedCategory;\n  }\n  const groups = char.match(SpecialCharRegExp);\n  const category = {\n    isWhitespace: !!groups?.[1],\n    isZeroWidthDiacritic: !!groups?.[2],\n    isInvisibleFormatMark: !!groups?.[3]\n  };\n  CategoryCache.set(char, category);\n  return category;\n}\nfunction clearUnicodeCaches() {\n  CategoryCache.clear();\n}\n\n;// CONCATENATED MODULE: ./src/core/fonts_utils.js\n\n\n\n\nconst SEAC_ANALYSIS_ENABLED = true;\nconst FontFlags = {\n  FixedPitch: 1,\n  Serif: 2,\n  Symbolic: 4,\n  Script: 8,\n  Nonsymbolic: 32,\n  Italic: 64,\n  AllCap: 65536,\n  SmallCap: 131072,\n  ForceBold: 262144\n};\nconst MacStandardGlyphOrdering = [\".notdef\", \".null\", \"nonmarkingreturn\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\", \"ampersand\", \"quotesingle\", \"parenleft\", \"parenright\", \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\", \"grave\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\", \"asciitilde\", \"Adieresis\", \"Aring\", \"Ccedilla\", \"Eacute\", \"Ntilde\", \"Odieresis\", \"Udieresis\", \"aacute\", \"agrave\", \"acircumflex\", \"adieresis\", \"atilde\", \"aring\", \"ccedilla\", \"eacute\", \"egrave\", \"ecircumflex\", \"edieresis\", \"iacute\", \"igrave\", \"icircumflex\", \"idieresis\", \"ntilde\", \"oacute\", \"ograve\", \"ocircumflex\", \"odieresis\", \"otilde\", \"uacute\", \"ugrave\", \"ucircumflex\", \"udieresis\", \"dagger\", \"degree\", \"cent\", \"sterling\", \"section\", \"bullet\", \"paragraph\", \"germandbls\", \"registered\", \"copyright\", \"trademark\", \"acute\", \"dieresis\", \"notequal\", \"AE\", \"Oslash\", \"infinity\", \"plusminus\", \"lessequal\", \"greaterequal\", \"yen\", \"mu\", \"partialdiff\", \"summation\", \"product\", \"pi\", \"integral\", \"ordfeminine\", \"ordmasculine\", \"Omega\", \"ae\", \"oslash\", \"questiondown\", \"exclamdown\", \"logicalnot\", \"radical\", \"florin\", \"approxequal\", \"Delta\", \"guillemotleft\", \"guillemotright\", \"ellipsis\", \"nonbreakingspace\", \"Agrave\", \"Atilde\", \"Otilde\", \"OE\", \"oe\", \"endash\", \"emdash\", \"quotedblleft\", \"quotedblright\", \"quoteleft\", \"quoteright\", \"divide\", \"lozenge\", \"ydieresis\", \"Ydieresis\", \"fraction\", \"currency\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"daggerdbl\", \"periodcentered\", \"quotesinglbase\", \"quotedblbase\", \"perthousand\", \"Acircumflex\", \"Ecircumflex\", \"Aacute\", \"Edieresis\", \"Egrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\", \"Igrave\", \"Oacute\", \"Ocircumflex\", \"apple\", \"Ograve\", \"Uacute\", \"Ucircumflex\", \"Ugrave\", \"dotlessi\", \"circumflex\", \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"ring\", \"cedilla\", \"hungarumlaut\", \"ogonek\", \"caron\", \"Lslash\", \"lslash\", \"Scaron\", \"scaron\", \"Zcaron\", \"zcaron\", \"brokenbar\", \"Eth\", \"eth\", \"Yacute\", \"yacute\", \"Thorn\", \"thorn\", \"minus\", \"multiply\", \"onesuperior\", \"twosuperior\", \"threesuperior\", \"onehalf\", \"onequarter\", \"threequarters\", \"franc\", \"Gbreve\", \"gbreve\", \"Idotaccent\", \"Scedilla\", \"scedilla\", \"Cacute\", \"cacute\", \"Ccaron\", \"ccaron\", \"dcroat\"];\nfunction recoverGlyphName(name, glyphsUnicodeMap) {\n  if (glyphsUnicodeMap[name] !== undefined) {\n    return name;\n  }\n  const unicode = getUnicodeForGlyph(name, glyphsUnicodeMap);\n  if (unicode !== -1) {\n    for (const key in glyphsUnicodeMap) {\n      if (glyphsUnicodeMap[key] === unicode) {\n        return key;\n      }\n    }\n  }\n  info(\"Unable to recover a standard glyph name for: \" + name);\n  return name;\n}\nfunction type1FontGlyphMapping(properties, builtInEncoding, glyphNames) {\n  const charCodeToGlyphId = Object.create(null);\n  let glyphId, charCode, baseEncoding;\n  const isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);\n  if (properties.isInternalFont) {\n    baseEncoding = builtInEncoding;\n    for (charCode = 0; charCode < baseEncoding.length; charCode++) {\n      glyphId = glyphNames.indexOf(baseEncoding[charCode]);\n      charCodeToGlyphId[charCode] = glyphId >= 0 ? glyphId : 0;\n    }\n  } else if (properties.baseEncodingName) {\n    baseEncoding = getEncoding(properties.baseEncodingName);\n    for (charCode = 0; charCode < baseEncoding.length; charCode++) {\n      glyphId = glyphNames.indexOf(baseEncoding[charCode]);\n      charCodeToGlyphId[charCode] = glyphId >= 0 ? glyphId : 0;\n    }\n  } else if (isSymbolicFont) {\n    for (charCode in builtInEncoding) {\n      charCodeToGlyphId[charCode] = builtInEncoding[charCode];\n    }\n  } else {\n    baseEncoding = StandardEncoding;\n    for (charCode = 0; charCode < baseEncoding.length; charCode++) {\n      glyphId = glyphNames.indexOf(baseEncoding[charCode]);\n      charCodeToGlyphId[charCode] = glyphId >= 0 ? glyphId : 0;\n    }\n  }\n  const differences = properties.differences;\n  let glyphsUnicodeMap;\n  if (differences) {\n    for (charCode in differences) {\n      const glyphName = differences[charCode];\n      glyphId = glyphNames.indexOf(glyphName);\n      if (glyphId === -1) {\n        if (!glyphsUnicodeMap) {\n          glyphsUnicodeMap = getGlyphsUnicode();\n        }\n        const standardGlyphName = recoverGlyphName(glyphName, glyphsUnicodeMap);\n        if (standardGlyphName !== glyphName) {\n          glyphId = glyphNames.indexOf(standardGlyphName);\n        }\n      }\n      charCodeToGlyphId[charCode] = glyphId >= 0 ? glyphId : 0;\n    }\n  }\n  return charCodeToGlyphId;\n}\nfunction normalizeFontName(name) {\n  return name.replaceAll(/[,_]/g, \"-\").replaceAll(/\\s/g, \"\");\n}\n\n;// CONCATENATED MODULE: ./src/core/standard_fonts.js\n\n\nconst getStdFontMap = getLookupTableFactory(function (t) {\n  t[\"Times-Roman\"] = \"Times-Roman\";\n  t.Helvetica = \"Helvetica\";\n  t.Courier = \"Courier\";\n  t.Symbol = \"Symbol\";\n  t[\"Times-Bold\"] = \"Times-Bold\";\n  t[\"Helvetica-Bold\"] = \"Helvetica-Bold\";\n  t[\"Courier-Bold\"] = \"Courier-Bold\";\n  t.ZapfDingbats = \"ZapfDingbats\";\n  t[\"Times-Italic\"] = \"Times-Italic\";\n  t[\"Helvetica-Oblique\"] = \"Helvetica-Oblique\";\n  t[\"Courier-Oblique\"] = \"Courier-Oblique\";\n  t[\"Times-BoldItalic\"] = \"Times-BoldItalic\";\n  t[\"Helvetica-BoldOblique\"] = \"Helvetica-BoldOblique\";\n  t[\"Courier-BoldOblique\"] = \"Courier-BoldOblique\";\n  t.ArialNarrow = \"Helvetica\";\n  t[\"ArialNarrow-Bold\"] = \"Helvetica-Bold\";\n  t[\"ArialNarrow-BoldItalic\"] = \"Helvetica-BoldOblique\";\n  t[\"ArialNarrow-Italic\"] = \"Helvetica-Oblique\";\n  t.ArialBlack = \"Helvetica\";\n  t[\"ArialBlack-Bold\"] = \"Helvetica-Bold\";\n  t[\"ArialBlack-BoldItalic\"] = \"Helvetica-BoldOblique\";\n  t[\"ArialBlack-Italic\"] = \"Helvetica-Oblique\";\n  t[\"Arial-Black\"] = \"Helvetica\";\n  t[\"Arial-Black-Bold\"] = \"Helvetica-Bold\";\n  t[\"Arial-Black-BoldItalic\"] = \"Helvetica-BoldOblique\";\n  t[\"Arial-Black-Italic\"] = \"Helvetica-Oblique\";\n  t.Arial = \"Helvetica\";\n  t[\"Arial-Bold\"] = \"Helvetica-Bold\";\n  t[\"Arial-BoldItalic\"] = \"Helvetica-BoldOblique\";\n  t[\"Arial-Italic\"] = \"Helvetica-Oblique\";\n  t.ArialMT = \"Helvetica\";\n  t[\"Arial-BoldItalicMT\"] = \"Helvetica-BoldOblique\";\n  t[\"Arial-BoldMT\"] = \"Helvetica-Bold\";\n  t[\"Arial-ItalicMT\"] = \"Helvetica-Oblique\";\n  t[\"Arial-BoldItalicMT-BoldItalic\"] = \"Helvetica-BoldOblique\";\n  t[\"Arial-BoldMT-Bold\"] = \"Helvetica-Bold\";\n  t[\"Arial-ItalicMT-Italic\"] = \"Helvetica-Oblique\";\n  t.ArialUnicodeMS = \"Helvetica\";\n  t[\"ArialUnicodeMS-Bold\"] = \"Helvetica-Bold\";\n  t[\"ArialUnicodeMS-BoldItalic\"] = \"Helvetica-BoldOblique\";\n  t[\"ArialUnicodeMS-Italic\"] = \"Helvetica-Oblique\";\n  t[\"Courier-BoldItalic\"] = \"Courier-BoldOblique\";\n  t[\"Courier-Italic\"] = \"Courier-Oblique\";\n  t.CourierNew = \"Courier\";\n  t[\"CourierNew-Bold\"] = \"Courier-Bold\";\n  t[\"CourierNew-BoldItalic\"] = \"Courier-BoldOblique\";\n  t[\"CourierNew-Italic\"] = \"Courier-Oblique\";\n  t[\"CourierNewPS-BoldItalicMT\"] = \"Courier-BoldOblique\";\n  t[\"CourierNewPS-BoldMT\"] = \"Courier-Bold\";\n  t[\"CourierNewPS-ItalicMT\"] = \"Courier-Oblique\";\n  t.CourierNewPSMT = \"Courier\";\n  t[\"Helvetica-BoldItalic\"] = \"Helvetica-BoldOblique\";\n  t[\"Helvetica-Italic\"] = \"Helvetica-Oblique\";\n  t[\"Symbol-Bold\"] = \"Symbol\";\n  t[\"Symbol-BoldItalic\"] = \"Symbol\";\n  t[\"Symbol-Italic\"] = \"Symbol\";\n  t.TimesNewRoman = \"Times-Roman\";\n  t[\"TimesNewRoman-Bold\"] = \"Times-Bold\";\n  t[\"TimesNewRoman-BoldItalic\"] = \"Times-BoldItalic\";\n  t[\"TimesNewRoman-Italic\"] = \"Times-Italic\";\n  t.TimesNewRomanPS = \"Times-Roman\";\n  t[\"TimesNewRomanPS-Bold\"] = \"Times-Bold\";\n  t[\"TimesNewRomanPS-BoldItalic\"] = \"Times-BoldItalic\";\n  t[\"TimesNewRomanPS-BoldItalicMT\"] = \"Times-BoldItalic\";\n  t[\"TimesNewRomanPS-BoldMT\"] = \"Times-Bold\";\n  t[\"TimesNewRomanPS-Italic\"] = \"Times-Italic\";\n  t[\"TimesNewRomanPS-ItalicMT\"] = \"Times-Italic\";\n  t.TimesNewRomanPSMT = \"Times-Roman\";\n  t[\"TimesNewRomanPSMT-Bold\"] = \"Times-Bold\";\n  t[\"TimesNewRomanPSMT-BoldItalic\"] = \"Times-BoldItalic\";\n  t[\"TimesNewRomanPSMT-Italic\"] = \"Times-Italic\";\n});\nconst getFontNameToFileMap = getLookupTableFactory(function (t) {\n  t.Courier = \"FoxitFixed.pfb\";\n  t[\"Courier-Bold\"] = \"FoxitFixedBold.pfb\";\n  t[\"Courier-BoldOblique\"] = \"FoxitFixedBoldItalic.pfb\";\n  t[\"Courier-Oblique\"] = \"FoxitFixedItalic.pfb\";\n  t.Helvetica = \"LiberationSans-Regular.ttf\";\n  t[\"Helvetica-Bold\"] = \"LiberationSans-Bold.ttf\";\n  t[\"Helvetica-BoldOblique\"] = \"LiberationSans-BoldItalic.ttf\";\n  t[\"Helvetica-Oblique\"] = \"LiberationSans-Italic.ttf\";\n  t[\"Times-Roman\"] = \"FoxitSerif.pfb\";\n  t[\"Times-Bold\"] = \"FoxitSerifBold.pfb\";\n  t[\"Times-BoldItalic\"] = \"FoxitSerifBoldItalic.pfb\";\n  t[\"Times-Italic\"] = \"FoxitSerifItalic.pfb\";\n  t.Symbol = \"FoxitSymbol.pfb\";\n  t.ZapfDingbats = \"FoxitDingbats.pfb\";\n  t[\"LiberationSans-Regular\"] = \"LiberationSans-Regular.ttf\";\n  t[\"LiberationSans-Bold\"] = \"LiberationSans-Bold.ttf\";\n  t[\"LiberationSans-Italic\"] = \"LiberationSans-Italic.ttf\";\n  t[\"LiberationSans-BoldItalic\"] = \"LiberationSans-BoldItalic.ttf\";\n});\nconst getNonStdFontMap = getLookupTableFactory(function (t) {\n  t.Calibri = \"Helvetica\";\n  t[\"Calibri-Bold\"] = \"Helvetica-Bold\";\n  t[\"Calibri-BoldItalic\"] = \"Helvetica-BoldOblique\";\n  t[\"Calibri-Italic\"] = \"Helvetica-Oblique\";\n  t.CenturyGothic = \"Helvetica\";\n  t[\"CenturyGothic-Bold\"] = \"Helvetica-Bold\";\n  t[\"CenturyGothic-BoldItalic\"] = \"Helvetica-BoldOblique\";\n  t[\"CenturyGothic-Italic\"] = \"Helvetica-Oblique\";\n  t.ComicSansMS = \"Comic Sans MS\";\n  t[\"ComicSansMS-Bold\"] = \"Comic Sans MS-Bold\";\n  t[\"ComicSansMS-BoldItalic\"] = \"Comic Sans MS-BoldItalic\";\n  t[\"ComicSansMS-Italic\"] = \"Comic Sans MS-Italic\";\n  t.Impact = \"Helvetica\";\n  t[\"ItcSymbol-Bold\"] = \"Helvetica-Bold\";\n  t[\"ItcSymbol-BoldItalic\"] = \"Helvetica-BoldOblique\";\n  t[\"ItcSymbol-Book\"] = \"Helvetica\";\n  t[\"ItcSymbol-BookItalic\"] = \"Helvetica-Oblique\";\n  t[\"ItcSymbol-Medium\"] = \"Helvetica\";\n  t[\"ItcSymbol-MediumItalic\"] = \"Helvetica-Oblique\";\n  t.LucidaConsole = \"Courier\";\n  t[\"LucidaConsole-Bold\"] = \"Courier-Bold\";\n  t[\"LucidaConsole-BoldItalic\"] = \"Courier-BoldOblique\";\n  t[\"LucidaConsole-Italic\"] = \"Courier-Oblique\";\n  t[\"LucidaSans-Demi\"] = \"Helvetica-Bold\";\n  t[\"MS-Gothic\"] = \"MS Gothic\";\n  t[\"MS-Gothic-Bold\"] = \"MS Gothic-Bold\";\n  t[\"MS-Gothic-BoldItalic\"] = \"MS Gothic-BoldItalic\";\n  t[\"MS-Gothic-Italic\"] = \"MS Gothic-Italic\";\n  t[\"MS-Mincho\"] = \"MS Mincho\";\n  t[\"MS-Mincho-Bold\"] = \"MS Mincho-Bold\";\n  t[\"MS-Mincho-BoldItalic\"] = \"MS Mincho-BoldItalic\";\n  t[\"MS-Mincho-Italic\"] = \"MS Mincho-Italic\";\n  t[\"MS-PGothic\"] = \"MS PGothic\";\n  t[\"MS-PGothic-Bold\"] = \"MS PGothic-Bold\";\n  t[\"MS-PGothic-BoldItalic\"] = \"MS PGothic-BoldItalic\";\n  t[\"MS-PGothic-Italic\"] = \"MS PGothic-Italic\";\n  t[\"MS-PMincho\"] = \"MS PMincho\";\n  t[\"MS-PMincho-Bold\"] = \"MS PMincho-Bold\";\n  t[\"MS-PMincho-BoldItalic\"] = \"MS PMincho-BoldItalic\";\n  t[\"MS-PMincho-Italic\"] = \"MS PMincho-Italic\";\n  t.NuptialScript = \"Times-Italic\";\n  t.SegoeUISymbol = \"Helvetica\";\n});\nconst getSerifFonts = getLookupTableFactory(function (t) {\n  t[\"Adobe Jenson\"] = true;\n  t[\"Adobe Text\"] = true;\n  t.Albertus = true;\n  t.Aldus = true;\n  t.Alexandria = true;\n  t.Algerian = true;\n  t[\"American Typewriter\"] = true;\n  t.Antiqua = true;\n  t.Apex = true;\n  t.Arno = true;\n  t.Aster = true;\n  t.Aurora = true;\n  t.Baskerville = true;\n  t.Bell = true;\n  t.Bembo = true;\n  t[\"Bembo Schoolbook\"] = true;\n  t.Benguiat = true;\n  t[\"Berkeley Old Style\"] = true;\n  t[\"Bernhard Modern\"] = true;\n  t[\"Berthold City\"] = true;\n  t.Bodoni = true;\n  t[\"Bauer Bodoni\"] = true;\n  t[\"Book Antiqua\"] = true;\n  t.Bookman = true;\n  t[\"Bordeaux Roman\"] = true;\n  t[\"Californian FB\"] = true;\n  t.Calisto = true;\n  t.Calvert = true;\n  t.Capitals = true;\n  t.Cambria = true;\n  t.Cartier = true;\n  t.Caslon = true;\n  t.Catull = true;\n  t.Centaur = true;\n  t[\"Century Old Style\"] = true;\n  t[\"Century Schoolbook\"] = true;\n  t.Chaparral = true;\n  t[\"Charis SIL\"] = true;\n  t.Cheltenham = true;\n  t[\"Cholla Slab\"] = true;\n  t.Clarendon = true;\n  t.Clearface = true;\n  t.Cochin = true;\n  t.Colonna = true;\n  t[\"Computer Modern\"] = true;\n  t[\"Concrete Roman\"] = true;\n  t.Constantia = true;\n  t[\"Cooper Black\"] = true;\n  t.Corona = true;\n  t.Ecotype = true;\n  t.Egyptienne = true;\n  t.Elephant = true;\n  t.Excelsior = true;\n  t.Fairfield = true;\n  t[\"FF Scala\"] = true;\n  t.Folkard = true;\n  t.Footlight = true;\n  t.FreeSerif = true;\n  t[\"Friz Quadrata\"] = true;\n  t.Garamond = true;\n  t.Gentium = true;\n  t.Georgia = true;\n  t.Gloucester = true;\n  t[\"Goudy Old Style\"] = true;\n  t[\"Goudy Schoolbook\"] = true;\n  t[\"Goudy Pro Font\"] = true;\n  t.Granjon = true;\n  t[\"Guardian Egyptian\"] = true;\n  t.Heather = true;\n  t.Hercules = true;\n  t[\"High Tower Text\"] = true;\n  t.Hiroshige = true;\n  t[\"Hoefler Text\"] = true;\n  t[\"Humana Serif\"] = true;\n  t.Imprint = true;\n  t[\"Ionic No. 5\"] = true;\n  t.Janson = true;\n  t.Joanna = true;\n  t.Korinna = true;\n  t.Lexicon = true;\n  t.LiberationSerif = true;\n  t[\"Liberation Serif\"] = true;\n  t[\"Linux Libertine\"] = true;\n  t.Literaturnaya = true;\n  t.Lucida = true;\n  t[\"Lucida Bright\"] = true;\n  t.Melior = true;\n  t.Memphis = true;\n  t.Miller = true;\n  t.Minion = true;\n  t.Modern = true;\n  t[\"Mona Lisa\"] = true;\n  t[\"Mrs Eaves\"] = true;\n  t[\"MS Serif\"] = true;\n  t[\"Museo Slab\"] = true;\n  t[\"New York\"] = true;\n  t[\"Nimbus Roman\"] = true;\n  t[\"NPS Rawlinson Roadway\"] = true;\n  t.NuptialScript = true;\n  t.Palatino = true;\n  t.Perpetua = true;\n  t.Plantin = true;\n  t[\"Plantin Schoolbook\"] = true;\n  t.Playbill = true;\n  t[\"Poor Richard\"] = true;\n  t[\"Rawlinson Roadway\"] = true;\n  t.Renault = true;\n  t.Requiem = true;\n  t.Rockwell = true;\n  t.Roman = true;\n  t[\"Rotis Serif\"] = true;\n  t.Sabon = true;\n  t.Scala = true;\n  t.Seagull = true;\n  t.Sistina = true;\n  t.Souvenir = true;\n  t.STIX = true;\n  t[\"Stone Informal\"] = true;\n  t[\"Stone Serif\"] = true;\n  t.Sylfaen = true;\n  t.Times = true;\n  t.Trajan = true;\n  t[\"Trinité\"] = true;\n  t[\"Trump Mediaeval\"] = true;\n  t.Utopia = true;\n  t[\"Vale Type\"] = true;\n  t[\"Bitstream Vera\"] = true;\n  t[\"Vera Serif\"] = true;\n  t.Versailles = true;\n  t.Wanted = true;\n  t.Weiss = true;\n  t[\"Wide Latin\"] = true;\n  t.Windsor = true;\n  t.XITS = true;\n});\nconst getSymbolsFonts = getLookupTableFactory(function (t) {\n  t.Dingbats = true;\n  t.Symbol = true;\n  t.ZapfDingbats = true;\n  t.Wingdings = true;\n  t[\"Wingdings-Bold\"] = true;\n  t[\"Wingdings-Regular\"] = true;\n});\nconst getGlyphMapForStandardFonts = getLookupTableFactory(function (t) {\n  t[2] = 10;\n  t[3] = 32;\n  t[4] = 33;\n  t[5] = 34;\n  t[6] = 35;\n  t[7] = 36;\n  t[8] = 37;\n  t[9] = 38;\n  t[10] = 39;\n  t[11] = 40;\n  t[12] = 41;\n  t[13] = 42;\n  t[14] = 43;\n  t[15] = 44;\n  t[16] = 45;\n  t[17] = 46;\n  t[18] = 47;\n  t[19] = 48;\n  t[20] = 49;\n  t[21] = 50;\n  t[22] = 51;\n  t[23] = 52;\n  t[24] = 53;\n  t[25] = 54;\n  t[26] = 55;\n  t[27] = 56;\n  t[28] = 57;\n  t[29] = 58;\n  t[30] = 894;\n  t[31] = 60;\n  t[32] = 61;\n  t[33] = 62;\n  t[34] = 63;\n  t[35] = 64;\n  t[36] = 65;\n  t[37] = 66;\n  t[38] = 67;\n  t[39] = 68;\n  t[40] = 69;\n  t[41] = 70;\n  t[42] = 71;\n  t[43] = 72;\n  t[44] = 73;\n  t[45] = 74;\n  t[46] = 75;\n  t[47] = 76;\n  t[48] = 77;\n  t[49] = 78;\n  t[50] = 79;\n  t[51] = 80;\n  t[52] = 81;\n  t[53] = 82;\n  t[54] = 83;\n  t[55] = 84;\n  t[56] = 85;\n  t[57] = 86;\n  t[58] = 87;\n  t[59] = 88;\n  t[60] = 89;\n  t[61] = 90;\n  t[62] = 91;\n  t[63] = 92;\n  t[64] = 93;\n  t[65] = 94;\n  t[66] = 95;\n  t[67] = 96;\n  t[68] = 97;\n  t[69] = 98;\n  t[70] = 99;\n  t[71] = 100;\n  t[72] = 101;\n  t[73] = 102;\n  t[74] = 103;\n  t[75] = 104;\n  t[76] = 105;\n  t[77] = 106;\n  t[78] = 107;\n  t[79] = 108;\n  t[80] = 109;\n  t[81] = 110;\n  t[82] = 111;\n  t[83] = 112;\n  t[84] = 113;\n  t[85] = 114;\n  t[86] = 115;\n  t[87] = 116;\n  t[88] = 117;\n  t[89] = 118;\n  t[90] = 119;\n  t[91] = 120;\n  t[92] = 121;\n  t[93] = 122;\n  t[94] = 123;\n  t[95] = 124;\n  t[96] = 125;\n  t[97] = 126;\n  t[98] = 196;\n  t[99] = 197;\n  t[100] = 199;\n  t[101] = 201;\n  t[102] = 209;\n  t[103] = 214;\n  t[104] = 220;\n  t[105] = 225;\n  t[106] = 224;\n  t[107] = 226;\n  t[108] = 228;\n  t[109] = 227;\n  t[110] = 229;\n  t[111] = 231;\n  t[112] = 233;\n  t[113] = 232;\n  t[114] = 234;\n  t[115] = 235;\n  t[116] = 237;\n  t[117] = 236;\n  t[118] = 238;\n  t[119] = 239;\n  t[120] = 241;\n  t[121] = 243;\n  t[122] = 242;\n  t[123] = 244;\n  t[124] = 246;\n  t[125] = 245;\n  t[126] = 250;\n  t[127] = 249;\n  t[128] = 251;\n  t[129] = 252;\n  t[130] = 8224;\n  t[131] = 176;\n  t[132] = 162;\n  t[133] = 163;\n  t[134] = 167;\n  t[135] = 8226;\n  t[136] = 182;\n  t[137] = 223;\n  t[138] = 174;\n  t[139] = 169;\n  t[140] = 8482;\n  t[141] = 180;\n  t[142] = 168;\n  t[143] = 8800;\n  t[144] = 198;\n  t[145] = 216;\n  t[146] = 8734;\n  t[147] = 177;\n  t[148] = 8804;\n  t[149] = 8805;\n  t[150] = 165;\n  t[151] = 181;\n  t[152] = 8706;\n  t[153] = 8721;\n  t[154] = 8719;\n  t[156] = 8747;\n  t[157] = 170;\n  t[158] = 186;\n  t[159] = 8486;\n  t[160] = 230;\n  t[161] = 248;\n  t[162] = 191;\n  t[163] = 161;\n  t[164] = 172;\n  t[165] = 8730;\n  t[166] = 402;\n  t[167] = 8776;\n  t[168] = 8710;\n  t[169] = 171;\n  t[170] = 187;\n  t[171] = 8230;\n  t[179] = 8220;\n  t[180] = 8221;\n  t[181] = 8216;\n  t[182] = 8217;\n  t[200] = 193;\n  t[203] = 205;\n  t[207] = 211;\n  t[210] = 218;\n  t[223] = 711;\n  t[224] = 321;\n  t[225] = 322;\n  t[226] = 352;\n  t[227] = 353;\n  t[228] = 381;\n  t[229] = 382;\n  t[233] = 221;\n  t[234] = 253;\n  t[252] = 263;\n  t[253] = 268;\n  t[254] = 269;\n  t[258] = 258;\n  t[260] = 260;\n  t[261] = 261;\n  t[265] = 280;\n  t[266] = 281;\n  t[267] = 282;\n  t[268] = 283;\n  t[269] = 313;\n  t[275] = 323;\n  t[276] = 324;\n  t[278] = 328;\n  t[283] = 344;\n  t[284] = 345;\n  t[285] = 346;\n  t[286] = 347;\n  t[292] = 367;\n  t[295] = 377;\n  t[296] = 378;\n  t[298] = 380;\n  t[305] = 963;\n  t[306] = 964;\n  t[307] = 966;\n  t[308] = 8215;\n  t[309] = 8252;\n  t[310] = 8319;\n  t[311] = 8359;\n  t[312] = 8592;\n  t[313] = 8593;\n  t[337] = 9552;\n  t[493] = 1039;\n  t[494] = 1040;\n  t[672] = 1488;\n  t[673] = 1489;\n  t[674] = 1490;\n  t[675] = 1491;\n  t[676] = 1492;\n  t[677] = 1493;\n  t[678] = 1494;\n  t[679] = 1495;\n  t[680] = 1496;\n  t[681] = 1497;\n  t[682] = 1498;\n  t[683] = 1499;\n  t[684] = 1500;\n  t[685] = 1501;\n  t[686] = 1502;\n  t[687] = 1503;\n  t[688] = 1504;\n  t[689] = 1505;\n  t[690] = 1506;\n  t[691] = 1507;\n  t[692] = 1508;\n  t[693] = 1509;\n  t[694] = 1510;\n  t[695] = 1511;\n  t[696] = 1512;\n  t[697] = 1513;\n  t[698] = 1514;\n  t[705] = 1524;\n  t[706] = 8362;\n  t[710] = 64288;\n  t[711] = 64298;\n  t[759] = 1617;\n  t[761] = 1776;\n  t[763] = 1778;\n  t[775] = 1652;\n  t[777] = 1764;\n  t[778] = 1780;\n  t[779] = 1781;\n  t[780] = 1782;\n  t[782] = 771;\n  t[783] = 64726;\n  t[786] = 8363;\n  t[788] = 8532;\n  t[790] = 768;\n  t[791] = 769;\n  t[792] = 768;\n  t[795] = 803;\n  t[797] = 64336;\n  t[798] = 64337;\n  t[799] = 64342;\n  t[800] = 64343;\n  t[801] = 64344;\n  t[802] = 64345;\n  t[803] = 64362;\n  t[804] = 64363;\n  t[805] = 64364;\n  t[2424] = 7821;\n  t[2425] = 7822;\n  t[2426] = 7823;\n  t[2427] = 7824;\n  t[2428] = 7825;\n  t[2429] = 7826;\n  t[2430] = 7827;\n  t[2433] = 7682;\n  t[2678] = 8045;\n  t[2679] = 8046;\n  t[2830] = 1552;\n  t[2838] = 686;\n  t[2840] = 751;\n  t[2842] = 753;\n  t[2843] = 754;\n  t[2844] = 755;\n  t[2846] = 757;\n  t[2856] = 767;\n  t[2857] = 848;\n  t[2858] = 849;\n  t[2862] = 853;\n  t[2863] = 854;\n  t[2864] = 855;\n  t[2865] = 861;\n  t[2866] = 862;\n  t[2906] = 7460;\n  t[2908] = 7462;\n  t[2909] = 7463;\n  t[2910] = 7464;\n  t[2912] = 7466;\n  t[2913] = 7467;\n  t[2914] = 7468;\n  t[2916] = 7470;\n  t[2917] = 7471;\n  t[2918] = 7472;\n  t[2920] = 7474;\n  t[2921] = 7475;\n  t[2922] = 7476;\n  t[2924] = 7478;\n  t[2925] = 7479;\n  t[2926] = 7480;\n  t[2928] = 7482;\n  t[2929] = 7483;\n  t[2930] = 7484;\n  t[2932] = 7486;\n  t[2933] = 7487;\n  t[2934] = 7488;\n  t[2936] = 7490;\n  t[2937] = 7491;\n  t[2938] = 7492;\n  t[2940] = 7494;\n  t[2941] = 7495;\n  t[2942] = 7496;\n  t[2944] = 7498;\n  t[2946] = 7500;\n  t[2948] = 7502;\n  t[2950] = 7504;\n  t[2951] = 7505;\n  t[2952] = 7506;\n  t[2954] = 7508;\n  t[2955] = 7509;\n  t[2956] = 7510;\n  t[2958] = 7512;\n  t[2959] = 7513;\n  t[2960] = 7514;\n  t[2962] = 7516;\n  t[2963] = 7517;\n  t[2964] = 7518;\n  t[2966] = 7520;\n  t[2967] = 7521;\n  t[2968] = 7522;\n  t[2970] = 7524;\n  t[2971] = 7525;\n  t[2972] = 7526;\n  t[2974] = 7528;\n  t[2975] = 7529;\n  t[2976] = 7530;\n  t[2978] = 1537;\n  t[2979] = 1538;\n  t[2980] = 1539;\n  t[2982] = 1549;\n  t[2983] = 1551;\n  t[2984] = 1552;\n  t[2986] = 1554;\n  t[2987] = 1555;\n  t[2988] = 1556;\n  t[2990] = 1623;\n  t[2991] = 1624;\n  t[2995] = 1775;\n  t[2999] = 1791;\n  t[3002] = 64290;\n  t[3003] = 64291;\n  t[3004] = 64292;\n  t[3006] = 64294;\n  t[3007] = 64295;\n  t[3008] = 64296;\n  t[3011] = 1900;\n  t[3014] = 8223;\n  t[3015] = 8244;\n  t[3017] = 7532;\n  t[3018] = 7533;\n  t[3019] = 7534;\n  t[3075] = 7590;\n  t[3076] = 7591;\n  t[3079] = 7594;\n  t[3080] = 7595;\n  t[3083] = 7598;\n  t[3084] = 7599;\n  t[3087] = 7602;\n  t[3088] = 7603;\n  t[3091] = 7606;\n  t[3092] = 7607;\n  t[3095] = 7610;\n  t[3096] = 7611;\n  t[3099] = 7614;\n  t[3100] = 7615;\n  t[3103] = 7618;\n  t[3104] = 7619;\n  t[3107] = 8337;\n  t[3108] = 8338;\n  t[3116] = 1884;\n  t[3119] = 1885;\n  t[3120] = 1885;\n  t[3123] = 1886;\n  t[3124] = 1886;\n  t[3127] = 1887;\n  t[3128] = 1887;\n  t[3131] = 1888;\n  t[3132] = 1888;\n  t[3135] = 1889;\n  t[3136] = 1889;\n  t[3139] = 1890;\n  t[3140] = 1890;\n  t[3143] = 1891;\n  t[3144] = 1891;\n  t[3147] = 1892;\n  t[3148] = 1892;\n  t[3153] = 580;\n  t[3154] = 581;\n  t[3157] = 584;\n  t[3158] = 585;\n  t[3161] = 588;\n  t[3162] = 589;\n  t[3165] = 891;\n  t[3166] = 892;\n  t[3169] = 1274;\n  t[3170] = 1275;\n  t[3173] = 1278;\n  t[3174] = 1279;\n  t[3181] = 7622;\n  t[3182] = 7623;\n  t[3282] = 11799;\n  t[3316] = 578;\n  t[3379] = 42785;\n  t[3393] = 1159;\n  t[3416] = 8377;\n});\nconst getSupplementalGlyphMapForArialBlack = getLookupTableFactory(function (t) {\n  t[227] = 322;\n  t[264] = 261;\n  t[291] = 346;\n});\nconst getSupplementalGlyphMapForCalibri = getLookupTableFactory(function (t) {\n  t[1] = 32;\n  t[4] = 65;\n  t[5] = 192;\n  t[6] = 193;\n  t[9] = 196;\n  t[17] = 66;\n  t[18] = 67;\n  t[21] = 268;\n  t[24] = 68;\n  t[28] = 69;\n  t[29] = 200;\n  t[30] = 201;\n  t[32] = 282;\n  t[38] = 70;\n  t[39] = 71;\n  t[44] = 72;\n  t[47] = 73;\n  t[48] = 204;\n  t[49] = 205;\n  t[58] = 74;\n  t[60] = 75;\n  t[62] = 76;\n  t[68] = 77;\n  t[69] = 78;\n  t[75] = 79;\n  t[76] = 210;\n  t[80] = 214;\n  t[87] = 80;\n  t[89] = 81;\n  t[90] = 82;\n  t[92] = 344;\n  t[94] = 83;\n  t[97] = 352;\n  t[100] = 84;\n  t[104] = 85;\n  t[109] = 220;\n  t[115] = 86;\n  t[116] = 87;\n  t[121] = 88;\n  t[122] = 89;\n  t[124] = 221;\n  t[127] = 90;\n  t[129] = 381;\n  t[258] = 97;\n  t[259] = 224;\n  t[260] = 225;\n  t[263] = 228;\n  t[268] = 261;\n  t[271] = 98;\n  t[272] = 99;\n  t[273] = 263;\n  t[275] = 269;\n  t[282] = 100;\n  t[286] = 101;\n  t[287] = 232;\n  t[288] = 233;\n  t[290] = 283;\n  t[295] = 281;\n  t[296] = 102;\n  t[336] = 103;\n  t[346] = 104;\n  t[349] = 105;\n  t[350] = 236;\n  t[351] = 237;\n  t[361] = 106;\n  t[364] = 107;\n  t[367] = 108;\n  t[371] = 322;\n  t[373] = 109;\n  t[374] = 110;\n  t[381] = 111;\n  t[382] = 242;\n  t[383] = 243;\n  t[386] = 246;\n  t[393] = 112;\n  t[395] = 113;\n  t[396] = 114;\n  t[398] = 345;\n  t[400] = 115;\n  t[401] = 347;\n  t[403] = 353;\n  t[410] = 116;\n  t[437] = 117;\n  t[442] = 252;\n  t[448] = 118;\n  t[449] = 119;\n  t[454] = 120;\n  t[455] = 121;\n  t[457] = 253;\n  t[460] = 122;\n  t[462] = 382;\n  t[463] = 380;\n  t[853] = 44;\n  t[855] = 58;\n  t[856] = 46;\n  t[876] = 47;\n  t[878] = 45;\n  t[882] = 45;\n  t[894] = 40;\n  t[895] = 41;\n  t[896] = 91;\n  t[897] = 93;\n  t[923] = 64;\n  t[1004] = 48;\n  t[1005] = 49;\n  t[1006] = 50;\n  t[1007] = 51;\n  t[1008] = 52;\n  t[1009] = 53;\n  t[1010] = 54;\n  t[1011] = 55;\n  t[1012] = 56;\n  t[1013] = 57;\n  t[1081] = 37;\n  t[1085] = 43;\n  t[1086] = 45;\n});\nfunction getStandardFontName(name) {\n  const fontName = normalizeFontName(name);\n  const stdFontMap = getStdFontMap();\n  return stdFontMap[fontName];\n}\nfunction isKnownFontName(name) {\n  const fontName = normalizeFontName(name);\n  return !!(getStdFontMap()[fontName] || getNonStdFontMap()[fontName] || getSerifFonts()[fontName] || getSymbolsFonts()[fontName]);\n}\n\n;// CONCATENATED MODULE: ./src/core/to_unicode_map.js\n\nclass ToUnicodeMap {\n  constructor(cmap = []) {\n    this._map = cmap;\n  }\n  get length() {\n    return this._map.length;\n  }\n  forEach(callback) {\n    for (const charCode in this._map) {\n      callback(charCode, this._map[charCode].charCodeAt(0));\n    }\n  }\n  has(i) {\n    return this._map[i] !== undefined;\n  }\n  get(i) {\n    return this._map[i];\n  }\n  charCodeOf(value) {\n    const map = this._map;\n    if (map.length <= 0x10000) {\n      return map.indexOf(value);\n    }\n    for (const charCode in map) {\n      if (map[charCode] === value) {\n        return charCode | 0;\n      }\n    }\n    return -1;\n  }\n  amend(map) {\n    for (const charCode in map) {\n      this._map[charCode] = map[charCode];\n    }\n  }\n}\nclass IdentityToUnicodeMap {\n  constructor(firstChar, lastChar) {\n    this.firstChar = firstChar;\n    this.lastChar = lastChar;\n  }\n  get length() {\n    return this.lastChar + 1 - this.firstChar;\n  }\n  forEach(callback) {\n    for (let i = this.firstChar, ii = this.lastChar; i <= ii; i++) {\n      callback(i, i);\n    }\n  }\n  has(i) {\n    return this.firstChar <= i && i <= this.lastChar;\n  }\n  get(i) {\n    if (this.firstChar <= i && i <= this.lastChar) {\n      return String.fromCharCode(i);\n    }\n    return undefined;\n  }\n  charCodeOf(v) {\n    return Number.isInteger(v) && v >= this.firstChar && v <= this.lastChar ? v : -1;\n  }\n  amend(map) {\n    unreachable(\"Should not call amend()\");\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/cff_font.js\n\n\n\nclass CFFFont {\n  constructor(file, properties) {\n    this.properties = properties;\n    const parser = new CFFParser(file, properties, SEAC_ANALYSIS_ENABLED);\n    this.cff = parser.parse();\n    this.cff.duplicateFirstGlyph();\n    const compiler = new CFFCompiler(this.cff);\n    this.seacs = this.cff.seacs;\n    try {\n      this.data = compiler.compile();\n    } catch {\n      warn(\"Failed to compile font \" + properties.loadedName);\n      this.data = file;\n    }\n    this._createBuiltInEncoding();\n  }\n  get numGlyphs() {\n    return this.cff.charStrings.count;\n  }\n  getCharset() {\n    return this.cff.charset.charset;\n  }\n  getGlyphMapping() {\n    const cff = this.cff;\n    const properties = this.properties;\n    const {\n      cidToGidMap,\n      cMap\n    } = properties;\n    const charsets = cff.charset.charset;\n    let charCodeToGlyphId;\n    let glyphId;\n    if (properties.composite) {\n      let invCidToGidMap;\n      if (cidToGidMap?.length > 0) {\n        invCidToGidMap = Object.create(null);\n        for (let i = 0, ii = cidToGidMap.length; i < ii; i++) {\n          const gid = cidToGidMap[i];\n          if (gid !== undefined) {\n            invCidToGidMap[gid] = i;\n          }\n        }\n      }\n      charCodeToGlyphId = Object.create(null);\n      let charCode;\n      if (cff.isCIDFont) {\n        for (glyphId = 0; glyphId < charsets.length; glyphId++) {\n          const cid = charsets[glyphId];\n          charCode = cMap.charCodeOf(cid);\n          if (invCidToGidMap?.[charCode] !== undefined) {\n            charCode = invCidToGidMap[charCode];\n          }\n          charCodeToGlyphId[charCode] = glyphId;\n        }\n      } else {\n        for (glyphId = 0; glyphId < cff.charStrings.count; glyphId++) {\n          charCode = cMap.charCodeOf(glyphId);\n          charCodeToGlyphId[charCode] = glyphId;\n        }\n      }\n      return charCodeToGlyphId;\n    }\n    let encoding = cff.encoding ? cff.encoding.encoding : null;\n    if (properties.isInternalFont) {\n      encoding = properties.defaultEncoding;\n    }\n    charCodeToGlyphId = type1FontGlyphMapping(properties, encoding, charsets);\n    return charCodeToGlyphId;\n  }\n  hasGlyphId(id) {\n    return this.cff.hasGlyphId(id);\n  }\n  _createBuiltInEncoding() {\n    const {\n      charset,\n      encoding\n    } = this.cff;\n    if (!charset || !encoding) {\n      return;\n    }\n    const charsets = charset.charset,\n      encodings = encoding.encoding;\n    const map = [];\n    for (const charCode in encodings) {\n      const glyphId = encodings[charCode];\n      if (glyphId >= 0) {\n        const glyphName = charsets[glyphId];\n        if (glyphName) {\n          map[charCode] = glyphName;\n        }\n      }\n    }\n    if (map.length > 0) {\n      this.properties.builtInEncoding = map;\n    }\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/font_renderer.js\n\n\n\n\n\n\nfunction getUint32(data, offset) {\n  return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;\n}\nfunction getUint16(data, offset) {\n  return data[offset] << 8 | data[offset + 1];\n}\nfunction getInt16(data, offset) {\n  return (data[offset] << 24 | data[offset + 1] << 16) >> 16;\n}\nfunction getInt8(data, offset) {\n  return data[offset] << 24 >> 24;\n}\nfunction getFloat214(data, offset) {\n  return getInt16(data, offset) / 16384;\n}\nfunction getSubroutineBias(subrs) {\n  const numSubrs = subrs.length;\n  let bias = 32768;\n  if (numSubrs < 1240) {\n    bias = 107;\n  } else if (numSubrs < 33900) {\n    bias = 1131;\n  }\n  return bias;\n}\nfunction parseCmap(data, start, end) {\n  const offset = getUint16(data, start + 2) === 1 ? getUint32(data, start + 8) : getUint32(data, start + 16);\n  const format = getUint16(data, start + offset);\n  let ranges, p, i;\n  if (format === 4) {\n    getUint16(data, start + offset + 2);\n    const segCount = getUint16(data, start + offset + 6) >> 1;\n    p = start + offset + 14;\n    ranges = [];\n    for (i = 0; i < segCount; i++, p += 2) {\n      ranges[i] = {\n        end: getUint16(data, p)\n      };\n    }\n    p += 2;\n    for (i = 0; i < segCount; i++, p += 2) {\n      ranges[i].start = getUint16(data, p);\n    }\n    for (i = 0; i < segCount; i++, p += 2) {\n      ranges[i].idDelta = getUint16(data, p);\n    }\n    for (i = 0; i < segCount; i++, p += 2) {\n      let idOffset = getUint16(data, p);\n      if (idOffset === 0) {\n        continue;\n      }\n      ranges[i].ids = [];\n      for (let j = 0, jj = ranges[i].end - ranges[i].start + 1; j < jj; j++) {\n        ranges[i].ids[j] = getUint16(data, p + idOffset);\n        idOffset += 2;\n      }\n    }\n    return ranges;\n  } else if (format === 12) {\n    const groups = getUint32(data, start + offset + 12);\n    p = start + offset + 16;\n    ranges = [];\n    for (i = 0; i < groups; i++) {\n      start = getUint32(data, p);\n      ranges.push({\n        start,\n        end: getUint32(data, p + 4),\n        idDelta: getUint32(data, p + 8) - start\n      });\n      p += 12;\n    }\n    return ranges;\n  }\n  throw new FormatError(`unsupported cmap: ${format}`);\n}\nfunction parseCff(data, start, end, seacAnalysisEnabled) {\n  const properties = {};\n  const parser = new CFFParser(new Stream(data, start, end - start), properties, seacAnalysisEnabled);\n  const cff = parser.parse();\n  return {\n    glyphs: cff.charStrings.objects,\n    subrs: cff.topDict.privateDict?.subrsIndex?.objects,\n    gsubrs: cff.globalSubrIndex?.objects,\n    isCFFCIDFont: cff.isCIDFont,\n    fdSelect: cff.fdSelect,\n    fdArray: cff.fdArray\n  };\n}\nfunction parseGlyfTable(glyf, loca, isGlyphLocationsLong) {\n  let itemSize, itemDecode;\n  if (isGlyphLocationsLong) {\n    itemSize = 4;\n    itemDecode = getUint32;\n  } else {\n    itemSize = 2;\n    itemDecode = (data, offset) => 2 * getUint16(data, offset);\n  }\n  const glyphs = [];\n  let startOffset = itemDecode(loca, 0);\n  for (let j = itemSize; j < loca.length; j += itemSize) {\n    const endOffset = itemDecode(loca, j);\n    glyphs.push(glyf.subarray(startOffset, endOffset));\n    startOffset = endOffset;\n  }\n  return glyphs;\n}\nfunction lookupCmap(ranges, unicode) {\n  const code = unicode.codePointAt(0);\n  let gid = 0,\n    l = 0,\n    r = ranges.length - 1;\n  while (l < r) {\n    const c = l + r + 1 >> 1;\n    if (code < ranges[c].start) {\n      r = c - 1;\n    } else {\n      l = c;\n    }\n  }\n  if (ranges[l].start <= code && code <= ranges[l].end) {\n    gid = ranges[l].idDelta + (ranges[l].ids ? ranges[l].ids[code - ranges[l].start] : code) & 0xffff;\n  }\n  return {\n    charCode: code,\n    glyphId: gid\n  };\n}\nfunction compileGlyf(code, cmds, font) {\n  function moveTo(x, y) {\n    cmds.add(FontRenderOps.MOVE_TO, [x, y]);\n  }\n  function lineTo(x, y) {\n    cmds.add(FontRenderOps.LINE_TO, [x, y]);\n  }\n  function quadraticCurveTo(xa, ya, x, y) {\n    cmds.add(FontRenderOps.QUADRATIC_CURVE_TO, [xa, ya, x, y]);\n  }\n  let i = 0;\n  const numberOfContours = getInt16(code, i);\n  let flags;\n  let x = 0,\n    y = 0;\n  i += 10;\n  if (numberOfContours < 0) {\n    do {\n      flags = getUint16(code, i);\n      const glyphIndex = getUint16(code, i + 2);\n      i += 4;\n      let arg1, arg2;\n      if (flags & 0x01) {\n        if (flags & 0x02) {\n          arg1 = getInt16(code, i);\n          arg2 = getInt16(code, i + 2);\n        } else {\n          arg1 = getUint16(code, i);\n          arg2 = getUint16(code, i + 2);\n        }\n        i += 4;\n      } else if (flags & 0x02) {\n        arg1 = getInt8(code, i++);\n        arg2 = getInt8(code, i++);\n      } else {\n        arg1 = code[i++];\n        arg2 = code[i++];\n      }\n      if (flags & 0x02) {\n        x = arg1;\n        y = arg2;\n      } else {\n        x = 0;\n        y = 0;\n      }\n      let scaleX = 1,\n        scaleY = 1,\n        scale01 = 0,\n        scale10 = 0;\n      if (flags & 0x08) {\n        scaleX = scaleY = getFloat214(code, i);\n        i += 2;\n      } else if (flags & 0x40) {\n        scaleX = getFloat214(code, i);\n        scaleY = getFloat214(code, i + 2);\n        i += 4;\n      } else if (flags & 0x80) {\n        scaleX = getFloat214(code, i);\n        scale01 = getFloat214(code, i + 2);\n        scale10 = getFloat214(code, i + 4);\n        scaleY = getFloat214(code, i + 6);\n        i += 8;\n      }\n      const subglyph = font.glyphs[glyphIndex];\n      if (subglyph) {\n        cmds.add(FontRenderOps.SAVE);\n        cmds.add(FontRenderOps.TRANSFORM, [scaleX, scale01, scale10, scaleY, x, y]);\n        if (!(flags & 0x02)) {}\n        compileGlyf(subglyph, cmds, font);\n        cmds.add(FontRenderOps.RESTORE);\n      }\n    } while (flags & 0x20);\n  } else {\n    const endPtsOfContours = [];\n    let j, jj;\n    for (j = 0; j < numberOfContours; j++) {\n      endPtsOfContours.push(getUint16(code, i));\n      i += 2;\n    }\n    const instructionLength = getUint16(code, i);\n    i += 2 + instructionLength;\n    const numberOfPoints = endPtsOfContours.at(-1) + 1;\n    const points = [];\n    while (points.length < numberOfPoints) {\n      flags = code[i++];\n      let repeat = 1;\n      if (flags & 0x08) {\n        repeat += code[i++];\n      }\n      while (repeat-- > 0) {\n        points.push({\n          flags\n        });\n      }\n    }\n    for (j = 0; j < numberOfPoints; j++) {\n      switch (points[j].flags & 0x12) {\n        case 0x00:\n          x += getInt16(code, i);\n          i += 2;\n          break;\n        case 0x02:\n          x -= code[i++];\n          break;\n        case 0x12:\n          x += code[i++];\n          break;\n      }\n      points[j].x = x;\n    }\n    for (j = 0; j < numberOfPoints; j++) {\n      switch (points[j].flags & 0x24) {\n        case 0x00:\n          y += getInt16(code, i);\n          i += 2;\n          break;\n        case 0x04:\n          y -= code[i++];\n          break;\n        case 0x24:\n          y += code[i++];\n          break;\n      }\n      points[j].y = y;\n    }\n    let startPoint = 0;\n    for (i = 0; i < numberOfContours; i++) {\n      const endPoint = endPtsOfContours[i];\n      const contour = points.slice(startPoint, endPoint + 1);\n      if (contour[0].flags & 1) {\n        contour.push(contour[0]);\n      } else if (contour.at(-1).flags & 1) {\n        contour.unshift(contour.at(-1));\n      } else {\n        const p = {\n          flags: 1,\n          x: (contour[0].x + contour.at(-1).x) / 2,\n          y: (contour[0].y + contour.at(-1).y) / 2\n        };\n        contour.unshift(p);\n        contour.push(p);\n      }\n      moveTo(contour[0].x, contour[0].y);\n      for (j = 1, jj = contour.length; j < jj; j++) {\n        if (contour[j].flags & 1) {\n          lineTo(contour[j].x, contour[j].y);\n        } else if (contour[j + 1].flags & 1) {\n          quadraticCurveTo(contour[j].x, contour[j].y, contour[j + 1].x, contour[j + 1].y);\n          j++;\n        } else {\n          quadraticCurveTo(contour[j].x, contour[j].y, (contour[j].x + contour[j + 1].x) / 2, (contour[j].y + contour[j + 1].y) / 2);\n        }\n      }\n      startPoint = endPoint + 1;\n    }\n  }\n}\nfunction compileCharString(charStringCode, cmds, font, glyphId) {\n  function moveTo(x, y) {\n    cmds.add(FontRenderOps.MOVE_TO, [x, y]);\n  }\n  function lineTo(x, y) {\n    cmds.add(FontRenderOps.LINE_TO, [x, y]);\n  }\n  function bezierCurveTo(x1, y1, x2, y2, x, y) {\n    cmds.add(FontRenderOps.BEZIER_CURVE_TO, [x1, y1, x2, y2, x, y]);\n  }\n  const stack = [];\n  let x = 0,\n    y = 0;\n  let stems = 0;\n  function parse(code) {\n    let i = 0;\n    while (i < code.length) {\n      let stackClean = false;\n      let v = code[i++];\n      let xa, xb, ya, yb, y1, y2, y3, n, subrCode;\n      switch (v) {\n        case 1:\n          stems += stack.length >> 1;\n          stackClean = true;\n          break;\n        case 3:\n          stems += stack.length >> 1;\n          stackClean = true;\n          break;\n        case 4:\n          y += stack.pop();\n          moveTo(x, y);\n          stackClean = true;\n          break;\n        case 5:\n          while (stack.length > 0) {\n            x += stack.shift();\n            y += stack.shift();\n            lineTo(x, y);\n          }\n          break;\n        case 6:\n          while (stack.length > 0) {\n            x += stack.shift();\n            lineTo(x, y);\n            if (stack.length === 0) {\n              break;\n            }\n            y += stack.shift();\n            lineTo(x, y);\n          }\n          break;\n        case 7:\n          while (stack.length > 0) {\n            y += stack.shift();\n            lineTo(x, y);\n            if (stack.length === 0) {\n              break;\n            }\n            x += stack.shift();\n            lineTo(x, y);\n          }\n          break;\n        case 8:\n          while (stack.length > 0) {\n            xa = x + stack.shift();\n            ya = y + stack.shift();\n            xb = xa + stack.shift();\n            yb = ya + stack.shift();\n            x = xb + stack.shift();\n            y = yb + stack.shift();\n            bezierCurveTo(xa, ya, xb, yb, x, y);\n          }\n          break;\n        case 10:\n          n = stack.pop();\n          subrCode = null;\n          if (font.isCFFCIDFont) {\n            const fdIndex = font.fdSelect.getFDIndex(glyphId);\n            if (fdIndex >= 0 && fdIndex < font.fdArray.length) {\n              const fontDict = font.fdArray[fdIndex];\n              let subrs;\n              if (fontDict.privateDict?.subrsIndex) {\n                subrs = fontDict.privateDict.subrsIndex.objects;\n              }\n              if (subrs) {\n                n += getSubroutineBias(subrs);\n                subrCode = subrs[n];\n              }\n            } else {\n              warn(\"Invalid fd index for glyph index.\");\n            }\n          } else {\n            subrCode = font.subrs[n + font.subrsBias];\n          }\n          if (subrCode) {\n            parse(subrCode);\n          }\n          break;\n        case 11:\n          return;\n        case 12:\n          v = code[i++];\n          switch (v) {\n            case 34:\n              xa = x + stack.shift();\n              xb = xa + stack.shift();\n              y1 = y + stack.shift();\n              x = xb + stack.shift();\n              bezierCurveTo(xa, y, xb, y1, x, y1);\n              xa = x + stack.shift();\n              xb = xa + stack.shift();\n              x = xb + stack.shift();\n              bezierCurveTo(xa, y1, xb, y, x, y);\n              break;\n            case 35:\n              xa = x + stack.shift();\n              ya = y + stack.shift();\n              xb = xa + stack.shift();\n              yb = ya + stack.shift();\n              x = xb + stack.shift();\n              y = yb + stack.shift();\n              bezierCurveTo(xa, ya, xb, yb, x, y);\n              xa = x + stack.shift();\n              ya = y + stack.shift();\n              xb = xa + stack.shift();\n              yb = ya + stack.shift();\n              x = xb + stack.shift();\n              y = yb + stack.shift();\n              bezierCurveTo(xa, ya, xb, yb, x, y);\n              stack.pop();\n              break;\n            case 36:\n              xa = x + stack.shift();\n              y1 = y + stack.shift();\n              xb = xa + stack.shift();\n              y2 = y1 + stack.shift();\n              x = xb + stack.shift();\n              bezierCurveTo(xa, y1, xb, y2, x, y2);\n              xa = x + stack.shift();\n              xb = xa + stack.shift();\n              y3 = y2 + stack.shift();\n              x = xb + stack.shift();\n              bezierCurveTo(xa, y2, xb, y3, x, y);\n              break;\n            case 37:\n              const x0 = x,\n                y0 = y;\n              xa = x + stack.shift();\n              ya = y + stack.shift();\n              xb = xa + stack.shift();\n              yb = ya + stack.shift();\n              x = xb + stack.shift();\n              y = yb + stack.shift();\n              bezierCurveTo(xa, ya, xb, yb, x, y);\n              xa = x + stack.shift();\n              ya = y + stack.shift();\n              xb = xa + stack.shift();\n              yb = ya + stack.shift();\n              x = xb;\n              y = yb;\n              if (Math.abs(x - x0) > Math.abs(y - y0)) {\n                x += stack.shift();\n              } else {\n                y += stack.shift();\n              }\n              bezierCurveTo(xa, ya, xb, yb, x, y);\n              break;\n            default:\n              throw new FormatError(`unknown operator: 12 ${v}`);\n          }\n          break;\n        case 14:\n          if (stack.length >= 4) {\n            const achar = stack.pop();\n            const bchar = stack.pop();\n            y = stack.pop();\n            x = stack.pop();\n            cmds.add(FontRenderOps.SAVE);\n            cmds.add(FontRenderOps.TRANSLATE, [x, y]);\n            let cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[StandardEncoding[achar]]));\n            compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);\n            cmds.add(FontRenderOps.RESTORE);\n            cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[StandardEncoding[bchar]]));\n            compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);\n          }\n          return;\n        case 18:\n          stems += stack.length >> 1;\n          stackClean = true;\n          break;\n        case 19:\n          stems += stack.length >> 1;\n          i += stems + 7 >> 3;\n          stackClean = true;\n          break;\n        case 20:\n          stems += stack.length >> 1;\n          i += stems + 7 >> 3;\n          stackClean = true;\n          break;\n        case 21:\n          y += stack.pop();\n          x += stack.pop();\n          moveTo(x, y);\n          stackClean = true;\n          break;\n        case 22:\n          x += stack.pop();\n          moveTo(x, y);\n          stackClean = true;\n          break;\n        case 23:\n          stems += stack.length >> 1;\n          stackClean = true;\n          break;\n        case 24:\n          while (stack.length > 2) {\n            xa = x + stack.shift();\n            ya = y + stack.shift();\n            xb = xa + stack.shift();\n            yb = ya + stack.shift();\n            x = xb + stack.shift();\n            y = yb + stack.shift();\n            bezierCurveTo(xa, ya, xb, yb, x, y);\n          }\n          x += stack.shift();\n          y += stack.shift();\n          lineTo(x, y);\n          break;\n        case 25:\n          while (stack.length > 6) {\n            x += stack.shift();\n            y += stack.shift();\n            lineTo(x, y);\n          }\n          xa = x + stack.shift();\n          ya = y + stack.shift();\n          xb = xa + stack.shift();\n          yb = ya + stack.shift();\n          x = xb + stack.shift();\n          y = yb + stack.shift();\n          bezierCurveTo(xa, ya, xb, yb, x, y);\n          break;\n        case 26:\n          if (stack.length % 2) {\n            x += stack.shift();\n          }\n          while (stack.length > 0) {\n            xa = x;\n            ya = y + stack.shift();\n            xb = xa + stack.shift();\n            yb = ya + stack.shift();\n            x = xb;\n            y = yb + stack.shift();\n            bezierCurveTo(xa, ya, xb, yb, x, y);\n          }\n          break;\n        case 27:\n          if (stack.length % 2) {\n            y += stack.shift();\n          }\n          while (stack.length > 0) {\n            xa = x + stack.shift();\n            ya = y;\n            xb = xa + stack.shift();\n            yb = ya + stack.shift();\n            x = xb + stack.shift();\n            y = yb;\n            bezierCurveTo(xa, ya, xb, yb, x, y);\n          }\n          break;\n        case 28:\n          stack.push((code[i] << 24 | code[i + 1] << 16) >> 16);\n          i += 2;\n          break;\n        case 29:\n          n = stack.pop() + font.gsubrsBias;\n          subrCode = font.gsubrs[n];\n          if (subrCode) {\n            parse(subrCode);\n          }\n          break;\n        case 30:\n          while (stack.length > 0) {\n            xa = x;\n            ya = y + stack.shift();\n            xb = xa + stack.shift();\n            yb = ya + stack.shift();\n            x = xb + stack.shift();\n            y = yb + (stack.length === 1 ? stack.shift() : 0);\n            bezierCurveTo(xa, ya, xb, yb, x, y);\n            if (stack.length === 0) {\n              break;\n            }\n            xa = x + stack.shift();\n            ya = y;\n            xb = xa + stack.shift();\n            yb = ya + stack.shift();\n            y = yb + stack.shift();\n            x = xb + (stack.length === 1 ? stack.shift() : 0);\n            bezierCurveTo(xa, ya, xb, yb, x, y);\n          }\n          break;\n        case 31:\n          while (stack.length > 0) {\n            xa = x + stack.shift();\n            ya = y;\n            xb = xa + stack.shift();\n            yb = ya + stack.shift();\n            y = yb + stack.shift();\n            x = xb + (stack.length === 1 ? stack.shift() : 0);\n            bezierCurveTo(xa, ya, xb, yb, x, y);\n            if (stack.length === 0) {\n              break;\n            }\n            xa = x;\n            ya = y + stack.shift();\n            xb = xa + stack.shift();\n            yb = ya + stack.shift();\n            x = xb + stack.shift();\n            y = yb + (stack.length === 1 ? stack.shift() : 0);\n            bezierCurveTo(xa, ya, xb, yb, x, y);\n          }\n          break;\n        default:\n          if (v < 32) {\n            throw new FormatError(`unknown operator: ${v}`);\n          }\n          if (v < 247) {\n            stack.push(v - 139);\n          } else if (v < 251) {\n            stack.push((v - 247) * 256 + code[i++] + 108);\n          } else if (v < 255) {\n            stack.push(-(v - 251) * 256 - code[i++] - 108);\n          } else {\n            stack.push((code[i] << 24 | code[i + 1] << 16 | code[i + 2] << 8 | code[i + 3]) / 65536);\n            i += 4;\n          }\n          break;\n      }\n      if (stackClean) {\n        stack.length = 0;\n      }\n    }\n  }\n  parse(charStringCode);\n}\nconst NOOP = [];\nclass Commands {\n  cmds = [];\n  add(cmd, args) {\n    if (args) {\n      if (!isNumberArray(args, null)) {\n        warn(`Commands.add - \"${cmd}\" has at least one non-number arg: \"${args}\".`);\n        const newArgs = args.map(arg => typeof arg === \"number\" ? arg : 0);\n        this.cmds.push(cmd, ...newArgs);\n      } else {\n        this.cmds.push(cmd, ...args);\n      }\n    } else {\n      this.cmds.push(cmd);\n    }\n  }\n}\nclass CompiledFont {\n  constructor(fontMatrix) {\n    if (this.constructor === CompiledFont) {\n      unreachable(\"Cannot initialize CompiledFont.\");\n    }\n    this.fontMatrix = fontMatrix;\n    this.compiledGlyphs = Object.create(null);\n    this.compiledCharCodeToGlyphId = Object.create(null);\n  }\n  getPathJs(unicode) {\n    const {\n      charCode,\n      glyphId\n    } = lookupCmap(this.cmap, unicode);\n    let fn = this.compiledGlyphs[glyphId],\n      compileEx;\n    if (!fn) {\n      try {\n        fn = this.compileGlyph(this.glyphs[glyphId], glyphId);\n      } catch (ex) {\n        fn = NOOP;\n        compileEx = ex;\n      }\n      this.compiledGlyphs[glyphId] = fn;\n    }\n    this.compiledCharCodeToGlyphId[charCode] ??= glyphId;\n    if (compileEx) {\n      throw compileEx;\n    }\n    return fn;\n  }\n  compileGlyph(code, glyphId) {\n    if (!code || code.length === 0 || code[0] === 14) {\n      return NOOP;\n    }\n    let fontMatrix = this.fontMatrix;\n    if (this.isCFFCIDFont) {\n      const fdIndex = this.fdSelect.getFDIndex(glyphId);\n      if (fdIndex >= 0 && fdIndex < this.fdArray.length) {\n        const fontDict = this.fdArray[fdIndex];\n        fontMatrix = fontDict.getByName(\"FontMatrix\") || FONT_IDENTITY_MATRIX;\n      } else {\n        warn(\"Invalid fd index for glyph index.\");\n      }\n    }\n    const cmds = new Commands();\n    cmds.add(FontRenderOps.SAVE);\n    cmds.add(FontRenderOps.TRANSFORM, fontMatrix.slice());\n    cmds.add(FontRenderOps.SCALE);\n    this.compileGlyphImpl(code, cmds, glyphId);\n    cmds.add(FontRenderOps.RESTORE);\n    return cmds.cmds;\n  }\n  compileGlyphImpl() {\n    unreachable(\"Children classes should implement this.\");\n  }\n  hasBuiltPath(unicode) {\n    const {\n      charCode,\n      glyphId\n    } = lookupCmap(this.cmap, unicode);\n    return this.compiledGlyphs[glyphId] !== undefined && this.compiledCharCodeToGlyphId[charCode] !== undefined;\n  }\n}\nclass TrueTypeCompiled extends CompiledFont {\n  constructor(glyphs, cmap, fontMatrix) {\n    super(fontMatrix || [0.000488, 0, 0, 0.000488, 0, 0]);\n    this.glyphs = glyphs;\n    this.cmap = cmap;\n  }\n  compileGlyphImpl(code, cmds) {\n    compileGlyf(code, cmds, this);\n  }\n}\nclass Type2Compiled extends CompiledFont {\n  constructor(cffInfo, cmap, fontMatrix, glyphNameMap) {\n    super(fontMatrix || [0.001, 0, 0, 0.001, 0, 0]);\n    this.glyphs = cffInfo.glyphs;\n    this.gsubrs = cffInfo.gsubrs || [];\n    this.subrs = cffInfo.subrs || [];\n    this.cmap = cmap;\n    this.glyphNameMap = glyphNameMap || getGlyphsUnicode();\n    this.gsubrsBias = getSubroutineBias(this.gsubrs);\n    this.subrsBias = getSubroutineBias(this.subrs);\n    this.isCFFCIDFont = cffInfo.isCFFCIDFont;\n    this.fdSelect = cffInfo.fdSelect;\n    this.fdArray = cffInfo.fdArray;\n  }\n  compileGlyphImpl(code, cmds, glyphId) {\n    compileCharString(code, cmds, this, glyphId);\n  }\n}\nclass FontRendererFactory {\n  static create(font, seacAnalysisEnabled) {\n    const data = new Uint8Array(font.data);\n    let cmap, glyf, loca, cff, indexToLocFormat, unitsPerEm;\n    const numTables = getUint16(data, 4);\n    for (let i = 0, p = 12; i < numTables; i++, p += 16) {\n      const tag = bytesToString(data.subarray(p, p + 4));\n      const offset = getUint32(data, p + 8);\n      const length = getUint32(data, p + 12);\n      switch (tag) {\n        case \"cmap\":\n          cmap = parseCmap(data, offset, offset + length);\n          break;\n        case \"glyf\":\n          glyf = data.subarray(offset, offset + length);\n          break;\n        case \"loca\":\n          loca = data.subarray(offset, offset + length);\n          break;\n        case \"head\":\n          unitsPerEm = getUint16(data, offset + 18);\n          indexToLocFormat = getUint16(data, offset + 50);\n          break;\n        case \"CFF \":\n          cff = parseCff(data, offset, offset + length, seacAnalysisEnabled);\n          break;\n      }\n    }\n    if (glyf) {\n      const fontMatrix = !unitsPerEm ? font.fontMatrix : [1 / unitsPerEm, 0, 0, 1 / unitsPerEm, 0, 0];\n      return new TrueTypeCompiled(parseGlyfTable(glyf, loca, indexToLocFormat), cmap, fontMatrix);\n    }\n    return new Type2Compiled(cff, cmap, font.fontMatrix, font.glyphNameMap);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/metrics.js\n\nconst getMetrics = getLookupTableFactory(function (t) {\n  t.Courier = 600;\n  t[\"Courier-Bold\"] = 600;\n  t[\"Courier-BoldOblique\"] = 600;\n  t[\"Courier-Oblique\"] = 600;\n  t.Helvetica = getLookupTableFactory(function (t) {\n    t.space = 278;\n    t.exclam = 278;\n    t.quotedbl = 355;\n    t.numbersign = 556;\n    t.dollar = 556;\n    t.percent = 889;\n    t.ampersand = 667;\n    t.quoteright = 222;\n    t.parenleft = 333;\n    t.parenright = 333;\n    t.asterisk = 389;\n    t.plus = 584;\n    t.comma = 278;\n    t.hyphen = 333;\n    t.period = 278;\n    t.slash = 278;\n    t.zero = 556;\n    t.one = 556;\n    t.two = 556;\n    t.three = 556;\n    t.four = 556;\n    t.five = 556;\n    t.six = 556;\n    t.seven = 556;\n    t.eight = 556;\n    t.nine = 556;\n    t.colon = 278;\n    t.semicolon = 278;\n    t.less = 584;\n    t.equal = 584;\n    t.greater = 584;\n    t.question = 556;\n    t.at = 1015;\n    t.A = 667;\n    t.B = 667;\n    t.C = 722;\n    t.D = 722;\n    t.E = 667;\n    t.F = 611;\n    t.G = 778;\n    t.H = 722;\n    t.I = 278;\n    t.J = 500;\n    t.K = 667;\n    t.L = 556;\n    t.M = 833;\n    t.N = 722;\n    t.O = 778;\n    t.P = 667;\n    t.Q = 778;\n    t.R = 722;\n    t.S = 667;\n    t.T = 611;\n    t.U = 722;\n    t.V = 667;\n    t.W = 944;\n    t.X = 667;\n    t.Y = 667;\n    t.Z = 611;\n    t.bracketleft = 278;\n    t.backslash = 278;\n    t.bracketright = 278;\n    t.asciicircum = 469;\n    t.underscore = 556;\n    t.quoteleft = 222;\n    t.a = 556;\n    t.b = 556;\n    t.c = 500;\n    t.d = 556;\n    t.e = 556;\n    t.f = 278;\n    t.g = 556;\n    t.h = 556;\n    t.i = 222;\n    t.j = 222;\n    t.k = 500;\n    t.l = 222;\n    t.m = 833;\n    t.n = 556;\n    t.o = 556;\n    t.p = 556;\n    t.q = 556;\n    t.r = 333;\n    t.s = 500;\n    t.t = 278;\n    t.u = 556;\n    t.v = 500;\n    t.w = 722;\n    t.x = 500;\n    t.y = 500;\n    t.z = 500;\n    t.braceleft = 334;\n    t.bar = 260;\n    t.braceright = 334;\n    t.asciitilde = 584;\n    t.exclamdown = 333;\n    t.cent = 556;\n    t.sterling = 556;\n    t.fraction = 167;\n    t.yen = 556;\n    t.florin = 556;\n    t.section = 556;\n    t.currency = 556;\n    t.quotesingle = 191;\n    t.quotedblleft = 333;\n    t.guillemotleft = 556;\n    t.guilsinglleft = 333;\n    t.guilsinglright = 333;\n    t.fi = 500;\n    t.fl = 500;\n    t.endash = 556;\n    t.dagger = 556;\n    t.daggerdbl = 556;\n    t.periodcentered = 278;\n    t.paragraph = 537;\n    t.bullet = 350;\n    t.quotesinglbase = 222;\n    t.quotedblbase = 333;\n    t.quotedblright = 333;\n    t.guillemotright = 556;\n    t.ellipsis = 1000;\n    t.perthousand = 1000;\n    t.questiondown = 611;\n    t.grave = 333;\n    t.acute = 333;\n    t.circumflex = 333;\n    t.tilde = 333;\n    t.macron = 333;\n    t.breve = 333;\n    t.dotaccent = 333;\n    t.dieresis = 333;\n    t.ring = 333;\n    t.cedilla = 333;\n    t.hungarumlaut = 333;\n    t.ogonek = 333;\n    t.caron = 333;\n    t.emdash = 1000;\n    t.AE = 1000;\n    t.ordfeminine = 370;\n    t.Lslash = 556;\n    t.Oslash = 778;\n    t.OE = 1000;\n    t.ordmasculine = 365;\n    t.ae = 889;\n    t.dotlessi = 278;\n    t.lslash = 222;\n    t.oslash = 611;\n    t.oe = 944;\n    t.germandbls = 611;\n    t.Idieresis = 278;\n    t.eacute = 556;\n    t.abreve = 556;\n    t.uhungarumlaut = 556;\n    t.ecaron = 556;\n    t.Ydieresis = 667;\n    t.divide = 584;\n    t.Yacute = 667;\n    t.Acircumflex = 667;\n    t.aacute = 556;\n    t.Ucircumflex = 722;\n    t.yacute = 500;\n    t.scommaaccent = 500;\n    t.ecircumflex = 556;\n    t.Uring = 722;\n    t.Udieresis = 722;\n    t.aogonek = 556;\n    t.Uacute = 722;\n    t.uogonek = 556;\n    t.Edieresis = 667;\n    t.Dcroat = 722;\n    t.commaaccent = 250;\n    t.copyright = 737;\n    t.Emacron = 667;\n    t.ccaron = 500;\n    t.aring = 556;\n    t.Ncommaaccent = 722;\n    t.lacute = 222;\n    t.agrave = 556;\n    t.Tcommaaccent = 611;\n    t.Cacute = 722;\n    t.atilde = 556;\n    t.Edotaccent = 667;\n    t.scaron = 500;\n    t.scedilla = 500;\n    t.iacute = 278;\n    t.lozenge = 471;\n    t.Rcaron = 722;\n    t.Gcommaaccent = 778;\n    t.ucircumflex = 556;\n    t.acircumflex = 556;\n    t.Amacron = 667;\n    t.rcaron = 333;\n    t.ccedilla = 500;\n    t.Zdotaccent = 611;\n    t.Thorn = 667;\n    t.Omacron = 778;\n    t.Racute = 722;\n    t.Sacute = 667;\n    t.dcaron = 643;\n    t.Umacron = 722;\n    t.uring = 556;\n    t.threesuperior = 333;\n    t.Ograve = 778;\n    t.Agrave = 667;\n    t.Abreve = 667;\n    t.multiply = 584;\n    t.uacute = 556;\n    t.Tcaron = 611;\n    t.partialdiff = 476;\n    t.ydieresis = 500;\n    t.Nacute = 722;\n    t.icircumflex = 278;\n    t.Ecircumflex = 667;\n    t.adieresis = 556;\n    t.edieresis = 556;\n    t.cacute = 500;\n    t.nacute = 556;\n    t.umacron = 556;\n    t.Ncaron = 722;\n    t.Iacute = 278;\n    t.plusminus = 584;\n    t.brokenbar = 260;\n    t.registered = 737;\n    t.Gbreve = 778;\n    t.Idotaccent = 278;\n    t.summation = 600;\n    t.Egrave = 667;\n    t.racute = 333;\n    t.omacron = 556;\n    t.Zacute = 611;\n    t.Zcaron = 611;\n    t.greaterequal = 549;\n    t.Eth = 722;\n    t.Ccedilla = 722;\n    t.lcommaaccent = 222;\n    t.tcaron = 317;\n    t.eogonek = 556;\n    t.Uogonek = 722;\n    t.Aacute = 667;\n    t.Adieresis = 667;\n    t.egrave = 556;\n    t.zacute = 500;\n    t.iogonek = 222;\n    t.Oacute = 778;\n    t.oacute = 556;\n    t.amacron = 556;\n    t.sacute = 500;\n    t.idieresis = 278;\n    t.Ocircumflex = 778;\n    t.Ugrave = 722;\n    t.Delta = 612;\n    t.thorn = 556;\n    t.twosuperior = 333;\n    t.Odieresis = 778;\n    t.mu = 556;\n    t.igrave = 278;\n    t.ohungarumlaut = 556;\n    t.Eogonek = 667;\n    t.dcroat = 556;\n    t.threequarters = 834;\n    t.Scedilla = 667;\n    t.lcaron = 299;\n    t.Kcommaaccent = 667;\n    t.Lacute = 556;\n    t.trademark = 1000;\n    t.edotaccent = 556;\n    t.Igrave = 278;\n    t.Imacron = 278;\n    t.Lcaron = 556;\n    t.onehalf = 834;\n    t.lessequal = 549;\n    t.ocircumflex = 556;\n    t.ntilde = 556;\n    t.Uhungarumlaut = 722;\n    t.Eacute = 667;\n    t.emacron = 556;\n    t.gbreve = 556;\n    t.onequarter = 834;\n    t.Scaron = 667;\n    t.Scommaaccent = 667;\n    t.Ohungarumlaut = 778;\n    t.degree = 400;\n    t.ograve = 556;\n    t.Ccaron = 722;\n    t.ugrave = 556;\n    t.radical = 453;\n    t.Dcaron = 722;\n    t.rcommaaccent = 333;\n    t.Ntilde = 722;\n    t.otilde = 556;\n    t.Rcommaaccent = 722;\n    t.Lcommaaccent = 556;\n    t.Atilde = 667;\n    t.Aogonek = 667;\n    t.Aring = 667;\n    t.Otilde = 778;\n    t.zdotaccent = 500;\n    t.Ecaron = 667;\n    t.Iogonek = 278;\n    t.kcommaaccent = 500;\n    t.minus = 584;\n    t.Icircumflex = 278;\n    t.ncaron = 556;\n    t.tcommaaccent = 278;\n    t.logicalnot = 584;\n    t.odieresis = 556;\n    t.udieresis = 556;\n    t.notequal = 549;\n    t.gcommaaccent = 556;\n    t.eth = 556;\n    t.zcaron = 500;\n    t.ncommaaccent = 556;\n    t.onesuperior = 333;\n    t.imacron = 278;\n    t.Euro = 556;\n  });\n  t[\"Helvetica-Bold\"] = getLookupTableFactory(function (t) {\n    t.space = 278;\n    t.exclam = 333;\n    t.quotedbl = 474;\n    t.numbersign = 556;\n    t.dollar = 556;\n    t.percent = 889;\n    t.ampersand = 722;\n    t.quoteright = 278;\n    t.parenleft = 333;\n    t.parenright = 333;\n    t.asterisk = 389;\n    t.plus = 584;\n    t.comma = 278;\n    t.hyphen = 333;\n    t.period = 278;\n    t.slash = 278;\n    t.zero = 556;\n    t.one = 556;\n    t.two = 556;\n    t.three = 556;\n    t.four = 556;\n    t.five = 556;\n    t.six = 556;\n    t.seven = 556;\n    t.eight = 556;\n    t.nine = 556;\n    t.colon = 333;\n    t.semicolon = 333;\n    t.less = 584;\n    t.equal = 584;\n    t.greater = 584;\n    t.question = 611;\n    t.at = 975;\n    t.A = 722;\n    t.B = 722;\n    t.C = 722;\n    t.D = 722;\n    t.E = 667;\n    t.F = 611;\n    t.G = 778;\n    t.H = 722;\n    t.I = 278;\n    t.J = 556;\n    t.K = 722;\n    t.L = 611;\n    t.M = 833;\n    t.N = 722;\n    t.O = 778;\n    t.P = 667;\n    t.Q = 778;\n    t.R = 722;\n    t.S = 667;\n    t.T = 611;\n    t.U = 722;\n    t.V = 667;\n    t.W = 944;\n    t.X = 667;\n    t.Y = 667;\n    t.Z = 611;\n    t.bracketleft = 333;\n    t.backslash = 278;\n    t.bracketright = 333;\n    t.asciicircum = 584;\n    t.underscore = 556;\n    t.quoteleft = 278;\n    t.a = 556;\n    t.b = 611;\n    t.c = 556;\n    t.d = 611;\n    t.e = 556;\n    t.f = 333;\n    t.g = 611;\n    t.h = 611;\n    t.i = 278;\n    t.j = 278;\n    t.k = 556;\n    t.l = 278;\n    t.m = 889;\n    t.n = 611;\n    t.o = 611;\n    t.p = 611;\n    t.q = 611;\n    t.r = 389;\n    t.s = 556;\n    t.t = 333;\n    t.u = 611;\n    t.v = 556;\n    t.w = 778;\n    t.x = 556;\n    t.y = 556;\n    t.z = 500;\n    t.braceleft = 389;\n    t.bar = 280;\n    t.braceright = 389;\n    t.asciitilde = 584;\n    t.exclamdown = 333;\n    t.cent = 556;\n    t.sterling = 556;\n    t.fraction = 167;\n    t.yen = 556;\n    t.florin = 556;\n    t.section = 556;\n    t.currency = 556;\n    t.quotesingle = 238;\n    t.quotedblleft = 500;\n    t.guillemotleft = 556;\n    t.guilsinglleft = 333;\n    t.guilsinglright = 333;\n    t.fi = 611;\n    t.fl = 611;\n    t.endash = 556;\n    t.dagger = 556;\n    t.daggerdbl = 556;\n    t.periodcentered = 278;\n    t.paragraph = 556;\n    t.bullet = 350;\n    t.quotesinglbase = 278;\n    t.quotedblbase = 500;\n    t.quotedblright = 500;\n    t.guillemotright = 556;\n    t.ellipsis = 1000;\n    t.perthousand = 1000;\n    t.questiondown = 611;\n    t.grave = 333;\n    t.acute = 333;\n    t.circumflex = 333;\n    t.tilde = 333;\n    t.macron = 333;\n    t.breve = 333;\n    t.dotaccent = 333;\n    t.dieresis = 333;\n    t.ring = 333;\n    t.cedilla = 333;\n    t.hungarumlaut = 333;\n    t.ogonek = 333;\n    t.caron = 333;\n    t.emdash = 1000;\n    t.AE = 1000;\n    t.ordfeminine = 370;\n    t.Lslash = 611;\n    t.Oslash = 778;\n    t.OE = 1000;\n    t.ordmasculine = 365;\n    t.ae = 889;\n    t.dotlessi = 278;\n    t.lslash = 278;\n    t.oslash = 611;\n    t.oe = 944;\n    t.germandbls = 611;\n    t.Idieresis = 278;\n    t.eacute = 556;\n    t.abreve = 556;\n    t.uhungarumlaut = 611;\n    t.ecaron = 556;\n    t.Ydieresis = 667;\n    t.divide = 584;\n    t.Yacute = 667;\n    t.Acircumflex = 722;\n    t.aacute = 556;\n    t.Ucircumflex = 722;\n    t.yacute = 556;\n    t.scommaaccent = 556;\n    t.ecircumflex = 556;\n    t.Uring = 722;\n    t.Udieresis = 722;\n    t.aogonek = 556;\n    t.Uacute = 722;\n    t.uogonek = 611;\n    t.Edieresis = 667;\n    t.Dcroat = 722;\n    t.commaaccent = 250;\n    t.copyright = 737;\n    t.Emacron = 667;\n    t.ccaron = 556;\n    t.aring = 556;\n    t.Ncommaaccent = 722;\n    t.lacute = 278;\n    t.agrave = 556;\n    t.Tcommaaccent = 611;\n    t.Cacute = 722;\n    t.atilde = 556;\n    t.Edotaccent = 667;\n    t.scaron = 556;\n    t.scedilla = 556;\n    t.iacute = 278;\n    t.lozenge = 494;\n    t.Rcaron = 722;\n    t.Gcommaaccent = 778;\n    t.ucircumflex = 611;\n    t.acircumflex = 556;\n    t.Amacron = 722;\n    t.rcaron = 389;\n    t.ccedilla = 556;\n    t.Zdotaccent = 611;\n    t.Thorn = 667;\n    t.Omacron = 778;\n    t.Racute = 722;\n    t.Sacute = 667;\n    t.dcaron = 743;\n    t.Umacron = 722;\n    t.uring = 611;\n    t.threesuperior = 333;\n    t.Ograve = 778;\n    t.Agrave = 722;\n    t.Abreve = 722;\n    t.multiply = 584;\n    t.uacute = 611;\n    t.Tcaron = 611;\n    t.partialdiff = 494;\n    t.ydieresis = 556;\n    t.Nacute = 722;\n    t.icircumflex = 278;\n    t.Ecircumflex = 667;\n    t.adieresis = 556;\n    t.edieresis = 556;\n    t.cacute = 556;\n    t.nacute = 611;\n    t.umacron = 611;\n    t.Ncaron = 722;\n    t.Iacute = 278;\n    t.plusminus = 584;\n    t.brokenbar = 280;\n    t.registered = 737;\n    t.Gbreve = 778;\n    t.Idotaccent = 278;\n    t.summation = 600;\n    t.Egrave = 667;\n    t.racute = 389;\n    t.omacron = 611;\n    t.Zacute = 611;\n    t.Zcaron = 611;\n    t.greaterequal = 549;\n    t.Eth = 722;\n    t.Ccedilla = 722;\n    t.lcommaaccent = 278;\n    t.tcaron = 389;\n    t.eogonek = 556;\n    t.Uogonek = 722;\n    t.Aacute = 722;\n    t.Adieresis = 722;\n    t.egrave = 556;\n    t.zacute = 500;\n    t.iogonek = 278;\n    t.Oacute = 778;\n    t.oacute = 611;\n    t.amacron = 556;\n    t.sacute = 556;\n    t.idieresis = 278;\n    t.Ocircumflex = 778;\n    t.Ugrave = 722;\n    t.Delta = 612;\n    t.thorn = 611;\n    t.twosuperior = 333;\n    t.Odieresis = 778;\n    t.mu = 611;\n    t.igrave = 278;\n    t.ohungarumlaut = 611;\n    t.Eogonek = 667;\n    t.dcroat = 611;\n    t.threequarters = 834;\n    t.Scedilla = 667;\n    t.lcaron = 400;\n    t.Kcommaaccent = 722;\n    t.Lacute = 611;\n    t.trademark = 1000;\n    t.edotaccent = 556;\n    t.Igrave = 278;\n    t.Imacron = 278;\n    t.Lcaron = 611;\n    t.onehalf = 834;\n    t.lessequal = 549;\n    t.ocircumflex = 611;\n    t.ntilde = 611;\n    t.Uhungarumlaut = 722;\n    t.Eacute = 667;\n    t.emacron = 556;\n    t.gbreve = 611;\n    t.onequarter = 834;\n    t.Scaron = 667;\n    t.Scommaaccent = 667;\n    t.Ohungarumlaut = 778;\n    t.degree = 400;\n    t.ograve = 611;\n    t.Ccaron = 722;\n    t.ugrave = 611;\n    t.radical = 549;\n    t.Dcaron = 722;\n    t.rcommaaccent = 389;\n    t.Ntilde = 722;\n    t.otilde = 611;\n    t.Rcommaaccent = 722;\n    t.Lcommaaccent = 611;\n    t.Atilde = 722;\n    t.Aogonek = 722;\n    t.Aring = 722;\n    t.Otilde = 778;\n    t.zdotaccent = 500;\n    t.Ecaron = 667;\n    t.Iogonek = 278;\n    t.kcommaaccent = 556;\n    t.minus = 584;\n    t.Icircumflex = 278;\n    t.ncaron = 611;\n    t.tcommaaccent = 333;\n    t.logicalnot = 584;\n    t.odieresis = 611;\n    t.udieresis = 611;\n    t.notequal = 549;\n    t.gcommaaccent = 611;\n    t.eth = 611;\n    t.zcaron = 500;\n    t.ncommaaccent = 611;\n    t.onesuperior = 333;\n    t.imacron = 278;\n    t.Euro = 556;\n  });\n  t[\"Helvetica-BoldOblique\"] = getLookupTableFactory(function (t) {\n    t.space = 278;\n    t.exclam = 333;\n    t.quotedbl = 474;\n    t.numbersign = 556;\n    t.dollar = 556;\n    t.percent = 889;\n    t.ampersand = 722;\n    t.quoteright = 278;\n    t.parenleft = 333;\n    t.parenright = 333;\n    t.asterisk = 389;\n    t.plus = 584;\n    t.comma = 278;\n    t.hyphen = 333;\n    t.period = 278;\n    t.slash = 278;\n    t.zero = 556;\n    t.one = 556;\n    t.two = 556;\n    t.three = 556;\n    t.four = 556;\n    t.five = 556;\n    t.six = 556;\n    t.seven = 556;\n    t.eight = 556;\n    t.nine = 556;\n    t.colon = 333;\n    t.semicolon = 333;\n    t.less = 584;\n    t.equal = 584;\n    t.greater = 584;\n    t.question = 611;\n    t.at = 975;\n    t.A = 722;\n    t.B = 722;\n    t.C = 722;\n    t.D = 722;\n    t.E = 667;\n    t.F = 611;\n    t.G = 778;\n    t.H = 722;\n    t.I = 278;\n    t.J = 556;\n    t.K = 722;\n    t.L = 611;\n    t.M = 833;\n    t.N = 722;\n    t.O = 778;\n    t.P = 667;\n    t.Q = 778;\n    t.R = 722;\n    t.S = 667;\n    t.T = 611;\n    t.U = 722;\n    t.V = 667;\n    t.W = 944;\n    t.X = 667;\n    t.Y = 667;\n    t.Z = 611;\n    t.bracketleft = 333;\n    t.backslash = 278;\n    t.bracketright = 333;\n    t.asciicircum = 584;\n    t.underscore = 556;\n    t.quoteleft = 278;\n    t.a = 556;\n    t.b = 611;\n    t.c = 556;\n    t.d = 611;\n    t.e = 556;\n    t.f = 333;\n    t.g = 611;\n    t.h = 611;\n    t.i = 278;\n    t.j = 278;\n    t.k = 556;\n    t.l = 278;\n    t.m = 889;\n    t.n = 611;\n    t.o = 611;\n    t.p = 611;\n    t.q = 611;\n    t.r = 389;\n    t.s = 556;\n    t.t = 333;\n    t.u = 611;\n    t.v = 556;\n    t.w = 778;\n    t.x = 556;\n    t.y = 556;\n    t.z = 500;\n    t.braceleft = 389;\n    t.bar = 280;\n    t.braceright = 389;\n    t.asciitilde = 584;\n    t.exclamdown = 333;\n    t.cent = 556;\n    t.sterling = 556;\n    t.fraction = 167;\n    t.yen = 556;\n    t.florin = 556;\n    t.section = 556;\n    t.currency = 556;\n    t.quotesingle = 238;\n    t.quotedblleft = 500;\n    t.guillemotleft = 556;\n    t.guilsinglleft = 333;\n    t.guilsinglright = 333;\n    t.fi = 611;\n    t.fl = 611;\n    t.endash = 556;\n    t.dagger = 556;\n    t.daggerdbl = 556;\n    t.periodcentered = 278;\n    t.paragraph = 556;\n    t.bullet = 350;\n    t.quotesinglbase = 278;\n    t.quotedblbase = 500;\n    t.quotedblright = 500;\n    t.guillemotright = 556;\n    t.ellipsis = 1000;\n    t.perthousand = 1000;\n    t.questiondown = 611;\n    t.grave = 333;\n    t.acute = 333;\n    t.circumflex = 333;\n    t.tilde = 333;\n    t.macron = 333;\n    t.breve = 333;\n    t.dotaccent = 333;\n    t.dieresis = 333;\n    t.ring = 333;\n    t.cedilla = 333;\n    t.hungarumlaut = 333;\n    t.ogonek = 333;\n    t.caron = 333;\n    t.emdash = 1000;\n    t.AE = 1000;\n    t.ordfeminine = 370;\n    t.Lslash = 611;\n    t.Oslash = 778;\n    t.OE = 1000;\n    t.ordmasculine = 365;\n    t.ae = 889;\n    t.dotlessi = 278;\n    t.lslash = 278;\n    t.oslash = 611;\n    t.oe = 944;\n    t.germandbls = 611;\n    t.Idieresis = 278;\n    t.eacute = 556;\n    t.abreve = 556;\n    t.uhungarumlaut = 611;\n    t.ecaron = 556;\n    t.Ydieresis = 667;\n    t.divide = 584;\n    t.Yacute = 667;\n    t.Acircumflex = 722;\n    t.aacute = 556;\n    t.Ucircumflex = 722;\n    t.yacute = 556;\n    t.scommaaccent = 556;\n    t.ecircumflex = 556;\n    t.Uring = 722;\n    t.Udieresis = 722;\n    t.aogonek = 556;\n    t.Uacute = 722;\n    t.uogonek = 611;\n    t.Edieresis = 667;\n    t.Dcroat = 722;\n    t.commaaccent = 250;\n    t.copyright = 737;\n    t.Emacron = 667;\n    t.ccaron = 556;\n    t.aring = 556;\n    t.Ncommaaccent = 722;\n    t.lacute = 278;\n    t.agrave = 556;\n    t.Tcommaaccent = 611;\n    t.Cacute = 722;\n    t.atilde = 556;\n    t.Edotaccent = 667;\n    t.scaron = 556;\n    t.scedilla = 556;\n    t.iacute = 278;\n    t.lozenge = 494;\n    t.Rcaron = 722;\n    t.Gcommaaccent = 778;\n    t.ucircumflex = 611;\n    t.acircumflex = 556;\n    t.Amacron = 722;\n    t.rcaron = 389;\n    t.ccedilla = 556;\n    t.Zdotaccent = 611;\n    t.Thorn = 667;\n    t.Omacron = 778;\n    t.Racute = 722;\n    t.Sacute = 667;\n    t.dcaron = 743;\n    t.Umacron = 722;\n    t.uring = 611;\n    t.threesuperior = 333;\n    t.Ograve = 778;\n    t.Agrave = 722;\n    t.Abreve = 722;\n    t.multiply = 584;\n    t.uacute = 611;\n    t.Tcaron = 611;\n    t.partialdiff = 494;\n    t.ydieresis = 556;\n    t.Nacute = 722;\n    t.icircumflex = 278;\n    t.Ecircumflex = 667;\n    t.adieresis = 556;\n    t.edieresis = 556;\n    t.cacute = 556;\n    t.nacute = 611;\n    t.umacron = 611;\n    t.Ncaron = 722;\n    t.Iacute = 278;\n    t.plusminus = 584;\n    t.brokenbar = 280;\n    t.registered = 737;\n    t.Gbreve = 778;\n    t.Idotaccent = 278;\n    t.summation = 600;\n    t.Egrave = 667;\n    t.racute = 389;\n    t.omacron = 611;\n    t.Zacute = 611;\n    t.Zcaron = 611;\n    t.greaterequal = 549;\n    t.Eth = 722;\n    t.Ccedilla = 722;\n    t.lcommaaccent = 278;\n    t.tcaron = 389;\n    t.eogonek = 556;\n    t.Uogonek = 722;\n    t.Aacute = 722;\n    t.Adieresis = 722;\n    t.egrave = 556;\n    t.zacute = 500;\n    t.iogonek = 278;\n    t.Oacute = 778;\n    t.oacute = 611;\n    t.amacron = 556;\n    t.sacute = 556;\n    t.idieresis = 278;\n    t.Ocircumflex = 778;\n    t.Ugrave = 722;\n    t.Delta = 612;\n    t.thorn = 611;\n    t.twosuperior = 333;\n    t.Odieresis = 778;\n    t.mu = 611;\n    t.igrave = 278;\n    t.ohungarumlaut = 611;\n    t.Eogonek = 667;\n    t.dcroat = 611;\n    t.threequarters = 834;\n    t.Scedilla = 667;\n    t.lcaron = 400;\n    t.Kcommaaccent = 722;\n    t.Lacute = 611;\n    t.trademark = 1000;\n    t.edotaccent = 556;\n    t.Igrave = 278;\n    t.Imacron = 278;\n    t.Lcaron = 611;\n    t.onehalf = 834;\n    t.lessequal = 549;\n    t.ocircumflex = 611;\n    t.ntilde = 611;\n    t.Uhungarumlaut = 722;\n    t.Eacute = 667;\n    t.emacron = 556;\n    t.gbreve = 611;\n    t.onequarter = 834;\n    t.Scaron = 667;\n    t.Scommaaccent = 667;\n    t.Ohungarumlaut = 778;\n    t.degree = 400;\n    t.ograve = 611;\n    t.Ccaron = 722;\n    t.ugrave = 611;\n    t.radical = 549;\n    t.Dcaron = 722;\n    t.rcommaaccent = 389;\n    t.Ntilde = 722;\n    t.otilde = 611;\n    t.Rcommaaccent = 722;\n    t.Lcommaaccent = 611;\n    t.Atilde = 722;\n    t.Aogonek = 722;\n    t.Aring = 722;\n    t.Otilde = 778;\n    t.zdotaccent = 500;\n    t.Ecaron = 667;\n    t.Iogonek = 278;\n    t.kcommaaccent = 556;\n    t.minus = 584;\n    t.Icircumflex = 278;\n    t.ncaron = 611;\n    t.tcommaaccent = 333;\n    t.logicalnot = 584;\n    t.odieresis = 611;\n    t.udieresis = 611;\n    t.notequal = 549;\n    t.gcommaaccent = 611;\n    t.eth = 611;\n    t.zcaron = 500;\n    t.ncommaaccent = 611;\n    t.onesuperior = 333;\n    t.imacron = 278;\n    t.Euro = 556;\n  });\n  t[\"Helvetica-Oblique\"] = getLookupTableFactory(function (t) {\n    t.space = 278;\n    t.exclam = 278;\n    t.quotedbl = 355;\n    t.numbersign = 556;\n    t.dollar = 556;\n    t.percent = 889;\n    t.ampersand = 667;\n    t.quoteright = 222;\n    t.parenleft = 333;\n    t.parenright = 333;\n    t.asterisk = 389;\n    t.plus = 584;\n    t.comma = 278;\n    t.hyphen = 333;\n    t.period = 278;\n    t.slash = 278;\n    t.zero = 556;\n    t.one = 556;\n    t.two = 556;\n    t.three = 556;\n    t.four = 556;\n    t.five = 556;\n    t.six = 556;\n    t.seven = 556;\n    t.eight = 556;\n    t.nine = 556;\n    t.colon = 278;\n    t.semicolon = 278;\n    t.less = 584;\n    t.equal = 584;\n    t.greater = 584;\n    t.question = 556;\n    t.at = 1015;\n    t.A = 667;\n    t.B = 667;\n    t.C = 722;\n    t.D = 722;\n    t.E = 667;\n    t.F = 611;\n    t.G = 778;\n    t.H = 722;\n    t.I = 278;\n    t.J = 500;\n    t.K = 667;\n    t.L = 556;\n    t.M = 833;\n    t.N = 722;\n    t.O = 778;\n    t.P = 667;\n    t.Q = 778;\n    t.R = 722;\n    t.S = 667;\n    t.T = 611;\n    t.U = 722;\n    t.V = 667;\n    t.W = 944;\n    t.X = 667;\n    t.Y = 667;\n    t.Z = 611;\n    t.bracketleft = 278;\n    t.backslash = 278;\n    t.bracketright = 278;\n    t.asciicircum = 469;\n    t.underscore = 556;\n    t.quoteleft = 222;\n    t.a = 556;\n    t.b = 556;\n    t.c = 500;\n    t.d = 556;\n    t.e = 556;\n    t.f = 278;\n    t.g = 556;\n    t.h = 556;\n    t.i = 222;\n    t.j = 222;\n    t.k = 500;\n    t.l = 222;\n    t.m = 833;\n    t.n = 556;\n    t.o = 556;\n    t.p = 556;\n    t.q = 556;\n    t.r = 333;\n    t.s = 500;\n    t.t = 278;\n    t.u = 556;\n    t.v = 500;\n    t.w = 722;\n    t.x = 500;\n    t.y = 500;\n    t.z = 500;\n    t.braceleft = 334;\n    t.bar = 260;\n    t.braceright = 334;\n    t.asciitilde = 584;\n    t.exclamdown = 333;\n    t.cent = 556;\n    t.sterling = 556;\n    t.fraction = 167;\n    t.yen = 556;\n    t.florin = 556;\n    t.section = 556;\n    t.currency = 556;\n    t.quotesingle = 191;\n    t.quotedblleft = 333;\n    t.guillemotleft = 556;\n    t.guilsinglleft = 333;\n    t.guilsinglright = 333;\n    t.fi = 500;\n    t.fl = 500;\n    t.endash = 556;\n    t.dagger = 556;\n    t.daggerdbl = 556;\n    t.periodcentered = 278;\n    t.paragraph = 537;\n    t.bullet = 350;\n    t.quotesinglbase = 222;\n    t.quotedblbase = 333;\n    t.quotedblright = 333;\n    t.guillemotright = 556;\n    t.ellipsis = 1000;\n    t.perthousand = 1000;\n    t.questiondown = 611;\n    t.grave = 333;\n    t.acute = 333;\n    t.circumflex = 333;\n    t.tilde = 333;\n    t.macron = 333;\n    t.breve = 333;\n    t.dotaccent = 333;\n    t.dieresis = 333;\n    t.ring = 333;\n    t.cedilla = 333;\n    t.hungarumlaut = 333;\n    t.ogonek = 333;\n    t.caron = 333;\n    t.emdash = 1000;\n    t.AE = 1000;\n    t.ordfeminine = 370;\n    t.Lslash = 556;\n    t.Oslash = 778;\n    t.OE = 1000;\n    t.ordmasculine = 365;\n    t.ae = 889;\n    t.dotlessi = 278;\n    t.lslash = 222;\n    t.oslash = 611;\n    t.oe = 944;\n    t.germandbls = 611;\n    t.Idieresis = 278;\n    t.eacute = 556;\n    t.abreve = 556;\n    t.uhungarumlaut = 556;\n    t.ecaron = 556;\n    t.Ydieresis = 667;\n    t.divide = 584;\n    t.Yacute = 667;\n    t.Acircumflex = 667;\n    t.aacute = 556;\n    t.Ucircumflex = 722;\n    t.yacute = 500;\n    t.scommaaccent = 500;\n    t.ecircumflex = 556;\n    t.Uring = 722;\n    t.Udieresis = 722;\n    t.aogonek = 556;\n    t.Uacute = 722;\n    t.uogonek = 556;\n    t.Edieresis = 667;\n    t.Dcroat = 722;\n    t.commaaccent = 250;\n    t.copyright = 737;\n    t.Emacron = 667;\n    t.ccaron = 500;\n    t.aring = 556;\n    t.Ncommaaccent = 722;\n    t.lacute = 222;\n    t.agrave = 556;\n    t.Tcommaaccent = 611;\n    t.Cacute = 722;\n    t.atilde = 556;\n    t.Edotaccent = 667;\n    t.scaron = 500;\n    t.scedilla = 500;\n    t.iacute = 278;\n    t.lozenge = 471;\n    t.Rcaron = 722;\n    t.Gcommaaccent = 778;\n    t.ucircumflex = 556;\n    t.acircumflex = 556;\n    t.Amacron = 667;\n    t.rcaron = 333;\n    t.ccedilla = 500;\n    t.Zdotaccent = 611;\n    t.Thorn = 667;\n    t.Omacron = 778;\n    t.Racute = 722;\n    t.Sacute = 667;\n    t.dcaron = 643;\n    t.Umacron = 722;\n    t.uring = 556;\n    t.threesuperior = 333;\n    t.Ograve = 778;\n    t.Agrave = 667;\n    t.Abreve = 667;\n    t.multiply = 584;\n    t.uacute = 556;\n    t.Tcaron = 611;\n    t.partialdiff = 476;\n    t.ydieresis = 500;\n    t.Nacute = 722;\n    t.icircumflex = 278;\n    t.Ecircumflex = 667;\n    t.adieresis = 556;\n    t.edieresis = 556;\n    t.cacute = 500;\n    t.nacute = 556;\n    t.umacron = 556;\n    t.Ncaron = 722;\n    t.Iacute = 278;\n    t.plusminus = 584;\n    t.brokenbar = 260;\n    t.registered = 737;\n    t.Gbreve = 778;\n    t.Idotaccent = 278;\n    t.summation = 600;\n    t.Egrave = 667;\n    t.racute = 333;\n    t.omacron = 556;\n    t.Zacute = 611;\n    t.Zcaron = 611;\n    t.greaterequal = 549;\n    t.Eth = 722;\n    t.Ccedilla = 722;\n    t.lcommaaccent = 222;\n    t.tcaron = 317;\n    t.eogonek = 556;\n    t.Uogonek = 722;\n    t.Aacute = 667;\n    t.Adieresis = 667;\n    t.egrave = 556;\n    t.zacute = 500;\n    t.iogonek = 222;\n    t.Oacute = 778;\n    t.oacute = 556;\n    t.amacron = 556;\n    t.sacute = 500;\n    t.idieresis = 278;\n    t.Ocircumflex = 778;\n    t.Ugrave = 722;\n    t.Delta = 612;\n    t.thorn = 556;\n    t.twosuperior = 333;\n    t.Odieresis = 778;\n    t.mu = 556;\n    t.igrave = 278;\n    t.ohungarumlaut = 556;\n    t.Eogonek = 667;\n    t.dcroat = 556;\n    t.threequarters = 834;\n    t.Scedilla = 667;\n    t.lcaron = 299;\n    t.Kcommaaccent = 667;\n    t.Lacute = 556;\n    t.trademark = 1000;\n    t.edotaccent = 556;\n    t.Igrave = 278;\n    t.Imacron = 278;\n    t.Lcaron = 556;\n    t.onehalf = 834;\n    t.lessequal = 549;\n    t.ocircumflex = 556;\n    t.ntilde = 556;\n    t.Uhungarumlaut = 722;\n    t.Eacute = 667;\n    t.emacron = 556;\n    t.gbreve = 556;\n    t.onequarter = 834;\n    t.Scaron = 667;\n    t.Scommaaccent = 667;\n    t.Ohungarumlaut = 778;\n    t.degree = 400;\n    t.ograve = 556;\n    t.Ccaron = 722;\n    t.ugrave = 556;\n    t.radical = 453;\n    t.Dcaron = 722;\n    t.rcommaaccent = 333;\n    t.Ntilde = 722;\n    t.otilde = 556;\n    t.Rcommaaccent = 722;\n    t.Lcommaaccent = 556;\n    t.Atilde = 667;\n    t.Aogonek = 667;\n    t.Aring = 667;\n    t.Otilde = 778;\n    t.zdotaccent = 500;\n    t.Ecaron = 667;\n    t.Iogonek = 278;\n    t.kcommaaccent = 500;\n    t.minus = 584;\n    t.Icircumflex = 278;\n    t.ncaron = 556;\n    t.tcommaaccent = 278;\n    t.logicalnot = 584;\n    t.odieresis = 556;\n    t.udieresis = 556;\n    t.notequal = 549;\n    t.gcommaaccent = 556;\n    t.eth = 556;\n    t.zcaron = 500;\n    t.ncommaaccent = 556;\n    t.onesuperior = 333;\n    t.imacron = 278;\n    t.Euro = 556;\n  });\n  t.Symbol = getLookupTableFactory(function (t) {\n    t.space = 250;\n    t.exclam = 333;\n    t.universal = 713;\n    t.numbersign = 500;\n    t.existential = 549;\n    t.percent = 833;\n    t.ampersand = 778;\n    t.suchthat = 439;\n    t.parenleft = 333;\n    t.parenright = 333;\n    t.asteriskmath = 500;\n    t.plus = 549;\n    t.comma = 250;\n    t.minus = 549;\n    t.period = 250;\n    t.slash = 278;\n    t.zero = 500;\n    t.one = 500;\n    t.two = 500;\n    t.three = 500;\n    t.four = 500;\n    t.five = 500;\n    t.six = 500;\n    t.seven = 500;\n    t.eight = 500;\n    t.nine = 500;\n    t.colon = 278;\n    t.semicolon = 278;\n    t.less = 549;\n    t.equal = 549;\n    t.greater = 549;\n    t.question = 444;\n    t.congruent = 549;\n    t.Alpha = 722;\n    t.Beta = 667;\n    t.Chi = 722;\n    t.Delta = 612;\n    t.Epsilon = 611;\n    t.Phi = 763;\n    t.Gamma = 603;\n    t.Eta = 722;\n    t.Iota = 333;\n    t.theta1 = 631;\n    t.Kappa = 722;\n    t.Lambda = 686;\n    t.Mu = 889;\n    t.Nu = 722;\n    t.Omicron = 722;\n    t.Pi = 768;\n    t.Theta = 741;\n    t.Rho = 556;\n    t.Sigma = 592;\n    t.Tau = 611;\n    t.Upsilon = 690;\n    t.sigma1 = 439;\n    t.Omega = 768;\n    t.Xi = 645;\n    t.Psi = 795;\n    t.Zeta = 611;\n    t.bracketleft = 333;\n    t.therefore = 863;\n    t.bracketright = 333;\n    t.perpendicular = 658;\n    t.underscore = 500;\n    t.radicalex = 500;\n    t.alpha = 631;\n    t.beta = 549;\n    t.chi = 549;\n    t.delta = 494;\n    t.epsilon = 439;\n    t.phi = 521;\n    t.gamma = 411;\n    t.eta = 603;\n    t.iota = 329;\n    t.phi1 = 603;\n    t.kappa = 549;\n    t.lambda = 549;\n    t.mu = 576;\n    t.nu = 521;\n    t.omicron = 549;\n    t.pi = 549;\n    t.theta = 521;\n    t.rho = 549;\n    t.sigma = 603;\n    t.tau = 439;\n    t.upsilon = 576;\n    t.omega1 = 713;\n    t.omega = 686;\n    t.xi = 493;\n    t.psi = 686;\n    t.zeta = 494;\n    t.braceleft = 480;\n    t.bar = 200;\n    t.braceright = 480;\n    t.similar = 549;\n    t.Euro = 750;\n    t.Upsilon1 = 620;\n    t.minute = 247;\n    t.lessequal = 549;\n    t.fraction = 167;\n    t.infinity = 713;\n    t.florin = 500;\n    t.club = 753;\n    t.diamond = 753;\n    t.heart = 753;\n    t.spade = 753;\n    t.arrowboth = 1042;\n    t.arrowleft = 987;\n    t.arrowup = 603;\n    t.arrowright = 987;\n    t.arrowdown = 603;\n    t.degree = 400;\n    t.plusminus = 549;\n    t.second = 411;\n    t.greaterequal = 549;\n    t.multiply = 549;\n    t.proportional = 713;\n    t.partialdiff = 494;\n    t.bullet = 460;\n    t.divide = 549;\n    t.notequal = 549;\n    t.equivalence = 549;\n    t.approxequal = 549;\n    t.ellipsis = 1000;\n    t.arrowvertex = 603;\n    t.arrowhorizex = 1000;\n    t.carriagereturn = 658;\n    t.aleph = 823;\n    t.Ifraktur = 686;\n    t.Rfraktur = 795;\n    t.weierstrass = 987;\n    t.circlemultiply = 768;\n    t.circleplus = 768;\n    t.emptyset = 823;\n    t.intersection = 768;\n    t.union = 768;\n    t.propersuperset = 713;\n    t.reflexsuperset = 713;\n    t.notsubset = 713;\n    t.propersubset = 713;\n    t.reflexsubset = 713;\n    t.element = 713;\n    t.notelement = 713;\n    t.angle = 768;\n    t.gradient = 713;\n    t.registerserif = 790;\n    t.copyrightserif = 790;\n    t.trademarkserif = 890;\n    t.product = 823;\n    t.radical = 549;\n    t.dotmath = 250;\n    t.logicalnot = 713;\n    t.logicaland = 603;\n    t.logicalor = 603;\n    t.arrowdblboth = 1042;\n    t.arrowdblleft = 987;\n    t.arrowdblup = 603;\n    t.arrowdblright = 987;\n    t.arrowdbldown = 603;\n    t.lozenge = 494;\n    t.angleleft = 329;\n    t.registersans = 790;\n    t.copyrightsans = 790;\n    t.trademarksans = 786;\n    t.summation = 713;\n    t.parenlefttp = 384;\n    t.parenleftex = 384;\n    t.parenleftbt = 384;\n    t.bracketlefttp = 384;\n    t.bracketleftex = 384;\n    t.bracketleftbt = 384;\n    t.bracelefttp = 494;\n    t.braceleftmid = 494;\n    t.braceleftbt = 494;\n    t.braceex = 494;\n    t.angleright = 329;\n    t.integral = 274;\n    t.integraltp = 686;\n    t.integralex = 686;\n    t.integralbt = 686;\n    t.parenrighttp = 384;\n    t.parenrightex = 384;\n    t.parenrightbt = 384;\n    t.bracketrighttp = 384;\n    t.bracketrightex = 384;\n    t.bracketrightbt = 384;\n    t.bracerighttp = 494;\n    t.bracerightmid = 494;\n    t.bracerightbt = 494;\n    t.apple = 790;\n  });\n  t[\"Times-Roman\"] = getLookupTableFactory(function (t) {\n    t.space = 250;\n    t.exclam = 333;\n    t.quotedbl = 408;\n    t.numbersign = 500;\n    t.dollar = 500;\n    t.percent = 833;\n    t.ampersand = 778;\n    t.quoteright = 333;\n    t.parenleft = 333;\n    t.parenright = 333;\n    t.asterisk = 500;\n    t.plus = 564;\n    t.comma = 250;\n    t.hyphen = 333;\n    t.period = 250;\n    t.slash = 278;\n    t.zero = 500;\n    t.one = 500;\n    t.two = 500;\n    t.three = 500;\n    t.four = 500;\n    t.five = 500;\n    t.six = 500;\n    t.seven = 500;\n    t.eight = 500;\n    t.nine = 500;\n    t.colon = 278;\n    t.semicolon = 278;\n    t.less = 564;\n    t.equal = 564;\n    t.greater = 564;\n    t.question = 444;\n    t.at = 921;\n    t.A = 722;\n    t.B = 667;\n    t.C = 667;\n    t.D = 722;\n    t.E = 611;\n    t.F = 556;\n    t.G = 722;\n    t.H = 722;\n    t.I = 333;\n    t.J = 389;\n    t.K = 722;\n    t.L = 611;\n    t.M = 889;\n    t.N = 722;\n    t.O = 722;\n    t.P = 556;\n    t.Q = 722;\n    t.R = 667;\n    t.S = 556;\n    t.T = 611;\n    t.U = 722;\n    t.V = 722;\n    t.W = 944;\n    t.X = 722;\n    t.Y = 722;\n    t.Z = 611;\n    t.bracketleft = 333;\n    t.backslash = 278;\n    t.bracketright = 333;\n    t.asciicircum = 469;\n    t.underscore = 500;\n    t.quoteleft = 333;\n    t.a = 444;\n    t.b = 500;\n    t.c = 444;\n    t.d = 500;\n    t.e = 444;\n    t.f = 333;\n    t.g = 500;\n    t.h = 500;\n    t.i = 278;\n    t.j = 278;\n    t.k = 500;\n    t.l = 278;\n    t.m = 778;\n    t.n = 500;\n    t.o = 500;\n    t.p = 500;\n    t.q = 500;\n    t.r = 333;\n    t.s = 389;\n    t.t = 278;\n    t.u = 500;\n    t.v = 500;\n    t.w = 722;\n    t.x = 500;\n    t.y = 500;\n    t.z = 444;\n    t.braceleft = 480;\n    t.bar = 200;\n    t.braceright = 480;\n    t.asciitilde = 541;\n    t.exclamdown = 333;\n    t.cent = 500;\n    t.sterling = 500;\n    t.fraction = 167;\n    t.yen = 500;\n    t.florin = 500;\n    t.section = 500;\n    t.currency = 500;\n    t.quotesingle = 180;\n    t.quotedblleft = 444;\n    t.guillemotleft = 500;\n    t.guilsinglleft = 333;\n    t.guilsinglright = 333;\n    t.fi = 556;\n    t.fl = 556;\n    t.endash = 500;\n    t.dagger = 500;\n    t.daggerdbl = 500;\n    t.periodcentered = 250;\n    t.paragraph = 453;\n    t.bullet = 350;\n    t.quotesinglbase = 333;\n    t.quotedblbase = 444;\n    t.quotedblright = 444;\n    t.guillemotright = 500;\n    t.ellipsis = 1000;\n    t.perthousand = 1000;\n    t.questiondown = 444;\n    t.grave = 333;\n    t.acute = 333;\n    t.circumflex = 333;\n    t.tilde = 333;\n    t.macron = 333;\n    t.breve = 333;\n    t.dotaccent = 333;\n    t.dieresis = 333;\n    t.ring = 333;\n    t.cedilla = 333;\n    t.hungarumlaut = 333;\n    t.ogonek = 333;\n    t.caron = 333;\n    t.emdash = 1000;\n    t.AE = 889;\n    t.ordfeminine = 276;\n    t.Lslash = 611;\n    t.Oslash = 722;\n    t.OE = 889;\n    t.ordmasculine = 310;\n    t.ae = 667;\n    t.dotlessi = 278;\n    t.lslash = 278;\n    t.oslash = 500;\n    t.oe = 722;\n    t.germandbls = 500;\n    t.Idieresis = 333;\n    t.eacute = 444;\n    t.abreve = 444;\n    t.uhungarumlaut = 500;\n    t.ecaron = 444;\n    t.Ydieresis = 722;\n    t.divide = 564;\n    t.Yacute = 722;\n    t.Acircumflex = 722;\n    t.aacute = 444;\n    t.Ucircumflex = 722;\n    t.yacute = 500;\n    t.scommaaccent = 389;\n    t.ecircumflex = 444;\n    t.Uring = 722;\n    t.Udieresis = 722;\n    t.aogonek = 444;\n    t.Uacute = 722;\n    t.uogonek = 500;\n    t.Edieresis = 611;\n    t.Dcroat = 722;\n    t.commaaccent = 250;\n    t.copyright = 760;\n    t.Emacron = 611;\n    t.ccaron = 444;\n    t.aring = 444;\n    t.Ncommaaccent = 722;\n    t.lacute = 278;\n    t.agrave = 444;\n    t.Tcommaaccent = 611;\n    t.Cacute = 667;\n    t.atilde = 444;\n    t.Edotaccent = 611;\n    t.scaron = 389;\n    t.scedilla = 389;\n    t.iacute = 278;\n    t.lozenge = 471;\n    t.Rcaron = 667;\n    t.Gcommaaccent = 722;\n    t.ucircumflex = 500;\n    t.acircumflex = 444;\n    t.Amacron = 722;\n    t.rcaron = 333;\n    t.ccedilla = 444;\n    t.Zdotaccent = 611;\n    t.Thorn = 556;\n    t.Omacron = 722;\n    t.Racute = 667;\n    t.Sacute = 556;\n    t.dcaron = 588;\n    t.Umacron = 722;\n    t.uring = 500;\n    t.threesuperior = 300;\n    t.Ograve = 722;\n    t.Agrave = 722;\n    t.Abreve = 722;\n    t.multiply = 564;\n    t.uacute = 500;\n    t.Tcaron = 611;\n    t.partialdiff = 476;\n    t.ydieresis = 500;\n    t.Nacute = 722;\n    t.icircumflex = 278;\n    t.Ecircumflex = 611;\n    t.adieresis = 444;\n    t.edieresis = 444;\n    t.cacute = 444;\n    t.nacute = 500;\n    t.umacron = 500;\n    t.Ncaron = 722;\n    t.Iacute = 333;\n    t.plusminus = 564;\n    t.brokenbar = 200;\n    t.registered = 760;\n    t.Gbreve = 722;\n    t.Idotaccent = 333;\n    t.summation = 600;\n    t.Egrave = 611;\n    t.racute = 333;\n    t.omacron = 500;\n    t.Zacute = 611;\n    t.Zcaron = 611;\n    t.greaterequal = 549;\n    t.Eth = 722;\n    t.Ccedilla = 667;\n    t.lcommaaccent = 278;\n    t.tcaron = 326;\n    t.eogonek = 444;\n    t.Uogonek = 722;\n    t.Aacute = 722;\n    t.Adieresis = 722;\n    t.egrave = 444;\n    t.zacute = 444;\n    t.iogonek = 278;\n    t.Oacute = 722;\n    t.oacute = 500;\n    t.amacron = 444;\n    t.sacute = 389;\n    t.idieresis = 278;\n    t.Ocircumflex = 722;\n    t.Ugrave = 722;\n    t.Delta = 612;\n    t.thorn = 500;\n    t.twosuperior = 300;\n    t.Odieresis = 722;\n    t.mu = 500;\n    t.igrave = 278;\n    t.ohungarumlaut = 500;\n    t.Eogonek = 611;\n    t.dcroat = 500;\n    t.threequarters = 750;\n    t.Scedilla = 556;\n    t.lcaron = 344;\n    t.Kcommaaccent = 722;\n    t.Lacute = 611;\n    t.trademark = 980;\n    t.edotaccent = 444;\n    t.Igrave = 333;\n    t.Imacron = 333;\n    t.Lcaron = 611;\n    t.onehalf = 750;\n    t.lessequal = 549;\n    t.ocircumflex = 500;\n    t.ntilde = 500;\n    t.Uhungarumlaut = 722;\n    t.Eacute = 611;\n    t.emacron = 444;\n    t.gbreve = 500;\n    t.onequarter = 750;\n    t.Scaron = 556;\n    t.Scommaaccent = 556;\n    t.Ohungarumlaut = 722;\n    t.degree = 400;\n    t.ograve = 500;\n    t.Ccaron = 667;\n    t.ugrave = 500;\n    t.radical = 453;\n    t.Dcaron = 722;\n    t.rcommaaccent = 333;\n    t.Ntilde = 722;\n    t.otilde = 500;\n    t.Rcommaaccent = 667;\n    t.Lcommaaccent = 611;\n    t.Atilde = 722;\n    t.Aogonek = 722;\n    t.Aring = 722;\n    t.Otilde = 722;\n    t.zdotaccent = 444;\n    t.Ecaron = 611;\n    t.Iogonek = 333;\n    t.kcommaaccent = 500;\n    t.minus = 564;\n    t.Icircumflex = 333;\n    t.ncaron = 500;\n    t.tcommaaccent = 278;\n    t.logicalnot = 564;\n    t.odieresis = 500;\n    t.udieresis = 500;\n    t.notequal = 549;\n    t.gcommaaccent = 500;\n    t.eth = 500;\n    t.zcaron = 444;\n    t.ncommaaccent = 500;\n    t.onesuperior = 300;\n    t.imacron = 278;\n    t.Euro = 500;\n  });\n  t[\"Times-Bold\"] = getLookupTableFactory(function (t) {\n    t.space = 250;\n    t.exclam = 333;\n    t.quotedbl = 555;\n    t.numbersign = 500;\n    t.dollar = 500;\n    t.percent = 1000;\n    t.ampersand = 833;\n    t.quoteright = 333;\n    t.parenleft = 333;\n    t.parenright = 333;\n    t.asterisk = 500;\n    t.plus = 570;\n    t.comma = 250;\n    t.hyphen = 333;\n    t.period = 250;\n    t.slash = 278;\n    t.zero = 500;\n    t.one = 500;\n    t.two = 500;\n    t.three = 500;\n    t.four = 500;\n    t.five = 500;\n    t.six = 500;\n    t.seven = 500;\n    t.eight = 500;\n    t.nine = 500;\n    t.colon = 333;\n    t.semicolon = 333;\n    t.less = 570;\n    t.equal = 570;\n    t.greater = 570;\n    t.question = 500;\n    t.at = 930;\n    t.A = 722;\n    t.B = 667;\n    t.C = 722;\n    t.D = 722;\n    t.E = 667;\n    t.F = 611;\n    t.G = 778;\n    t.H = 778;\n    t.I = 389;\n    t.J = 500;\n    t.K = 778;\n    t.L = 667;\n    t.M = 944;\n    t.N = 722;\n    t.O = 778;\n    t.P = 611;\n    t.Q = 778;\n    t.R = 722;\n    t.S = 556;\n    t.T = 667;\n    t.U = 722;\n    t.V = 722;\n    t.W = 1000;\n    t.X = 722;\n    t.Y = 722;\n    t.Z = 667;\n    t.bracketleft = 333;\n    t.backslash = 278;\n    t.bracketright = 333;\n    t.asciicircum = 581;\n    t.underscore = 500;\n    t.quoteleft = 333;\n    t.a = 500;\n    t.b = 556;\n    t.c = 444;\n    t.d = 556;\n    t.e = 444;\n    t.f = 333;\n    t.g = 500;\n    t.h = 556;\n    t.i = 278;\n    t.j = 333;\n    t.k = 556;\n    t.l = 278;\n    t.m = 833;\n    t.n = 556;\n    t.o = 500;\n    t.p = 556;\n    t.q = 556;\n    t.r = 444;\n    t.s = 389;\n    t.t = 333;\n    t.u = 556;\n    t.v = 500;\n    t.w = 722;\n    t.x = 500;\n    t.y = 500;\n    t.z = 444;\n    t.braceleft = 394;\n    t.bar = 220;\n    t.braceright = 394;\n    t.asciitilde = 520;\n    t.exclamdown = 333;\n    t.cent = 500;\n    t.sterling = 500;\n    t.fraction = 167;\n    t.yen = 500;\n    t.florin = 500;\n    t.section = 500;\n    t.currency = 500;\n    t.quotesingle = 278;\n    t.quotedblleft = 500;\n    t.guillemotleft = 500;\n    t.guilsinglleft = 333;\n    t.guilsinglright = 333;\n    t.fi = 556;\n    t.fl = 556;\n    t.endash = 500;\n    t.dagger = 500;\n    t.daggerdbl = 500;\n    t.periodcentered = 250;\n    t.paragraph = 540;\n    t.bullet = 350;\n    t.quotesinglbase = 333;\n    t.quotedblbase = 500;\n    t.quotedblright = 500;\n    t.guillemotright = 500;\n    t.ellipsis = 1000;\n    t.perthousand = 1000;\n    t.questiondown = 500;\n    t.grave = 333;\n    t.acute = 333;\n    t.circumflex = 333;\n    t.tilde = 333;\n    t.macron = 333;\n    t.breve = 333;\n    t.dotaccent = 333;\n    t.dieresis = 333;\n    t.ring = 333;\n    t.cedilla = 333;\n    t.hungarumlaut = 333;\n    t.ogonek = 333;\n    t.caron = 333;\n    t.emdash = 1000;\n    t.AE = 1000;\n    t.ordfeminine = 300;\n    t.Lslash = 667;\n    t.Oslash = 778;\n    t.OE = 1000;\n    t.ordmasculine = 330;\n    t.ae = 722;\n    t.dotlessi = 278;\n    t.lslash = 278;\n    t.oslash = 500;\n    t.oe = 722;\n    t.germandbls = 556;\n    t.Idieresis = 389;\n    t.eacute = 444;\n    t.abreve = 500;\n    t.uhungarumlaut = 556;\n    t.ecaron = 444;\n    t.Ydieresis = 722;\n    t.divide = 570;\n    t.Yacute = 722;\n    t.Acircumflex = 722;\n    t.aacute = 500;\n    t.Ucircumflex = 722;\n    t.yacute = 500;\n    t.scommaaccent = 389;\n    t.ecircumflex = 444;\n    t.Uring = 722;\n    t.Udieresis = 722;\n    t.aogonek = 500;\n    t.Uacute = 722;\n    t.uogonek = 556;\n    t.Edieresis = 667;\n    t.Dcroat = 722;\n    t.commaaccent = 250;\n    t.copyright = 747;\n    t.Emacron = 667;\n    t.ccaron = 444;\n    t.aring = 500;\n    t.Ncommaaccent = 722;\n    t.lacute = 278;\n    t.agrave = 500;\n    t.Tcommaaccent = 667;\n    t.Cacute = 722;\n    t.atilde = 500;\n    t.Edotaccent = 667;\n    t.scaron = 389;\n    t.scedilla = 389;\n    t.iacute = 278;\n    t.lozenge = 494;\n    t.Rcaron = 722;\n    t.Gcommaaccent = 778;\n    t.ucircumflex = 556;\n    t.acircumflex = 500;\n    t.Amacron = 722;\n    t.rcaron = 444;\n    t.ccedilla = 444;\n    t.Zdotaccent = 667;\n    t.Thorn = 611;\n    t.Omacron = 778;\n    t.Racute = 722;\n    t.Sacute = 556;\n    t.dcaron = 672;\n    t.Umacron = 722;\n    t.uring = 556;\n    t.threesuperior = 300;\n    t.Ograve = 778;\n    t.Agrave = 722;\n    t.Abreve = 722;\n    t.multiply = 570;\n    t.uacute = 556;\n    t.Tcaron = 667;\n    t.partialdiff = 494;\n    t.ydieresis = 500;\n    t.Nacute = 722;\n    t.icircumflex = 278;\n    t.Ecircumflex = 667;\n    t.adieresis = 500;\n    t.edieresis = 444;\n    t.cacute = 444;\n    t.nacute = 556;\n    t.umacron = 556;\n    t.Ncaron = 722;\n    t.Iacute = 389;\n    t.plusminus = 570;\n    t.brokenbar = 220;\n    t.registered = 747;\n    t.Gbreve = 778;\n    t.Idotaccent = 389;\n    t.summation = 600;\n    t.Egrave = 667;\n    t.racute = 444;\n    t.omacron = 500;\n    t.Zacute = 667;\n    t.Zcaron = 667;\n    t.greaterequal = 549;\n    t.Eth = 722;\n    t.Ccedilla = 722;\n    t.lcommaaccent = 278;\n    t.tcaron = 416;\n    t.eogonek = 444;\n    t.Uogonek = 722;\n    t.Aacute = 722;\n    t.Adieresis = 722;\n    t.egrave = 444;\n    t.zacute = 444;\n    t.iogonek = 278;\n    t.Oacute = 778;\n    t.oacute = 500;\n    t.amacron = 500;\n    t.sacute = 389;\n    t.idieresis = 278;\n    t.Ocircumflex = 778;\n    t.Ugrave = 722;\n    t.Delta = 612;\n    t.thorn = 556;\n    t.twosuperior = 300;\n    t.Odieresis = 778;\n    t.mu = 556;\n    t.igrave = 278;\n    t.ohungarumlaut = 500;\n    t.Eogonek = 667;\n    t.dcroat = 556;\n    t.threequarters = 750;\n    t.Scedilla = 556;\n    t.lcaron = 394;\n    t.Kcommaaccent = 778;\n    t.Lacute = 667;\n    t.trademark = 1000;\n    t.edotaccent = 444;\n    t.Igrave = 389;\n    t.Imacron = 389;\n    t.Lcaron = 667;\n    t.onehalf = 750;\n    t.lessequal = 549;\n    t.ocircumflex = 500;\n    t.ntilde = 556;\n    t.Uhungarumlaut = 722;\n    t.Eacute = 667;\n    t.emacron = 444;\n    t.gbreve = 500;\n    t.onequarter = 750;\n    t.Scaron = 556;\n    t.Scommaaccent = 556;\n    t.Ohungarumlaut = 778;\n    t.degree = 400;\n    t.ograve = 500;\n    t.Ccaron = 722;\n    t.ugrave = 556;\n    t.radical = 549;\n    t.Dcaron = 722;\n    t.rcommaaccent = 444;\n    t.Ntilde = 722;\n    t.otilde = 500;\n    t.Rcommaaccent = 722;\n    t.Lcommaaccent = 667;\n    t.Atilde = 722;\n    t.Aogonek = 722;\n    t.Aring = 722;\n    t.Otilde = 778;\n    t.zdotaccent = 444;\n    t.Ecaron = 667;\n    t.Iogonek = 389;\n    t.kcommaaccent = 556;\n    t.minus = 570;\n    t.Icircumflex = 389;\n    t.ncaron = 556;\n    t.tcommaaccent = 333;\n    t.logicalnot = 570;\n    t.odieresis = 500;\n    t.udieresis = 556;\n    t.notequal = 549;\n    t.gcommaaccent = 500;\n    t.eth = 500;\n    t.zcaron = 444;\n    t.ncommaaccent = 556;\n    t.onesuperior = 300;\n    t.imacron = 278;\n    t.Euro = 500;\n  });\n  t[\"Times-BoldItalic\"] = getLookupTableFactory(function (t) {\n    t.space = 250;\n    t.exclam = 389;\n    t.quotedbl = 555;\n    t.numbersign = 500;\n    t.dollar = 500;\n    t.percent = 833;\n    t.ampersand = 778;\n    t.quoteright = 333;\n    t.parenleft = 333;\n    t.parenright = 333;\n    t.asterisk = 500;\n    t.plus = 570;\n    t.comma = 250;\n    t.hyphen = 333;\n    t.period = 250;\n    t.slash = 278;\n    t.zero = 500;\n    t.one = 500;\n    t.two = 500;\n    t.three = 500;\n    t.four = 500;\n    t.five = 500;\n    t.six = 500;\n    t.seven = 500;\n    t.eight = 500;\n    t.nine = 500;\n    t.colon = 333;\n    t.semicolon = 333;\n    t.less = 570;\n    t.equal = 570;\n    t.greater = 570;\n    t.question = 500;\n    t.at = 832;\n    t.A = 667;\n    t.B = 667;\n    t.C = 667;\n    t.D = 722;\n    t.E = 667;\n    t.F = 667;\n    t.G = 722;\n    t.H = 778;\n    t.I = 389;\n    t.J = 500;\n    t.K = 667;\n    t.L = 611;\n    t.M = 889;\n    t.N = 722;\n    t.O = 722;\n    t.P = 611;\n    t.Q = 722;\n    t.R = 667;\n    t.S = 556;\n    t.T = 611;\n    t.U = 722;\n    t.V = 667;\n    t.W = 889;\n    t.X = 667;\n    t.Y = 611;\n    t.Z = 611;\n    t.bracketleft = 333;\n    t.backslash = 278;\n    t.bracketright = 333;\n    t.asciicircum = 570;\n    t.underscore = 500;\n    t.quoteleft = 333;\n    t.a = 500;\n    t.b = 500;\n    t.c = 444;\n    t.d = 500;\n    t.e = 444;\n    t.f = 333;\n    t.g = 500;\n    t.h = 556;\n    t.i = 278;\n    t.j = 278;\n    t.k = 500;\n    t.l = 278;\n    t.m = 778;\n    t.n = 556;\n    t.o = 500;\n    t.p = 500;\n    t.q = 500;\n    t.r = 389;\n    t.s = 389;\n    t.t = 278;\n    t.u = 556;\n    t.v = 444;\n    t.w = 667;\n    t.x = 500;\n    t.y = 444;\n    t.z = 389;\n    t.braceleft = 348;\n    t.bar = 220;\n    t.braceright = 348;\n    t.asciitilde = 570;\n    t.exclamdown = 389;\n    t.cent = 500;\n    t.sterling = 500;\n    t.fraction = 167;\n    t.yen = 500;\n    t.florin = 500;\n    t.section = 500;\n    t.currency = 500;\n    t.quotesingle = 278;\n    t.quotedblleft = 500;\n    t.guillemotleft = 500;\n    t.guilsinglleft = 333;\n    t.guilsinglright = 333;\n    t.fi = 556;\n    t.fl = 556;\n    t.endash = 500;\n    t.dagger = 500;\n    t.daggerdbl = 500;\n    t.periodcentered = 250;\n    t.paragraph = 500;\n    t.bullet = 350;\n    t.quotesinglbase = 333;\n    t.quotedblbase = 500;\n    t.quotedblright = 500;\n    t.guillemotright = 500;\n    t.ellipsis = 1000;\n    t.perthousand = 1000;\n    t.questiondown = 500;\n    t.grave = 333;\n    t.acute = 333;\n    t.circumflex = 333;\n    t.tilde = 333;\n    t.macron = 333;\n    t.breve = 333;\n    t.dotaccent = 333;\n    t.dieresis = 333;\n    t.ring = 333;\n    t.cedilla = 333;\n    t.hungarumlaut = 333;\n    t.ogonek = 333;\n    t.caron = 333;\n    t.emdash = 1000;\n    t.AE = 944;\n    t.ordfeminine = 266;\n    t.Lslash = 611;\n    t.Oslash = 722;\n    t.OE = 944;\n    t.ordmasculine = 300;\n    t.ae = 722;\n    t.dotlessi = 278;\n    t.lslash = 278;\n    t.oslash = 500;\n    t.oe = 722;\n    t.germandbls = 500;\n    t.Idieresis = 389;\n    t.eacute = 444;\n    t.abreve = 500;\n    t.uhungarumlaut = 556;\n    t.ecaron = 444;\n    t.Ydieresis = 611;\n    t.divide = 570;\n    t.Yacute = 611;\n    t.Acircumflex = 667;\n    t.aacute = 500;\n    t.Ucircumflex = 722;\n    t.yacute = 444;\n    t.scommaaccent = 389;\n    t.ecircumflex = 444;\n    t.Uring = 722;\n    t.Udieresis = 722;\n    t.aogonek = 500;\n    t.Uacute = 722;\n    t.uogonek = 556;\n    t.Edieresis = 667;\n    t.Dcroat = 722;\n    t.commaaccent = 250;\n    t.copyright = 747;\n    t.Emacron = 667;\n    t.ccaron = 444;\n    t.aring = 500;\n    t.Ncommaaccent = 722;\n    t.lacute = 278;\n    t.agrave = 500;\n    t.Tcommaaccent = 611;\n    t.Cacute = 667;\n    t.atilde = 500;\n    t.Edotaccent = 667;\n    t.scaron = 389;\n    t.scedilla = 389;\n    t.iacute = 278;\n    t.lozenge = 494;\n    t.Rcaron = 667;\n    t.Gcommaaccent = 722;\n    t.ucircumflex = 556;\n    t.acircumflex = 500;\n    t.Amacron = 667;\n    t.rcaron = 389;\n    t.ccedilla = 444;\n    t.Zdotaccent = 611;\n    t.Thorn = 611;\n    t.Omacron = 722;\n    t.Racute = 667;\n    t.Sacute = 556;\n    t.dcaron = 608;\n    t.Umacron = 722;\n    t.uring = 556;\n    t.threesuperior = 300;\n    t.Ograve = 722;\n    t.Agrave = 667;\n    t.Abreve = 667;\n    t.multiply = 570;\n    t.uacute = 556;\n    t.Tcaron = 611;\n    t.partialdiff = 494;\n    t.ydieresis = 444;\n    t.Nacute = 722;\n    t.icircumflex = 278;\n    t.Ecircumflex = 667;\n    t.adieresis = 500;\n    t.edieresis = 444;\n    t.cacute = 444;\n    t.nacute = 556;\n    t.umacron = 556;\n    t.Ncaron = 722;\n    t.Iacute = 389;\n    t.plusminus = 570;\n    t.brokenbar = 220;\n    t.registered = 747;\n    t.Gbreve = 722;\n    t.Idotaccent = 389;\n    t.summation = 600;\n    t.Egrave = 667;\n    t.racute = 389;\n    t.omacron = 500;\n    t.Zacute = 611;\n    t.Zcaron = 611;\n    t.greaterequal = 549;\n    t.Eth = 722;\n    t.Ccedilla = 667;\n    t.lcommaaccent = 278;\n    t.tcaron = 366;\n    t.eogonek = 444;\n    t.Uogonek = 722;\n    t.Aacute = 667;\n    t.Adieresis = 667;\n    t.egrave = 444;\n    t.zacute = 389;\n    t.iogonek = 278;\n    t.Oacute = 722;\n    t.oacute = 500;\n    t.amacron = 500;\n    t.sacute = 389;\n    t.idieresis = 278;\n    t.Ocircumflex = 722;\n    t.Ugrave = 722;\n    t.Delta = 612;\n    t.thorn = 500;\n    t.twosuperior = 300;\n    t.Odieresis = 722;\n    t.mu = 576;\n    t.igrave = 278;\n    t.ohungarumlaut = 500;\n    t.Eogonek = 667;\n    t.dcroat = 500;\n    t.threequarters = 750;\n    t.Scedilla = 556;\n    t.lcaron = 382;\n    t.Kcommaaccent = 667;\n    t.Lacute = 611;\n    t.trademark = 1000;\n    t.edotaccent = 444;\n    t.Igrave = 389;\n    t.Imacron = 389;\n    t.Lcaron = 611;\n    t.onehalf = 750;\n    t.lessequal = 549;\n    t.ocircumflex = 500;\n    t.ntilde = 556;\n    t.Uhungarumlaut = 722;\n    t.Eacute = 667;\n    t.emacron = 444;\n    t.gbreve = 500;\n    t.onequarter = 750;\n    t.Scaron = 556;\n    t.Scommaaccent = 556;\n    t.Ohungarumlaut = 722;\n    t.degree = 400;\n    t.ograve = 500;\n    t.Ccaron = 667;\n    t.ugrave = 556;\n    t.radical = 549;\n    t.Dcaron = 722;\n    t.rcommaaccent = 389;\n    t.Ntilde = 722;\n    t.otilde = 500;\n    t.Rcommaaccent = 667;\n    t.Lcommaaccent = 611;\n    t.Atilde = 667;\n    t.Aogonek = 667;\n    t.Aring = 667;\n    t.Otilde = 722;\n    t.zdotaccent = 389;\n    t.Ecaron = 667;\n    t.Iogonek = 389;\n    t.kcommaaccent = 500;\n    t.minus = 606;\n    t.Icircumflex = 389;\n    t.ncaron = 556;\n    t.tcommaaccent = 278;\n    t.logicalnot = 606;\n    t.odieresis = 500;\n    t.udieresis = 556;\n    t.notequal = 549;\n    t.gcommaaccent = 500;\n    t.eth = 500;\n    t.zcaron = 389;\n    t.ncommaaccent = 556;\n    t.onesuperior = 300;\n    t.imacron = 278;\n    t.Euro = 500;\n  });\n  t[\"Times-Italic\"] = getLookupTableFactory(function (t) {\n    t.space = 250;\n    t.exclam = 333;\n    t.quotedbl = 420;\n    t.numbersign = 500;\n    t.dollar = 500;\n    t.percent = 833;\n    t.ampersand = 778;\n    t.quoteright = 333;\n    t.parenleft = 333;\n    t.parenright = 333;\n    t.asterisk = 500;\n    t.plus = 675;\n    t.comma = 250;\n    t.hyphen = 333;\n    t.period = 250;\n    t.slash = 278;\n    t.zero = 500;\n    t.one = 500;\n    t.two = 500;\n    t.three = 500;\n    t.four = 500;\n    t.five = 500;\n    t.six = 500;\n    t.seven = 500;\n    t.eight = 500;\n    t.nine = 500;\n    t.colon = 333;\n    t.semicolon = 333;\n    t.less = 675;\n    t.equal = 675;\n    t.greater = 675;\n    t.question = 500;\n    t.at = 920;\n    t.A = 611;\n    t.B = 611;\n    t.C = 667;\n    t.D = 722;\n    t.E = 611;\n    t.F = 611;\n    t.G = 722;\n    t.H = 722;\n    t.I = 333;\n    t.J = 444;\n    t.K = 667;\n    t.L = 556;\n    t.M = 833;\n    t.N = 667;\n    t.O = 722;\n    t.P = 611;\n    t.Q = 722;\n    t.R = 611;\n    t.S = 500;\n    t.T = 556;\n    t.U = 722;\n    t.V = 611;\n    t.W = 833;\n    t.X = 611;\n    t.Y = 556;\n    t.Z = 556;\n    t.bracketleft = 389;\n    t.backslash = 278;\n    t.bracketright = 389;\n    t.asciicircum = 422;\n    t.underscore = 500;\n    t.quoteleft = 333;\n    t.a = 500;\n    t.b = 500;\n    t.c = 444;\n    t.d = 500;\n    t.e = 444;\n    t.f = 278;\n    t.g = 500;\n    t.h = 500;\n    t.i = 278;\n    t.j = 278;\n    t.k = 444;\n    t.l = 278;\n    t.m = 722;\n    t.n = 500;\n    t.o = 500;\n    t.p = 500;\n    t.q = 500;\n    t.r = 389;\n    t.s = 389;\n    t.t = 278;\n    t.u = 500;\n    t.v = 444;\n    t.w = 667;\n    t.x = 444;\n    t.y = 444;\n    t.z = 389;\n    t.braceleft = 400;\n    t.bar = 275;\n    t.braceright = 400;\n    t.asciitilde = 541;\n    t.exclamdown = 389;\n    t.cent = 500;\n    t.sterling = 500;\n    t.fraction = 167;\n    t.yen = 500;\n    t.florin = 500;\n    t.section = 500;\n    t.currency = 500;\n    t.quotesingle = 214;\n    t.quotedblleft = 556;\n    t.guillemotleft = 500;\n    t.guilsinglleft = 333;\n    t.guilsinglright = 333;\n    t.fi = 500;\n    t.fl = 500;\n    t.endash = 500;\n    t.dagger = 500;\n    t.daggerdbl = 500;\n    t.periodcentered = 250;\n    t.paragraph = 523;\n    t.bullet = 350;\n    t.quotesinglbase = 333;\n    t.quotedblbase = 556;\n    t.quotedblright = 556;\n    t.guillemotright = 500;\n    t.ellipsis = 889;\n    t.perthousand = 1000;\n    t.questiondown = 500;\n    t.grave = 333;\n    t.acute = 333;\n    t.circumflex = 333;\n    t.tilde = 333;\n    t.macron = 333;\n    t.breve = 333;\n    t.dotaccent = 333;\n    t.dieresis = 333;\n    t.ring = 333;\n    t.cedilla = 333;\n    t.hungarumlaut = 333;\n    t.ogonek = 333;\n    t.caron = 333;\n    t.emdash = 889;\n    t.AE = 889;\n    t.ordfeminine = 276;\n    t.Lslash = 556;\n    t.Oslash = 722;\n    t.OE = 944;\n    t.ordmasculine = 310;\n    t.ae = 667;\n    t.dotlessi = 278;\n    t.lslash = 278;\n    t.oslash = 500;\n    t.oe = 667;\n    t.germandbls = 500;\n    t.Idieresis = 333;\n    t.eacute = 444;\n    t.abreve = 500;\n    t.uhungarumlaut = 500;\n    t.ecaron = 444;\n    t.Ydieresis = 556;\n    t.divide = 675;\n    t.Yacute = 556;\n    t.Acircumflex = 611;\n    t.aacute = 500;\n    t.Ucircumflex = 722;\n    t.yacute = 444;\n    t.scommaaccent = 389;\n    t.ecircumflex = 444;\n    t.Uring = 722;\n    t.Udieresis = 722;\n    t.aogonek = 500;\n    t.Uacute = 722;\n    t.uogonek = 500;\n    t.Edieresis = 611;\n    t.Dcroat = 722;\n    t.commaaccent = 250;\n    t.copyright = 760;\n    t.Emacron = 611;\n    t.ccaron = 444;\n    t.aring = 500;\n    t.Ncommaaccent = 667;\n    t.lacute = 278;\n    t.agrave = 500;\n    t.Tcommaaccent = 556;\n    t.Cacute = 667;\n    t.atilde = 500;\n    t.Edotaccent = 611;\n    t.scaron = 389;\n    t.scedilla = 389;\n    t.iacute = 278;\n    t.lozenge = 471;\n    t.Rcaron = 611;\n    t.Gcommaaccent = 722;\n    t.ucircumflex = 500;\n    t.acircumflex = 500;\n    t.Amacron = 611;\n    t.rcaron = 389;\n    t.ccedilla = 444;\n    t.Zdotaccent = 556;\n    t.Thorn = 611;\n    t.Omacron = 722;\n    t.Racute = 611;\n    t.Sacute = 500;\n    t.dcaron = 544;\n    t.Umacron = 722;\n    t.uring = 500;\n    t.threesuperior = 300;\n    t.Ograve = 722;\n    t.Agrave = 611;\n    t.Abreve = 611;\n    t.multiply = 675;\n    t.uacute = 500;\n    t.Tcaron = 556;\n    t.partialdiff = 476;\n    t.ydieresis = 444;\n    t.Nacute = 667;\n    t.icircumflex = 278;\n    t.Ecircumflex = 611;\n    t.adieresis = 500;\n    t.edieresis = 444;\n    t.cacute = 444;\n    t.nacute = 500;\n    t.umacron = 500;\n    t.Ncaron = 667;\n    t.Iacute = 333;\n    t.plusminus = 675;\n    t.brokenbar = 275;\n    t.registered = 760;\n    t.Gbreve = 722;\n    t.Idotaccent = 333;\n    t.summation = 600;\n    t.Egrave = 611;\n    t.racute = 389;\n    t.omacron = 500;\n    t.Zacute = 556;\n    t.Zcaron = 556;\n    t.greaterequal = 549;\n    t.Eth = 722;\n    t.Ccedilla = 667;\n    t.lcommaaccent = 278;\n    t.tcaron = 300;\n    t.eogonek = 444;\n    t.Uogonek = 722;\n    t.Aacute = 611;\n    t.Adieresis = 611;\n    t.egrave = 444;\n    t.zacute = 389;\n    t.iogonek = 278;\n    t.Oacute = 722;\n    t.oacute = 500;\n    t.amacron = 500;\n    t.sacute = 389;\n    t.idieresis = 278;\n    t.Ocircumflex = 722;\n    t.Ugrave = 722;\n    t.Delta = 612;\n    t.thorn = 500;\n    t.twosuperior = 300;\n    t.Odieresis = 722;\n    t.mu = 500;\n    t.igrave = 278;\n    t.ohungarumlaut = 500;\n    t.Eogonek = 611;\n    t.dcroat = 500;\n    t.threequarters = 750;\n    t.Scedilla = 500;\n    t.lcaron = 300;\n    t.Kcommaaccent = 667;\n    t.Lacute = 556;\n    t.trademark = 980;\n    t.edotaccent = 444;\n    t.Igrave = 333;\n    t.Imacron = 333;\n    t.Lcaron = 611;\n    t.onehalf = 750;\n    t.lessequal = 549;\n    t.ocircumflex = 500;\n    t.ntilde = 500;\n    t.Uhungarumlaut = 722;\n    t.Eacute = 611;\n    t.emacron = 444;\n    t.gbreve = 500;\n    t.onequarter = 750;\n    t.Scaron = 500;\n    t.Scommaaccent = 500;\n    t.Ohungarumlaut = 722;\n    t.degree = 400;\n    t.ograve = 500;\n    t.Ccaron = 667;\n    t.ugrave = 500;\n    t.radical = 453;\n    t.Dcaron = 722;\n    t.rcommaaccent = 389;\n    t.Ntilde = 667;\n    t.otilde = 500;\n    t.Rcommaaccent = 611;\n    t.Lcommaaccent = 556;\n    t.Atilde = 611;\n    t.Aogonek = 611;\n    t.Aring = 611;\n    t.Otilde = 722;\n    t.zdotaccent = 389;\n    t.Ecaron = 611;\n    t.Iogonek = 333;\n    t.kcommaaccent = 444;\n    t.minus = 675;\n    t.Icircumflex = 333;\n    t.ncaron = 500;\n    t.tcommaaccent = 278;\n    t.logicalnot = 675;\n    t.odieresis = 500;\n    t.udieresis = 500;\n    t.notequal = 549;\n    t.gcommaaccent = 500;\n    t.eth = 500;\n    t.zcaron = 389;\n    t.ncommaaccent = 500;\n    t.onesuperior = 300;\n    t.imacron = 278;\n    t.Euro = 500;\n  });\n  t.ZapfDingbats = getLookupTableFactory(function (t) {\n    t.space = 278;\n    t.a1 = 974;\n    t.a2 = 961;\n    t.a202 = 974;\n    t.a3 = 980;\n    t.a4 = 719;\n    t.a5 = 789;\n    t.a119 = 790;\n    t.a118 = 791;\n    t.a117 = 690;\n    t.a11 = 960;\n    t.a12 = 939;\n    t.a13 = 549;\n    t.a14 = 855;\n    t.a15 = 911;\n    t.a16 = 933;\n    t.a105 = 911;\n    t.a17 = 945;\n    t.a18 = 974;\n    t.a19 = 755;\n    t.a20 = 846;\n    t.a21 = 762;\n    t.a22 = 761;\n    t.a23 = 571;\n    t.a24 = 677;\n    t.a25 = 763;\n    t.a26 = 760;\n    t.a27 = 759;\n    t.a28 = 754;\n    t.a6 = 494;\n    t.a7 = 552;\n    t.a8 = 537;\n    t.a9 = 577;\n    t.a10 = 692;\n    t.a29 = 786;\n    t.a30 = 788;\n    t.a31 = 788;\n    t.a32 = 790;\n    t.a33 = 793;\n    t.a34 = 794;\n    t.a35 = 816;\n    t.a36 = 823;\n    t.a37 = 789;\n    t.a38 = 841;\n    t.a39 = 823;\n    t.a40 = 833;\n    t.a41 = 816;\n    t.a42 = 831;\n    t.a43 = 923;\n    t.a44 = 744;\n    t.a45 = 723;\n    t.a46 = 749;\n    t.a47 = 790;\n    t.a48 = 792;\n    t.a49 = 695;\n    t.a50 = 776;\n    t.a51 = 768;\n    t.a52 = 792;\n    t.a53 = 759;\n    t.a54 = 707;\n    t.a55 = 708;\n    t.a56 = 682;\n    t.a57 = 701;\n    t.a58 = 826;\n    t.a59 = 815;\n    t.a60 = 789;\n    t.a61 = 789;\n    t.a62 = 707;\n    t.a63 = 687;\n    t.a64 = 696;\n    t.a65 = 689;\n    t.a66 = 786;\n    t.a67 = 787;\n    t.a68 = 713;\n    t.a69 = 791;\n    t.a70 = 785;\n    t.a71 = 791;\n    t.a72 = 873;\n    t.a73 = 761;\n    t.a74 = 762;\n    t.a203 = 762;\n    t.a75 = 759;\n    t.a204 = 759;\n    t.a76 = 892;\n    t.a77 = 892;\n    t.a78 = 788;\n    t.a79 = 784;\n    t.a81 = 438;\n    t.a82 = 138;\n    t.a83 = 277;\n    t.a84 = 415;\n    t.a97 = 392;\n    t.a98 = 392;\n    t.a99 = 668;\n    t.a100 = 668;\n    t.a89 = 390;\n    t.a90 = 390;\n    t.a93 = 317;\n    t.a94 = 317;\n    t.a91 = 276;\n    t.a92 = 276;\n    t.a205 = 509;\n    t.a85 = 509;\n    t.a206 = 410;\n    t.a86 = 410;\n    t.a87 = 234;\n    t.a88 = 234;\n    t.a95 = 334;\n    t.a96 = 334;\n    t.a101 = 732;\n    t.a102 = 544;\n    t.a103 = 544;\n    t.a104 = 910;\n    t.a106 = 667;\n    t.a107 = 760;\n    t.a108 = 760;\n    t.a112 = 776;\n    t.a111 = 595;\n    t.a110 = 694;\n    t.a109 = 626;\n    t.a120 = 788;\n    t.a121 = 788;\n    t.a122 = 788;\n    t.a123 = 788;\n    t.a124 = 788;\n    t.a125 = 788;\n    t.a126 = 788;\n    t.a127 = 788;\n    t.a128 = 788;\n    t.a129 = 788;\n    t.a130 = 788;\n    t.a131 = 788;\n    t.a132 = 788;\n    t.a133 = 788;\n    t.a134 = 788;\n    t.a135 = 788;\n    t.a136 = 788;\n    t.a137 = 788;\n    t.a138 = 788;\n    t.a139 = 788;\n    t.a140 = 788;\n    t.a141 = 788;\n    t.a142 = 788;\n    t.a143 = 788;\n    t.a144 = 788;\n    t.a145 = 788;\n    t.a146 = 788;\n    t.a147 = 788;\n    t.a148 = 788;\n    t.a149 = 788;\n    t.a150 = 788;\n    t.a151 = 788;\n    t.a152 = 788;\n    t.a153 = 788;\n    t.a154 = 788;\n    t.a155 = 788;\n    t.a156 = 788;\n    t.a157 = 788;\n    t.a158 = 788;\n    t.a159 = 788;\n    t.a160 = 894;\n    t.a161 = 838;\n    t.a163 = 1016;\n    t.a164 = 458;\n    t.a196 = 748;\n    t.a165 = 924;\n    t.a192 = 748;\n    t.a166 = 918;\n    t.a167 = 927;\n    t.a168 = 928;\n    t.a169 = 928;\n    t.a170 = 834;\n    t.a171 = 873;\n    t.a172 = 828;\n    t.a173 = 924;\n    t.a162 = 924;\n    t.a174 = 917;\n    t.a175 = 930;\n    t.a176 = 931;\n    t.a177 = 463;\n    t.a178 = 883;\n    t.a179 = 836;\n    t.a193 = 836;\n    t.a180 = 867;\n    t.a199 = 867;\n    t.a181 = 696;\n    t.a200 = 696;\n    t.a182 = 874;\n    t.a201 = 874;\n    t.a183 = 760;\n    t.a184 = 946;\n    t.a197 = 771;\n    t.a185 = 865;\n    t.a194 = 771;\n    t.a198 = 888;\n    t.a186 = 967;\n    t.a195 = 888;\n    t.a187 = 831;\n    t.a188 = 873;\n    t.a189 = 927;\n    t.a190 = 970;\n    t.a191 = 918;\n  });\n});\nconst getFontBasicMetrics = getLookupTableFactory(function (t) {\n  t.Courier = {\n    ascent: 629,\n    descent: -157,\n    capHeight: 562,\n    xHeight: -426\n  };\n  t[\"Courier-Bold\"] = {\n    ascent: 629,\n    descent: -157,\n    capHeight: 562,\n    xHeight: 439\n  };\n  t[\"Courier-Oblique\"] = {\n    ascent: 629,\n    descent: -157,\n    capHeight: 562,\n    xHeight: 426\n  };\n  t[\"Courier-BoldOblique\"] = {\n    ascent: 629,\n    descent: -157,\n    capHeight: 562,\n    xHeight: 426\n  };\n  t.Helvetica = {\n    ascent: 718,\n    descent: -207,\n    capHeight: 718,\n    xHeight: 523\n  };\n  t[\"Helvetica-Bold\"] = {\n    ascent: 718,\n    descent: -207,\n    capHeight: 718,\n    xHeight: 532\n  };\n  t[\"Helvetica-Oblique\"] = {\n    ascent: 718,\n    descent: -207,\n    capHeight: 718,\n    xHeight: 523\n  };\n  t[\"Helvetica-BoldOblique\"] = {\n    ascent: 718,\n    descent: -207,\n    capHeight: 718,\n    xHeight: 532\n  };\n  t[\"Times-Roman\"] = {\n    ascent: 683,\n    descent: -217,\n    capHeight: 662,\n    xHeight: 450\n  };\n  t[\"Times-Bold\"] = {\n    ascent: 683,\n    descent: -217,\n    capHeight: 676,\n    xHeight: 461\n  };\n  t[\"Times-Italic\"] = {\n    ascent: 683,\n    descent: -217,\n    capHeight: 653,\n    xHeight: 441\n  };\n  t[\"Times-BoldItalic\"] = {\n    ascent: 683,\n    descent: -217,\n    capHeight: 669,\n    xHeight: 462\n  };\n  t.Symbol = {\n    ascent: Math.NaN,\n    descent: Math.NaN,\n    capHeight: Math.NaN,\n    xHeight: Math.NaN\n  };\n  t.ZapfDingbats = {\n    ascent: Math.NaN,\n    descent: Math.NaN,\n    capHeight: Math.NaN,\n    xHeight: Math.NaN\n  };\n});\n\n;// CONCATENATED MODULE: ./src/core/glyf.js\nconst ON_CURVE_POINT = 1 << 0;\nconst X_SHORT_VECTOR = 1 << 1;\nconst Y_SHORT_VECTOR = 1 << 2;\nconst REPEAT_FLAG = 1 << 3;\nconst X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR = 1 << 4;\nconst Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR = 1 << 5;\nconst OVERLAP_SIMPLE = 1 << 6;\nconst ARG_1_AND_2_ARE_WORDS = 1 << 0;\nconst ARGS_ARE_XY_VALUES = 1 << 1;\nconst WE_HAVE_A_SCALE = 1 << 3;\nconst MORE_COMPONENTS = 1 << 5;\nconst WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;\nconst WE_HAVE_A_TWO_BY_TWO = 1 << 7;\nconst WE_HAVE_INSTRUCTIONS = 1 << 8;\nclass GlyfTable {\n  constructor({\n    glyfTable,\n    isGlyphLocationsLong,\n    locaTable,\n    numGlyphs\n  }) {\n    this.glyphs = [];\n    const loca = new DataView(locaTable.buffer, locaTable.byteOffset, locaTable.byteLength);\n    const glyf = new DataView(glyfTable.buffer, glyfTable.byteOffset, glyfTable.byteLength);\n    const offsetSize = isGlyphLocationsLong ? 4 : 2;\n    let prev = isGlyphLocationsLong ? loca.getUint32(0) : 2 * loca.getUint16(0);\n    let pos = 0;\n    for (let i = 0; i < numGlyphs; i++) {\n      pos += offsetSize;\n      const next = isGlyphLocationsLong ? loca.getUint32(pos) : 2 * loca.getUint16(pos);\n      if (next === prev) {\n        this.glyphs.push(new Glyph({}));\n        continue;\n      }\n      const glyph = Glyph.parse(prev, glyf);\n      this.glyphs.push(glyph);\n      prev = next;\n    }\n  }\n  getSize() {\n    return this.glyphs.reduce((a, g) => {\n      const size = g.getSize();\n      return a + (size + 3 & ~3);\n    }, 0);\n  }\n  write() {\n    const totalSize = this.getSize();\n    const glyfTable = new DataView(new ArrayBuffer(totalSize));\n    const isLocationLong = totalSize > 0x1fffe;\n    const offsetSize = isLocationLong ? 4 : 2;\n    const locaTable = new DataView(new ArrayBuffer((this.glyphs.length + 1) * offsetSize));\n    if (isLocationLong) {\n      locaTable.setUint32(0, 0);\n    } else {\n      locaTable.setUint16(0, 0);\n    }\n    let pos = 0;\n    let locaIndex = 0;\n    for (const glyph of this.glyphs) {\n      pos += glyph.write(pos, glyfTable);\n      pos = pos + 3 & ~3;\n      locaIndex += offsetSize;\n      if (isLocationLong) {\n        locaTable.setUint32(locaIndex, pos);\n      } else {\n        locaTable.setUint16(locaIndex, pos >> 1);\n      }\n    }\n    return {\n      isLocationLong,\n      loca: new Uint8Array(locaTable.buffer),\n      glyf: new Uint8Array(glyfTable.buffer)\n    };\n  }\n  scale(factors) {\n    for (let i = 0, ii = this.glyphs.length; i < ii; i++) {\n      this.glyphs[i].scale(factors[i]);\n    }\n  }\n}\nclass Glyph {\n  constructor({\n    header = null,\n    simple = null,\n    composites = null\n  }) {\n    this.header = header;\n    this.simple = simple;\n    this.composites = composites;\n  }\n  static parse(pos, glyf) {\n    const [read, header] = GlyphHeader.parse(pos, glyf);\n    pos += read;\n    if (header.numberOfContours < 0) {\n      const composites = [];\n      while (true) {\n        const [n, composite] = CompositeGlyph.parse(pos, glyf);\n        pos += n;\n        composites.push(composite);\n        if (!(composite.flags & MORE_COMPONENTS)) {\n          break;\n        }\n      }\n      return new Glyph({\n        header,\n        composites\n      });\n    }\n    const simple = SimpleGlyph.parse(pos, glyf, header.numberOfContours);\n    return new Glyph({\n      header,\n      simple\n    });\n  }\n  getSize() {\n    if (!this.header) {\n      return 0;\n    }\n    const size = this.simple ? this.simple.getSize() : this.composites.reduce((a, c) => a + c.getSize(), 0);\n    return this.header.getSize() + size;\n  }\n  write(pos, buf) {\n    if (!this.header) {\n      return 0;\n    }\n    const spos = pos;\n    pos += this.header.write(pos, buf);\n    if (this.simple) {\n      pos += this.simple.write(pos, buf);\n    } else {\n      for (const composite of this.composites) {\n        pos += composite.write(pos, buf);\n      }\n    }\n    return pos - spos;\n  }\n  scale(factor) {\n    if (!this.header) {\n      return;\n    }\n    const xMiddle = (this.header.xMin + this.header.xMax) / 2;\n    this.header.scale(xMiddle, factor);\n    if (this.simple) {\n      this.simple.scale(xMiddle, factor);\n    } else {\n      for (const composite of this.composites) {\n        composite.scale(xMiddle, factor);\n      }\n    }\n  }\n}\nclass GlyphHeader {\n  constructor({\n    numberOfContours,\n    xMin,\n    yMin,\n    xMax,\n    yMax\n  }) {\n    this.numberOfContours = numberOfContours;\n    this.xMin = xMin;\n    this.yMin = yMin;\n    this.xMax = xMax;\n    this.yMax = yMax;\n  }\n  static parse(pos, glyf) {\n    return [10, new GlyphHeader({\n      numberOfContours: glyf.getInt16(pos),\n      xMin: glyf.getInt16(pos + 2),\n      yMin: glyf.getInt16(pos + 4),\n      xMax: glyf.getInt16(pos + 6),\n      yMax: glyf.getInt16(pos + 8)\n    })];\n  }\n  getSize() {\n    return 10;\n  }\n  write(pos, buf) {\n    buf.setInt16(pos, this.numberOfContours);\n    buf.setInt16(pos + 2, this.xMin);\n    buf.setInt16(pos + 4, this.yMin);\n    buf.setInt16(pos + 6, this.xMax);\n    buf.setInt16(pos + 8, this.yMax);\n    return 10;\n  }\n  scale(x, factor) {\n    this.xMin = Math.round(x + (this.xMin - x) * factor);\n    this.xMax = Math.round(x + (this.xMax - x) * factor);\n  }\n}\nclass Contour {\n  constructor({\n    flags,\n    xCoordinates,\n    yCoordinates\n  }) {\n    this.xCoordinates = xCoordinates;\n    this.yCoordinates = yCoordinates;\n    this.flags = flags;\n  }\n}\nclass SimpleGlyph {\n  constructor({\n    contours,\n    instructions\n  }) {\n    this.contours = contours;\n    this.instructions = instructions;\n  }\n  static parse(pos, glyf, numberOfContours) {\n    const endPtsOfContours = [];\n    for (let i = 0; i < numberOfContours; i++) {\n      const endPt = glyf.getUint16(pos);\n      pos += 2;\n      endPtsOfContours.push(endPt);\n    }\n    const numberOfPt = endPtsOfContours[numberOfContours - 1] + 1;\n    const instructionLength = glyf.getUint16(pos);\n    pos += 2;\n    const instructions = new Uint8Array(glyf).slice(pos, pos + instructionLength);\n    pos += instructionLength;\n    const flags = [];\n    for (let i = 0; i < numberOfPt; pos++, i++) {\n      let flag = glyf.getUint8(pos);\n      flags.push(flag);\n      if (flag & REPEAT_FLAG) {\n        const count = glyf.getUint8(++pos);\n        flag ^= REPEAT_FLAG;\n        for (let m = 0; m < count; m++) {\n          flags.push(flag);\n        }\n        i += count;\n      }\n    }\n    const allXCoordinates = [];\n    let xCoordinates = [];\n    let yCoordinates = [];\n    let pointFlags = [];\n    const contours = [];\n    let endPtsOfContoursIndex = 0;\n    let lastCoordinate = 0;\n    for (let i = 0; i < numberOfPt; i++) {\n      const flag = flags[i];\n      if (flag & X_SHORT_VECTOR) {\n        const x = glyf.getUint8(pos++);\n        lastCoordinate += flag & X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR ? x : -x;\n        xCoordinates.push(lastCoordinate);\n      } else if (flag & X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR) {\n        xCoordinates.push(lastCoordinate);\n      } else {\n        lastCoordinate += glyf.getInt16(pos);\n        pos += 2;\n        xCoordinates.push(lastCoordinate);\n      }\n      if (endPtsOfContours[endPtsOfContoursIndex] === i) {\n        endPtsOfContoursIndex++;\n        allXCoordinates.push(xCoordinates);\n        xCoordinates = [];\n      }\n    }\n    lastCoordinate = 0;\n    endPtsOfContoursIndex = 0;\n    for (let i = 0; i < numberOfPt; i++) {\n      const flag = flags[i];\n      if (flag & Y_SHORT_VECTOR) {\n        const y = glyf.getUint8(pos++);\n        lastCoordinate += flag & Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR ? y : -y;\n        yCoordinates.push(lastCoordinate);\n      } else if (flag & Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR) {\n        yCoordinates.push(lastCoordinate);\n      } else {\n        lastCoordinate += glyf.getInt16(pos);\n        pos += 2;\n        yCoordinates.push(lastCoordinate);\n      }\n      pointFlags.push(flag & ON_CURVE_POINT | flag & OVERLAP_SIMPLE);\n      if (endPtsOfContours[endPtsOfContoursIndex] === i) {\n        xCoordinates = allXCoordinates[endPtsOfContoursIndex];\n        endPtsOfContoursIndex++;\n        contours.push(new Contour({\n          flags: pointFlags,\n          xCoordinates,\n          yCoordinates\n        }));\n        yCoordinates = [];\n        pointFlags = [];\n      }\n    }\n    return new SimpleGlyph({\n      contours,\n      instructions\n    });\n  }\n  getSize() {\n    let size = this.contours.length * 2 + 2 + this.instructions.length;\n    let lastX = 0;\n    let lastY = 0;\n    for (const contour of this.contours) {\n      size += contour.flags.length;\n      for (let i = 0, ii = contour.xCoordinates.length; i < ii; i++) {\n        const x = contour.xCoordinates[i];\n        const y = contour.yCoordinates[i];\n        let abs = Math.abs(x - lastX);\n        if (abs > 255) {\n          size += 2;\n        } else if (abs > 0) {\n          size += 1;\n        }\n        lastX = x;\n        abs = Math.abs(y - lastY);\n        if (abs > 255) {\n          size += 2;\n        } else if (abs > 0) {\n          size += 1;\n        }\n        lastY = y;\n      }\n    }\n    return size;\n  }\n  write(pos, buf) {\n    const spos = pos;\n    const xCoordinates = [];\n    const yCoordinates = [];\n    const flags = [];\n    let lastX = 0;\n    let lastY = 0;\n    for (const contour of this.contours) {\n      for (let i = 0, ii = contour.xCoordinates.length; i < ii; i++) {\n        let flag = contour.flags[i];\n        const x = contour.xCoordinates[i];\n        let delta = x - lastX;\n        if (delta === 0) {\n          flag |= X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR;\n          xCoordinates.push(0);\n        } else {\n          const abs = Math.abs(delta);\n          if (abs <= 255) {\n            flag |= delta >= 0 ? X_SHORT_VECTOR | X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR : X_SHORT_VECTOR;\n            xCoordinates.push(abs);\n          } else {\n            xCoordinates.push(delta);\n          }\n        }\n        lastX = x;\n        const y = contour.yCoordinates[i];\n        delta = y - lastY;\n        if (delta === 0) {\n          flag |= Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR;\n          yCoordinates.push(0);\n        } else {\n          const abs = Math.abs(delta);\n          if (abs <= 255) {\n            flag |= delta >= 0 ? Y_SHORT_VECTOR | Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR : Y_SHORT_VECTOR;\n            yCoordinates.push(abs);\n          } else {\n            yCoordinates.push(delta);\n          }\n        }\n        lastY = y;\n        flags.push(flag);\n      }\n      buf.setUint16(pos, xCoordinates.length - 1);\n      pos += 2;\n    }\n    buf.setUint16(pos, this.instructions.length);\n    pos += 2;\n    if (this.instructions.length) {\n      new Uint8Array(buf.buffer, 0, buf.buffer.byteLength).set(this.instructions, pos);\n      pos += this.instructions.length;\n    }\n    for (const flag of flags) {\n      buf.setUint8(pos++, flag);\n    }\n    for (let i = 0, ii = xCoordinates.length; i < ii; i++) {\n      const x = xCoordinates[i];\n      const flag = flags[i];\n      if (flag & X_SHORT_VECTOR) {\n        buf.setUint8(pos++, x);\n      } else if (!(flag & X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR)) {\n        buf.setInt16(pos, x);\n        pos += 2;\n      }\n    }\n    for (let i = 0, ii = yCoordinates.length; i < ii; i++) {\n      const y = yCoordinates[i];\n      const flag = flags[i];\n      if (flag & Y_SHORT_VECTOR) {\n        buf.setUint8(pos++, y);\n      } else if (!(flag & Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR)) {\n        buf.setInt16(pos, y);\n        pos += 2;\n      }\n    }\n    return pos - spos;\n  }\n  scale(x, factor) {\n    for (const contour of this.contours) {\n      if (contour.xCoordinates.length === 0) {\n        continue;\n      }\n      for (let i = 0, ii = contour.xCoordinates.length; i < ii; i++) {\n        contour.xCoordinates[i] = Math.round(x + (contour.xCoordinates[i] - x) * factor);\n      }\n    }\n  }\n}\nclass CompositeGlyph {\n  constructor({\n    flags,\n    glyphIndex,\n    argument1,\n    argument2,\n    transf,\n    instructions\n  }) {\n    this.flags = flags;\n    this.glyphIndex = glyphIndex;\n    this.argument1 = argument1;\n    this.argument2 = argument2;\n    this.transf = transf;\n    this.instructions = instructions;\n  }\n  static parse(pos, glyf) {\n    const spos = pos;\n    const transf = [];\n    let flags = glyf.getUint16(pos);\n    const glyphIndex = glyf.getUint16(pos + 2);\n    pos += 4;\n    let argument1, argument2;\n    if (flags & ARG_1_AND_2_ARE_WORDS) {\n      if (flags & ARGS_ARE_XY_VALUES) {\n        argument1 = glyf.getInt16(pos);\n        argument2 = glyf.getInt16(pos + 2);\n      } else {\n        argument1 = glyf.getUint16(pos);\n        argument2 = glyf.getUint16(pos + 2);\n      }\n      pos += 4;\n      flags ^= ARG_1_AND_2_ARE_WORDS;\n    } else {\n      if (flags & ARGS_ARE_XY_VALUES) {\n        argument1 = glyf.getInt8(pos);\n        argument2 = glyf.getInt8(pos + 1);\n      } else {\n        argument1 = glyf.getUint8(pos);\n        argument2 = glyf.getUint8(pos + 1);\n      }\n      pos += 2;\n    }\n    if (flags & WE_HAVE_A_SCALE) {\n      transf.push(glyf.getUint16(pos));\n      pos += 2;\n    } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {\n      transf.push(glyf.getUint16(pos), glyf.getUint16(pos + 2));\n      pos += 4;\n    } else if (flags & WE_HAVE_A_TWO_BY_TWO) {\n      transf.push(glyf.getUint16(pos), glyf.getUint16(pos + 2), glyf.getUint16(pos + 4), glyf.getUint16(pos + 6));\n      pos += 8;\n    }\n    let instructions = null;\n    if (flags & WE_HAVE_INSTRUCTIONS) {\n      const instructionLength = glyf.getUint16(pos);\n      pos += 2;\n      instructions = new Uint8Array(glyf).slice(pos, pos + instructionLength);\n      pos += instructionLength;\n    }\n    return [pos - spos, new CompositeGlyph({\n      flags,\n      glyphIndex,\n      argument1,\n      argument2,\n      transf,\n      instructions\n    })];\n  }\n  getSize() {\n    let size = 2 + 2 + this.transf.length * 2;\n    if (this.flags & WE_HAVE_INSTRUCTIONS) {\n      size += 2 + this.instructions.length;\n    }\n    size += 2;\n    if (this.flags & 2) {\n      if (!(this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127)) {\n        size += 2;\n      }\n    } else if (!(this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255)) {\n      size += 2;\n    }\n    return size;\n  }\n  write(pos, buf) {\n    const spos = pos;\n    if (this.flags & ARGS_ARE_XY_VALUES) {\n      if (!(this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127)) {\n        this.flags |= ARG_1_AND_2_ARE_WORDS;\n      }\n    } else if (!(this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255)) {\n      this.flags |= ARG_1_AND_2_ARE_WORDS;\n    }\n    buf.setUint16(pos, this.flags);\n    buf.setUint16(pos + 2, this.glyphIndex);\n    pos += 4;\n    if (this.flags & ARG_1_AND_2_ARE_WORDS) {\n      if (this.flags & ARGS_ARE_XY_VALUES) {\n        buf.setInt16(pos, this.argument1);\n        buf.setInt16(pos + 2, this.argument2);\n      } else {\n        buf.setUint16(pos, this.argument1);\n        buf.setUint16(pos + 2, this.argument2);\n      }\n      pos += 4;\n    } else {\n      buf.setUint8(pos, this.argument1);\n      buf.setUint8(pos + 1, this.argument2);\n      pos += 2;\n    }\n    if (this.flags & WE_HAVE_INSTRUCTIONS) {\n      buf.setUint16(pos, this.instructions.length);\n      pos += 2;\n      if (this.instructions.length) {\n        new Uint8Array(buf.buffer, 0, buf.buffer.byteLength).set(this.instructions, pos);\n        pos += this.instructions.length;\n      }\n    }\n    return pos - spos;\n  }\n  scale(x, factor) {}\n}\n\n;// CONCATENATED MODULE: ./src/core/opentype_file_builder.js\n\n\nfunction writeInt16(dest, offset, num) {\n  dest[offset] = num >> 8 & 0xff;\n  dest[offset + 1] = num & 0xff;\n}\nfunction writeInt32(dest, offset, num) {\n  dest[offset] = num >> 24 & 0xff;\n  dest[offset + 1] = num >> 16 & 0xff;\n  dest[offset + 2] = num >> 8 & 0xff;\n  dest[offset + 3] = num & 0xff;\n}\nfunction writeData(dest, offset, data) {\n  if (data instanceof Uint8Array) {\n    dest.set(data, offset);\n  } else if (typeof data === \"string\") {\n    for (let i = 0, ii = data.length; i < ii; i++) {\n      dest[offset++] = data.charCodeAt(i) & 0xff;\n    }\n  } else {\n    for (const num of data) {\n      dest[offset++] = num & 0xff;\n    }\n  }\n}\nconst OTF_HEADER_SIZE = 12;\nconst OTF_TABLE_ENTRY_SIZE = 16;\nclass OpenTypeFileBuilder {\n  constructor(sfnt) {\n    this.sfnt = sfnt;\n    this.tables = Object.create(null);\n  }\n  static getSearchParams(entriesCount, entrySize) {\n    let maxPower2 = 1,\n      log2 = 0;\n    while ((maxPower2 ^ entriesCount) > maxPower2) {\n      maxPower2 <<= 1;\n      log2++;\n    }\n    const searchRange = maxPower2 * entrySize;\n    return {\n      range: searchRange,\n      entry: log2,\n      rangeShift: entrySize * entriesCount - searchRange\n    };\n  }\n  toArray() {\n    let sfnt = this.sfnt;\n    const tables = this.tables;\n    const tablesNames = Object.keys(tables);\n    tablesNames.sort();\n    const numTables = tablesNames.length;\n    let i, j, jj, table, tableName;\n    let offset = OTF_HEADER_SIZE + numTables * OTF_TABLE_ENTRY_SIZE;\n    const tableOffsets = [offset];\n    for (i = 0; i < numTables; i++) {\n      table = tables[tablesNames[i]];\n      const paddedLength = (table.length + 3 & ~3) >>> 0;\n      offset += paddedLength;\n      tableOffsets.push(offset);\n    }\n    const file = new Uint8Array(offset);\n    for (i = 0; i < numTables; i++) {\n      table = tables[tablesNames[i]];\n      writeData(file, tableOffsets[i], table);\n    }\n    if (sfnt === \"true\") {\n      sfnt = string32(0x00010000);\n    }\n    file[0] = sfnt.charCodeAt(0) & 0xff;\n    file[1] = sfnt.charCodeAt(1) & 0xff;\n    file[2] = sfnt.charCodeAt(2) & 0xff;\n    file[3] = sfnt.charCodeAt(3) & 0xff;\n    writeInt16(file, 4, numTables);\n    const searchParams = OpenTypeFileBuilder.getSearchParams(numTables, 16);\n    writeInt16(file, 6, searchParams.range);\n    writeInt16(file, 8, searchParams.entry);\n    writeInt16(file, 10, searchParams.rangeShift);\n    offset = OTF_HEADER_SIZE;\n    for (i = 0; i < numTables; i++) {\n      tableName = tablesNames[i];\n      file[offset] = tableName.charCodeAt(0) & 0xff;\n      file[offset + 1] = tableName.charCodeAt(1) & 0xff;\n      file[offset + 2] = tableName.charCodeAt(2) & 0xff;\n      file[offset + 3] = tableName.charCodeAt(3) & 0xff;\n      let checksum = 0;\n      for (j = tableOffsets[i], jj = tableOffsets[i + 1]; j < jj; j += 4) {\n        const quad = readUint32(file, j);\n        checksum = checksum + quad >>> 0;\n      }\n      writeInt32(file, offset + 4, checksum);\n      writeInt32(file, offset + 8, tableOffsets[i]);\n      writeInt32(file, offset + 12, tables[tableName].length);\n      offset += OTF_TABLE_ENTRY_SIZE;\n    }\n    return file;\n  }\n  addTable(tag, data) {\n    if (tag in this.tables) {\n      throw new Error(\"Table \" + tag + \" already exists\");\n    }\n    this.tables[tag] = data;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/type1_parser.js\n\n\n\n\nconst HINTING_ENABLED = false;\nconst COMMAND_MAP = {\n  hstem: [1],\n  vstem: [3],\n  vmoveto: [4],\n  rlineto: [5],\n  hlineto: [6],\n  vlineto: [7],\n  rrcurveto: [8],\n  callsubr: [10],\n  flex: [12, 35],\n  drop: [12, 18],\n  endchar: [14],\n  rmoveto: [21],\n  hmoveto: [22],\n  vhcurveto: [30],\n  hvcurveto: [31]\n};\nclass Type1CharString {\n  constructor() {\n    this.width = 0;\n    this.lsb = 0;\n    this.flexing = false;\n    this.output = [];\n    this.stack = [];\n  }\n  convert(encoded, subrs, seacAnalysisEnabled) {\n    const count = encoded.length;\n    let error = false;\n    let wx, sbx, subrNumber;\n    for (let i = 0; i < count; i++) {\n      let value = encoded[i];\n      if (value < 32) {\n        if (value === 12) {\n          value = (value << 8) + encoded[++i];\n        }\n        switch (value) {\n          case 1:\n            if (!HINTING_ENABLED) {\n              this.stack = [];\n              break;\n            }\n            error = this.executeCommand(2, COMMAND_MAP.hstem);\n            break;\n          case 3:\n            if (!HINTING_ENABLED) {\n              this.stack = [];\n              break;\n            }\n            error = this.executeCommand(2, COMMAND_MAP.vstem);\n            break;\n          case 4:\n            if (this.flexing) {\n              if (this.stack.length < 1) {\n                error = true;\n                break;\n              }\n              const dy = this.stack.pop();\n              this.stack.push(0, dy);\n              break;\n            }\n            error = this.executeCommand(1, COMMAND_MAP.vmoveto);\n            break;\n          case 5:\n            error = this.executeCommand(2, COMMAND_MAP.rlineto);\n            break;\n          case 6:\n            error = this.executeCommand(1, COMMAND_MAP.hlineto);\n            break;\n          case 7:\n            error = this.executeCommand(1, COMMAND_MAP.vlineto);\n            break;\n          case 8:\n            error = this.executeCommand(6, COMMAND_MAP.rrcurveto);\n            break;\n          case 9:\n            this.stack = [];\n            break;\n          case 10:\n            if (this.stack.length < 1) {\n              error = true;\n              break;\n            }\n            subrNumber = this.stack.pop();\n            if (!subrs[subrNumber]) {\n              error = true;\n              break;\n            }\n            error = this.convert(subrs[subrNumber], subrs, seacAnalysisEnabled);\n            break;\n          case 11:\n            return error;\n          case 13:\n            if (this.stack.length < 2) {\n              error = true;\n              break;\n            }\n            wx = this.stack.pop();\n            sbx = this.stack.pop();\n            this.lsb = sbx;\n            this.width = wx;\n            this.stack.push(wx, sbx);\n            error = this.executeCommand(2, COMMAND_MAP.hmoveto);\n            break;\n          case 14:\n            this.output.push(COMMAND_MAP.endchar[0]);\n            break;\n          case 21:\n            if (this.flexing) {\n              break;\n            }\n            error = this.executeCommand(2, COMMAND_MAP.rmoveto);\n            break;\n          case 22:\n            if (this.flexing) {\n              this.stack.push(0);\n              break;\n            }\n            error = this.executeCommand(1, COMMAND_MAP.hmoveto);\n            break;\n          case 30:\n            error = this.executeCommand(4, COMMAND_MAP.vhcurveto);\n            break;\n          case 31:\n            error = this.executeCommand(4, COMMAND_MAP.hvcurveto);\n            break;\n          case (12 << 8) + 0:\n            this.stack = [];\n            break;\n          case (12 << 8) + 1:\n            if (!HINTING_ENABLED) {\n              this.stack = [];\n              break;\n            }\n            error = this.executeCommand(2, COMMAND_MAP.vstem);\n            break;\n          case (12 << 8) + 2:\n            if (!HINTING_ENABLED) {\n              this.stack = [];\n              break;\n            }\n            error = this.executeCommand(2, COMMAND_MAP.hstem);\n            break;\n          case (12 << 8) + 6:\n            if (seacAnalysisEnabled) {\n              const asb = this.stack.at(-5);\n              this.seac = this.stack.splice(-4, 4);\n              this.seac[0] += this.lsb - asb;\n              error = this.executeCommand(0, COMMAND_MAP.endchar);\n            } else {\n              error = this.executeCommand(4, COMMAND_MAP.endchar);\n            }\n            break;\n          case (12 << 8) + 7:\n            if (this.stack.length < 4) {\n              error = true;\n              break;\n            }\n            this.stack.pop();\n            wx = this.stack.pop();\n            const sby = this.stack.pop();\n            sbx = this.stack.pop();\n            this.lsb = sbx;\n            this.width = wx;\n            this.stack.push(wx, sbx, sby);\n            error = this.executeCommand(3, COMMAND_MAP.rmoveto);\n            break;\n          case (12 << 8) + 12:\n            if (this.stack.length < 2) {\n              error = true;\n              break;\n            }\n            const num2 = this.stack.pop();\n            const num1 = this.stack.pop();\n            this.stack.push(num1 / num2);\n            break;\n          case (12 << 8) + 16:\n            if (this.stack.length < 2) {\n              error = true;\n              break;\n            }\n            subrNumber = this.stack.pop();\n            const numArgs = this.stack.pop();\n            if (subrNumber === 0 && numArgs === 3) {\n              const flexArgs = this.stack.splice(-17, 17);\n              this.stack.push(flexArgs[2] + flexArgs[0], flexArgs[3] + flexArgs[1], flexArgs[4], flexArgs[5], flexArgs[6], flexArgs[7], flexArgs[8], flexArgs[9], flexArgs[10], flexArgs[11], flexArgs[12], flexArgs[13], flexArgs[14]);\n              error = this.executeCommand(13, COMMAND_MAP.flex, true);\n              this.flexing = false;\n              this.stack.push(flexArgs[15], flexArgs[16]);\n            } else if (subrNumber === 1 && numArgs === 0) {\n              this.flexing = true;\n            }\n            break;\n          case (12 << 8) + 17:\n            break;\n          case (12 << 8) + 33:\n            this.stack = [];\n            break;\n          default:\n            warn('Unknown type 1 charstring command of \"' + value + '\"');\n            break;\n        }\n        if (error) {\n          break;\n        }\n        continue;\n      } else if (value <= 246) {\n        value -= 139;\n      } else if (value <= 250) {\n        value = (value - 247) * 256 + encoded[++i] + 108;\n      } else if (value <= 254) {\n        value = -((value - 251) * 256) - encoded[++i] - 108;\n      } else {\n        value = (encoded[++i] & 0xff) << 24 | (encoded[++i] & 0xff) << 16 | (encoded[++i] & 0xff) << 8 | (encoded[++i] & 0xff) << 0;\n      }\n      this.stack.push(value);\n    }\n    return error;\n  }\n  executeCommand(howManyArgs, command, keepStack) {\n    const stackLength = this.stack.length;\n    if (howManyArgs > stackLength) {\n      return true;\n    }\n    const start = stackLength - howManyArgs;\n    for (let i = start; i < stackLength; i++) {\n      let value = this.stack[i];\n      if (Number.isInteger(value)) {\n        this.output.push(28, value >> 8 & 0xff, value & 0xff);\n      } else {\n        value = 65536 * value | 0;\n        this.output.push(255, value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n      }\n    }\n    this.output.push(...command);\n    if (keepStack) {\n      this.stack.splice(start, howManyArgs);\n    } else {\n      this.stack.length = 0;\n    }\n    return false;\n  }\n}\nconst EEXEC_ENCRYPT_KEY = 55665;\nconst CHAR_STRS_ENCRYPT_KEY = 4330;\nfunction isHexDigit(code) {\n  return code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102;\n}\nfunction decrypt(data, key, discardNumber) {\n  if (discardNumber >= data.length) {\n    return new Uint8Array(0);\n  }\n  const c1 = 52845,\n    c2 = 22719;\n  let r = key | 0,\n    i,\n    j;\n  for (i = 0; i < discardNumber; i++) {\n    r = (data[i] + r) * c1 + c2 & (1 << 16) - 1;\n  }\n  const count = data.length - discardNumber;\n  const decrypted = new Uint8Array(count);\n  for (i = discardNumber, j = 0; j < count; i++, j++) {\n    const value = data[i];\n    decrypted[j] = value ^ r >> 8;\n    r = (value + r) * c1 + c2 & (1 << 16) - 1;\n  }\n  return decrypted;\n}\nfunction decryptAscii(data, key, discardNumber) {\n  const c1 = 52845,\n    c2 = 22719;\n  let r = key | 0;\n  const count = data.length,\n    maybeLength = count >>> 1;\n  const decrypted = new Uint8Array(maybeLength);\n  let i, j;\n  for (i = 0, j = 0; i < count; i++) {\n    const digit1 = data[i];\n    if (!isHexDigit(digit1)) {\n      continue;\n    }\n    i++;\n    let digit2;\n    while (i < count && !isHexDigit(digit2 = data[i])) {\n      i++;\n    }\n    if (i < count) {\n      const value = parseInt(String.fromCharCode(digit1, digit2), 16);\n      decrypted[j++] = value ^ r >> 8;\n      r = (value + r) * c1 + c2 & (1 << 16) - 1;\n    }\n  }\n  return decrypted.slice(discardNumber, j);\n}\nfunction isSpecial(c) {\n  return c === 0x2f || c === 0x5b || c === 0x5d || c === 0x7b || c === 0x7d || c === 0x28 || c === 0x29;\n}\nclass Type1Parser {\n  constructor(stream, encrypted, seacAnalysisEnabled) {\n    if (encrypted) {\n      const data = stream.getBytes();\n      const isBinary = !((isHexDigit(data[0]) || isWhiteSpace(data[0])) && isHexDigit(data[1]) && isHexDigit(data[2]) && isHexDigit(data[3]) && isHexDigit(data[4]) && isHexDigit(data[5]) && isHexDigit(data[6]) && isHexDigit(data[7]));\n      stream = new Stream(isBinary ? decrypt(data, EEXEC_ENCRYPT_KEY, 4) : decryptAscii(data, EEXEC_ENCRYPT_KEY, 4));\n    }\n    this.seacAnalysisEnabled = !!seacAnalysisEnabled;\n    this.stream = stream;\n    this.nextChar();\n  }\n  readNumberArray() {\n    this.getToken();\n    const array = [];\n    while (true) {\n      const token = this.getToken();\n      if (token === null || token === \"]\" || token === \"}\") {\n        break;\n      }\n      array.push(parseFloat(token || 0));\n    }\n    return array;\n  }\n  readNumber() {\n    const token = this.getToken();\n    return parseFloat(token || 0);\n  }\n  readInt() {\n    const token = this.getToken();\n    return parseInt(token || 0, 10) | 0;\n  }\n  readBoolean() {\n    const token = this.getToken();\n    return token === \"true\" ? 1 : 0;\n  }\n  nextChar() {\n    return this.currentChar = this.stream.getByte();\n  }\n  prevChar() {\n    this.stream.skip(-2);\n    return this.currentChar = this.stream.getByte();\n  }\n  getToken() {\n    let comment = false;\n    let ch = this.currentChar;\n    while (true) {\n      if (ch === -1) {\n        return null;\n      }\n      if (comment) {\n        if (ch === 0x0a || ch === 0x0d) {\n          comment = false;\n        }\n      } else if (ch === 0x25) {\n        comment = true;\n      } else if (!isWhiteSpace(ch)) {\n        break;\n      }\n      ch = this.nextChar();\n    }\n    if (isSpecial(ch)) {\n      this.nextChar();\n      return String.fromCharCode(ch);\n    }\n    let token = \"\";\n    do {\n      token += String.fromCharCode(ch);\n      ch = this.nextChar();\n    } while (ch >= 0 && !isWhiteSpace(ch) && !isSpecial(ch));\n    return token;\n  }\n  readCharStrings(bytes, lenIV) {\n    if (lenIV === -1) {\n      return bytes;\n    }\n    return decrypt(bytes, CHAR_STRS_ENCRYPT_KEY, lenIV);\n  }\n  extractFontProgram(properties) {\n    const stream = this.stream;\n    const subrs = [],\n      charstrings = [];\n    const privateData = Object.create(null);\n    privateData.lenIV = 4;\n    const program = {\n      subrs: [],\n      charstrings: [],\n      properties: {\n        privateData\n      }\n    };\n    let token, length, data, lenIV;\n    while ((token = this.getToken()) !== null) {\n      if (token !== \"/\") {\n        continue;\n      }\n      token = this.getToken();\n      switch (token) {\n        case \"CharStrings\":\n          this.getToken();\n          this.getToken();\n          this.getToken();\n          this.getToken();\n          while (true) {\n            token = this.getToken();\n            if (token === null || token === \"end\") {\n              break;\n            }\n            if (token !== \"/\") {\n              continue;\n            }\n            const glyph = this.getToken();\n            length = this.readInt();\n            this.getToken();\n            data = length > 0 ? stream.getBytes(length) : new Uint8Array(0);\n            lenIV = program.properties.privateData.lenIV;\n            const encoded = this.readCharStrings(data, lenIV);\n            this.nextChar();\n            token = this.getToken();\n            if (token === \"noaccess\") {\n              this.getToken();\n            } else if (token === \"/\") {\n              this.prevChar();\n            }\n            charstrings.push({\n              glyph,\n              encoded\n            });\n          }\n          break;\n        case \"Subrs\":\n          this.readInt();\n          this.getToken();\n          while (this.getToken() === \"dup\") {\n            const index = this.readInt();\n            length = this.readInt();\n            this.getToken();\n            data = length > 0 ? stream.getBytes(length) : new Uint8Array(0);\n            lenIV = program.properties.privateData.lenIV;\n            const encoded = this.readCharStrings(data, lenIV);\n            this.nextChar();\n            token = this.getToken();\n            if (token === \"noaccess\") {\n              this.getToken();\n            }\n            subrs[index] = encoded;\n          }\n          break;\n        case \"BlueValues\":\n        case \"OtherBlues\":\n        case \"FamilyBlues\":\n        case \"FamilyOtherBlues\":\n          const blueArray = this.readNumberArray();\n          if (blueArray.length > 0 && blueArray.length % 2 === 0 && HINTING_ENABLED) {\n            program.properties.privateData[token] = blueArray;\n          }\n          break;\n        case \"StemSnapH\":\n        case \"StemSnapV\":\n          program.properties.privateData[token] = this.readNumberArray();\n          break;\n        case \"StdHW\":\n        case \"StdVW\":\n          program.properties.privateData[token] = this.readNumberArray()[0];\n          break;\n        case \"BlueShift\":\n        case \"lenIV\":\n        case \"BlueFuzz\":\n        case \"BlueScale\":\n        case \"LanguageGroup\":\n          program.properties.privateData[token] = this.readNumber();\n          break;\n        case \"ExpansionFactor\":\n          program.properties.privateData[token] = this.readNumber() || 0.06;\n          break;\n        case \"ForceBold\":\n          program.properties.privateData[token] = this.readBoolean();\n          break;\n      }\n    }\n    for (const {\n      encoded,\n      glyph\n    } of charstrings) {\n      const charString = new Type1CharString();\n      const error = charString.convert(encoded, subrs, this.seacAnalysisEnabled);\n      let output = charString.output;\n      if (error) {\n        output = [14];\n      }\n      const charStringObject = {\n        glyphName: glyph,\n        charstring: output,\n        width: charString.width,\n        lsb: charString.lsb,\n        seac: charString.seac\n      };\n      if (glyph === \".notdef\") {\n        program.charstrings.unshift(charStringObject);\n      } else {\n        program.charstrings.push(charStringObject);\n      }\n      if (properties.builtInEncoding) {\n        const index = properties.builtInEncoding.indexOf(glyph);\n        if (index > -1 && properties.widths[index] === undefined && index >= properties.firstChar && index <= properties.lastChar) {\n          properties.widths[index] = charString.width;\n        }\n      }\n    }\n    return program;\n  }\n  extractFontHeader(properties) {\n    let token;\n    while ((token = this.getToken()) !== null) {\n      if (token !== \"/\") {\n        continue;\n      }\n      token = this.getToken();\n      switch (token) {\n        case \"FontMatrix\":\n          const matrix = this.readNumberArray();\n          properties.fontMatrix = matrix;\n          break;\n        case \"Encoding\":\n          const encodingArg = this.getToken();\n          let encoding;\n          if (!/^\\d+$/.test(encodingArg)) {\n            encoding = getEncoding(encodingArg);\n          } else {\n            encoding = [];\n            const size = parseInt(encodingArg, 10) | 0;\n            this.getToken();\n            for (let j = 0; j < size; j++) {\n              token = this.getToken();\n              while (token !== \"dup\" && token !== \"def\") {\n                token = this.getToken();\n                if (token === null) {\n                  return;\n                }\n              }\n              if (token === \"def\") {\n                break;\n              }\n              const index = this.readInt();\n              this.getToken();\n              const glyph = this.getToken();\n              encoding[index] = glyph;\n              this.getToken();\n            }\n          }\n          properties.builtInEncoding = encoding;\n          break;\n        case \"FontBBox\":\n          const fontBBox = this.readNumberArray();\n          properties.ascent = Math.max(fontBBox[3], fontBBox[1]);\n          properties.descent = Math.min(fontBBox[1], fontBBox[3]);\n          properties.ascentScaled = true;\n          break;\n      }\n    }\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/type1_font.js\n\n\n\n\n\n\nfunction findBlock(streamBytes, signature, startIndex) {\n  const streamBytesLength = streamBytes.length;\n  const signatureLength = signature.length;\n  const scanLength = streamBytesLength - signatureLength;\n  let i = startIndex,\n    found = false;\n  while (i < scanLength) {\n    let j = 0;\n    while (j < signatureLength && streamBytes[i + j] === signature[j]) {\n      j++;\n    }\n    if (j >= signatureLength) {\n      i += j;\n      while (i < streamBytesLength && isWhiteSpace(streamBytes[i])) {\n        i++;\n      }\n      found = true;\n      break;\n    }\n    i++;\n  }\n  return {\n    found,\n    length: i\n  };\n}\nfunction getHeaderBlock(stream, suggestedLength) {\n  const EEXEC_SIGNATURE = [0x65, 0x65, 0x78, 0x65, 0x63];\n  const streamStartPos = stream.pos;\n  let headerBytes, headerBytesLength, block;\n  try {\n    headerBytes = stream.getBytes(suggestedLength);\n    headerBytesLength = headerBytes.length;\n  } catch {}\n  if (headerBytesLength === suggestedLength) {\n    block = findBlock(headerBytes, EEXEC_SIGNATURE, suggestedLength - 2 * EEXEC_SIGNATURE.length);\n    if (block.found && block.length === suggestedLength) {\n      return {\n        stream: new Stream(headerBytes),\n        length: suggestedLength\n      };\n    }\n  }\n  warn('Invalid \"Length1\" property in Type1 font -- trying to recover.');\n  stream.pos = streamStartPos;\n  const SCAN_BLOCK_LENGTH = 2048;\n  let actualLength;\n  while (true) {\n    const scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);\n    block = findBlock(scanBytes, EEXEC_SIGNATURE, 0);\n    if (block.length === 0) {\n      break;\n    }\n    stream.pos += block.length;\n    if (block.found) {\n      actualLength = stream.pos - streamStartPos;\n      break;\n    }\n  }\n  stream.pos = streamStartPos;\n  if (actualLength) {\n    return {\n      stream: new Stream(stream.getBytes(actualLength)),\n      length: actualLength\n    };\n  }\n  warn('Unable to recover \"Length1\" property in Type1 font -- using as is.');\n  return {\n    stream: new Stream(stream.getBytes(suggestedLength)),\n    length: suggestedLength\n  };\n}\nfunction getEexecBlock(stream, suggestedLength) {\n  const eexecBytes = stream.getBytes();\n  if (eexecBytes.length === 0) {\n    throw new FormatError(\"getEexecBlock - no font program found.\");\n  }\n  return {\n    stream: new Stream(eexecBytes),\n    length: eexecBytes.length\n  };\n}\nclass Type1Font {\n  constructor(name, file, properties) {\n    const PFB_HEADER_SIZE = 6;\n    let headerBlockLength = properties.length1;\n    let eexecBlockLength = properties.length2;\n    let pfbHeader = file.peekBytes(PFB_HEADER_SIZE);\n    const pfbHeaderPresent = pfbHeader[0] === 0x80 && pfbHeader[1] === 0x01;\n    if (pfbHeaderPresent) {\n      file.skip(PFB_HEADER_SIZE);\n      headerBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];\n    }\n    const headerBlock = getHeaderBlock(file, headerBlockLength);\n    const headerBlockParser = new Type1Parser(headerBlock.stream, false, SEAC_ANALYSIS_ENABLED);\n    headerBlockParser.extractFontHeader(properties);\n    if (pfbHeaderPresent) {\n      pfbHeader = file.getBytes(PFB_HEADER_SIZE);\n      eexecBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];\n    }\n    const eexecBlock = getEexecBlock(file, eexecBlockLength);\n    const eexecBlockParser = new Type1Parser(eexecBlock.stream, true, SEAC_ANALYSIS_ENABLED);\n    const data = eexecBlockParser.extractFontProgram(properties);\n    for (const key in data.properties) {\n      properties[key] = data.properties[key];\n    }\n    const charstrings = data.charstrings;\n    const type2Charstrings = this.getType2Charstrings(charstrings);\n    const subrs = this.getType2Subrs(data.subrs);\n    this.charstrings = charstrings;\n    this.data = this.wrap(name, type2Charstrings, this.charstrings, subrs, properties);\n    this.seacs = this.getSeacs(data.charstrings);\n  }\n  get numGlyphs() {\n    return this.charstrings.length + 1;\n  }\n  getCharset() {\n    const charset = [\".notdef\"];\n    for (const {\n      glyphName\n    } of this.charstrings) {\n      charset.push(glyphName);\n    }\n    return charset;\n  }\n  getGlyphMapping(properties) {\n    const charstrings = this.charstrings;\n    if (properties.composite) {\n      const charCodeToGlyphId = Object.create(null);\n      for (let glyphId = 0, charstringsLen = charstrings.length; glyphId < charstringsLen; glyphId++) {\n        const charCode = properties.cMap.charCodeOf(glyphId);\n        charCodeToGlyphId[charCode] = glyphId + 1;\n      }\n      return charCodeToGlyphId;\n    }\n    const glyphNames = [\".notdef\"];\n    let builtInEncoding, glyphId;\n    for (glyphId = 0; glyphId < charstrings.length; glyphId++) {\n      glyphNames.push(charstrings[glyphId].glyphName);\n    }\n    const encoding = properties.builtInEncoding;\n    if (encoding) {\n      builtInEncoding = Object.create(null);\n      for (const charCode in encoding) {\n        glyphId = glyphNames.indexOf(encoding[charCode]);\n        if (glyphId >= 0) {\n          builtInEncoding[charCode] = glyphId;\n        }\n      }\n    }\n    return type1FontGlyphMapping(properties, builtInEncoding, glyphNames);\n  }\n  hasGlyphId(id) {\n    if (id < 0 || id >= this.numGlyphs) {\n      return false;\n    }\n    if (id === 0) {\n      return true;\n    }\n    const glyph = this.charstrings[id - 1];\n    return glyph.charstring.length > 0;\n  }\n  getSeacs(charstrings) {\n    const seacMap = [];\n    for (let i = 0, ii = charstrings.length; i < ii; i++) {\n      const charstring = charstrings[i];\n      if (charstring.seac) {\n        seacMap[i + 1] = charstring.seac;\n      }\n    }\n    return seacMap;\n  }\n  getType2Charstrings(type1Charstrings) {\n    const type2Charstrings = [];\n    for (const type1Charstring of type1Charstrings) {\n      type2Charstrings.push(type1Charstring.charstring);\n    }\n    return type2Charstrings;\n  }\n  getType2Subrs(type1Subrs) {\n    let bias = 0;\n    const count = type1Subrs.length;\n    if (count < 1133) {\n      bias = 107;\n    } else if (count < 33769) {\n      bias = 1131;\n    } else {\n      bias = 32768;\n    }\n    const type2Subrs = [];\n    let i;\n    for (i = 0; i < bias; i++) {\n      type2Subrs.push([0x0b]);\n    }\n    for (i = 0; i < count; i++) {\n      type2Subrs.push(type1Subrs[i]);\n    }\n    return type2Subrs;\n  }\n  wrap(name, glyphs, charstrings, subrs, properties) {\n    const cff = new CFF();\n    cff.header = new CFFHeader(1, 0, 4, 4);\n    cff.names = [name];\n    const topDict = new CFFTopDict();\n    topDict.setByName(\"version\", 391);\n    topDict.setByName(\"Notice\", 392);\n    topDict.setByName(\"FullName\", 393);\n    topDict.setByName(\"FamilyName\", 394);\n    topDict.setByName(\"Weight\", 395);\n    topDict.setByName(\"Encoding\", null);\n    topDict.setByName(\"FontMatrix\", properties.fontMatrix);\n    topDict.setByName(\"FontBBox\", properties.bbox);\n    topDict.setByName(\"charset\", null);\n    topDict.setByName(\"CharStrings\", null);\n    topDict.setByName(\"Private\", null);\n    cff.topDict = topDict;\n    const strings = new CFFStrings();\n    strings.add(\"Version 0.11\");\n    strings.add(\"See original notice\");\n    strings.add(name);\n    strings.add(name);\n    strings.add(\"Medium\");\n    cff.strings = strings;\n    cff.globalSubrIndex = new CFFIndex();\n    const count = glyphs.length;\n    const charsetArray = [\".notdef\"];\n    let i, ii;\n    for (i = 0; i < count; i++) {\n      const glyphName = charstrings[i].glyphName;\n      const index = CFFStandardStrings.indexOf(glyphName);\n      if (index === -1) {\n        strings.add(glyphName);\n      }\n      charsetArray.push(glyphName);\n    }\n    cff.charset = new CFFCharset(false, 0, charsetArray);\n    const charStringsIndex = new CFFIndex();\n    charStringsIndex.add([0x8b, 0x0e]);\n    for (i = 0; i < count; i++) {\n      charStringsIndex.add(glyphs[i]);\n    }\n    cff.charStrings = charStringsIndex;\n    const privateDict = new CFFPrivateDict();\n    privateDict.setByName(\"Subrs\", null);\n    const fields = [\"BlueValues\", \"OtherBlues\", \"FamilyBlues\", \"FamilyOtherBlues\", \"StemSnapH\", \"StemSnapV\", \"BlueShift\", \"BlueFuzz\", \"BlueScale\", \"LanguageGroup\", \"ExpansionFactor\", \"ForceBold\", \"StdHW\", \"StdVW\"];\n    for (i = 0, ii = fields.length; i < ii; i++) {\n      const field = fields[i];\n      if (!(field in properties.privateData)) {\n        continue;\n      }\n      const value = properties.privateData[field];\n      if (Array.isArray(value)) {\n        for (let j = value.length - 1; j > 0; j--) {\n          value[j] -= value[j - 1];\n        }\n      }\n      privateDict.setByName(field, value);\n    }\n    cff.topDict.privateDict = privateDict;\n    const subrIndex = new CFFIndex();\n    for (i = 0, ii = subrs.length; i < ii; i++) {\n      subrIndex.add(subrs[i]);\n    }\n    privateDict.subrsIndex = subrIndex;\n    const compiler = new CFFCompiler(cff);\n    return compiler.compile();\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/fonts.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst PRIVATE_USE_AREAS = [[0xe000, 0xf8ff], [0x100000, 0x10fffd]];\nconst PDF_GLYPH_SPACE_UNITS = 1000;\nconst EXPORT_DATA_PROPERTIES = [\"ascent\", \"bbox\", \"black\", \"bold\", \"charProcOperatorList\", \"composite\", \"cssFontInfo\", \"data\", \"defaultVMetrics\", \"defaultWidth\", \"descent\", \"fallbackName\", \"fontMatrix\", \"isInvalidPDFjsFont\", \"isType3Font\", \"italic\", \"loadedName\", \"mimetype\", \"missingFile\", \"name\", \"remeasure\", \"subtype\", \"systemFontInfo\", \"type\", \"vertical\"];\nconst EXPORT_DATA_EXTRA_PROPERTIES = [\"cMap\", \"defaultEncoding\", \"differences\", \"isMonospace\", \"isSerifFont\", \"isSymbolicFont\", \"seacMap\", \"toFontChar\", \"toUnicode\", \"vmetrics\", \"widths\"];\nfunction adjustWidths(properties) {\n  if (!properties.fontMatrix) {\n    return;\n  }\n  if (properties.fontMatrix[0] === FONT_IDENTITY_MATRIX[0]) {\n    return;\n  }\n  const scale = 0.001 / properties.fontMatrix[0];\n  const glyphsWidths = properties.widths;\n  for (const glyph in glyphsWidths) {\n    glyphsWidths[glyph] *= scale;\n  }\n  properties.defaultWidth *= scale;\n}\nfunction adjustTrueTypeToUnicode(properties, isSymbolicFont, nameRecords) {\n  if (properties.isInternalFont) {\n    return;\n  }\n  if (properties.hasIncludedToUnicodeMap) {\n    return;\n  }\n  if (properties.hasEncoding) {\n    return;\n  }\n  if (properties.toUnicode instanceof IdentityToUnicodeMap) {\n    return;\n  }\n  if (!isSymbolicFont) {\n    return;\n  }\n  if (nameRecords.length === 0) {\n    return;\n  }\n  if (properties.defaultEncoding === WinAnsiEncoding) {\n    return;\n  }\n  for (const r of nameRecords) {\n    if (!isWinNameRecord(r)) {\n      return;\n    }\n  }\n  const encoding = WinAnsiEncoding;\n  const toUnicode = [],\n    glyphsUnicodeMap = getGlyphsUnicode();\n  for (const charCode in encoding) {\n    const glyphName = encoding[charCode];\n    if (glyphName === \"\") {\n      continue;\n    }\n    const unicode = glyphsUnicodeMap[glyphName];\n    if (unicode === undefined) {\n      continue;\n    }\n    toUnicode[charCode] = String.fromCharCode(unicode);\n  }\n  if (toUnicode.length > 0) {\n    properties.toUnicode.amend(toUnicode);\n  }\n}\nfunction adjustType1ToUnicode(properties, builtInEncoding) {\n  if (properties.isInternalFont) {\n    return;\n  }\n  if (properties.hasIncludedToUnicodeMap) {\n    return;\n  }\n  if (builtInEncoding === properties.defaultEncoding) {\n    return;\n  }\n  if (properties.toUnicode instanceof IdentityToUnicodeMap) {\n    return;\n  }\n  const toUnicode = [],\n    glyphsUnicodeMap = getGlyphsUnicode();\n  for (const charCode in builtInEncoding) {\n    if (properties.hasEncoding) {\n      if (properties.baseEncodingName || properties.differences[charCode] !== undefined) {\n        continue;\n      }\n    }\n    const glyphName = builtInEncoding[charCode];\n    const unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);\n    if (unicode !== -1) {\n      toUnicode[charCode] = String.fromCharCode(unicode);\n    }\n  }\n  if (toUnicode.length > 0) {\n    properties.toUnicode.amend(toUnicode);\n  }\n}\nfunction amendFallbackToUnicode(properties) {\n  if (!properties.fallbackToUnicode) {\n    return;\n  }\n  if (properties.toUnicode instanceof IdentityToUnicodeMap) {\n    return;\n  }\n  const toUnicode = [];\n  for (const charCode in properties.fallbackToUnicode) {\n    if (properties.toUnicode.has(charCode)) {\n      continue;\n    }\n    toUnicode[charCode] = properties.fallbackToUnicode[charCode];\n  }\n  if (toUnicode.length > 0) {\n    properties.toUnicode.amend(toUnicode);\n  }\n}\nclass fonts_Glyph {\n  constructor(originalCharCode, fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) {\n    this.originalCharCode = originalCharCode;\n    this.fontChar = fontChar;\n    this.unicode = unicode;\n    this.accent = accent;\n    this.width = width;\n    this.vmetric = vmetric;\n    this.operatorListId = operatorListId;\n    this.isSpace = isSpace;\n    this.isInFont = isInFont;\n  }\n  get category() {\n    return shadow(this, \"category\", getCharUnicodeCategory(this.unicode), true);\n  }\n}\nfunction int16(b0, b1) {\n  return (b0 << 8) + b1;\n}\nfunction writeSignedInt16(bytes, index, value) {\n  bytes[index + 1] = value;\n  bytes[index] = value >>> 8;\n}\nfunction signedInt16(b0, b1) {\n  const value = (b0 << 8) + b1;\n  return value & 1 << 15 ? value - 0x10000 : value;\n}\nfunction writeUint32(bytes, index, value) {\n  bytes[index + 3] = value & 0xff;\n  bytes[index + 2] = value >>> 8;\n  bytes[index + 1] = value >>> 16;\n  bytes[index] = value >>> 24;\n}\nfunction int32(b0, b1, b2, b3) {\n  return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;\n}\nfunction string16(value) {\n  return String.fromCharCode(value >> 8 & 0xff, value & 0xff);\n}\nfunction safeString16(value) {\n  if (value > 0x7fff) {\n    value = 0x7fff;\n  } else if (value < -0x8000) {\n    value = -0x8000;\n  }\n  return String.fromCharCode(value >> 8 & 0xff, value & 0xff);\n}\nfunction isTrueTypeFile(file) {\n  const header = file.peekBytes(4);\n  return readUint32(header, 0) === 0x00010000 || bytesToString(header) === \"true\";\n}\nfunction isTrueTypeCollectionFile(file) {\n  const header = file.peekBytes(4);\n  return bytesToString(header) === \"ttcf\";\n}\nfunction isOpenTypeFile(file) {\n  const header = file.peekBytes(4);\n  return bytesToString(header) === \"OTTO\";\n}\nfunction isType1File(file) {\n  const header = file.peekBytes(2);\n  if (header[0] === 0x25 && header[1] === 0x21) {\n    return true;\n  }\n  if (header[0] === 0x80 && header[1] === 0x01) {\n    return true;\n  }\n  return false;\n}\nfunction isCFFFile(file) {\n  const header = file.peekBytes(4);\n  if (header[0] >= 1 && header[3] >= 1 && header[3] <= 4) {\n    return true;\n  }\n  return false;\n}\nfunction getFontFileType(file, {\n  type,\n  subtype,\n  composite\n}) {\n  let fileType, fileSubtype;\n  if (isTrueTypeFile(file) || isTrueTypeCollectionFile(file)) {\n    fileType = composite ? \"CIDFontType2\" : \"TrueType\";\n  } else if (isOpenTypeFile(file)) {\n    fileType = composite ? \"CIDFontType2\" : \"OpenType\";\n  } else if (isType1File(file)) {\n    if (composite) {\n      fileType = \"CIDFontType0\";\n    } else {\n      fileType = type === \"MMType1\" ? \"MMType1\" : \"Type1\";\n    }\n  } else if (isCFFFile(file)) {\n    if (composite) {\n      fileType = \"CIDFontType0\";\n      fileSubtype = \"CIDFontType0C\";\n    } else {\n      fileType = type === \"MMType1\" ? \"MMType1\" : \"Type1\";\n      fileSubtype = \"Type1C\";\n    }\n  } else {\n    warn(\"getFontFileType: Unable to detect correct font file Type/Subtype.\");\n    fileType = type;\n    fileSubtype = subtype;\n  }\n  return [fileType, fileSubtype];\n}\nfunction applyStandardFontGlyphMap(map, glyphMap) {\n  for (const charCode in glyphMap) {\n    map[+charCode] = glyphMap[charCode];\n  }\n}\nfunction buildToFontChar(encoding, glyphsUnicodeMap, differences) {\n  const toFontChar = [];\n  let unicode;\n  for (let i = 0, ii = encoding.length; i < ii; i++) {\n    unicode = getUnicodeForGlyph(encoding[i], glyphsUnicodeMap);\n    if (unicode !== -1) {\n      toFontChar[i] = unicode;\n    }\n  }\n  for (const charCode in differences) {\n    unicode = getUnicodeForGlyph(differences[charCode], glyphsUnicodeMap);\n    if (unicode !== -1) {\n      toFontChar[+charCode] = unicode;\n    }\n  }\n  return toFontChar;\n}\nfunction isMacNameRecord(r) {\n  return r.platform === 1 && r.encoding === 0 && r.language === 0;\n}\nfunction isWinNameRecord(r) {\n  return r.platform === 3 && r.encoding === 1 && r.language === 0x409;\n}\nfunction convertCidString(charCode, cid, shouldThrow = false) {\n  switch (cid.length) {\n    case 1:\n      return cid.charCodeAt(0);\n    case 2:\n      return cid.charCodeAt(0) << 8 | cid.charCodeAt(1);\n  }\n  const msg = `Unsupported CID string (charCode ${charCode}): \"${cid}\".`;\n  if (shouldThrow) {\n    throw new FormatError(msg);\n  }\n  warn(msg);\n  return cid;\n}\nfunction adjustMapping(charCodeToGlyphId, hasGlyph, newGlyphZeroId, toUnicode) {\n  const newMap = Object.create(null);\n  const toUnicodeExtraMap = new Map();\n  const toFontChar = [];\n  const usedGlyphIds = new Set();\n  let privateUseAreaIndex = 0;\n  const privateUseOffetStart = PRIVATE_USE_AREAS[privateUseAreaIndex][0];\n  let nextAvailableFontCharCode = privateUseOffetStart;\n  let privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];\n  const isInPrivateArea = code => PRIVATE_USE_AREAS[0][0] <= code && code <= PRIVATE_USE_AREAS[0][1] || PRIVATE_USE_AREAS[1][0] <= code && code <= PRIVATE_USE_AREAS[1][1];\n  for (let originalCharCode in charCodeToGlyphId) {\n    originalCharCode |= 0;\n    let glyphId = charCodeToGlyphId[originalCharCode];\n    if (!hasGlyph(glyphId)) {\n      continue;\n    }\n    if (nextAvailableFontCharCode > privateUseOffetEnd) {\n      privateUseAreaIndex++;\n      if (privateUseAreaIndex >= PRIVATE_USE_AREAS.length) {\n        warn(\"Ran out of space in font private use area.\");\n        break;\n      }\n      nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];\n      privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];\n    }\n    const fontCharCode = nextAvailableFontCharCode++;\n    if (glyphId === 0) {\n      glyphId = newGlyphZeroId;\n    }\n    let unicode = toUnicode.get(originalCharCode);\n    if (typeof unicode === \"string\") {\n      unicode = unicode.codePointAt(0);\n    }\n    if (unicode && !isInPrivateArea(unicode) && !usedGlyphIds.has(glyphId)) {\n      toUnicodeExtraMap.set(unicode, glyphId);\n      usedGlyphIds.add(glyphId);\n    }\n    newMap[fontCharCode] = glyphId;\n    toFontChar[originalCharCode] = fontCharCode;\n  }\n  return {\n    toFontChar,\n    charCodeToGlyphId: newMap,\n    toUnicodeExtraMap,\n    nextAvailableFontCharCode\n  };\n}\nfunction getRanges(glyphs, toUnicodeExtraMap, numGlyphs) {\n  const codes = [];\n  for (const charCode in glyphs) {\n    if (glyphs[charCode] >= numGlyphs) {\n      continue;\n    }\n    codes.push({\n      fontCharCode: charCode | 0,\n      glyphId: glyphs[charCode]\n    });\n  }\n  if (toUnicodeExtraMap) {\n    for (const [unicode, glyphId] of toUnicodeExtraMap) {\n      if (glyphId >= numGlyphs) {\n        continue;\n      }\n      codes.push({\n        fontCharCode: unicode,\n        glyphId\n      });\n    }\n  }\n  if (codes.length === 0) {\n    codes.push({\n      fontCharCode: 0,\n      glyphId: 0\n    });\n  }\n  codes.sort(function fontGetRangesSort(a, b) {\n    return a.fontCharCode - b.fontCharCode;\n  });\n  const ranges = [];\n  const length = codes.length;\n  for (let n = 0; n < length;) {\n    const start = codes[n].fontCharCode;\n    const codeIndices = [codes[n].glyphId];\n    ++n;\n    let end = start;\n    while (n < length && end + 1 === codes[n].fontCharCode) {\n      codeIndices.push(codes[n].glyphId);\n      ++end;\n      ++n;\n      if (end === 0xffff) {\n        break;\n      }\n    }\n    ranges.push([start, end, codeIndices]);\n  }\n  return ranges;\n}\nfunction createCmapTable(glyphs, toUnicodeExtraMap, numGlyphs) {\n  const ranges = getRanges(glyphs, toUnicodeExtraMap, numGlyphs);\n  const numTables = ranges.at(-1)[1] > 0xffff ? 2 : 1;\n  let cmap = \"\\x00\\x00\" + string16(numTables) + \"\\x00\\x03\" + \"\\x00\\x01\" + string32(4 + numTables * 8);\n  let i, ii, j, jj;\n  for (i = ranges.length - 1; i >= 0; --i) {\n    if (ranges[i][0] <= 0xffff) {\n      break;\n    }\n  }\n  const bmpLength = i + 1;\n  if (ranges[i][0] < 0xffff && ranges[i][1] === 0xffff) {\n    ranges[i][1] = 0xfffe;\n  }\n  const trailingRangesCount = ranges[i][1] < 0xffff ? 1 : 0;\n  const segCount = bmpLength + trailingRangesCount;\n  const searchParams = OpenTypeFileBuilder.getSearchParams(segCount, 2);\n  let startCount = \"\";\n  let endCount = \"\";\n  let idDeltas = \"\";\n  let idRangeOffsets = \"\";\n  let glyphsIds = \"\";\n  let bias = 0;\n  let range, start, end, codes;\n  for (i = 0, ii = bmpLength; i < ii; i++) {\n    range = ranges[i];\n    start = range[0];\n    end = range[1];\n    startCount += string16(start);\n    endCount += string16(end);\n    codes = range[2];\n    let contiguous = true;\n    for (j = 1, jj = codes.length; j < jj; ++j) {\n      if (codes[j] !== codes[j - 1] + 1) {\n        contiguous = false;\n        break;\n      }\n    }\n    if (!contiguous) {\n      const offset = (segCount - i) * 2 + bias * 2;\n      bias += end - start + 1;\n      idDeltas += string16(0);\n      idRangeOffsets += string16(offset);\n      for (j = 0, jj = codes.length; j < jj; ++j) {\n        glyphsIds += string16(codes[j]);\n      }\n    } else {\n      const startCode = codes[0];\n      idDeltas += string16(startCode - start & 0xffff);\n      idRangeOffsets += string16(0);\n    }\n  }\n  if (trailingRangesCount > 0) {\n    endCount += \"\\xFF\\xFF\";\n    startCount += \"\\xFF\\xFF\";\n    idDeltas += \"\\x00\\x01\";\n    idRangeOffsets += \"\\x00\\x00\";\n  }\n  const format314 = \"\\x00\\x00\" + string16(2 * segCount) + string16(searchParams.range) + string16(searchParams.entry) + string16(searchParams.rangeShift) + endCount + \"\\x00\\x00\" + startCount + idDeltas + idRangeOffsets + glyphsIds;\n  let format31012 = \"\";\n  let header31012 = \"\";\n  if (numTables > 1) {\n    cmap += \"\\x00\\x03\" + \"\\x00\\x0A\" + string32(4 + numTables * 8 + 4 + format314.length);\n    format31012 = \"\";\n    for (i = 0, ii = ranges.length; i < ii; i++) {\n      range = ranges[i];\n      start = range[0];\n      codes = range[2];\n      let code = codes[0];\n      for (j = 1, jj = codes.length; j < jj; ++j) {\n        if (codes[j] !== codes[j - 1] + 1) {\n          end = range[0] + j - 1;\n          format31012 += string32(start) + string32(end) + string32(code);\n          start = end + 1;\n          code = codes[j];\n        }\n      }\n      format31012 += string32(start) + string32(range[1]) + string32(code);\n    }\n    header31012 = \"\\x00\\x0C\" + \"\\x00\\x00\" + string32(format31012.length + 16) + \"\\x00\\x00\\x00\\x00\" + string32(format31012.length / 12);\n  }\n  return cmap + \"\\x00\\x04\" + string16(format314.length + 4) + format314 + header31012 + format31012;\n}\nfunction validateOS2Table(os2, file) {\n  file.pos = (file.start || 0) + os2.offset;\n  const version = file.getUint16();\n  file.skip(60);\n  const selection = file.getUint16();\n  if (version < 4 && selection & 0x0300) {\n    return false;\n  }\n  const firstChar = file.getUint16();\n  const lastChar = file.getUint16();\n  if (firstChar > lastChar) {\n    return false;\n  }\n  file.skip(6);\n  const usWinAscent = file.getUint16();\n  if (usWinAscent === 0) {\n    return false;\n  }\n  os2.data[8] = os2.data[9] = 0;\n  return true;\n}\nfunction createOS2Table(properties, charstrings, override) {\n  override ||= {\n    unitsPerEm: 0,\n    yMax: 0,\n    yMin: 0,\n    ascent: 0,\n    descent: 0\n  };\n  let ulUnicodeRange1 = 0;\n  let ulUnicodeRange2 = 0;\n  let ulUnicodeRange3 = 0;\n  let ulUnicodeRange4 = 0;\n  let firstCharIndex = null;\n  let lastCharIndex = 0;\n  let position = -1;\n  if (charstrings) {\n    for (let code in charstrings) {\n      code |= 0;\n      if (firstCharIndex > code || !firstCharIndex) {\n        firstCharIndex = code;\n      }\n      if (lastCharIndex < code) {\n        lastCharIndex = code;\n      }\n      position = getUnicodeRangeFor(code, position);\n      if (position < 32) {\n        ulUnicodeRange1 |= 1 << position;\n      } else if (position < 64) {\n        ulUnicodeRange2 |= 1 << position - 32;\n      } else if (position < 96) {\n        ulUnicodeRange3 |= 1 << position - 64;\n      } else if (position < 123) {\n        ulUnicodeRange4 |= 1 << position - 96;\n      } else {\n        throw new FormatError(\"Unicode ranges Bits > 123 are reserved for internal usage\");\n      }\n    }\n    if (lastCharIndex > 0xffff) {\n      lastCharIndex = 0xffff;\n    }\n  } else {\n    firstCharIndex = 0;\n    lastCharIndex = 255;\n  }\n  const bbox = properties.bbox || [0, 0, 0, 0];\n  const unitsPerEm = override.unitsPerEm || 1 / (properties.fontMatrix || FONT_IDENTITY_MATRIX)[0];\n  const scale = properties.ascentScaled ? 1.0 : unitsPerEm / PDF_GLYPH_SPACE_UNITS;\n  const typoAscent = override.ascent || Math.round(scale * (properties.ascent || bbox[3]));\n  let typoDescent = override.descent || Math.round(scale * (properties.descent || bbox[1]));\n  if (typoDescent > 0 && properties.descent > 0 && bbox[1] < 0) {\n    typoDescent = -typoDescent;\n  }\n  const winAscent = override.yMax || typoAscent;\n  const winDescent = -override.yMin || -typoDescent;\n  return \"\\x00\\x03\" + \"\\x02\\x24\" + \"\\x01\\xF4\" + \"\\x00\\x05\" + \"\\x00\\x00\" + \"\\x02\\x8A\" + \"\\x02\\xBB\" + \"\\x00\\x00\" + \"\\x00\\x8C\" + \"\\x02\\x8A\" + \"\\x02\\xBB\" + \"\\x00\\x00\" + \"\\x01\\xDF\" + \"\\x00\\x31\" + \"\\x01\\x02\" + \"\\x00\\x00\" + \"\\x00\\x00\\x06\" + String.fromCharCode(properties.fixedPitch ? 0x09 : 0x00) + \"\\x00\\x00\\x00\\x00\\x00\\x00\" + string32(ulUnicodeRange1) + string32(ulUnicodeRange2) + string32(ulUnicodeRange3) + string32(ulUnicodeRange4) + \"\\x2A\\x32\\x31\\x2A\" + string16(properties.italicAngle ? 1 : 0) + string16(firstCharIndex || properties.firstChar) + string16(lastCharIndex || properties.lastChar) + string16(typoAscent) + string16(typoDescent) + \"\\x00\\x64\" + string16(winAscent) + string16(winDescent) + \"\\x00\\x00\\x00\\x00\" + \"\\x00\\x00\\x00\\x00\" + string16(properties.xHeight) + string16(properties.capHeight) + string16(0) + string16(firstCharIndex || properties.firstChar) + \"\\x00\\x03\";\n}\nfunction createPostTable(properties) {\n  const angle = Math.floor(properties.italicAngle * 2 ** 16);\n  return \"\\x00\\x03\\x00\\x00\" + string32(angle) + \"\\x00\\x00\" + \"\\x00\\x00\" + string32(properties.fixedPitch ? 1 : 0) + \"\\x00\\x00\\x00\\x00\" + \"\\x00\\x00\\x00\\x00\" + \"\\x00\\x00\\x00\\x00\" + \"\\x00\\x00\\x00\\x00\";\n}\nfunction createPostscriptName(name) {\n  return name.replaceAll(/[^\\x21-\\x7E]|[[\\](){}<>/%]/g, \"\").slice(0, 63);\n}\nfunction createNameTable(name, proto) {\n  if (!proto) {\n    proto = [[], []];\n  }\n  const strings = [proto[0][0] || \"Original licence\", proto[0][1] || name, proto[0][2] || \"Unknown\", proto[0][3] || \"uniqueID\", proto[0][4] || name, proto[0][5] || \"Version 0.11\", proto[0][6] || createPostscriptName(name), proto[0][7] || \"Unknown\", proto[0][8] || \"Unknown\", proto[0][9] || \"Unknown\"];\n  const stringsUnicode = [];\n  let i, ii, j, jj, str;\n  for (i = 0, ii = strings.length; i < ii; i++) {\n    str = proto[1][i] || strings[i];\n    const strBufUnicode = [];\n    for (j = 0, jj = str.length; j < jj; j++) {\n      strBufUnicode.push(string16(str.charCodeAt(j)));\n    }\n    stringsUnicode.push(strBufUnicode.join(\"\"));\n  }\n  const names = [strings, stringsUnicode];\n  const platforms = [\"\\x00\\x01\", \"\\x00\\x03\"];\n  const encodings = [\"\\x00\\x00\", \"\\x00\\x01\"];\n  const languages = [\"\\x00\\x00\", \"\\x04\\x09\"];\n  const namesRecordCount = strings.length * platforms.length;\n  let nameTable = \"\\x00\\x00\" + string16(namesRecordCount) + string16(namesRecordCount * 12 + 6);\n  let strOffset = 0;\n  for (i = 0, ii = platforms.length; i < ii; i++) {\n    const strs = names[i];\n    for (j = 0, jj = strs.length; j < jj; j++) {\n      str = strs[j];\n      const nameRecord = platforms[i] + encodings[i] + languages[i] + string16(j) + string16(str.length) + string16(strOffset);\n      nameTable += nameRecord;\n      strOffset += str.length;\n    }\n  }\n  nameTable += strings.join(\"\") + stringsUnicode.join(\"\");\n  return nameTable;\n}\nclass Font {\n  constructor(name, file, properties) {\n    this.name = name;\n    this.psName = null;\n    this.mimetype = null;\n    this.disableFontFace = false;\n    this.loadedName = properties.loadedName;\n    this.isType3Font = properties.isType3Font;\n    this.missingFile = false;\n    this.cssFontInfo = properties.cssFontInfo;\n    this._charsCache = Object.create(null);\n    this._glyphCache = Object.create(null);\n    let isSerifFont = !!(properties.flags & FontFlags.Serif);\n    if (!isSerifFont && !properties.isSimulatedFlags) {\n      const baseName = name.replaceAll(/[,_]/g, \"-\").split(\"-\", 1)[0],\n        serifFonts = getSerifFonts();\n      for (const namePart of baseName.split(\"+\")) {\n        if (serifFonts[namePart]) {\n          isSerifFont = true;\n          break;\n        }\n      }\n    }\n    this.isSerifFont = isSerifFont;\n    this.isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);\n    this.isMonospace = !!(properties.flags & FontFlags.FixedPitch);\n    let {\n      type,\n      subtype\n    } = properties;\n    this.type = type;\n    this.subtype = subtype;\n    this.systemFontInfo = properties.systemFontInfo;\n    const matches = name.match(/^InvalidPDFjsFont_(.*)_\\d+$/);\n    this.isInvalidPDFjsFont = !!matches;\n    if (this.isInvalidPDFjsFont) {\n      this.fallbackName = matches[1];\n    } else if (this.isMonospace) {\n      this.fallbackName = \"monospace\";\n    } else if (this.isSerifFont) {\n      this.fallbackName = \"serif\";\n    } else {\n      this.fallbackName = \"sans-serif\";\n    }\n    if (this.systemFontInfo?.guessFallback) {\n      this.systemFontInfo.guessFallback = false;\n      this.systemFontInfo.css += `,${this.fallbackName}`;\n    }\n    this.differences = properties.differences;\n    this.widths = properties.widths;\n    this.defaultWidth = properties.defaultWidth;\n    this.composite = properties.composite;\n    this.cMap = properties.cMap;\n    this.capHeight = properties.capHeight / PDF_GLYPH_SPACE_UNITS;\n    this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;\n    this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;\n    this.lineHeight = this.ascent - this.descent;\n    this.fontMatrix = properties.fontMatrix;\n    this.bbox = properties.bbox;\n    this.defaultEncoding = properties.defaultEncoding;\n    this.toUnicode = properties.toUnicode;\n    this.toFontChar = [];\n    if (properties.type === \"Type3\") {\n      for (let charCode = 0; charCode < 256; charCode++) {\n        this.toFontChar[charCode] = this.differences[charCode] || properties.defaultEncoding[charCode];\n      }\n      return;\n    }\n    this.cidEncoding = properties.cidEncoding || \"\";\n    this.vertical = !!properties.vertical;\n    if (this.vertical) {\n      this.vmetrics = properties.vmetrics;\n      this.defaultVMetrics = properties.defaultVMetrics;\n    }\n    if (!file || file.isEmpty) {\n      if (file) {\n        warn('Font file is empty in \"' + name + '\" (' + this.loadedName + \")\");\n      }\n      this.fallbackToSystemFont(properties);\n      return;\n    }\n    [type, subtype] = getFontFileType(file, properties);\n    if (type !== this.type || subtype !== this.subtype) {\n      info(\"Inconsistent font file Type/SubType, expected: \" + `${this.type}/${this.subtype} but found: ${type}/${subtype}.`);\n    }\n    let data;\n    try {\n      switch (type) {\n        case \"MMType1\":\n          info(\"MMType1 font (\" + name + \"), falling back to Type1.\");\n        case \"Type1\":\n        case \"CIDFontType0\":\n          this.mimetype = \"font/opentype\";\n          const cff = subtype === \"Type1C\" || subtype === \"CIDFontType0C\" ? new CFFFont(file, properties) : new Type1Font(name, file, properties);\n          adjustWidths(properties);\n          data = this.convert(name, cff, properties);\n          break;\n        case \"OpenType\":\n        case \"TrueType\":\n        case \"CIDFontType2\":\n          this.mimetype = \"font/opentype\";\n          data = this.checkAndRepair(name, file, properties);\n          if (this.isOpenType) {\n            adjustWidths(properties);\n            type = \"OpenType\";\n          }\n          break;\n        default:\n          throw new FormatError(`Font ${type} is not supported`);\n      }\n    } catch (e) {\n      warn(e);\n      this.fallbackToSystemFont(properties);\n      return;\n    }\n    amendFallbackToUnicode(properties);\n    this.data = data;\n    this.type = type;\n    this.subtype = subtype;\n    this.fontMatrix = properties.fontMatrix;\n    this.widths = properties.widths;\n    this.defaultWidth = properties.defaultWidth;\n    this.toUnicode = properties.toUnicode;\n    this.seacMap = properties.seacMap;\n  }\n  get renderer() {\n    const renderer = FontRendererFactory.create(this, SEAC_ANALYSIS_ENABLED);\n    return shadow(this, \"renderer\", renderer);\n  }\n  exportData(extraProperties = false) {\n    const exportDataProperties = extraProperties ? [...EXPORT_DATA_PROPERTIES, ...EXPORT_DATA_EXTRA_PROPERTIES] : EXPORT_DATA_PROPERTIES;\n    const data = Object.create(null);\n    let property, value;\n    for (property of exportDataProperties) {\n      value = this[property];\n      if (value !== undefined) {\n        data[property] = value;\n      }\n    }\n    return data;\n  }\n  fallbackToSystemFont(properties) {\n    this.missingFile = true;\n    const {\n      name,\n      type\n    } = this;\n    let fontName = normalizeFontName(name);\n    const stdFontMap = getStdFontMap(),\n      nonStdFontMap = getNonStdFontMap();\n    const isStandardFont = !!stdFontMap[fontName];\n    const isMappedToStandardFont = !!(nonStdFontMap[fontName] && stdFontMap[nonStdFontMap[fontName]]);\n    fontName = stdFontMap[fontName] || nonStdFontMap[fontName] || fontName;\n    const fontBasicMetricsMap = getFontBasicMetrics();\n    const metrics = fontBasicMetricsMap[fontName];\n    if (metrics) {\n      if (isNaN(this.ascent)) {\n        this.ascent = metrics.ascent / PDF_GLYPH_SPACE_UNITS;\n      }\n      if (isNaN(this.descent)) {\n        this.descent = metrics.descent / PDF_GLYPH_SPACE_UNITS;\n      }\n      if (isNaN(this.capHeight)) {\n        this.capHeight = metrics.capHeight / PDF_GLYPH_SPACE_UNITS;\n      }\n    }\n    this.bold = /bold/gi.test(fontName);\n    this.italic = /oblique|italic/gi.test(fontName);\n    this.black = /Black/g.test(name);\n    const isNarrow = /Narrow/g.test(name);\n    this.remeasure = (!isStandardFont || isNarrow) && Object.keys(this.widths).length > 0;\n    if ((isStandardFont || isMappedToStandardFont) && type === \"CIDFontType2\" && this.cidEncoding.startsWith(\"Identity-\")) {\n      const cidToGidMap = properties.cidToGidMap;\n      const map = [];\n      applyStandardFontGlyphMap(map, getGlyphMapForStandardFonts());\n      if (/Arial-?Black/i.test(name)) {\n        applyStandardFontGlyphMap(map, getSupplementalGlyphMapForArialBlack());\n      } else if (/Calibri/i.test(name)) {\n        applyStandardFontGlyphMap(map, getSupplementalGlyphMapForCalibri());\n      }\n      if (cidToGidMap) {\n        for (const charCode in map) {\n          const cid = map[charCode];\n          if (cidToGidMap[cid] !== undefined) {\n            map[+charCode] = cidToGidMap[cid];\n          }\n        }\n        if (cidToGidMap.length !== this.toUnicode.length && properties.hasIncludedToUnicodeMap && this.toUnicode instanceof IdentityToUnicodeMap) {\n          this.toUnicode.forEach(function (charCode, unicodeCharCode) {\n            const cid = map[charCode];\n            if (cidToGidMap[cid] === undefined) {\n              map[+charCode] = unicodeCharCode;\n            }\n          });\n        }\n      }\n      if (!(this.toUnicode instanceof IdentityToUnicodeMap)) {\n        this.toUnicode.forEach(function (charCode, unicodeCharCode) {\n          map[+charCode] = unicodeCharCode;\n        });\n      }\n      this.toFontChar = map;\n      this.toUnicode = new ToUnicodeMap(map);\n    } else if (/Symbol/i.test(fontName)) {\n      this.toFontChar = buildToFontChar(SymbolSetEncoding, getGlyphsUnicode(), this.differences);\n    } else if (/Dingbats/i.test(fontName)) {\n      this.toFontChar = buildToFontChar(ZapfDingbatsEncoding, getDingbatsGlyphsUnicode(), this.differences);\n    } else if (isStandardFont) {\n      const map = buildToFontChar(this.defaultEncoding, getGlyphsUnicode(), this.differences);\n      if (type === \"CIDFontType2\" && !this.cidEncoding.startsWith(\"Identity-\") && !(this.toUnicode instanceof IdentityToUnicodeMap)) {\n        this.toUnicode.forEach(function (charCode, unicodeCharCode) {\n          map[+charCode] = unicodeCharCode;\n        });\n      }\n      this.toFontChar = map;\n    } else {\n      const glyphsUnicodeMap = getGlyphsUnicode();\n      const map = [];\n      this.toUnicode.forEach((charCode, unicodeCharCode) => {\n        if (!this.composite) {\n          const glyphName = this.differences[charCode] || this.defaultEncoding[charCode];\n          const unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);\n          if (unicode !== -1) {\n            unicodeCharCode = unicode;\n          }\n        }\n        map[+charCode] = unicodeCharCode;\n      });\n      if (this.composite && this.toUnicode instanceof IdentityToUnicodeMap) {\n        if (/Tahoma|Verdana/i.test(name)) {\n          applyStandardFontGlyphMap(map, getGlyphMapForStandardFonts());\n        }\n      }\n      this.toFontChar = map;\n    }\n    amendFallbackToUnicode(properties);\n    this.loadedName = fontName.split(\"-\", 1)[0];\n  }\n  checkAndRepair(name, font, properties) {\n    const VALID_TABLES = [\"OS/2\", \"cmap\", \"head\", \"hhea\", \"hmtx\", \"maxp\", \"name\", \"post\", \"loca\", \"glyf\", \"fpgm\", \"prep\", \"cvt \", \"CFF \"];\n    function readTables(file, numTables) {\n      const tables = Object.create(null);\n      tables[\"OS/2\"] = null;\n      tables.cmap = null;\n      tables.head = null;\n      tables.hhea = null;\n      tables.hmtx = null;\n      tables.maxp = null;\n      tables.name = null;\n      tables.post = null;\n      for (let i = 0; i < numTables; i++) {\n        const table = readTableEntry(file);\n        if (!VALID_TABLES.includes(table.tag)) {\n          continue;\n        }\n        if (table.length === 0) {\n          continue;\n        }\n        tables[table.tag] = table;\n      }\n      return tables;\n    }\n    function readTableEntry(file) {\n      const tag = file.getString(4);\n      const checksum = file.getInt32() >>> 0;\n      const offset = file.getInt32() >>> 0;\n      const length = file.getInt32() >>> 0;\n      const previousPosition = file.pos;\n      file.pos = file.start || 0;\n      file.skip(offset);\n      const data = file.getBytes(length);\n      file.pos = previousPosition;\n      if (tag === \"head\") {\n        data[8] = data[9] = data[10] = data[11] = 0;\n        data[17] |= 0x20;\n      }\n      return {\n        tag,\n        checksum,\n        length,\n        offset,\n        data\n      };\n    }\n    function readOpenTypeHeader(ttf) {\n      return {\n        version: ttf.getString(4),\n        numTables: ttf.getUint16(),\n        searchRange: ttf.getUint16(),\n        entrySelector: ttf.getUint16(),\n        rangeShift: ttf.getUint16()\n      };\n    }\n    function readTrueTypeCollectionHeader(ttc) {\n      const ttcTag = ttc.getString(4);\n      assert(ttcTag === \"ttcf\", \"Must be a TrueType Collection font.\");\n      const majorVersion = ttc.getUint16();\n      const minorVersion = ttc.getUint16();\n      const numFonts = ttc.getInt32() >>> 0;\n      const offsetTable = [];\n      for (let i = 0; i < numFonts; i++) {\n        offsetTable.push(ttc.getInt32() >>> 0);\n      }\n      const header = {\n        ttcTag,\n        majorVersion,\n        minorVersion,\n        numFonts,\n        offsetTable\n      };\n      switch (majorVersion) {\n        case 1:\n          return header;\n        case 2:\n          header.dsigTag = ttc.getInt32() >>> 0;\n          header.dsigLength = ttc.getInt32() >>> 0;\n          header.dsigOffset = ttc.getInt32() >>> 0;\n          return header;\n      }\n      throw new FormatError(`Invalid TrueType Collection majorVersion: ${majorVersion}.`);\n    }\n    function readTrueTypeCollectionData(ttc, fontName) {\n      const {\n        numFonts,\n        offsetTable\n      } = readTrueTypeCollectionHeader(ttc);\n      const fontNameParts = fontName.split(\"+\");\n      let fallbackData;\n      for (let i = 0; i < numFonts; i++) {\n        ttc.pos = (ttc.start || 0) + offsetTable[i];\n        const potentialHeader = readOpenTypeHeader(ttc);\n        const potentialTables = readTables(ttc, potentialHeader.numTables);\n        if (!potentialTables.name) {\n          throw new FormatError('TrueType Collection font must contain a \"name\" table.');\n        }\n        const [nameTable] = readNameTable(potentialTables.name);\n        for (let j = 0, jj = nameTable.length; j < jj; j++) {\n          for (let k = 0, kk = nameTable[j].length; k < kk; k++) {\n            const nameEntry = nameTable[j][k]?.replaceAll(/\\s/g, \"\");\n            if (!nameEntry) {\n              continue;\n            }\n            if (nameEntry === fontName) {\n              return {\n                header: potentialHeader,\n                tables: potentialTables\n              };\n            }\n            if (fontNameParts.length < 2) {\n              continue;\n            }\n            for (const part of fontNameParts) {\n              if (nameEntry === part) {\n                fallbackData = {\n                  name: part,\n                  header: potentialHeader,\n                  tables: potentialTables\n                };\n              }\n            }\n          }\n        }\n      }\n      if (fallbackData) {\n        warn(`TrueType Collection does not contain \"${fontName}\" font, ` + `falling back to \"${fallbackData.name}\" font instead.`);\n        return {\n          header: fallbackData.header,\n          tables: fallbackData.tables\n        };\n      }\n      throw new FormatError(`TrueType Collection does not contain \"${fontName}\" font.`);\n    }\n    function readCmapTable(cmap, file, isSymbolicFont, hasEncoding) {\n      if (!cmap) {\n        warn(\"No cmap table available.\");\n        return {\n          platformId: -1,\n          encodingId: -1,\n          mappings: [],\n          hasShortCmap: false\n        };\n      }\n      let segment;\n      let start = (file.start || 0) + cmap.offset;\n      file.pos = start;\n      file.skip(2);\n      const numTables = file.getUint16();\n      let potentialTable;\n      let canBreak = false;\n      for (let i = 0; i < numTables; i++) {\n        const platformId = file.getUint16();\n        const encodingId = file.getUint16();\n        const offset = file.getInt32() >>> 0;\n        let useTable = false;\n        if (potentialTable?.platformId === platformId && potentialTable?.encodingId === encodingId) {\n          continue;\n        }\n        if (platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 3)) {\n          useTable = true;\n        } else if (platformId === 1 && encodingId === 0) {\n          useTable = true;\n        } else if (platformId === 3 && encodingId === 1 && (hasEncoding || !potentialTable)) {\n          useTable = true;\n          if (!isSymbolicFont) {\n            canBreak = true;\n          }\n        } else if (isSymbolicFont && platformId === 3 && encodingId === 0) {\n          useTable = true;\n          let correctlySorted = true;\n          if (i < numTables - 1) {\n            const nextBytes = file.peekBytes(2),\n              nextPlatformId = int16(nextBytes[0], nextBytes[1]);\n            if (nextPlatformId < platformId) {\n              correctlySorted = false;\n            }\n          }\n          if (correctlySorted) {\n            canBreak = true;\n          }\n        }\n        if (useTable) {\n          potentialTable = {\n            platformId,\n            encodingId,\n            offset\n          };\n        }\n        if (canBreak) {\n          break;\n        }\n      }\n      if (potentialTable) {\n        file.pos = start + potentialTable.offset;\n      }\n      if (!potentialTable || file.peekByte() === -1) {\n        warn(\"Could not find a preferred cmap table.\");\n        return {\n          platformId: -1,\n          encodingId: -1,\n          mappings: [],\n          hasShortCmap: false\n        };\n      }\n      const format = file.getUint16();\n      let hasShortCmap = false;\n      const mappings = [];\n      let j, glyphId;\n      if (format === 0) {\n        file.skip(2 + 2);\n        for (j = 0; j < 256; j++) {\n          const index = file.getByte();\n          if (!index) {\n            continue;\n          }\n          mappings.push({\n            charCode: j,\n            glyphId: index\n          });\n        }\n        hasShortCmap = true;\n      } else if (format === 2) {\n        file.skip(2 + 2);\n        const subHeaderKeys = [];\n        let maxSubHeaderKey = 0;\n        for (let i = 0; i < 256; i++) {\n          const subHeaderKey = file.getUint16() >> 3;\n          subHeaderKeys.push(subHeaderKey);\n          maxSubHeaderKey = Math.max(subHeaderKey, maxSubHeaderKey);\n        }\n        const subHeaders = [];\n        for (let i = 0; i <= maxSubHeaderKey; i++) {\n          subHeaders.push({\n            firstCode: file.getUint16(),\n            entryCount: file.getUint16(),\n            idDelta: signedInt16(file.getByte(), file.getByte()),\n            idRangePos: file.pos + file.getUint16()\n          });\n        }\n        for (let i = 0; i < 256; i++) {\n          if (subHeaderKeys[i] === 0) {\n            file.pos = subHeaders[0].idRangePos + 2 * i;\n            glyphId = file.getUint16();\n            mappings.push({\n              charCode: i,\n              glyphId\n            });\n          } else {\n            const s = subHeaders[subHeaderKeys[i]];\n            for (j = 0; j < s.entryCount; j++) {\n              const charCode = (i << 8) + j + s.firstCode;\n              file.pos = s.idRangePos + 2 * j;\n              glyphId = file.getUint16();\n              if (glyphId !== 0) {\n                glyphId = (glyphId + s.idDelta) % 65536;\n              }\n              mappings.push({\n                charCode,\n                glyphId\n              });\n            }\n          }\n        }\n      } else if (format === 4) {\n        file.skip(2 + 2);\n        const segCount = file.getUint16() >> 1;\n        file.skip(6);\n        const segments = [];\n        let segIndex;\n        for (segIndex = 0; segIndex < segCount; segIndex++) {\n          segments.push({\n            end: file.getUint16()\n          });\n        }\n        file.skip(2);\n        for (segIndex = 0; segIndex < segCount; segIndex++) {\n          segments[segIndex].start = file.getUint16();\n        }\n        for (segIndex = 0; segIndex < segCount; segIndex++) {\n          segments[segIndex].delta = file.getUint16();\n        }\n        let offsetsCount = 0,\n          offsetIndex;\n        for (segIndex = 0; segIndex < segCount; segIndex++) {\n          segment = segments[segIndex];\n          const rangeOffset = file.getUint16();\n          if (!rangeOffset) {\n            segment.offsetIndex = -1;\n            continue;\n          }\n          offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);\n          segment.offsetIndex = offsetIndex;\n          offsetsCount = Math.max(offsetsCount, offsetIndex + segment.end - segment.start + 1);\n        }\n        const offsets = [];\n        for (j = 0; j < offsetsCount; j++) {\n          offsets.push(file.getUint16());\n        }\n        for (segIndex = 0; segIndex < segCount; segIndex++) {\n          segment = segments[segIndex];\n          start = segment.start;\n          const end = segment.end;\n          const delta = segment.delta;\n          offsetIndex = segment.offsetIndex;\n          for (j = start; j <= end; j++) {\n            if (j === 0xffff) {\n              continue;\n            }\n            glyphId = offsetIndex < 0 ? j : offsets[offsetIndex + j - start];\n            glyphId = glyphId + delta & 0xffff;\n            mappings.push({\n              charCode: j,\n              glyphId\n            });\n          }\n        }\n      } else if (format === 6) {\n        file.skip(2 + 2);\n        const firstCode = file.getUint16();\n        const entryCount = file.getUint16();\n        for (j = 0; j < entryCount; j++) {\n          glyphId = file.getUint16();\n          const charCode = firstCode + j;\n          mappings.push({\n            charCode,\n            glyphId\n          });\n        }\n      } else if (format === 12) {\n        file.skip(2 + 4 + 4);\n        const nGroups = file.getInt32() >>> 0;\n        for (j = 0; j < nGroups; j++) {\n          const startCharCode = file.getInt32() >>> 0;\n          const endCharCode = file.getInt32() >>> 0;\n          let glyphCode = file.getInt32() >>> 0;\n          for (let charCode = startCharCode; charCode <= endCharCode; charCode++) {\n            mappings.push({\n              charCode,\n              glyphId: glyphCode++\n            });\n          }\n        }\n      } else {\n        warn(\"cmap table has unsupported format: \" + format);\n        return {\n          platformId: -1,\n          encodingId: -1,\n          mappings: [],\n          hasShortCmap: false\n        };\n      }\n      mappings.sort(function (a, b) {\n        return a.charCode - b.charCode;\n      });\n      for (let i = 1; i < mappings.length; i++) {\n        if (mappings[i - 1].charCode === mappings[i].charCode) {\n          mappings.splice(i, 1);\n          i--;\n        }\n      }\n      return {\n        platformId: potentialTable.platformId,\n        encodingId: potentialTable.encodingId,\n        mappings,\n        hasShortCmap\n      };\n    }\n    function sanitizeMetrics(file, header, metrics, headTable, numGlyphs, dupFirstEntry) {\n      if (!header) {\n        if (metrics) {\n          metrics.data = null;\n        }\n        return;\n      }\n      file.pos = (file.start || 0) + header.offset;\n      file.pos += 4;\n      file.pos += 2;\n      file.pos += 2;\n      file.pos += 2;\n      file.pos += 2;\n      file.pos += 2;\n      file.pos += 2;\n      file.pos += 2;\n      file.pos += 2;\n      file.pos += 2;\n      const caretOffset = file.getUint16();\n      file.pos += 8;\n      file.pos += 2;\n      let numOfMetrics = file.getUint16();\n      if (caretOffset !== 0) {\n        const macStyle = int16(headTable.data[44], headTable.data[45]);\n        if (!(macStyle & 2)) {\n          header.data[22] = 0;\n          header.data[23] = 0;\n        }\n      }\n      if (numOfMetrics > numGlyphs) {\n        info(`The numOfMetrics (${numOfMetrics}) should not be ` + `greater than the numGlyphs (${numGlyphs}).`);\n        numOfMetrics = numGlyphs;\n        header.data[34] = (numOfMetrics & 0xff00) >> 8;\n        header.data[35] = numOfMetrics & 0x00ff;\n      }\n      const numOfSidebearings = numGlyphs - numOfMetrics;\n      const numMissing = numOfSidebearings - (metrics.length - numOfMetrics * 4 >> 1);\n      if (numMissing > 0) {\n        const entries = new Uint8Array(metrics.length + numMissing * 2);\n        entries.set(metrics.data);\n        if (dupFirstEntry) {\n          entries[metrics.length] = metrics.data[2];\n          entries[metrics.length + 1] = metrics.data[3];\n        }\n        metrics.data = entries;\n      }\n    }\n    function sanitizeGlyph(source, sourceStart, sourceEnd, dest, destStart, hintsValid) {\n      const glyphProfile = {\n        length: 0,\n        sizeOfInstructions: 0\n      };\n      if (sourceStart < 0 || sourceStart >= source.length || sourceEnd > source.length || sourceEnd - sourceStart <= 12) {\n        return glyphProfile;\n      }\n      const glyf = source.subarray(sourceStart, sourceEnd);\n      const xMin = signedInt16(glyf[2], glyf[3]);\n      const yMin = signedInt16(glyf[4], glyf[5]);\n      const xMax = signedInt16(glyf[6], glyf[7]);\n      const yMax = signedInt16(glyf[8], glyf[9]);\n      if (xMin > xMax) {\n        writeSignedInt16(glyf, 2, xMax);\n        writeSignedInt16(glyf, 6, xMin);\n      }\n      if (yMin > yMax) {\n        writeSignedInt16(glyf, 4, yMax);\n        writeSignedInt16(glyf, 8, yMin);\n      }\n      const contoursCount = signedInt16(glyf[0], glyf[1]);\n      if (contoursCount < 0) {\n        if (contoursCount < -1) {\n          return glyphProfile;\n        }\n        dest.set(glyf, destStart);\n        glyphProfile.length = glyf.length;\n        return glyphProfile;\n      }\n      let i,\n        j = 10,\n        flagsCount = 0;\n      for (i = 0; i < contoursCount; i++) {\n        const endPoint = glyf[j] << 8 | glyf[j + 1];\n        flagsCount = endPoint + 1;\n        j += 2;\n      }\n      const instructionsStart = j;\n      const instructionsLength = glyf[j] << 8 | glyf[j + 1];\n      glyphProfile.sizeOfInstructions = instructionsLength;\n      j += 2 + instructionsLength;\n      const instructionsEnd = j;\n      let coordinatesLength = 0;\n      for (i = 0; i < flagsCount; i++) {\n        const flag = glyf[j++];\n        if (flag & 0xc0) {\n          glyf[j - 1] = flag & 0x3f;\n        }\n        let xLength = 2;\n        if (flag & 2) {\n          xLength = 1;\n        } else if (flag & 16) {\n          xLength = 0;\n        }\n        let yLength = 2;\n        if (flag & 4) {\n          yLength = 1;\n        } else if (flag & 32) {\n          yLength = 0;\n        }\n        const xyLength = xLength + yLength;\n        coordinatesLength += xyLength;\n        if (flag & 8) {\n          const repeat = glyf[j++];\n          if (repeat === 0) {\n            glyf[j - 1] ^= 8;\n          }\n          i += repeat;\n          coordinatesLength += repeat * xyLength;\n        }\n      }\n      if (coordinatesLength === 0) {\n        return glyphProfile;\n      }\n      let glyphDataLength = j + coordinatesLength;\n      if (glyphDataLength > glyf.length) {\n        return glyphProfile;\n      }\n      if (!hintsValid && instructionsLength > 0) {\n        dest.set(glyf.subarray(0, instructionsStart), destStart);\n        dest.set([0, 0], destStart + instructionsStart);\n        dest.set(glyf.subarray(instructionsEnd, glyphDataLength), destStart + instructionsStart + 2);\n        glyphDataLength -= instructionsLength;\n        if (glyf.length - glyphDataLength > 3) {\n          glyphDataLength = glyphDataLength + 3 & ~3;\n        }\n        glyphProfile.length = glyphDataLength;\n        return glyphProfile;\n      }\n      if (glyf.length - glyphDataLength > 3) {\n        glyphDataLength = glyphDataLength + 3 & ~3;\n        dest.set(glyf.subarray(0, glyphDataLength), destStart);\n        glyphProfile.length = glyphDataLength;\n        return glyphProfile;\n      }\n      dest.set(glyf, destStart);\n      glyphProfile.length = glyf.length;\n      return glyphProfile;\n    }\n    function sanitizeHead(head, numGlyphs, locaLength) {\n      const data = head.data;\n      const version = int32(data[0], data[1], data[2], data[3]);\n      if (version >> 16 !== 1) {\n        info(\"Attempting to fix invalid version in head table: \" + version);\n        data[0] = 0;\n        data[1] = 1;\n        data[2] = 0;\n        data[3] = 0;\n      }\n      const indexToLocFormat = int16(data[50], data[51]);\n      if (indexToLocFormat < 0 || indexToLocFormat > 1) {\n        info(\"Attempting to fix invalid indexToLocFormat in head table: \" + indexToLocFormat);\n        const numGlyphsPlusOne = numGlyphs + 1;\n        if (locaLength === numGlyphsPlusOne << 1) {\n          data[50] = 0;\n          data[51] = 0;\n        } else if (locaLength === numGlyphsPlusOne << 2) {\n          data[50] = 0;\n          data[51] = 1;\n        } else {\n          throw new FormatError(\"Could not fix indexToLocFormat: \" + indexToLocFormat);\n        }\n      }\n    }\n    function sanitizeGlyphLocations(loca, glyf, numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry, maxSizeOfInstructions) {\n      let itemSize, itemDecode, itemEncode;\n      if (isGlyphLocationsLong) {\n        itemSize = 4;\n        itemDecode = function fontItemDecodeLong(data, offset) {\n          return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];\n        };\n        itemEncode = function fontItemEncodeLong(data, offset, value) {\n          data[offset] = value >>> 24 & 0xff;\n          data[offset + 1] = value >> 16 & 0xff;\n          data[offset + 2] = value >> 8 & 0xff;\n          data[offset + 3] = value & 0xff;\n        };\n      } else {\n        itemSize = 2;\n        itemDecode = function fontItemDecode(data, offset) {\n          return data[offset] << 9 | data[offset + 1] << 1;\n        };\n        itemEncode = function fontItemEncode(data, offset, value) {\n          data[offset] = value >> 9 & 0xff;\n          data[offset + 1] = value >> 1 & 0xff;\n        };\n      }\n      const numGlyphsOut = dupFirstEntry ? numGlyphs + 1 : numGlyphs;\n      const locaDataSize = itemSize * (1 + numGlyphsOut);\n      const locaData = new Uint8Array(locaDataSize);\n      locaData.set(loca.data.subarray(0, locaDataSize));\n      loca.data = locaData;\n      const oldGlyfData = glyf.data;\n      const oldGlyfDataLength = oldGlyfData.length;\n      const newGlyfData = new Uint8Array(oldGlyfDataLength);\n      let i, j;\n      const locaEntries = [];\n      for (i = 0, j = 0; i < numGlyphs + 1; i++, j += itemSize) {\n        let offset = itemDecode(locaData, j);\n        if (offset > oldGlyfDataLength) {\n          offset = oldGlyfDataLength;\n        }\n        locaEntries.push({\n          index: i,\n          offset,\n          endOffset: 0\n        });\n      }\n      locaEntries.sort((a, b) => a.offset - b.offset);\n      for (i = 0; i < numGlyphs; i++) {\n        locaEntries[i].endOffset = locaEntries[i + 1].offset;\n      }\n      locaEntries.sort((a, b) => a.index - b.index);\n      for (i = 0; i < numGlyphs; i++) {\n        const {\n          offset,\n          endOffset\n        } = locaEntries[i];\n        if (offset !== 0 || endOffset !== 0) {\n          break;\n        }\n        const nextOffset = locaEntries[i + 1].offset;\n        if (nextOffset === 0) {\n          continue;\n        }\n        locaEntries[i].endOffset = nextOffset;\n        break;\n      }\n      const last = locaEntries.at(-2);\n      if (last.offset !== 0 && last.endOffset === 0) {\n        last.endOffset = oldGlyfDataLength;\n      }\n      const missingGlyphs = Object.create(null);\n      let writeOffset = 0;\n      itemEncode(locaData, 0, writeOffset);\n      for (i = 0, j = itemSize; i < numGlyphs; i++, j += itemSize) {\n        const glyphProfile = sanitizeGlyph(oldGlyfData, locaEntries[i].offset, locaEntries[i].endOffset, newGlyfData, writeOffset, hintsValid);\n        const newLength = glyphProfile.length;\n        if (newLength === 0) {\n          missingGlyphs[i] = true;\n        }\n        if (glyphProfile.sizeOfInstructions > maxSizeOfInstructions) {\n          maxSizeOfInstructions = glyphProfile.sizeOfInstructions;\n        }\n        writeOffset += newLength;\n        itemEncode(locaData, j, writeOffset);\n      }\n      if (writeOffset === 0) {\n        const simpleGlyph = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);\n        for (i = 0, j = itemSize; i < numGlyphsOut; i++, j += itemSize) {\n          itemEncode(locaData, j, simpleGlyph.length);\n        }\n        glyf.data = simpleGlyph;\n      } else if (dupFirstEntry) {\n        const firstEntryLength = itemDecode(locaData, itemSize);\n        if (newGlyfData.length > firstEntryLength + writeOffset) {\n          glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);\n        } else {\n          glyf.data = new Uint8Array(firstEntryLength + writeOffset);\n          glyf.data.set(newGlyfData.subarray(0, writeOffset));\n        }\n        glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);\n        itemEncode(loca.data, locaData.length - itemSize, writeOffset + firstEntryLength);\n      } else {\n        glyf.data = newGlyfData.subarray(0, writeOffset);\n      }\n      return {\n        missingGlyphs,\n        maxSizeOfInstructions\n      };\n    }\n    function readPostScriptTable(post, propertiesObj, maxpNumGlyphs) {\n      const start = (font.start || 0) + post.offset;\n      font.pos = start;\n      const length = post.length,\n        end = start + length;\n      const version = font.getInt32();\n      font.skip(28);\n      let glyphNames;\n      let valid = true;\n      let i;\n      switch (version) {\n        case 0x00010000:\n          glyphNames = MacStandardGlyphOrdering;\n          break;\n        case 0x00020000:\n          const numGlyphs = font.getUint16();\n          if (numGlyphs !== maxpNumGlyphs) {\n            valid = false;\n            break;\n          }\n          const glyphNameIndexes = [];\n          for (i = 0; i < numGlyphs; ++i) {\n            const index = font.getUint16();\n            if (index >= 32768) {\n              valid = false;\n              break;\n            }\n            glyphNameIndexes.push(index);\n          }\n          if (!valid) {\n            break;\n          }\n          const customNames = [],\n            strBuf = [];\n          while (font.pos < end) {\n            const stringLength = font.getByte();\n            strBuf.length = stringLength;\n            for (i = 0; i < stringLength; ++i) {\n              strBuf[i] = String.fromCharCode(font.getByte());\n            }\n            customNames.push(strBuf.join(\"\"));\n          }\n          glyphNames = [];\n          for (i = 0; i < numGlyphs; ++i) {\n            const j = glyphNameIndexes[i];\n            if (j < 258) {\n              glyphNames.push(MacStandardGlyphOrdering[j]);\n              continue;\n            }\n            glyphNames.push(customNames[j - 258]);\n          }\n          break;\n        case 0x00030000:\n          break;\n        default:\n          warn(\"Unknown/unsupported post table version \" + version);\n          valid = false;\n          if (propertiesObj.defaultEncoding) {\n            glyphNames = propertiesObj.defaultEncoding;\n          }\n          break;\n      }\n      propertiesObj.glyphNames = glyphNames;\n      return valid;\n    }\n    function readNameTable(nameTable) {\n      const start = (font.start || 0) + nameTable.offset;\n      font.pos = start;\n      const names = [[], []],\n        records = [];\n      const length = nameTable.length,\n        end = start + length;\n      const format = font.getUint16();\n      const FORMAT_0_HEADER_LENGTH = 6;\n      if (format !== 0 || length < FORMAT_0_HEADER_LENGTH) {\n        return [names, records];\n      }\n      const numRecords = font.getUint16();\n      const stringsStart = font.getUint16();\n      const NAME_RECORD_LENGTH = 12;\n      let i, ii;\n      for (i = 0; i < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i++) {\n        const r = {\n          platform: font.getUint16(),\n          encoding: font.getUint16(),\n          language: font.getUint16(),\n          name: font.getUint16(),\n          length: font.getUint16(),\n          offset: font.getUint16()\n        };\n        if (isMacNameRecord(r) || isWinNameRecord(r)) {\n          records.push(r);\n        }\n      }\n      for (i = 0, ii = records.length; i < ii; i++) {\n        const record = records[i];\n        if (record.length <= 0) {\n          continue;\n        }\n        const pos = start + stringsStart + record.offset;\n        if (pos + record.length > end) {\n          continue;\n        }\n        font.pos = pos;\n        const nameIndex = record.name;\n        if (record.encoding) {\n          let str = \"\";\n          for (let j = 0, jj = record.length; j < jj; j += 2) {\n            str += String.fromCharCode(font.getUint16());\n          }\n          names[1][nameIndex] = str;\n        } else {\n          names[0][nameIndex] = font.getString(record.length);\n        }\n      }\n      return [names, records];\n    }\n    const TTOpsStackDeltas = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];\n    function sanitizeTTProgram(table, ttContext) {\n      let data = table.data;\n      let i = 0,\n        j,\n        n,\n        b,\n        funcId,\n        pc,\n        lastEndf = 0,\n        lastDeff = 0;\n      const stack = [];\n      const callstack = [];\n      const functionsCalled = [];\n      let tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;\n      let inFDEF = false,\n        ifLevel = 0,\n        inELSE = 0;\n      for (let ii = data.length; i < ii;) {\n        const op = data[i++];\n        if (op === 0x40) {\n          n = data[i++];\n          if (inFDEF || inELSE) {\n            i += n;\n          } else {\n            for (j = 0; j < n; j++) {\n              stack.push(data[i++]);\n            }\n          }\n        } else if (op === 0x41) {\n          n = data[i++];\n          if (inFDEF || inELSE) {\n            i += n * 2;\n          } else {\n            for (j = 0; j < n; j++) {\n              b = data[i++];\n              stack.push(b << 8 | data[i++]);\n            }\n          }\n        } else if ((op & 0xf8) === 0xb0) {\n          n = op - 0xb0 + 1;\n          if (inFDEF || inELSE) {\n            i += n;\n          } else {\n            for (j = 0; j < n; j++) {\n              stack.push(data[i++]);\n            }\n          }\n        } else if ((op & 0xf8) === 0xb8) {\n          n = op - 0xb8 + 1;\n          if (inFDEF || inELSE) {\n            i += n * 2;\n          } else {\n            for (j = 0; j < n; j++) {\n              b = data[i++];\n              stack.push(b << 8 | data[i++]);\n            }\n          }\n        } else if (op === 0x2b && !tooComplexToFollowFunctions) {\n          if (!inFDEF && !inELSE) {\n            funcId = stack.at(-1);\n            if (isNaN(funcId)) {\n              info(\"TT: CALL empty stack (or invalid entry).\");\n            } else {\n              ttContext.functionsUsed[funcId] = true;\n              if (funcId in ttContext.functionsStackDeltas) {\n                const newStackLength = stack.length + ttContext.functionsStackDeltas[funcId];\n                if (newStackLength < 0) {\n                  warn(\"TT: CALL invalid functions stack delta.\");\n                  ttContext.hintsValid = false;\n                  return;\n                }\n                stack.length = newStackLength;\n              } else if (funcId in ttContext.functionsDefined && !functionsCalled.includes(funcId)) {\n                callstack.push({\n                  data,\n                  i,\n                  stackTop: stack.length - 1\n                });\n                functionsCalled.push(funcId);\n                pc = ttContext.functionsDefined[funcId];\n                if (!pc) {\n                  warn(\"TT: CALL non-existent function\");\n                  ttContext.hintsValid = false;\n                  return;\n                }\n                data = pc.data;\n                i = pc.i;\n              }\n            }\n          }\n        } else if (op === 0x2c && !tooComplexToFollowFunctions) {\n          if (inFDEF || inELSE) {\n            warn(\"TT: nested FDEFs not allowed\");\n            tooComplexToFollowFunctions = true;\n          }\n          inFDEF = true;\n          lastDeff = i;\n          funcId = stack.pop();\n          ttContext.functionsDefined[funcId] = {\n            data,\n            i\n          };\n        } else if (op === 0x2d) {\n          if (inFDEF) {\n            inFDEF = false;\n            lastEndf = i;\n          } else {\n            pc = callstack.pop();\n            if (!pc) {\n              warn(\"TT: ENDF bad stack\");\n              ttContext.hintsValid = false;\n              return;\n            }\n            funcId = functionsCalled.pop();\n            data = pc.data;\n            i = pc.i;\n            ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop;\n          }\n        } else if (op === 0x89) {\n          if (inFDEF || inELSE) {\n            warn(\"TT: nested IDEFs not allowed\");\n            tooComplexToFollowFunctions = true;\n          }\n          inFDEF = true;\n          lastDeff = i;\n        } else if (op === 0x58) {\n          ++ifLevel;\n        } else if (op === 0x1b) {\n          inELSE = ifLevel;\n        } else if (op === 0x59) {\n          if (inELSE === ifLevel) {\n            inELSE = 0;\n          }\n          --ifLevel;\n        } else if (op === 0x1c) {\n          if (!inFDEF && !inELSE) {\n            const offset = stack.at(-1);\n            if (offset > 0) {\n              i += offset - 1;\n            }\n          }\n        }\n        if (!inFDEF && !inELSE) {\n          let stackDelta = 0;\n          if (op <= 0x8e) {\n            stackDelta = TTOpsStackDeltas[op];\n          } else if (op >= 0xc0 && op <= 0xdf) {\n            stackDelta = -1;\n          } else if (op >= 0xe0) {\n            stackDelta = -2;\n          }\n          if (op >= 0x71 && op <= 0x75) {\n            n = stack.pop();\n            if (!isNaN(n)) {\n              stackDelta = -n * 2;\n            }\n          }\n          while (stackDelta < 0 && stack.length > 0) {\n            stack.pop();\n            stackDelta++;\n          }\n          while (stackDelta > 0) {\n            stack.push(NaN);\n            stackDelta--;\n          }\n        }\n      }\n      ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;\n      const content = [data];\n      if (i > data.length) {\n        content.push(new Uint8Array(i - data.length));\n      }\n      if (lastDeff > lastEndf) {\n        warn(\"TT: complementing a missing function tail\");\n        content.push(new Uint8Array([0x22, 0x2d]));\n      }\n      foldTTTable(table, content);\n    }\n    function checkInvalidFunctions(ttContext, maxFunctionDefs) {\n      if (ttContext.tooComplexToFollowFunctions) {\n        return;\n      }\n      if (ttContext.functionsDefined.length > maxFunctionDefs) {\n        warn(\"TT: more functions defined than expected\");\n        ttContext.hintsValid = false;\n        return;\n      }\n      for (let j = 0, jj = ttContext.functionsUsed.length; j < jj; j++) {\n        if (j > maxFunctionDefs) {\n          warn(\"TT: invalid function id: \" + j);\n          ttContext.hintsValid = false;\n          return;\n        }\n        if (ttContext.functionsUsed[j] && !ttContext.functionsDefined[j]) {\n          warn(\"TT: undefined function: \" + j);\n          ttContext.hintsValid = false;\n          return;\n        }\n      }\n    }\n    function foldTTTable(table, content) {\n      if (content.length > 1) {\n        let newLength = 0;\n        let j, jj;\n        for (j = 0, jj = content.length; j < jj; j++) {\n          newLength += content[j].length;\n        }\n        newLength = newLength + 3 & ~3;\n        const result = new Uint8Array(newLength);\n        let pos = 0;\n        for (j = 0, jj = content.length; j < jj; j++) {\n          result.set(content[j], pos);\n          pos += content[j].length;\n        }\n        table.data = result;\n        table.length = newLength;\n      }\n    }\n    function sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs) {\n      const ttContext = {\n        functionsDefined: [],\n        functionsUsed: [],\n        functionsStackDeltas: [],\n        tooComplexToFollowFunctions: false,\n        hintsValid: true\n      };\n      if (fpgm) {\n        sanitizeTTProgram(fpgm, ttContext);\n      }\n      if (prep) {\n        sanitizeTTProgram(prep, ttContext);\n      }\n      if (fpgm) {\n        checkInvalidFunctions(ttContext, maxFunctionDefs);\n      }\n      if (cvt && cvt.length & 1) {\n        const cvtData = new Uint8Array(cvt.length + 1);\n        cvtData.set(cvt.data);\n        cvt.data = cvtData;\n      }\n      return ttContext.hintsValid;\n    }\n    font = new Stream(new Uint8Array(font.getBytes()));\n    let header, tables;\n    if (isTrueTypeCollectionFile(font)) {\n      const ttcData = readTrueTypeCollectionData(font, this.name);\n      header = ttcData.header;\n      tables = ttcData.tables;\n    } else {\n      header = readOpenTypeHeader(font);\n      tables = readTables(font, header.numTables);\n    }\n    let cff, cffFile;\n    const isTrueType = !tables[\"CFF \"];\n    if (!isTrueType) {\n      const isComposite = properties.composite && (properties.cidToGidMap?.length > 0 || !(properties.cMap instanceof IdentityCMap));\n      if (header.version === \"OTTO\" && !isComposite || !tables.head || !tables.hhea || !tables.maxp || !tables.post) {\n        cffFile = new Stream(tables[\"CFF \"].data);\n        cff = new CFFFont(cffFile, properties);\n        adjustWidths(properties);\n        return this.convert(name, cff, properties);\n      }\n      delete tables.glyf;\n      delete tables.loca;\n      delete tables.fpgm;\n      delete tables.prep;\n      delete tables[\"cvt \"];\n      this.isOpenType = true;\n    } else {\n      if (!tables.loca) {\n        throw new FormatError('Required \"loca\" table is not found');\n      }\n      if (!tables.glyf) {\n        warn('Required \"glyf\" table is not found -- trying to recover.');\n        tables.glyf = {\n          tag: \"glyf\",\n          data: new Uint8Array(0)\n        };\n      }\n      this.isOpenType = false;\n    }\n    if (!tables.maxp) {\n      throw new FormatError('Required \"maxp\" table is not found');\n    }\n    font.pos = (font.start || 0) + tables.maxp.offset;\n    let version = font.getInt32();\n    const numGlyphs = font.getUint16();\n    if (version !== 0x00010000 && version !== 0x00005000) {\n      if (tables.maxp.length === 6) {\n        version = 0x0005000;\n      } else if (tables.maxp.length >= 32) {\n        version = 0x00010000;\n      } else {\n        throw new FormatError(`\"maxp\" table has a wrong version number`);\n      }\n      writeUint32(tables.maxp.data, 0, version);\n    }\n    if (properties.scaleFactors?.length === numGlyphs && isTrueType) {\n      const {\n        scaleFactors\n      } = properties;\n      const isGlyphLocationsLong = int16(tables.head.data[50], tables.head.data[51]);\n      const glyphs = new GlyfTable({\n        glyfTable: tables.glyf.data,\n        isGlyphLocationsLong,\n        locaTable: tables.loca.data,\n        numGlyphs\n      });\n      glyphs.scale(scaleFactors);\n      const {\n        glyf,\n        loca,\n        isLocationLong\n      } = glyphs.write();\n      tables.glyf.data = glyf;\n      tables.loca.data = loca;\n      if (isLocationLong !== !!isGlyphLocationsLong) {\n        tables.head.data[50] = 0;\n        tables.head.data[51] = isLocationLong ? 1 : 0;\n      }\n      const metrics = tables.hmtx.data;\n      for (let i = 0; i < numGlyphs; i++) {\n        const j = 4 * i;\n        const advanceWidth = Math.round(scaleFactors[i] * int16(metrics[j], metrics[j + 1]));\n        metrics[j] = advanceWidth >> 8 & 0xff;\n        metrics[j + 1] = advanceWidth & 0xff;\n        const lsb = Math.round(scaleFactors[i] * signedInt16(metrics[j + 2], metrics[j + 3]));\n        writeSignedInt16(metrics, j + 2, lsb);\n      }\n    }\n    let numGlyphsOut = numGlyphs + 1;\n    let dupFirstEntry = true;\n    if (numGlyphsOut > 0xffff) {\n      dupFirstEntry = false;\n      numGlyphsOut = numGlyphs;\n      warn(\"Not enough space in glyfs to duplicate first glyph.\");\n    }\n    let maxFunctionDefs = 0;\n    let maxSizeOfInstructions = 0;\n    if (version >= 0x00010000 && tables.maxp.length >= 32) {\n      font.pos += 8;\n      const maxZones = font.getUint16();\n      if (maxZones > 2) {\n        tables.maxp.data[14] = 0;\n        tables.maxp.data[15] = 2;\n      }\n      font.pos += 4;\n      maxFunctionDefs = font.getUint16();\n      font.pos += 4;\n      maxSizeOfInstructions = font.getUint16();\n    }\n    tables.maxp.data[4] = numGlyphsOut >> 8;\n    tables.maxp.data[5] = numGlyphsOut & 255;\n    const hintsValid = sanitizeTTPrograms(tables.fpgm, tables.prep, tables[\"cvt \"], maxFunctionDefs);\n    if (!hintsValid) {\n      delete tables.fpgm;\n      delete tables.prep;\n      delete tables[\"cvt \"];\n    }\n    sanitizeMetrics(font, tables.hhea, tables.hmtx, tables.head, numGlyphsOut, dupFirstEntry);\n    if (!tables.head) {\n      throw new FormatError('Required \"head\" table is not found');\n    }\n    sanitizeHead(tables.head, numGlyphs, isTrueType ? tables.loca.length : 0);\n    let missingGlyphs = Object.create(null);\n    if (isTrueType) {\n      const isGlyphLocationsLong = int16(tables.head.data[50], tables.head.data[51]);\n      const glyphsInfo = sanitizeGlyphLocations(tables.loca, tables.glyf, numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry, maxSizeOfInstructions);\n      missingGlyphs = glyphsInfo.missingGlyphs;\n      if (version >= 0x00010000 && tables.maxp.length >= 32) {\n        tables.maxp.data[26] = glyphsInfo.maxSizeOfInstructions >> 8;\n        tables.maxp.data[27] = glyphsInfo.maxSizeOfInstructions & 255;\n      }\n    }\n    if (!tables.hhea) {\n      throw new FormatError('Required \"hhea\" table is not found');\n    }\n    if (tables.hhea.data[10] === 0 && tables.hhea.data[11] === 0) {\n      tables.hhea.data[10] = 0xff;\n      tables.hhea.data[11] = 0xff;\n    }\n    const metricsOverride = {\n      unitsPerEm: int16(tables.head.data[18], tables.head.data[19]),\n      yMax: signedInt16(tables.head.data[42], tables.head.data[43]),\n      yMin: signedInt16(tables.head.data[38], tables.head.data[39]),\n      ascent: signedInt16(tables.hhea.data[4], tables.hhea.data[5]),\n      descent: signedInt16(tables.hhea.data[6], tables.hhea.data[7]),\n      lineGap: signedInt16(tables.hhea.data[8], tables.hhea.data[9])\n    };\n    this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;\n    this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;\n    this.lineGap = metricsOverride.lineGap / metricsOverride.unitsPerEm;\n    if (this.cssFontInfo?.lineHeight) {\n      this.lineHeight = this.cssFontInfo.metrics.lineHeight;\n      this.lineGap = this.cssFontInfo.metrics.lineGap;\n    } else {\n      this.lineHeight = this.ascent - this.descent + this.lineGap;\n    }\n    if (tables.post) {\n      readPostScriptTable(tables.post, properties, numGlyphs);\n    }\n    tables.post = {\n      tag: \"post\",\n      data: createPostTable(properties)\n    };\n    const charCodeToGlyphId = [];\n    function hasGlyph(glyphId) {\n      return !missingGlyphs[glyphId];\n    }\n    if (properties.composite) {\n      const cidToGidMap = properties.cidToGidMap || [];\n      const isCidToGidMapEmpty = cidToGidMap.length === 0;\n      properties.cMap.forEach(function (charCode, cid) {\n        if (typeof cid === \"string\") {\n          cid = convertCidString(charCode, cid, true);\n        }\n        if (cid > 0xffff) {\n          throw new FormatError(\"Max size of CID is 65,535\");\n        }\n        let glyphId = -1;\n        if (isCidToGidMapEmpty) {\n          glyphId = cid;\n        } else if (cidToGidMap[cid] !== undefined) {\n          glyphId = cidToGidMap[cid];\n        }\n        if (glyphId >= 0 && glyphId < numGlyphs && hasGlyph(glyphId)) {\n          charCodeToGlyphId[charCode] = glyphId;\n        }\n      });\n    } else {\n      const cmapTable = readCmapTable(tables.cmap, font, this.isSymbolicFont, properties.hasEncoding);\n      const cmapPlatformId = cmapTable.platformId;\n      const cmapEncodingId = cmapTable.encodingId;\n      const cmapMappings = cmapTable.mappings;\n      let baseEncoding = [],\n        forcePostTable = false;\n      if (properties.hasEncoding && (properties.baseEncodingName === \"MacRomanEncoding\" || properties.baseEncodingName === \"WinAnsiEncoding\")) {\n        baseEncoding = getEncoding(properties.baseEncodingName);\n      }\n      if (properties.hasEncoding && !this.isSymbolicFont && (cmapPlatformId === 3 && cmapEncodingId === 1 || cmapPlatformId === 1 && cmapEncodingId === 0)) {\n        const glyphsUnicodeMap = getGlyphsUnicode();\n        for (let charCode = 0; charCode < 256; charCode++) {\n          let glyphName;\n          if (this.differences[charCode] !== undefined) {\n            glyphName = this.differences[charCode];\n          } else if (baseEncoding.length && baseEncoding[charCode] !== \"\") {\n            glyphName = baseEncoding[charCode];\n          } else {\n            glyphName = StandardEncoding[charCode];\n          }\n          if (!glyphName) {\n            continue;\n          }\n          const standardGlyphName = recoverGlyphName(glyphName, glyphsUnicodeMap);\n          let unicodeOrCharCode;\n          if (cmapPlatformId === 3 && cmapEncodingId === 1) {\n            unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName];\n          } else if (cmapPlatformId === 1 && cmapEncodingId === 0) {\n            unicodeOrCharCode = MacRomanEncoding.indexOf(standardGlyphName);\n          }\n          if (unicodeOrCharCode === undefined) {\n            if (!properties.glyphNames && properties.hasIncludedToUnicodeMap && !(this.toUnicode instanceof IdentityToUnicodeMap)) {\n              const unicode = this.toUnicode.get(charCode);\n              if (unicode) {\n                unicodeOrCharCode = unicode.codePointAt(0);\n              }\n            }\n            if (unicodeOrCharCode === undefined) {\n              continue;\n            }\n          }\n          for (const mapping of cmapMappings) {\n            if (mapping.charCode !== unicodeOrCharCode) {\n              continue;\n            }\n            charCodeToGlyphId[charCode] = mapping.glyphId;\n            break;\n          }\n        }\n      } else if (cmapPlatformId === 0) {\n        for (const mapping of cmapMappings) {\n          charCodeToGlyphId[mapping.charCode] = mapping.glyphId;\n        }\n        forcePostTable = true;\n      } else if (cmapPlatformId === 3 && cmapEncodingId === 0) {\n        for (const mapping of cmapMappings) {\n          let charCode = mapping.charCode;\n          if (charCode >= 0xf000 && charCode <= 0xf0ff) {\n            charCode &= 0xff;\n          }\n          charCodeToGlyphId[charCode] = mapping.glyphId;\n        }\n      } else {\n        for (const mapping of cmapMappings) {\n          charCodeToGlyphId[mapping.charCode] = mapping.glyphId;\n        }\n      }\n      if (properties.glyphNames && (baseEncoding.length || this.differences.length)) {\n        for (let i = 0; i < 256; ++i) {\n          if (!forcePostTable && charCodeToGlyphId[i] !== undefined) {\n            continue;\n          }\n          const glyphName = this.differences[i] || baseEncoding[i];\n          if (!glyphName) {\n            continue;\n          }\n          const glyphId = properties.glyphNames.indexOf(glyphName);\n          if (glyphId > 0 && hasGlyph(glyphId)) {\n            charCodeToGlyphId[i] = glyphId;\n          }\n        }\n      }\n    }\n    if (charCodeToGlyphId.length === 0) {\n      charCodeToGlyphId[0] = 0;\n    }\n    let glyphZeroId = numGlyphsOut - 1;\n    if (!dupFirstEntry) {\n      glyphZeroId = 0;\n    }\n    if (!properties.cssFontInfo) {\n      const newMapping = adjustMapping(charCodeToGlyphId, hasGlyph, glyphZeroId, this.toUnicode);\n      this.toFontChar = newMapping.toFontChar;\n      tables.cmap = {\n        tag: \"cmap\",\n        data: createCmapTable(newMapping.charCodeToGlyphId, newMapping.toUnicodeExtraMap, numGlyphsOut)\n      };\n      if (!tables[\"OS/2\"] || !validateOS2Table(tables[\"OS/2\"], font)) {\n        tables[\"OS/2\"] = {\n          tag: \"OS/2\",\n          data: createOS2Table(properties, newMapping.charCodeToGlyphId, metricsOverride)\n        };\n      }\n    }\n    if (!isTrueType) {\n      try {\n        cffFile = new Stream(tables[\"CFF \"].data);\n        const parser = new CFFParser(cffFile, properties, SEAC_ANALYSIS_ENABLED);\n        cff = parser.parse();\n        cff.duplicateFirstGlyph();\n        const compiler = new CFFCompiler(cff);\n        tables[\"CFF \"].data = compiler.compile();\n      } catch {\n        warn(\"Failed to compile font \" + properties.loadedName);\n      }\n    }\n    if (!tables.name) {\n      tables.name = {\n        tag: \"name\",\n        data: createNameTable(this.name)\n      };\n    } else {\n      const [namePrototype, nameRecords] = readNameTable(tables.name);\n      tables.name.data = createNameTable(name, namePrototype);\n      this.psName = namePrototype[0][6] || null;\n      if (!properties.composite) {\n        adjustTrueTypeToUnicode(properties, this.isSymbolicFont, nameRecords);\n      }\n    }\n    const builder = new OpenTypeFileBuilder(header.version);\n    for (const tableTag in tables) {\n      builder.addTable(tableTag, tables[tableTag].data);\n    }\n    return builder.toArray();\n  }\n  convert(fontName, font, properties) {\n    properties.fixedPitch = false;\n    if (properties.builtInEncoding) {\n      adjustType1ToUnicode(properties, properties.builtInEncoding);\n    }\n    let glyphZeroId = 1;\n    if (font instanceof CFFFont) {\n      glyphZeroId = font.numGlyphs - 1;\n    }\n    const mapping = font.getGlyphMapping(properties);\n    let newMapping = null;\n    let newCharCodeToGlyphId = mapping;\n    let toUnicodeExtraMap = null;\n    if (!properties.cssFontInfo) {\n      newMapping = adjustMapping(mapping, font.hasGlyphId.bind(font), glyphZeroId, this.toUnicode);\n      this.toFontChar = newMapping.toFontChar;\n      newCharCodeToGlyphId = newMapping.charCodeToGlyphId;\n      toUnicodeExtraMap = newMapping.toUnicodeExtraMap;\n    }\n    const numGlyphs = font.numGlyphs;\n    function getCharCodes(charCodeToGlyphId, glyphId) {\n      let charCodes = null;\n      for (const charCode in charCodeToGlyphId) {\n        if (glyphId === charCodeToGlyphId[charCode]) {\n          (charCodes ||= []).push(charCode | 0);\n        }\n      }\n      return charCodes;\n    }\n    function createCharCode(charCodeToGlyphId, glyphId) {\n      for (const charCode in charCodeToGlyphId) {\n        if (glyphId === charCodeToGlyphId[charCode]) {\n          return charCode | 0;\n        }\n      }\n      newMapping.charCodeToGlyphId[newMapping.nextAvailableFontCharCode] = glyphId;\n      return newMapping.nextAvailableFontCharCode++;\n    }\n    const seacs = font.seacs;\n    if (newMapping && SEAC_ANALYSIS_ENABLED && seacs?.length) {\n      const matrix = properties.fontMatrix || FONT_IDENTITY_MATRIX;\n      const charset = font.getCharset();\n      const seacMap = Object.create(null);\n      for (let glyphId in seacs) {\n        glyphId |= 0;\n        const seac = seacs[glyphId];\n        const baseGlyphName = StandardEncoding[seac[2]];\n        const accentGlyphName = StandardEncoding[seac[3]];\n        const baseGlyphId = charset.indexOf(baseGlyphName);\n        const accentGlyphId = charset.indexOf(accentGlyphName);\n        if (baseGlyphId < 0 || accentGlyphId < 0) {\n          continue;\n        }\n        const accentOffset = {\n          x: seac[0] * matrix[0] + seac[1] * matrix[2] + matrix[4],\n          y: seac[0] * matrix[1] + seac[1] * matrix[3] + matrix[5]\n        };\n        const charCodes = getCharCodes(mapping, glyphId);\n        if (!charCodes) {\n          continue;\n        }\n        for (const charCode of charCodes) {\n          const charCodeToGlyphId = newMapping.charCodeToGlyphId;\n          const baseFontCharCode = createCharCode(charCodeToGlyphId, baseGlyphId);\n          const accentFontCharCode = createCharCode(charCodeToGlyphId, accentGlyphId);\n          seacMap[charCode] = {\n            baseFontCharCode,\n            accentFontCharCode,\n            accentOffset\n          };\n        }\n      }\n      properties.seacMap = seacMap;\n    }\n    const unitsPerEm = 1 / (properties.fontMatrix || FONT_IDENTITY_MATRIX)[0];\n    const builder = new OpenTypeFileBuilder(\"\\x4F\\x54\\x54\\x4F\");\n    builder.addTable(\"CFF \", font.data);\n    builder.addTable(\"OS/2\", createOS2Table(properties, newCharCodeToGlyphId));\n    builder.addTable(\"cmap\", createCmapTable(newCharCodeToGlyphId, toUnicodeExtraMap, numGlyphs));\n    builder.addTable(\"head\", \"\\x00\\x01\\x00\\x00\" + \"\\x00\\x00\\x10\\x00\" + \"\\x00\\x00\\x00\\x00\" + \"\\x5F\\x0F\\x3C\\xF5\" + \"\\x00\\x00\" + safeString16(unitsPerEm) + \"\\x00\\x00\\x00\\x00\\x9e\\x0b\\x7e\\x27\" + \"\\x00\\x00\\x00\\x00\\x9e\\x0b\\x7e\\x27\" + \"\\x00\\x00\" + safeString16(properties.descent) + \"\\x0F\\xFF\" + safeString16(properties.ascent) + string16(properties.italicAngle ? 2 : 0) + \"\\x00\\x11\" + \"\\x00\\x00\" + \"\\x00\\x00\" + \"\\x00\\x00\");\n    builder.addTable(\"hhea\", \"\\x00\\x01\\x00\\x00\" + safeString16(properties.ascent) + safeString16(properties.descent) + \"\\x00\\x00\" + \"\\xFF\\xFF\" + \"\\x00\\x00\" + \"\\x00\\x00\" + \"\\x00\\x00\" + safeString16(properties.capHeight) + safeString16(Math.tan(properties.italicAngle) * properties.xHeight) + \"\\x00\\x00\" + \"\\x00\\x00\" + \"\\x00\\x00\" + \"\\x00\\x00\" + \"\\x00\\x00\" + \"\\x00\\x00\" + string16(numGlyphs));\n    builder.addTable(\"hmtx\", function fontFieldsHmtx() {\n      const charstrings = font.charstrings;\n      const cffWidths = font.cff ? font.cff.widths : null;\n      let hmtx = \"\\x00\\x00\\x00\\x00\";\n      for (let i = 1, ii = numGlyphs; i < ii; i++) {\n        let width = 0;\n        if (charstrings) {\n          const charstring = charstrings[i - 1];\n          width = \"width\" in charstring ? charstring.width : 0;\n        } else if (cffWidths) {\n          width = Math.ceil(cffWidths[i] || 0);\n        }\n        hmtx += string16(width) + string16(0);\n      }\n      return hmtx;\n    }());\n    builder.addTable(\"maxp\", \"\\x00\\x00\\x50\\x00\" + string16(numGlyphs));\n    builder.addTable(\"name\", createNameTable(fontName));\n    builder.addTable(\"post\", createPostTable(properties));\n    return builder.toArray();\n  }\n  get spaceWidth() {\n    const possibleSpaceReplacements = [\"space\", \"minus\", \"one\", \"i\", \"I\"];\n    let width;\n    for (const glyphName of possibleSpaceReplacements) {\n      if (glyphName in this.widths) {\n        width = this.widths[glyphName];\n        break;\n      }\n      const glyphsUnicodeMap = getGlyphsUnicode();\n      const glyphUnicode = glyphsUnicodeMap[glyphName];\n      let charcode = 0;\n      if (this.composite && this.cMap.contains(glyphUnicode)) {\n        charcode = this.cMap.lookup(glyphUnicode);\n        if (typeof charcode === \"string\") {\n          charcode = convertCidString(glyphUnicode, charcode);\n        }\n      }\n      if (!charcode && this.toUnicode) {\n        charcode = this.toUnicode.charCodeOf(glyphUnicode);\n      }\n      if (charcode <= 0) {\n        charcode = glyphUnicode;\n      }\n      width = this.widths[charcode];\n      if (width) {\n        break;\n      }\n    }\n    return shadow(this, \"spaceWidth\", width || this.defaultWidth);\n  }\n  _charToGlyph(charcode, isSpace = false) {\n    let glyph = this._glyphCache[charcode];\n    if (glyph?.isSpace === isSpace) {\n      return glyph;\n    }\n    let fontCharCode, width, operatorListId;\n    let widthCode = charcode;\n    if (this.cMap?.contains(charcode)) {\n      widthCode = this.cMap.lookup(charcode);\n      if (typeof widthCode === \"string\") {\n        widthCode = convertCidString(charcode, widthCode);\n      }\n    }\n    width = this.widths[widthCode];\n    if (typeof width !== \"number\") {\n      width = this.defaultWidth;\n    }\n    const vmetric = this.vmetrics?.[widthCode];\n    let unicode = this.toUnicode.get(charcode) || charcode;\n    if (typeof unicode === \"number\") {\n      unicode = String.fromCharCode(unicode);\n    }\n    let isInFont = this.toFontChar[charcode] !== undefined;\n    fontCharCode = this.toFontChar[charcode] || charcode;\n    if (this.missingFile) {\n      const glyphName = this.differences[charcode] || this.defaultEncoding[charcode];\n      if ((glyphName === \".notdef\" || glyphName === \"\") && this.type === \"Type1\") {\n        fontCharCode = 0x20;\n      }\n      fontCharCode = mapSpecialUnicodeValues(fontCharCode);\n    }\n    if (this.isType3Font) {\n      operatorListId = fontCharCode;\n    }\n    let accent = null;\n    if (this.seacMap?.[charcode]) {\n      isInFont = true;\n      const seac = this.seacMap[charcode];\n      fontCharCode = seac.baseFontCharCode;\n      accent = {\n        fontChar: String.fromCodePoint(seac.accentFontCharCode),\n        offset: seac.accentOffset\n      };\n    }\n    let fontChar = \"\";\n    if (typeof fontCharCode === \"number\") {\n      if (fontCharCode <= 0x10ffff) {\n        fontChar = String.fromCodePoint(fontCharCode);\n      } else {\n        warn(`charToGlyph - invalid fontCharCode: ${fontCharCode}`);\n      }\n    }\n    glyph = new fonts_Glyph(charcode, fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont);\n    return this._glyphCache[charcode] = glyph;\n  }\n  charsToGlyphs(chars) {\n    let glyphs = this._charsCache[chars];\n    if (glyphs) {\n      return glyphs;\n    }\n    glyphs = [];\n    if (this.cMap) {\n      const c = Object.create(null),\n        ii = chars.length;\n      let i = 0;\n      while (i < ii) {\n        this.cMap.readCharCode(chars, i, c);\n        const {\n          charcode,\n          length\n        } = c;\n        i += length;\n        const glyph = this._charToGlyph(charcode, length === 1 && chars.charCodeAt(i - 1) === 0x20);\n        glyphs.push(glyph);\n      }\n    } else {\n      for (let i = 0, ii = chars.length; i < ii; ++i) {\n        const charcode = chars.charCodeAt(i);\n        const glyph = this._charToGlyph(charcode, charcode === 0x20);\n        glyphs.push(glyph);\n      }\n    }\n    return this._charsCache[chars] = glyphs;\n  }\n  getCharPositions(chars) {\n    const positions = [];\n    if (this.cMap) {\n      const c = Object.create(null);\n      let i = 0;\n      while (i < chars.length) {\n        this.cMap.readCharCode(chars, i, c);\n        const length = c.length;\n        positions.push([i, i + length]);\n        i += length;\n      }\n    } else {\n      for (let i = 0, ii = chars.length; i < ii; ++i) {\n        positions.push([i, i + 1]);\n      }\n    }\n    return positions;\n  }\n  get glyphCacheValues() {\n    return Object.values(this._glyphCache);\n  }\n  encodeString(str) {\n    const buffers = [];\n    const currentBuf = [];\n    const hasCurrentBufErrors = () => buffers.length % 2 === 1;\n    const getCharCode = this.toUnicode instanceof IdentityToUnicodeMap ? unicode => this.toUnicode.charCodeOf(unicode) : unicode => this.toUnicode.charCodeOf(String.fromCodePoint(unicode));\n    for (let i = 0, ii = str.length; i < ii; i++) {\n      const unicode = str.codePointAt(i);\n      if (unicode > 0xd7ff && (unicode < 0xe000 || unicode > 0xfffd)) {\n        i++;\n      }\n      if (this.toUnicode) {\n        const charCode = getCharCode(unicode);\n        if (charCode !== -1) {\n          if (hasCurrentBufErrors()) {\n            buffers.push(currentBuf.join(\"\"));\n            currentBuf.length = 0;\n          }\n          const charCodeLength = this.cMap ? this.cMap.getCharCodeLength(charCode) : 1;\n          for (let j = charCodeLength - 1; j >= 0; j--) {\n            currentBuf.push(String.fromCharCode(charCode >> 8 * j & 0xff));\n          }\n          continue;\n        }\n      }\n      if (!hasCurrentBufErrors()) {\n        buffers.push(currentBuf.join(\"\"));\n        currentBuf.length = 0;\n      }\n      currentBuf.push(String.fromCodePoint(unicode));\n    }\n    buffers.push(currentBuf.join(\"\"));\n    return buffers;\n  }\n}\nclass ErrorFont {\n  constructor(error) {\n    this.error = error;\n    this.loadedName = \"g_font_error\";\n    this.missingFile = true;\n  }\n  charsToGlyphs() {\n    return [];\n  }\n  encodeString(chars) {\n    return [chars];\n  }\n  exportData(extraProperties = false) {\n    return {\n      error: this.error\n    };\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/pattern.js\n\n\n\n\nconst ShadingType = {\n  FUNCTION_BASED: 1,\n  AXIAL: 2,\n  RADIAL: 3,\n  FREE_FORM_MESH: 4,\n  LATTICE_FORM_MESH: 5,\n  COONS_PATCH_MESH: 6,\n  TENSOR_PATCH_MESH: 7\n};\nclass Pattern {\n  constructor() {\n    unreachable(\"Cannot initialize Pattern.\");\n  }\n  static parseShading(shading, xref, res, pdfFunctionFactory, localColorSpaceCache) {\n    const dict = shading instanceof BaseStream ? shading.dict : shading;\n    const type = dict.get(\"ShadingType\");\n    try {\n      switch (type) {\n        case ShadingType.AXIAL:\n        case ShadingType.RADIAL:\n          return new RadialAxialShading(dict, xref, res, pdfFunctionFactory, localColorSpaceCache);\n        case ShadingType.FREE_FORM_MESH:\n        case ShadingType.LATTICE_FORM_MESH:\n        case ShadingType.COONS_PATCH_MESH:\n        case ShadingType.TENSOR_PATCH_MESH:\n          return new MeshShading(shading, xref, res, pdfFunctionFactory, localColorSpaceCache);\n        default:\n          throw new FormatError(\"Unsupported ShadingType: \" + type);\n      }\n    } catch (ex) {\n      if (ex instanceof MissingDataException) {\n        throw ex;\n      }\n      warn(ex);\n      return new DummyShading();\n    }\n  }\n}\nclass BaseShading {\n  static SMALL_NUMBER = 1e-6;\n  constructor() {\n    if (this.constructor === BaseShading) {\n      unreachable(\"Cannot initialize BaseShading.\");\n    }\n  }\n  getIR() {\n    unreachable(\"Abstract method `getIR` called.\");\n  }\n}\nclass RadialAxialShading extends BaseShading {\n  constructor(dict, xref, resources, pdfFunctionFactory, localColorSpaceCache) {\n    super();\n    this.coordsArr = dict.getArray(\"Coords\");\n    this.shadingType = dict.get(\"ShadingType\");\n    const cs = ColorSpace.parse({\n      cs: dict.getRaw(\"CS\") || dict.getRaw(\"ColorSpace\"),\n      xref,\n      resources,\n      pdfFunctionFactory,\n      localColorSpaceCache\n    });\n    const bbox = dict.getArray(\"BBox\");\n    this.bbox = Array.isArray(bbox) && bbox.length === 4 ? Util.normalizeRect(bbox) : null;\n    let t0 = 0.0,\n      t1 = 1.0;\n    if (dict.has(\"Domain\")) {\n      const domainArr = dict.getArray(\"Domain\");\n      t0 = domainArr[0];\n      t1 = domainArr[1];\n    }\n    let extendStart = false,\n      extendEnd = false;\n    if (dict.has(\"Extend\")) {\n      const extendArr = dict.getArray(\"Extend\");\n      extendStart = extendArr[0];\n      extendEnd = extendArr[1];\n    }\n    if (this.shadingType === ShadingType.RADIAL && (!extendStart || !extendEnd)) {\n      const [x1, y1, r1, x2, y2, r2] = this.coordsArr;\n      const distance = Math.hypot(x1 - x2, y1 - y2);\n      if (r1 <= r2 + distance && r2 <= r1 + distance) {\n        warn(\"Unsupported radial gradient.\");\n      }\n    }\n    this.extendStart = extendStart;\n    this.extendEnd = extendEnd;\n    const fnObj = dict.getRaw(\"Function\");\n    const fn = pdfFunctionFactory.createFromArray(fnObj);\n    const NUMBER_OF_SAMPLES = 840;\n    const step = (t1 - t0) / NUMBER_OF_SAMPLES;\n    const colorStops = this.colorStops = [];\n    if (t0 >= t1 || step <= 0) {\n      info(\"Bad shading domain.\");\n      return;\n    }\n    const color = new Float32Array(cs.numComps),\n      ratio = new Float32Array(1);\n    let rgbColor;\n    let iBase = 0;\n    ratio[0] = t0;\n    fn(ratio, 0, color, 0);\n    let rgbBase = cs.getRgb(color, 0);\n    const cssColorBase = Util.makeHexColor(rgbBase[0], rgbBase[1], rgbBase[2]);\n    colorStops.push([0, cssColorBase]);\n    let iPrev = 1;\n    ratio[0] = t0 + step;\n    fn(ratio, 0, color, 0);\n    let rgbPrev = cs.getRgb(color, 0);\n    let maxSlopeR = rgbPrev[0] - rgbBase[0] + 1;\n    let maxSlopeG = rgbPrev[1] - rgbBase[1] + 1;\n    let maxSlopeB = rgbPrev[2] - rgbBase[2] + 1;\n    let minSlopeR = rgbPrev[0] - rgbBase[0] - 1;\n    let minSlopeG = rgbPrev[1] - rgbBase[1] - 1;\n    let minSlopeB = rgbPrev[2] - rgbBase[2] - 1;\n    for (let i = 2; i < NUMBER_OF_SAMPLES; i++) {\n      ratio[0] = t0 + i * step;\n      fn(ratio, 0, color, 0);\n      rgbColor = cs.getRgb(color, 0);\n      const run = i - iBase;\n      maxSlopeR = Math.min(maxSlopeR, (rgbColor[0] - rgbBase[0] + 1) / run);\n      maxSlopeG = Math.min(maxSlopeG, (rgbColor[1] - rgbBase[1] + 1) / run);\n      maxSlopeB = Math.min(maxSlopeB, (rgbColor[2] - rgbBase[2] + 1) / run);\n      minSlopeR = Math.max(minSlopeR, (rgbColor[0] - rgbBase[0] - 1) / run);\n      minSlopeG = Math.max(minSlopeG, (rgbColor[1] - rgbBase[1] - 1) / run);\n      minSlopeB = Math.max(minSlopeB, (rgbColor[2] - rgbBase[2] - 1) / run);\n      const slopesExist = minSlopeR <= maxSlopeR && minSlopeG <= maxSlopeG && minSlopeB <= maxSlopeB;\n      if (!slopesExist) {\n        const cssColor = Util.makeHexColor(rgbPrev[0], rgbPrev[1], rgbPrev[2]);\n        colorStops.push([iPrev / NUMBER_OF_SAMPLES, cssColor]);\n        maxSlopeR = rgbColor[0] - rgbPrev[0] + 1;\n        maxSlopeG = rgbColor[1] - rgbPrev[1] + 1;\n        maxSlopeB = rgbColor[2] - rgbPrev[2] + 1;\n        minSlopeR = rgbColor[0] - rgbPrev[0] - 1;\n        minSlopeG = rgbColor[1] - rgbPrev[1] - 1;\n        minSlopeB = rgbColor[2] - rgbPrev[2] - 1;\n        iBase = iPrev;\n        rgbBase = rgbPrev;\n      }\n      iPrev = i;\n      rgbPrev = rgbColor;\n    }\n    const cssColor = Util.makeHexColor(rgbPrev[0], rgbPrev[1], rgbPrev[2]);\n    colorStops.push([1, cssColor]);\n    let background = \"transparent\";\n    if (dict.has(\"Background\")) {\n      rgbColor = cs.getRgb(dict.get(\"Background\"), 0);\n      background = Util.makeHexColor(rgbColor[0], rgbColor[1], rgbColor[2]);\n    }\n    if (!extendStart) {\n      colorStops.unshift([0, background]);\n      colorStops[1][0] += BaseShading.SMALL_NUMBER;\n    }\n    if (!extendEnd) {\n      colorStops.at(-1)[0] -= BaseShading.SMALL_NUMBER;\n      colorStops.push([1, background]);\n    }\n    this.colorStops = colorStops;\n  }\n  getIR() {\n    const coordsArr = this.coordsArr;\n    const shadingType = this.shadingType;\n    let type, p0, p1, r0, r1;\n    if (shadingType === ShadingType.AXIAL) {\n      p0 = [coordsArr[0], coordsArr[1]];\n      p1 = [coordsArr[2], coordsArr[3]];\n      r0 = null;\n      r1 = null;\n      type = \"axial\";\n    } else if (shadingType === ShadingType.RADIAL) {\n      p0 = [coordsArr[0], coordsArr[1]];\n      p1 = [coordsArr[3], coordsArr[4]];\n      r0 = coordsArr[2];\n      r1 = coordsArr[5];\n      type = \"radial\";\n    } else {\n      unreachable(`getPattern type unknown: ${shadingType}`);\n    }\n    return [\"RadialAxial\", type, this.bbox, this.colorStops, p0, p1, r0, r1];\n  }\n}\nclass MeshStreamReader {\n  constructor(stream, context) {\n    this.stream = stream;\n    this.context = context;\n    this.buffer = 0;\n    this.bufferLength = 0;\n    const numComps = context.numComps;\n    this.tmpCompsBuf = new Float32Array(numComps);\n    const csNumComps = context.colorSpace.numComps;\n    this.tmpCsCompsBuf = context.colorFn ? new Float32Array(csNumComps) : this.tmpCompsBuf;\n  }\n  get hasData() {\n    if (this.stream.end) {\n      return this.stream.pos < this.stream.end;\n    }\n    if (this.bufferLength > 0) {\n      return true;\n    }\n    const nextByte = this.stream.getByte();\n    if (nextByte < 0) {\n      return false;\n    }\n    this.buffer = nextByte;\n    this.bufferLength = 8;\n    return true;\n  }\n  readBits(n) {\n    let buffer = this.buffer;\n    let bufferLength = this.bufferLength;\n    if (n === 32) {\n      if (bufferLength === 0) {\n        return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;\n      }\n      buffer = buffer << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();\n      const nextByte = this.stream.getByte();\n      this.buffer = nextByte & (1 << bufferLength) - 1;\n      return (buffer << 8 - bufferLength | (nextByte & 0xff) >> bufferLength) >>> 0;\n    }\n    if (n === 8 && bufferLength === 0) {\n      return this.stream.getByte();\n    }\n    while (bufferLength < n) {\n      buffer = buffer << 8 | this.stream.getByte();\n      bufferLength += 8;\n    }\n    bufferLength -= n;\n    this.bufferLength = bufferLength;\n    this.buffer = buffer & (1 << bufferLength) - 1;\n    return buffer >> bufferLength;\n  }\n  align() {\n    this.buffer = 0;\n    this.bufferLength = 0;\n  }\n  readFlag() {\n    return this.readBits(this.context.bitsPerFlag);\n  }\n  readCoordinate() {\n    const bitsPerCoordinate = this.context.bitsPerCoordinate;\n    const xi = this.readBits(bitsPerCoordinate);\n    const yi = this.readBits(bitsPerCoordinate);\n    const decode = this.context.decode;\n    const scale = bitsPerCoordinate < 32 ? 1 / ((1 << bitsPerCoordinate) - 1) : 2.3283064365386963e-10;\n    return [xi * scale * (decode[1] - decode[0]) + decode[0], yi * scale * (decode[3] - decode[2]) + decode[2]];\n  }\n  readComponents() {\n    const numComps = this.context.numComps;\n    const bitsPerComponent = this.context.bitsPerComponent;\n    const scale = bitsPerComponent < 32 ? 1 / ((1 << bitsPerComponent) - 1) : 2.3283064365386963e-10;\n    const decode = this.context.decode;\n    const components = this.tmpCompsBuf;\n    for (let i = 0, j = 4; i < numComps; i++, j += 2) {\n      const ci = this.readBits(bitsPerComponent);\n      components[i] = ci * scale * (decode[j + 1] - decode[j]) + decode[j];\n    }\n    const color = this.tmpCsCompsBuf;\n    if (this.context.colorFn) {\n      this.context.colorFn(components, 0, color, 0);\n    }\n    return this.context.colorSpace.getRgb(color, 0);\n  }\n}\nlet bCache = Object.create(null);\nfunction buildB(count) {\n  const lut = [];\n  for (let i = 0; i <= count; i++) {\n    const t = i / count,\n      t_ = 1 - t;\n    lut.push(new Float32Array([t_ ** 3, 3 * t * t_ ** 2, 3 * t ** 2 * t_, t ** 3]));\n  }\n  return lut;\n}\nfunction getB(count) {\n  return bCache[count] ||= buildB(count);\n}\nfunction clearPatternCaches() {\n  bCache = Object.create(null);\n}\nclass MeshShading extends BaseShading {\n  static MIN_SPLIT_PATCH_CHUNKS_AMOUNT = 3;\n  static MAX_SPLIT_PATCH_CHUNKS_AMOUNT = 20;\n  static TRIANGLE_DENSITY = 20;\n  constructor(stream, xref, resources, pdfFunctionFactory, localColorSpaceCache) {\n    super();\n    if (!(stream instanceof BaseStream)) {\n      throw new FormatError(\"Mesh data is not a stream\");\n    }\n    const dict = stream.dict;\n    this.shadingType = dict.get(\"ShadingType\");\n    const bbox = dict.getArray(\"BBox\");\n    this.bbox = Array.isArray(bbox) && bbox.length === 4 ? Util.normalizeRect(bbox) : null;\n    const cs = ColorSpace.parse({\n      cs: dict.getRaw(\"CS\") || dict.getRaw(\"ColorSpace\"),\n      xref,\n      resources,\n      pdfFunctionFactory,\n      localColorSpaceCache\n    });\n    this.background = dict.has(\"Background\") ? cs.getRgb(dict.get(\"Background\"), 0) : null;\n    const fnObj = dict.getRaw(\"Function\");\n    const fn = fnObj ? pdfFunctionFactory.createFromArray(fnObj) : null;\n    this.coords = [];\n    this.colors = [];\n    this.figures = [];\n    const decodeContext = {\n      bitsPerCoordinate: dict.get(\"BitsPerCoordinate\"),\n      bitsPerComponent: dict.get(\"BitsPerComponent\"),\n      bitsPerFlag: dict.get(\"BitsPerFlag\"),\n      decode: dict.getArray(\"Decode\"),\n      colorFn: fn,\n      colorSpace: cs,\n      numComps: fn ? 1 : cs.numComps\n    };\n    const reader = new MeshStreamReader(stream, decodeContext);\n    let patchMesh = false;\n    switch (this.shadingType) {\n      case ShadingType.FREE_FORM_MESH:\n        this._decodeType4Shading(reader);\n        break;\n      case ShadingType.LATTICE_FORM_MESH:\n        const verticesPerRow = dict.get(\"VerticesPerRow\") | 0;\n        if (verticesPerRow < 2) {\n          throw new FormatError(\"Invalid VerticesPerRow\");\n        }\n        this._decodeType5Shading(reader, verticesPerRow);\n        break;\n      case ShadingType.COONS_PATCH_MESH:\n        this._decodeType6Shading(reader);\n        patchMesh = true;\n        break;\n      case ShadingType.TENSOR_PATCH_MESH:\n        this._decodeType7Shading(reader);\n        patchMesh = true;\n        break;\n      default:\n        unreachable(\"Unsupported mesh type.\");\n        break;\n    }\n    if (patchMesh) {\n      this._updateBounds();\n      for (let i = 0, ii = this.figures.length; i < ii; i++) {\n        this._buildFigureFromPatch(i);\n      }\n    }\n    this._updateBounds();\n    this._packData();\n  }\n  _decodeType4Shading(reader) {\n    const coords = this.coords;\n    const colors = this.colors;\n    const operators = [];\n    const ps = [];\n    let verticesLeft = 0;\n    while (reader.hasData) {\n      const f = reader.readFlag();\n      const coord = reader.readCoordinate();\n      const color = reader.readComponents();\n      if (verticesLeft === 0) {\n        if (!(0 <= f && f <= 2)) {\n          throw new FormatError(\"Unknown type4 flag\");\n        }\n        switch (f) {\n          case 0:\n            verticesLeft = 3;\n            break;\n          case 1:\n            ps.push(ps.at(-2), ps.at(-1));\n            verticesLeft = 1;\n            break;\n          case 2:\n            ps.push(ps.at(-3), ps.at(-1));\n            verticesLeft = 1;\n            break;\n        }\n        operators.push(f);\n      }\n      ps.push(coords.length);\n      coords.push(coord);\n      colors.push(color);\n      verticesLeft--;\n      reader.align();\n    }\n    this.figures.push({\n      type: \"triangles\",\n      coords: new Int32Array(ps),\n      colors: new Int32Array(ps)\n    });\n  }\n  _decodeType5Shading(reader, verticesPerRow) {\n    const coords = this.coords;\n    const colors = this.colors;\n    const ps = [];\n    while (reader.hasData) {\n      const coord = reader.readCoordinate();\n      const color = reader.readComponents();\n      ps.push(coords.length);\n      coords.push(coord);\n      colors.push(color);\n    }\n    this.figures.push({\n      type: \"lattice\",\n      coords: new Int32Array(ps),\n      colors: new Int32Array(ps),\n      verticesPerRow\n    });\n  }\n  _decodeType6Shading(reader) {\n    const coords = this.coords;\n    const colors = this.colors;\n    const ps = new Int32Array(16);\n    const cs = new Int32Array(4);\n    while (reader.hasData) {\n      const f = reader.readFlag();\n      if (!(0 <= f && f <= 3)) {\n        throw new FormatError(\"Unknown type6 flag\");\n      }\n      const pi = coords.length;\n      for (let i = 0, ii = f !== 0 ? 8 : 12; i < ii; i++) {\n        coords.push(reader.readCoordinate());\n      }\n      const ci = colors.length;\n      for (let i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {\n        colors.push(reader.readComponents());\n      }\n      let tmp1, tmp2, tmp3, tmp4;\n      switch (f) {\n        case 0:\n          ps[12] = pi + 3;\n          ps[13] = pi + 4;\n          ps[14] = pi + 5;\n          ps[15] = pi + 6;\n          ps[8] = pi + 2;\n          ps[11] = pi + 7;\n          ps[4] = pi + 1;\n          ps[7] = pi + 8;\n          ps[0] = pi;\n          ps[1] = pi + 11;\n          ps[2] = pi + 10;\n          ps[3] = pi + 9;\n          cs[2] = ci + 1;\n          cs[3] = ci + 2;\n          cs[0] = ci;\n          cs[1] = ci + 3;\n          break;\n        case 1:\n          tmp1 = ps[12];\n          tmp2 = ps[13];\n          tmp3 = ps[14];\n          tmp4 = ps[15];\n          ps[12] = tmp4;\n          ps[13] = pi + 0;\n          ps[14] = pi + 1;\n          ps[15] = pi + 2;\n          ps[8] = tmp3;\n          ps[11] = pi + 3;\n          ps[4] = tmp2;\n          ps[7] = pi + 4;\n          ps[0] = tmp1;\n          ps[1] = pi + 7;\n          ps[2] = pi + 6;\n          ps[3] = pi + 5;\n          tmp1 = cs[2];\n          tmp2 = cs[3];\n          cs[2] = tmp2;\n          cs[3] = ci;\n          cs[0] = tmp1;\n          cs[1] = ci + 1;\n          break;\n        case 2:\n          tmp1 = ps[15];\n          tmp2 = ps[11];\n          ps[12] = ps[3];\n          ps[13] = pi + 0;\n          ps[14] = pi + 1;\n          ps[15] = pi + 2;\n          ps[8] = ps[7];\n          ps[11] = pi + 3;\n          ps[4] = tmp2;\n          ps[7] = pi + 4;\n          ps[0] = tmp1;\n          ps[1] = pi + 7;\n          ps[2] = pi + 6;\n          ps[3] = pi + 5;\n          tmp1 = cs[3];\n          cs[2] = cs[1];\n          cs[3] = ci;\n          cs[0] = tmp1;\n          cs[1] = ci + 1;\n          break;\n        case 3:\n          ps[12] = ps[0];\n          ps[13] = pi + 0;\n          ps[14] = pi + 1;\n          ps[15] = pi + 2;\n          ps[8] = ps[1];\n          ps[11] = pi + 3;\n          ps[4] = ps[2];\n          ps[7] = pi + 4;\n          ps[0] = ps[3];\n          ps[1] = pi + 7;\n          ps[2] = pi + 6;\n          ps[3] = pi + 5;\n          cs[2] = cs[0];\n          cs[3] = ci;\n          cs[0] = cs[1];\n          cs[1] = ci + 1;\n          break;\n      }\n      ps[5] = coords.length;\n      coords.push([(-4 * coords[ps[0]][0] - coords[ps[15]][0] + 6 * (coords[ps[4]][0] + coords[ps[1]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[13]][0] + coords[ps[7]][0])) / 9, (-4 * coords[ps[0]][1] - coords[ps[15]][1] + 6 * (coords[ps[4]][1] + coords[ps[1]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[13]][1] + coords[ps[7]][1])) / 9]);\n      ps[6] = coords.length;\n      coords.push([(-4 * coords[ps[3]][0] - coords[ps[12]][0] + 6 * (coords[ps[2]][0] + coords[ps[7]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[4]][0] + coords[ps[14]][0])) / 9, (-4 * coords[ps[3]][1] - coords[ps[12]][1] + 6 * (coords[ps[2]][1] + coords[ps[7]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[4]][1] + coords[ps[14]][1])) / 9]);\n      ps[9] = coords.length;\n      coords.push([(-4 * coords[ps[12]][0] - coords[ps[3]][0] + 6 * (coords[ps[8]][0] + coords[ps[13]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[11]][0] + coords[ps[1]][0])) / 9, (-4 * coords[ps[12]][1] - coords[ps[3]][1] + 6 * (coords[ps[8]][1] + coords[ps[13]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[11]][1] + coords[ps[1]][1])) / 9]);\n      ps[10] = coords.length;\n      coords.push([(-4 * coords[ps[15]][0] - coords[ps[0]][0] + 6 * (coords[ps[11]][0] + coords[ps[14]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[2]][0] + coords[ps[8]][0])) / 9, (-4 * coords[ps[15]][1] - coords[ps[0]][1] + 6 * (coords[ps[11]][1] + coords[ps[14]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[2]][1] + coords[ps[8]][1])) / 9]);\n      this.figures.push({\n        type: \"patch\",\n        coords: new Int32Array(ps),\n        colors: new Int32Array(cs)\n      });\n    }\n  }\n  _decodeType7Shading(reader) {\n    const coords = this.coords;\n    const colors = this.colors;\n    const ps = new Int32Array(16);\n    const cs = new Int32Array(4);\n    while (reader.hasData) {\n      const f = reader.readFlag();\n      if (!(0 <= f && f <= 3)) {\n        throw new FormatError(\"Unknown type7 flag\");\n      }\n      const pi = coords.length;\n      for (let i = 0, ii = f !== 0 ? 12 : 16; i < ii; i++) {\n        coords.push(reader.readCoordinate());\n      }\n      const ci = colors.length;\n      for (let i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {\n        colors.push(reader.readComponents());\n      }\n      let tmp1, tmp2, tmp3, tmp4;\n      switch (f) {\n        case 0:\n          ps[12] = pi + 3;\n          ps[13] = pi + 4;\n          ps[14] = pi + 5;\n          ps[15] = pi + 6;\n          ps[8] = pi + 2;\n          ps[9] = pi + 13;\n          ps[10] = pi + 14;\n          ps[11] = pi + 7;\n          ps[4] = pi + 1;\n          ps[5] = pi + 12;\n          ps[6] = pi + 15;\n          ps[7] = pi + 8;\n          ps[0] = pi;\n          ps[1] = pi + 11;\n          ps[2] = pi + 10;\n          ps[3] = pi + 9;\n          cs[2] = ci + 1;\n          cs[3] = ci + 2;\n          cs[0] = ci;\n          cs[1] = ci + 3;\n          break;\n        case 1:\n          tmp1 = ps[12];\n          tmp2 = ps[13];\n          tmp3 = ps[14];\n          tmp4 = ps[15];\n          ps[12] = tmp4;\n          ps[13] = pi + 0;\n          ps[14] = pi + 1;\n          ps[15] = pi + 2;\n          ps[8] = tmp3;\n          ps[9] = pi + 9;\n          ps[10] = pi + 10;\n          ps[11] = pi + 3;\n          ps[4] = tmp2;\n          ps[5] = pi + 8;\n          ps[6] = pi + 11;\n          ps[7] = pi + 4;\n          ps[0] = tmp1;\n          ps[1] = pi + 7;\n          ps[2] = pi + 6;\n          ps[3] = pi + 5;\n          tmp1 = cs[2];\n          tmp2 = cs[3];\n          cs[2] = tmp2;\n          cs[3] = ci;\n          cs[0] = tmp1;\n          cs[1] = ci + 1;\n          break;\n        case 2:\n          tmp1 = ps[15];\n          tmp2 = ps[11];\n          ps[12] = ps[3];\n          ps[13] = pi + 0;\n          ps[14] = pi + 1;\n          ps[15] = pi + 2;\n          ps[8] = ps[7];\n          ps[9] = pi + 9;\n          ps[10] = pi + 10;\n          ps[11] = pi + 3;\n          ps[4] = tmp2;\n          ps[5] = pi + 8;\n          ps[6] = pi + 11;\n          ps[7] = pi + 4;\n          ps[0] = tmp1;\n          ps[1] = pi + 7;\n          ps[2] = pi + 6;\n          ps[3] = pi + 5;\n          tmp1 = cs[3];\n          cs[2] = cs[1];\n          cs[3] = ci;\n          cs[0] = tmp1;\n          cs[1] = ci + 1;\n          break;\n        case 3:\n          ps[12] = ps[0];\n          ps[13] = pi + 0;\n          ps[14] = pi + 1;\n          ps[15] = pi + 2;\n          ps[8] = ps[1];\n          ps[9] = pi + 9;\n          ps[10] = pi + 10;\n          ps[11] = pi + 3;\n          ps[4] = ps[2];\n          ps[5] = pi + 8;\n          ps[6] = pi + 11;\n          ps[7] = pi + 4;\n          ps[0] = ps[3];\n          ps[1] = pi + 7;\n          ps[2] = pi + 6;\n          ps[3] = pi + 5;\n          cs[2] = cs[0];\n          cs[3] = ci;\n          cs[0] = cs[1];\n          cs[1] = ci + 1;\n          break;\n      }\n      this.figures.push({\n        type: \"patch\",\n        coords: new Int32Array(ps),\n        colors: new Int32Array(cs)\n      });\n    }\n  }\n  _buildFigureFromPatch(index) {\n    const figure = this.figures[index];\n    assert(figure.type === \"patch\", \"Unexpected patch mesh figure\");\n    const coords = this.coords,\n      colors = this.colors;\n    const pi = figure.coords;\n    const ci = figure.colors;\n    const figureMinX = Math.min(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);\n    const figureMinY = Math.min(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);\n    const figureMaxX = Math.max(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);\n    const figureMaxY = Math.max(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);\n    let splitXBy = Math.ceil((figureMaxX - figureMinX) * MeshShading.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));\n    splitXBy = Math.max(MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitXBy));\n    let splitYBy = Math.ceil((figureMaxY - figureMinY) * MeshShading.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));\n    splitYBy = Math.max(MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitYBy));\n    const verticesPerRow = splitXBy + 1;\n    const figureCoords = new Int32Array((splitYBy + 1) * verticesPerRow);\n    const figureColors = new Int32Array((splitYBy + 1) * verticesPerRow);\n    let k = 0;\n    const cl = new Uint8Array(3),\n      cr = new Uint8Array(3);\n    const c0 = colors[ci[0]],\n      c1 = colors[ci[1]],\n      c2 = colors[ci[2]],\n      c3 = colors[ci[3]];\n    const bRow = getB(splitYBy),\n      bCol = getB(splitXBy);\n    for (let row = 0; row <= splitYBy; row++) {\n      cl[0] = (c0[0] * (splitYBy - row) + c2[0] * row) / splitYBy | 0;\n      cl[1] = (c0[1] * (splitYBy - row) + c2[1] * row) / splitYBy | 0;\n      cl[2] = (c0[2] * (splitYBy - row) + c2[2] * row) / splitYBy | 0;\n      cr[0] = (c1[0] * (splitYBy - row) + c3[0] * row) / splitYBy | 0;\n      cr[1] = (c1[1] * (splitYBy - row) + c3[1] * row) / splitYBy | 0;\n      cr[2] = (c1[2] * (splitYBy - row) + c3[2] * row) / splitYBy | 0;\n      for (let col = 0; col <= splitXBy; col++, k++) {\n        if ((row === 0 || row === splitYBy) && (col === 0 || col === splitXBy)) {\n          continue;\n        }\n        let x = 0,\n          y = 0;\n        let q = 0;\n        for (let i = 0; i <= 3; i++) {\n          for (let j = 0; j <= 3; j++, q++) {\n            const m = bRow[row][i] * bCol[col][j];\n            x += coords[pi[q]][0] * m;\n            y += coords[pi[q]][1] * m;\n          }\n        }\n        figureCoords[k] = coords.length;\n        coords.push([x, y]);\n        figureColors[k] = colors.length;\n        const newColor = new Uint8Array(3);\n        newColor[0] = (cl[0] * (splitXBy - col) + cr[0] * col) / splitXBy | 0;\n        newColor[1] = (cl[1] * (splitXBy - col) + cr[1] * col) / splitXBy | 0;\n        newColor[2] = (cl[2] * (splitXBy - col) + cr[2] * col) / splitXBy | 0;\n        colors.push(newColor);\n      }\n    }\n    figureCoords[0] = pi[0];\n    figureColors[0] = ci[0];\n    figureCoords[splitXBy] = pi[3];\n    figureColors[splitXBy] = ci[1];\n    figureCoords[verticesPerRow * splitYBy] = pi[12];\n    figureColors[verticesPerRow * splitYBy] = ci[2];\n    figureCoords[verticesPerRow * splitYBy + splitXBy] = pi[15];\n    figureColors[verticesPerRow * splitYBy + splitXBy] = ci[3];\n    this.figures[index] = {\n      type: \"lattice\",\n      coords: figureCoords,\n      colors: figureColors,\n      verticesPerRow\n    };\n  }\n  _updateBounds() {\n    let minX = this.coords[0][0],\n      minY = this.coords[0][1],\n      maxX = minX,\n      maxY = minY;\n    for (let i = 1, ii = this.coords.length; i < ii; i++) {\n      const x = this.coords[i][0],\n        y = this.coords[i][1];\n      minX = minX > x ? x : minX;\n      minY = minY > y ? y : minY;\n      maxX = maxX < x ? x : maxX;\n      maxY = maxY < y ? y : maxY;\n    }\n    this.bounds = [minX, minY, maxX, maxY];\n  }\n  _packData() {\n    let i, ii, j, jj;\n    const coords = this.coords;\n    const coordsPacked = new Float32Array(coords.length * 2);\n    for (i = 0, j = 0, ii = coords.length; i < ii; i++) {\n      const xy = coords[i];\n      coordsPacked[j++] = xy[0];\n      coordsPacked[j++] = xy[1];\n    }\n    this.coords = coordsPacked;\n    const colors = this.colors;\n    const colorsPacked = new Uint8Array(colors.length * 3);\n    for (i = 0, j = 0, ii = colors.length; i < ii; i++) {\n      const c = colors[i];\n      colorsPacked[j++] = c[0];\n      colorsPacked[j++] = c[1];\n      colorsPacked[j++] = c[2];\n    }\n    this.colors = colorsPacked;\n    const figures = this.figures;\n    for (i = 0, ii = figures.length; i < ii; i++) {\n      const figure = figures[i],\n        ps = figure.coords,\n        cs = figure.colors;\n      for (j = 0, jj = ps.length; j < jj; j++) {\n        ps[j] *= 2;\n        cs[j] *= 3;\n      }\n    }\n  }\n  getIR() {\n    const {\n      bounds\n    } = this;\n    if (bounds[2] - bounds[0] === 0 || bounds[3] - bounds[1] === 0) {\n      throw new FormatError(`Invalid MeshShading bounds: [${bounds}].`);\n    }\n    return [\"Mesh\", this.shadingType, this.coords, this.colors, this.figures, bounds, this.bbox, this.background];\n  }\n}\nclass DummyShading extends BaseShading {\n  getIR() {\n    return [\"Dummy\"];\n  }\n}\nfunction getTilingPatternIR(operatorList, dict, color) {\n  const matrix = dict.getArray(\"Matrix\");\n  const bbox = Util.normalizeRect(dict.getArray(\"BBox\"));\n  const xstep = dict.get(\"XStep\");\n  const ystep = dict.get(\"YStep\");\n  const paintType = dict.get(\"PaintType\");\n  const tilingType = dict.get(\"TilingType\");\n  if (bbox[2] - bbox[0] === 0 || bbox[3] - bbox[1] === 0) {\n    throw new FormatError(`Invalid getTilingPatternIR /BBox array: [${bbox}].`);\n  }\n  return [\"TilingPattern\", color, operatorList, matrix, bbox, xstep, ystep, paintType, tilingType];\n}\n\n;// CONCATENATED MODULE: ./src/core/calibri_factors.js\nconst CalibriBoldFactors = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nconst CalibriBoldMetrics = {\n  lineHeight: 1.2207,\n  lineGap: 0.2207\n};\nconst CalibriBoldItalicFactors = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nconst CalibriBoldItalicMetrics = {\n  lineHeight: 1.2207,\n  lineGap: 0.2207\n};\nconst CalibriItalicFactors = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nconst CalibriItalicMetrics = {\n  lineHeight: 1.2207,\n  lineGap: 0.2207\n};\nconst CalibriRegularFactors = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nconst CalibriRegularMetrics = {\n  lineHeight: 1.2207,\n  lineGap: 0.2207\n};\n\n;// CONCATENATED MODULE: ./src/core/helvetica_factors.js\nconst HelveticaBoldFactors = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nconst HelveticaBoldMetrics = {\n  lineHeight: 1.2,\n  lineGap: 0.2\n};\nconst HelveticaBoldItalicFactors = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nconst HelveticaBoldItalicMetrics = {\n  lineHeight: 1.35,\n  lineGap: 0.2\n};\nconst HelveticaItalicFactors = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nconst HelveticaItalicMetrics = {\n  lineHeight: 1.35,\n  lineGap: 0.2\n};\nconst HelveticaRegularFactors = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nconst HelveticaRegularMetrics = {\n  lineHeight: 1.2,\n  lineGap: 0.2\n};\n\n;// CONCATENATED MODULE: ./src/core/liberationsans_widths.js\nconst LiberationSansBoldWidths = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1000, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1000, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1000, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1000, 1000, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1000, 1000, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1000, 768, 600, 834, 834, 834, 834, 1000, 500, 1000, 500, 1000, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1000, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];\nconst LiberationSansBoldMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\nconst LiberationSansBoldItalicWidths = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1000, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1000, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1000, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1000, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1000, 1000, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1000, 1000, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1000, 768, 600, 834, 834, 834, 834, 999, 500, 1000, 500, 1000, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1000, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];\nconst LiberationSansBoldItalicMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\nconst LiberationSansItalicWidths = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1000, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1000, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1000, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1000, 1000, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1000, 1000, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1000, 768, 600, 834, 834, 834, 834, 1000, 500, 998, 500, 1000, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1000, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];\nconst LiberationSansItalicMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\nconst LiberationSansRegularWidths = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1000, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1000, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1000, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1000, 1000, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1000, 1000, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1000, 768, 600, 834, 834, 834, 834, 1000, 500, 1000, 500, 1000, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1000, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];\nconst LiberationSansRegularMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\n\n;// CONCATENATED MODULE: ./src/core/myriadpro_factors.js\nconst MyriadProBoldFactors = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nconst MyriadProBoldMetrics = {\n  lineHeight: 1.2,\n  lineGap: 0.2\n};\nconst MyriadProBoldItalicFactors = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nconst MyriadProBoldItalicMetrics = {\n  lineHeight: 1.2,\n  lineGap: 0.2\n};\nconst MyriadProItalicFactors = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nconst MyriadProItalicMetrics = {\n  lineHeight: 1.2,\n  lineGap: 0.2\n};\nconst MyriadProRegularFactors = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nconst MyriadProRegularMetrics = {\n  lineHeight: 1.2,\n  lineGap: 0.2\n};\n\n;// CONCATENATED MODULE: ./src/core/segoeui_factors.js\nconst SegoeuiBoldFactors = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nconst SegoeuiBoldMetrics = {\n  lineHeight: 1.33008,\n  lineGap: 0\n};\nconst SegoeuiBoldItalicFactors = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nconst SegoeuiBoldItalicMetrics = {\n  lineHeight: 1.33008,\n  lineGap: 0\n};\nconst SegoeuiItalicFactors = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nconst SegoeuiItalicMetrics = {\n  lineHeight: 1.33008,\n  lineGap: 0\n};\nconst SegoeuiRegularFactors = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nconst SegoeuiRegularMetrics = {\n  lineHeight: 1.33008,\n  lineGap: 0\n};\n\n;// CONCATENATED MODULE: ./src/core/xfa_fonts.js\n\n\n\n\n\n\n\n\nconst getXFAFontMap = getLookupTableFactory(function (t) {\n  t[\"MyriadPro-Regular\"] = t[\"PdfJS-Fallback-Regular\"] = {\n    name: \"LiberationSans-Regular\",\n    factors: MyriadProRegularFactors,\n    baseWidths: LiberationSansRegularWidths,\n    baseMapping: LiberationSansRegularMapping,\n    metrics: MyriadProRegularMetrics\n  };\n  t[\"MyriadPro-Bold\"] = t[\"PdfJS-Fallback-Bold\"] = {\n    name: \"LiberationSans-Bold\",\n    factors: MyriadProBoldFactors,\n    baseWidths: LiberationSansBoldWidths,\n    baseMapping: LiberationSansBoldMapping,\n    metrics: MyriadProBoldMetrics\n  };\n  t[\"MyriadPro-It\"] = t[\"MyriadPro-Italic\"] = t[\"PdfJS-Fallback-Italic\"] = {\n    name: \"LiberationSans-Italic\",\n    factors: MyriadProItalicFactors,\n    baseWidths: LiberationSansItalicWidths,\n    baseMapping: LiberationSansItalicMapping,\n    metrics: MyriadProItalicMetrics\n  };\n  t[\"MyriadPro-BoldIt\"] = t[\"MyriadPro-BoldItalic\"] = t[\"PdfJS-Fallback-BoldItalic\"] = {\n    name: \"LiberationSans-BoldItalic\",\n    factors: MyriadProBoldItalicFactors,\n    baseWidths: LiberationSansBoldItalicWidths,\n    baseMapping: LiberationSansBoldItalicMapping,\n    metrics: MyriadProBoldItalicMetrics\n  };\n  t.ArialMT = t.Arial = t[\"Arial-Regular\"] = {\n    name: \"LiberationSans-Regular\",\n    baseWidths: LiberationSansRegularWidths,\n    baseMapping: LiberationSansRegularMapping\n  };\n  t[\"Arial-BoldMT\"] = t[\"Arial-Bold\"] = {\n    name: \"LiberationSans-Bold\",\n    baseWidths: LiberationSansBoldWidths,\n    baseMapping: LiberationSansBoldMapping\n  };\n  t[\"Arial-ItalicMT\"] = t[\"Arial-Italic\"] = {\n    name: \"LiberationSans-Italic\",\n    baseWidths: LiberationSansItalicWidths,\n    baseMapping: LiberationSansItalicMapping\n  };\n  t[\"Arial-BoldItalicMT\"] = t[\"Arial-BoldItalic\"] = {\n    name: \"LiberationSans-BoldItalic\",\n    baseWidths: LiberationSansBoldItalicWidths,\n    baseMapping: LiberationSansBoldItalicMapping\n  };\n  t[\"Calibri-Regular\"] = {\n    name: \"LiberationSans-Regular\",\n    factors: CalibriRegularFactors,\n    baseWidths: LiberationSansRegularWidths,\n    baseMapping: LiberationSansRegularMapping,\n    metrics: CalibriRegularMetrics\n  };\n  t[\"Calibri-Bold\"] = {\n    name: \"LiberationSans-Bold\",\n    factors: CalibriBoldFactors,\n    baseWidths: LiberationSansBoldWidths,\n    baseMapping: LiberationSansBoldMapping,\n    metrics: CalibriBoldMetrics\n  };\n  t[\"Calibri-Italic\"] = {\n    name: \"LiberationSans-Italic\",\n    factors: CalibriItalicFactors,\n    baseWidths: LiberationSansItalicWidths,\n    baseMapping: LiberationSansItalicMapping,\n    metrics: CalibriItalicMetrics\n  };\n  t[\"Calibri-BoldItalic\"] = {\n    name: \"LiberationSans-BoldItalic\",\n    factors: CalibriBoldItalicFactors,\n    baseWidths: LiberationSansBoldItalicWidths,\n    baseMapping: LiberationSansBoldItalicMapping,\n    metrics: CalibriBoldItalicMetrics\n  };\n  t[\"Segoeui-Regular\"] = {\n    name: \"LiberationSans-Regular\",\n    factors: SegoeuiRegularFactors,\n    baseWidths: LiberationSansRegularWidths,\n    baseMapping: LiberationSansRegularMapping,\n    metrics: SegoeuiRegularMetrics\n  };\n  t[\"Segoeui-Bold\"] = {\n    name: \"LiberationSans-Bold\",\n    factors: SegoeuiBoldFactors,\n    baseWidths: LiberationSansBoldWidths,\n    baseMapping: LiberationSansBoldMapping,\n    metrics: SegoeuiBoldMetrics\n  };\n  t[\"Segoeui-Italic\"] = {\n    name: \"LiberationSans-Italic\",\n    factors: SegoeuiItalicFactors,\n    baseWidths: LiberationSansItalicWidths,\n    baseMapping: LiberationSansItalicMapping,\n    metrics: SegoeuiItalicMetrics\n  };\n  t[\"Segoeui-BoldItalic\"] = {\n    name: \"LiberationSans-BoldItalic\",\n    factors: SegoeuiBoldItalicFactors,\n    baseWidths: LiberationSansBoldItalicWidths,\n    baseMapping: LiberationSansBoldItalicMapping,\n    metrics: SegoeuiBoldItalicMetrics\n  };\n  t[\"Helvetica-Regular\"] = t.Helvetica = {\n    name: \"LiberationSans-Regular\",\n    factors: HelveticaRegularFactors,\n    baseWidths: LiberationSansRegularWidths,\n    baseMapping: LiberationSansRegularMapping,\n    metrics: HelveticaRegularMetrics\n  };\n  t[\"Helvetica-Bold\"] = {\n    name: \"LiberationSans-Bold\",\n    factors: HelveticaBoldFactors,\n    baseWidths: LiberationSansBoldWidths,\n    baseMapping: LiberationSansBoldMapping,\n    metrics: HelveticaBoldMetrics\n  };\n  t[\"Helvetica-Italic\"] = {\n    name: \"LiberationSans-Italic\",\n    factors: HelveticaItalicFactors,\n    baseWidths: LiberationSansItalicWidths,\n    baseMapping: LiberationSansItalicMapping,\n    metrics: HelveticaItalicMetrics\n  };\n  t[\"Helvetica-BoldItalic\"] = {\n    name: \"LiberationSans-BoldItalic\",\n    factors: HelveticaBoldItalicFactors,\n    baseWidths: LiberationSansBoldItalicWidths,\n    baseMapping: LiberationSansBoldItalicMapping,\n    metrics: HelveticaBoldItalicMetrics\n  };\n});\nfunction getXfaFontName(name) {\n  const fontName = normalizeFontName(name);\n  const fontMap = getXFAFontMap();\n  return fontMap[fontName];\n}\nfunction getXfaFontWidths(name) {\n  const info = getXfaFontName(name);\n  if (!info) {\n    return null;\n  }\n  const {\n    baseWidths,\n    baseMapping,\n    factors\n  } = info;\n  const rescaledBaseWidths = !factors ? baseWidths : baseWidths.map((w, i) => w * factors[i]);\n  let currentCode = -2;\n  let currentArray;\n  const newWidths = [];\n  for (const [unicode, glyphIndex] of baseMapping.map((charUnicode, index) => [charUnicode, index]).sort(([unicode1], [unicode2]) => unicode1 - unicode2)) {\n    if (unicode === -1) {\n      continue;\n    }\n    if (unicode === currentCode + 1) {\n      currentArray.push(rescaledBaseWidths[glyphIndex]);\n      currentCode += 1;\n    } else {\n      currentCode = unicode;\n      currentArray = [rescaledBaseWidths[glyphIndex]];\n      newWidths.push(unicode, currentArray);\n    }\n  }\n  return newWidths;\n}\nfunction getXfaFontDict(name) {\n  const widths = getXfaFontWidths(name);\n  const dict = new Dict(null);\n  dict.set(\"BaseFont\", Name.get(name));\n  dict.set(\"Type\", Name.get(\"Font\"));\n  dict.set(\"Subtype\", Name.get(\"CIDFontType2\"));\n  dict.set(\"Encoding\", Name.get(\"Identity-H\"));\n  dict.set(\"CIDToGIDMap\", Name.get(\"Identity\"));\n  dict.set(\"W\", widths);\n  dict.set(\"FirstChar\", widths[0]);\n  dict.set(\"LastChar\", widths.at(-2) + widths.at(-1).length - 1);\n  const descriptor = new Dict(null);\n  dict.set(\"FontDescriptor\", descriptor);\n  const systemInfo = new Dict(null);\n  systemInfo.set(\"Ordering\", \"Identity\");\n  systemInfo.set(\"Registry\", \"Adobe\");\n  systemInfo.set(\"Supplement\", 0);\n  dict.set(\"CIDSystemInfo\", systemInfo);\n  return dict;\n}\n\n;// CONCATENATED MODULE: ./src/core/ps_parser.js\n\n\n\nclass PostScriptParser {\n  constructor(lexer) {\n    this.lexer = lexer;\n    this.operators = [];\n    this.token = null;\n    this.prev = null;\n  }\n  nextToken() {\n    this.prev = this.token;\n    this.token = this.lexer.getToken();\n  }\n  accept(type) {\n    if (this.token.type === type) {\n      this.nextToken();\n      return true;\n    }\n    return false;\n  }\n  expect(type) {\n    if (this.accept(type)) {\n      return true;\n    }\n    throw new FormatError(`Unexpected symbol: found ${this.token.type} expected ${type}.`);\n  }\n  parse() {\n    this.nextToken();\n    this.expect(PostScriptTokenTypes.LBRACE);\n    this.parseBlock();\n    this.expect(PostScriptTokenTypes.RBRACE);\n    return this.operators;\n  }\n  parseBlock() {\n    while (true) {\n      if (this.accept(PostScriptTokenTypes.NUMBER)) {\n        this.operators.push(this.prev.value);\n      } else if (this.accept(PostScriptTokenTypes.OPERATOR)) {\n        this.operators.push(this.prev.value);\n      } else if (this.accept(PostScriptTokenTypes.LBRACE)) {\n        this.parseCondition();\n      } else {\n        return;\n      }\n    }\n  }\n  parseCondition() {\n    const conditionLocation = this.operators.length;\n    this.operators.push(null, null);\n    this.parseBlock();\n    this.expect(PostScriptTokenTypes.RBRACE);\n    if (this.accept(PostScriptTokenTypes.IF)) {\n      this.operators[conditionLocation] = this.operators.length;\n      this.operators[conditionLocation + 1] = \"jz\";\n    } else if (this.accept(PostScriptTokenTypes.LBRACE)) {\n      const jumpLocation = this.operators.length;\n      this.operators.push(null, null);\n      const endOfTrue = this.operators.length;\n      this.parseBlock();\n      this.expect(PostScriptTokenTypes.RBRACE);\n      this.expect(PostScriptTokenTypes.IFELSE);\n      this.operators[jumpLocation] = this.operators.length;\n      this.operators[jumpLocation + 1] = \"j\";\n      this.operators[conditionLocation] = endOfTrue;\n      this.operators[conditionLocation + 1] = \"jz\";\n    } else {\n      throw new FormatError(\"PS Function: error parsing conditional.\");\n    }\n  }\n}\nconst PostScriptTokenTypes = {\n  LBRACE: 0,\n  RBRACE: 1,\n  NUMBER: 2,\n  OPERATOR: 3,\n  IF: 4,\n  IFELSE: 5\n};\nclass PostScriptToken {\n  static get opCache() {\n    return shadow(this, \"opCache\", Object.create(null));\n  }\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n  static getOperator(op) {\n    return PostScriptToken.opCache[op] ||= new PostScriptToken(PostScriptTokenTypes.OPERATOR, op);\n  }\n  static get LBRACE() {\n    return shadow(this, \"LBRACE\", new PostScriptToken(PostScriptTokenTypes.LBRACE, \"{\"));\n  }\n  static get RBRACE() {\n    return shadow(this, \"RBRACE\", new PostScriptToken(PostScriptTokenTypes.RBRACE, \"}\"));\n  }\n  static get IF() {\n    return shadow(this, \"IF\", new PostScriptToken(PostScriptTokenTypes.IF, \"IF\"));\n  }\n  static get IFELSE() {\n    return shadow(this, \"IFELSE\", new PostScriptToken(PostScriptTokenTypes.IFELSE, \"IFELSE\"));\n  }\n}\nclass PostScriptLexer {\n  constructor(stream) {\n    this.stream = stream;\n    this.nextChar();\n    this.strBuf = [];\n  }\n  nextChar() {\n    return this.currentChar = this.stream.getByte();\n  }\n  getToken() {\n    let comment = false;\n    let ch = this.currentChar;\n    while (true) {\n      if (ch < 0) {\n        return EOF;\n      }\n      if (comment) {\n        if (ch === 0x0a || ch === 0x0d) {\n          comment = false;\n        }\n      } else if (ch === 0x25) {\n        comment = true;\n      } else if (!isWhiteSpace(ch)) {\n        break;\n      }\n      ch = this.nextChar();\n    }\n    switch (ch | 0) {\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x2b:\n      case 0x2d:\n      case 0x2e:\n        return new PostScriptToken(PostScriptTokenTypes.NUMBER, this.getNumber());\n      case 0x7b:\n        this.nextChar();\n        return PostScriptToken.LBRACE;\n      case 0x7d:\n        this.nextChar();\n        return PostScriptToken.RBRACE;\n    }\n    const strBuf = this.strBuf;\n    strBuf.length = 0;\n    strBuf[0] = String.fromCharCode(ch);\n    while ((ch = this.nextChar()) >= 0 && (ch >= 0x41 && ch <= 0x5a || ch >= 0x61 && ch <= 0x7a)) {\n      strBuf.push(String.fromCharCode(ch));\n    }\n    const str = strBuf.join(\"\");\n    switch (str.toLowerCase()) {\n      case \"if\":\n        return PostScriptToken.IF;\n      case \"ifelse\":\n        return PostScriptToken.IFELSE;\n      default:\n        return PostScriptToken.getOperator(str);\n    }\n  }\n  getNumber() {\n    let ch = this.currentChar;\n    const strBuf = this.strBuf;\n    strBuf.length = 0;\n    strBuf[0] = String.fromCharCode(ch);\n    while ((ch = this.nextChar()) >= 0) {\n      if (ch >= 0x30 && ch <= 0x39 || ch === 0x2d || ch === 0x2e) {\n        strBuf.push(String.fromCharCode(ch));\n      } else {\n        break;\n      }\n    }\n    const value = parseFloat(strBuf.join(\"\"));\n    if (isNaN(value)) {\n      throw new FormatError(`Invalid floating point number: ${value}`);\n    }\n    return value;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/image_utils.js\n\n\nclass BaseLocalCache {\n  constructor(options) {\n    if (this.constructor === BaseLocalCache) {\n      unreachable(\"Cannot initialize BaseLocalCache.\");\n    }\n    this._onlyRefs = options?.onlyRefs === true;\n    if (!this._onlyRefs) {\n      this._nameRefMap = new Map();\n      this._imageMap = new Map();\n    }\n    this._imageCache = new RefSetCache();\n  }\n  getByName(name) {\n    if (this._onlyRefs) {\n      unreachable(\"Should not call `getByName` method.\");\n    }\n    const ref = this._nameRefMap.get(name);\n    if (ref) {\n      return this.getByRef(ref);\n    }\n    return this._imageMap.get(name) || null;\n  }\n  getByRef(ref) {\n    return this._imageCache.get(ref) || null;\n  }\n  set(name, ref, data) {\n    unreachable(\"Abstract method `set` called.\");\n  }\n}\nclass LocalImageCache extends BaseLocalCache {\n  set(name, ref = null, data) {\n    if (typeof name !== \"string\") {\n      throw new Error('LocalImageCache.set - expected \"name\" argument.');\n    }\n    if (ref) {\n      if (this._imageCache.has(ref)) {\n        return;\n      }\n      this._nameRefMap.set(name, ref);\n      this._imageCache.put(ref, data);\n      return;\n    }\n    if (this._imageMap.has(name)) {\n      return;\n    }\n    this._imageMap.set(name, data);\n  }\n}\nclass LocalColorSpaceCache extends BaseLocalCache {\n  set(name = null, ref = null, data) {\n    if (typeof name !== \"string\" && !ref) {\n      throw new Error('LocalColorSpaceCache.set - expected \"name\" and/or \"ref\" argument.');\n    }\n    if (ref) {\n      if (this._imageCache.has(ref)) {\n        return;\n      }\n      if (name !== null) {\n        this._nameRefMap.set(name, ref);\n      }\n      this._imageCache.put(ref, data);\n      return;\n    }\n    if (this._imageMap.has(name)) {\n      return;\n    }\n    this._imageMap.set(name, data);\n  }\n}\nclass LocalFunctionCache extends BaseLocalCache {\n  constructor(options) {\n    super({\n      onlyRefs: true\n    });\n  }\n  set(name = null, ref, data) {\n    if (!ref) {\n      throw new Error('LocalFunctionCache.set - expected \"ref\" argument.');\n    }\n    if (this._imageCache.has(ref)) {\n      return;\n    }\n    this._imageCache.put(ref, data);\n  }\n}\nclass LocalGStateCache extends BaseLocalCache {\n  set(name, ref = null, data) {\n    if (typeof name !== \"string\") {\n      throw new Error('LocalGStateCache.set - expected \"name\" argument.');\n    }\n    if (ref) {\n      if (this._imageCache.has(ref)) {\n        return;\n      }\n      this._nameRefMap.set(name, ref);\n      this._imageCache.put(ref, data);\n      return;\n    }\n    if (this._imageMap.has(name)) {\n      return;\n    }\n    this._imageMap.set(name, data);\n  }\n}\nclass LocalTilingPatternCache extends BaseLocalCache {\n  constructor(options) {\n    super({\n      onlyRefs: true\n    });\n  }\n  set(name = null, ref, data) {\n    if (!ref) {\n      throw new Error('LocalTilingPatternCache.set - expected \"ref\" argument.');\n    }\n    if (this._imageCache.has(ref)) {\n      return;\n    }\n    this._imageCache.put(ref, data);\n  }\n}\nclass RegionalImageCache extends BaseLocalCache {\n  constructor(options) {\n    super({\n      onlyRefs: true\n    });\n  }\n  set(name = null, ref, data) {\n    if (!ref) {\n      throw new Error('RegionalImageCache.set - expected \"ref\" argument.');\n    }\n    if (this._imageCache.has(ref)) {\n      return;\n    }\n    this._imageCache.put(ref, data);\n  }\n}\nclass GlobalImageCache {\n  static NUM_PAGES_THRESHOLD = 2;\n  static MIN_IMAGES_TO_CACHE = 10;\n  static MAX_BYTE_SIZE = 5 * MAX_IMAGE_SIZE_TO_CACHE;\n  constructor() {\n    this._refCache = new RefSetCache();\n    this._imageCache = new RefSetCache();\n  }\n  get _byteSize() {\n    let byteSize = 0;\n    for (const imageData of this._imageCache) {\n      byteSize += imageData.byteSize;\n    }\n    return byteSize;\n  }\n  get _cacheLimitReached() {\n    if (this._imageCache.size < GlobalImageCache.MIN_IMAGES_TO_CACHE) {\n      return false;\n    }\n    if (this._byteSize < GlobalImageCache.MAX_BYTE_SIZE) {\n      return false;\n    }\n    return true;\n  }\n  shouldCache(ref, pageIndex) {\n    let pageIndexSet = this._refCache.get(ref);\n    if (!pageIndexSet) {\n      pageIndexSet = new Set();\n      this._refCache.put(ref, pageIndexSet);\n    }\n    pageIndexSet.add(pageIndex);\n    if (pageIndexSet.size < GlobalImageCache.NUM_PAGES_THRESHOLD) {\n      return false;\n    }\n    if (!this._imageCache.has(ref) && this._cacheLimitReached) {\n      return false;\n    }\n    return true;\n  }\n  addByteSize(ref, byteSize) {\n    const imageData = this._imageCache.get(ref);\n    if (!imageData) {\n      return;\n    }\n    if (imageData.byteSize) {\n      return;\n    }\n    imageData.byteSize = byteSize;\n  }\n  getData(ref, pageIndex) {\n    const pageIndexSet = this._refCache.get(ref);\n    if (!pageIndexSet) {\n      return null;\n    }\n    if (pageIndexSet.size < GlobalImageCache.NUM_PAGES_THRESHOLD) {\n      return null;\n    }\n    const imageData = this._imageCache.get(ref);\n    if (!imageData) {\n      return null;\n    }\n    pageIndexSet.add(pageIndex);\n    return imageData;\n  }\n  setData(ref, data) {\n    if (!this._refCache.has(ref)) {\n      throw new Error('GlobalImageCache.setData - expected \"shouldCache\" to have been called.');\n    }\n    if (this._imageCache.has(ref)) {\n      return;\n    }\n    if (this._cacheLimitReached) {\n      warn(\"GlobalImageCache.setData - cache limit reached.\");\n      return;\n    }\n    this._imageCache.put(ref, data);\n  }\n  clear(onlyData = false) {\n    if (!onlyData) {\n      this._refCache.clear();\n    }\n    this._imageCache.clear();\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/function.js\n\n\n\n\n\n\nclass PDFFunctionFactory {\n  constructor({\n    xref,\n    isEvalSupported = true\n  }) {\n    this.xref = xref;\n    this.isEvalSupported = isEvalSupported !== false;\n  }\n  create(fn) {\n    const cachedFunction = this.getCached(fn);\n    if (cachedFunction) {\n      return cachedFunction;\n    }\n    const parsedFunction = PDFFunction.parse({\n      xref: this.xref,\n      isEvalSupported: this.isEvalSupported,\n      fn: fn instanceof Ref ? this.xref.fetch(fn) : fn\n    });\n    this._cache(fn, parsedFunction);\n    return parsedFunction;\n  }\n  createFromArray(fnObj) {\n    const cachedFunction = this.getCached(fnObj);\n    if (cachedFunction) {\n      return cachedFunction;\n    }\n    const parsedFunction = PDFFunction.parseArray({\n      xref: this.xref,\n      isEvalSupported: this.isEvalSupported,\n      fnObj: fnObj instanceof Ref ? this.xref.fetch(fnObj) : fnObj\n    });\n    this._cache(fnObj, parsedFunction);\n    return parsedFunction;\n  }\n  getCached(cacheKey) {\n    let fnRef;\n    if (cacheKey instanceof Ref) {\n      fnRef = cacheKey;\n    } else if (cacheKey instanceof Dict) {\n      fnRef = cacheKey.objId;\n    } else if (cacheKey instanceof BaseStream) {\n      fnRef = cacheKey.dict?.objId;\n    }\n    if (fnRef) {\n      const localFunction = this._localFunctionCache.getByRef(fnRef);\n      if (localFunction) {\n        return localFunction;\n      }\n    }\n    return null;\n  }\n  _cache(cacheKey, parsedFunction) {\n    if (!parsedFunction) {\n      throw new Error('PDFFunctionFactory._cache - expected \"parsedFunction\" argument.');\n    }\n    let fnRef;\n    if (cacheKey instanceof Ref) {\n      fnRef = cacheKey;\n    } else if (cacheKey instanceof Dict) {\n      fnRef = cacheKey.objId;\n    } else if (cacheKey instanceof BaseStream) {\n      fnRef = cacheKey.dict?.objId;\n    }\n    if (fnRef) {\n      this._localFunctionCache.set(null, fnRef, parsedFunction);\n    }\n  }\n  get _localFunctionCache() {\n    return shadow(this, \"_localFunctionCache\", new LocalFunctionCache());\n  }\n}\nfunction toNumberArray(arr) {\n  if (!Array.isArray(arr)) {\n    return null;\n  }\n  if (!isNumberArray(arr, null)) {\n    return arr.map(x => +x);\n  }\n  return arr;\n}\nclass PDFFunction {\n  static getSampleArray(size, outputSize, bps, stream) {\n    let i, ii;\n    let length = 1;\n    for (i = 0, ii = size.length; i < ii; i++) {\n      length *= size[i];\n    }\n    length *= outputSize;\n    const array = new Array(length);\n    let codeSize = 0;\n    let codeBuf = 0;\n    const sampleMul = 1.0 / (2.0 ** bps - 1);\n    const strBytes = stream.getBytes((length * bps + 7) / 8);\n    let strIdx = 0;\n    for (i = 0; i < length; i++) {\n      while (codeSize < bps) {\n        codeBuf <<= 8;\n        codeBuf |= strBytes[strIdx++];\n        codeSize += 8;\n      }\n      codeSize -= bps;\n      array[i] = (codeBuf >> codeSize) * sampleMul;\n      codeBuf &= (1 << codeSize) - 1;\n    }\n    return array;\n  }\n  static parse({\n    xref,\n    isEvalSupported,\n    fn\n  }) {\n    const dict = fn.dict || fn;\n    const typeNum = dict.get(\"FunctionType\");\n    switch (typeNum) {\n      case 0:\n        return this.constructSampled({\n          xref,\n          isEvalSupported,\n          fn,\n          dict\n        });\n      case 1:\n        break;\n      case 2:\n        return this.constructInterpolated({\n          xref,\n          isEvalSupported,\n          dict\n        });\n      case 3:\n        return this.constructStiched({\n          xref,\n          isEvalSupported,\n          dict\n        });\n      case 4:\n        return this.constructPostScript({\n          xref,\n          isEvalSupported,\n          fn,\n          dict\n        });\n    }\n    throw new FormatError(\"Unknown type of function\");\n  }\n  static parseArray({\n    xref,\n    isEvalSupported,\n    fnObj\n  }) {\n    if (!Array.isArray(fnObj)) {\n      return this.parse({\n        xref,\n        isEvalSupported,\n        fn: fnObj\n      });\n    }\n    const fnArray = [];\n    for (const fn of fnObj) {\n      fnArray.push(this.parse({\n        xref,\n        isEvalSupported,\n        fn: xref.fetchIfRef(fn)\n      }));\n    }\n    return function (src, srcOffset, dest, destOffset) {\n      for (let i = 0, ii = fnArray.length; i < ii; i++) {\n        fnArray[i](src, srcOffset, dest, destOffset + i);\n      }\n    };\n  }\n  static constructSampled({\n    xref,\n    isEvalSupported,\n    fn,\n    dict\n  }) {\n    function toMultiArray(arr) {\n      const inputLength = arr.length;\n      const out = [];\n      let index = 0;\n      for (let i = 0; i < inputLength; i += 2) {\n        out[index++] = [arr[i], arr[i + 1]];\n      }\n      return out;\n    }\n    function interpolate(x, xmin, xmax, ymin, ymax) {\n      return ymin + (x - xmin) * ((ymax - ymin) / (xmax - xmin));\n    }\n    let domain = toNumberArray(dict.getArray(\"Domain\"));\n    let range = toNumberArray(dict.getArray(\"Range\"));\n    if (!domain || !range) {\n      throw new FormatError(\"No domain or range\");\n    }\n    const inputSize = domain.length / 2;\n    const outputSize = range.length / 2;\n    domain = toMultiArray(domain);\n    range = toMultiArray(range);\n    const size = toNumberArray(dict.getArray(\"Size\"));\n    const bps = dict.get(\"BitsPerSample\");\n    const order = dict.get(\"Order\") || 1;\n    if (order !== 1) {\n      info(\"No support for cubic spline interpolation: \" + order);\n    }\n    let encode = toNumberArray(dict.getArray(\"Encode\"));\n    if (!encode) {\n      encode = [];\n      for (let i = 0; i < inputSize; ++i) {\n        encode.push([0, size[i] - 1]);\n      }\n    } else {\n      encode = toMultiArray(encode);\n    }\n    let decode = toNumberArray(dict.getArray(\"Decode\"));\n    decode = !decode ? range : toMultiArray(decode);\n    const samples = this.getSampleArray(size, outputSize, bps, fn);\n    return function constructSampledFn(src, srcOffset, dest, destOffset) {\n      const cubeVertices = 1 << inputSize;\n      const cubeN = new Float64Array(cubeVertices);\n      const cubeVertex = new Uint32Array(cubeVertices);\n      let i, j;\n      for (j = 0; j < cubeVertices; j++) {\n        cubeN[j] = 1;\n      }\n      let k = outputSize,\n        pos = 1;\n      for (i = 0; i < inputSize; ++i) {\n        const domain_2i = domain[i][0];\n        const domain_2i_1 = domain[i][1];\n        const xi = Math.min(Math.max(src[srcOffset + i], domain_2i), domain_2i_1);\n        let e = interpolate(xi, domain_2i, domain_2i_1, encode[i][0], encode[i][1]);\n        const size_i = size[i];\n        e = Math.min(Math.max(e, 0), size_i - 1);\n        const e0 = e < size_i - 1 ? Math.floor(e) : e - 1;\n        const n0 = e0 + 1 - e;\n        const n1 = e - e0;\n        const offset0 = e0 * k;\n        const offset1 = offset0 + k;\n        for (j = 0; j < cubeVertices; j++) {\n          if (j & pos) {\n            cubeN[j] *= n1;\n            cubeVertex[j] += offset1;\n          } else {\n            cubeN[j] *= n0;\n            cubeVertex[j] += offset0;\n          }\n        }\n        k *= size_i;\n        pos <<= 1;\n      }\n      for (j = 0; j < outputSize; ++j) {\n        let rj = 0;\n        for (i = 0; i < cubeVertices; i++) {\n          rj += samples[cubeVertex[i] + j] * cubeN[i];\n        }\n        rj = interpolate(rj, 0, 1, decode[j][0], decode[j][1]);\n        dest[destOffset + j] = Math.min(Math.max(rj, range[j][0]), range[j][1]);\n      }\n    };\n  }\n  static constructInterpolated({\n    xref,\n    isEvalSupported,\n    dict\n  }) {\n    const c0 = toNumberArray(dict.getArray(\"C0\")) || [0];\n    const c1 = toNumberArray(dict.getArray(\"C1\")) || [1];\n    const n = dict.get(\"N\");\n    const diff = [];\n    for (let i = 0, ii = c0.length; i < ii; ++i) {\n      diff.push(c1[i] - c0[i]);\n    }\n    const length = diff.length;\n    return function constructInterpolatedFn(src, srcOffset, dest, destOffset) {\n      const x = n === 1 ? src[srcOffset] : src[srcOffset] ** n;\n      for (let j = 0; j < length; ++j) {\n        dest[destOffset + j] = c0[j] + x * diff[j];\n      }\n    };\n  }\n  static constructStiched({\n    xref,\n    isEvalSupported,\n    dict\n  }) {\n    const domain = toNumberArray(dict.getArray(\"Domain\"));\n    if (!domain) {\n      throw new FormatError(\"No domain\");\n    }\n    const inputSize = domain.length / 2;\n    if (inputSize !== 1) {\n      throw new FormatError(\"Bad domain for stiched function\");\n    }\n    const fns = [];\n    for (const fn of dict.get(\"Functions\")) {\n      fns.push(this.parse({\n        xref,\n        isEvalSupported,\n        fn: xref.fetchIfRef(fn)\n      }));\n    }\n    const bounds = toNumberArray(dict.getArray(\"Bounds\"));\n    const encode = toNumberArray(dict.getArray(\"Encode\"));\n    const tmpBuf = new Float32Array(1);\n    return function constructStichedFn(src, srcOffset, dest, destOffset) {\n      const clip = function constructStichedFromIRClip(v, min, max) {\n        if (v > max) {\n          v = max;\n        } else if (v < min) {\n          v = min;\n        }\n        return v;\n      };\n      const v = clip(src[srcOffset], domain[0], domain[1]);\n      const length = bounds.length;\n      let i;\n      for (i = 0; i < length; ++i) {\n        if (v < bounds[i]) {\n          break;\n        }\n      }\n      let dmin = domain[0];\n      if (i > 0) {\n        dmin = bounds[i - 1];\n      }\n      let dmax = domain[1];\n      if (i < bounds.length) {\n        dmax = bounds[i];\n      }\n      const rmin = encode[2 * i];\n      const rmax = encode[2 * i + 1];\n      tmpBuf[0] = dmin === dmax ? rmin : rmin + (v - dmin) * (rmax - rmin) / (dmax - dmin);\n      fns[i](tmpBuf, 0, dest, destOffset);\n    };\n  }\n  static constructPostScript({\n    xref,\n    isEvalSupported,\n    fn,\n    dict\n  }) {\n    const domain = toNumberArray(dict.getArray(\"Domain\"));\n    const range = toNumberArray(dict.getArray(\"Range\"));\n    if (!domain) {\n      throw new FormatError(\"No domain.\");\n    }\n    if (!range) {\n      throw new FormatError(\"No range.\");\n    }\n    const lexer = new PostScriptLexer(fn);\n    const parser = new PostScriptParser(lexer);\n    const code = parser.parse();\n    if (isEvalSupported && FeatureTest.isEvalSupported) {\n      const compiled = new PostScriptCompiler().compile(code, domain, range);\n      if (compiled) {\n        return new Function(\"src\", \"srcOffset\", \"dest\", \"destOffset\", compiled);\n      }\n    }\n    info(\"Unable to compile PS function\");\n    const numOutputs = range.length >> 1;\n    const numInputs = domain.length >> 1;\n    const evaluator = new PostScriptEvaluator(code);\n    const cache = Object.create(null);\n    const MAX_CACHE_SIZE = 2048 * 4;\n    let cache_available = MAX_CACHE_SIZE;\n    const tmpBuf = new Float32Array(numInputs);\n    return function constructPostScriptFn(src, srcOffset, dest, destOffset) {\n      let i, value;\n      let key = \"\";\n      const input = tmpBuf;\n      for (i = 0; i < numInputs; i++) {\n        value = src[srcOffset + i];\n        input[i] = value;\n        key += value + \"_\";\n      }\n      const cachedValue = cache[key];\n      if (cachedValue !== undefined) {\n        dest.set(cachedValue, destOffset);\n        return;\n      }\n      const output = new Float32Array(numOutputs);\n      const stack = evaluator.execute(input);\n      const stackIndex = stack.length - numOutputs;\n      for (i = 0; i < numOutputs; i++) {\n        value = stack[stackIndex + i];\n        let bound = range[i * 2];\n        if (value < bound) {\n          value = bound;\n        } else {\n          bound = range[i * 2 + 1];\n          if (value > bound) {\n            value = bound;\n          }\n        }\n        output[i] = value;\n      }\n      if (cache_available > 0) {\n        cache_available--;\n        cache[key] = output;\n      }\n      dest.set(output, destOffset);\n    };\n  }\n}\nfunction isPDFFunction(v) {\n  let fnDict;\n  if (v instanceof Dict) {\n    fnDict = v;\n  } else if (v instanceof BaseStream) {\n    fnDict = v.dict;\n  } else {\n    return false;\n  }\n  return fnDict.has(\"FunctionType\");\n}\nclass PostScriptStack {\n  static MAX_STACK_SIZE = 100;\n  constructor(initialStack) {\n    this.stack = initialStack ? Array.from(initialStack) : [];\n  }\n  push(value) {\n    if (this.stack.length >= PostScriptStack.MAX_STACK_SIZE) {\n      throw new Error(\"PostScript function stack overflow.\");\n    }\n    this.stack.push(value);\n  }\n  pop() {\n    if (this.stack.length <= 0) {\n      throw new Error(\"PostScript function stack underflow.\");\n    }\n    return this.stack.pop();\n  }\n  copy(n) {\n    if (this.stack.length + n >= PostScriptStack.MAX_STACK_SIZE) {\n      throw new Error(\"PostScript function stack overflow.\");\n    }\n    const stack = this.stack;\n    for (let i = stack.length - n, j = n - 1; j >= 0; j--, i++) {\n      stack.push(stack[i]);\n    }\n  }\n  index(n) {\n    this.push(this.stack[this.stack.length - n - 1]);\n  }\n  roll(n, p) {\n    const stack = this.stack;\n    const l = stack.length - n;\n    const r = stack.length - 1;\n    const c = l + (p - Math.floor(p / n) * n);\n    for (let i = l, j = r; i < j; i++, j--) {\n      const t = stack[i];\n      stack[i] = stack[j];\n      stack[j] = t;\n    }\n    for (let i = l, j = c - 1; i < j; i++, j--) {\n      const t = stack[i];\n      stack[i] = stack[j];\n      stack[j] = t;\n    }\n    for (let i = c, j = r; i < j; i++, j--) {\n      const t = stack[i];\n      stack[i] = stack[j];\n      stack[j] = t;\n    }\n  }\n}\nclass PostScriptEvaluator {\n  constructor(operators) {\n    this.operators = operators;\n  }\n  execute(initialStack) {\n    const stack = new PostScriptStack(initialStack);\n    let counter = 0;\n    const operators = this.operators;\n    const length = operators.length;\n    let operator, a, b;\n    while (counter < length) {\n      operator = operators[counter++];\n      if (typeof operator === \"number\") {\n        stack.push(operator);\n        continue;\n      }\n      switch (operator) {\n        case \"jz\":\n          b = stack.pop();\n          a = stack.pop();\n          if (!a) {\n            counter = b;\n          }\n          break;\n        case \"j\":\n          a = stack.pop();\n          counter = a;\n          break;\n        case \"abs\":\n          a = stack.pop();\n          stack.push(Math.abs(a));\n          break;\n        case \"add\":\n          b = stack.pop();\n          a = stack.pop();\n          stack.push(a + b);\n          break;\n        case \"and\":\n          b = stack.pop();\n          a = stack.pop();\n          if (typeof a === \"boolean\" && typeof b === \"boolean\") {\n            stack.push(a && b);\n          } else {\n            stack.push(a & b);\n          }\n          break;\n        case \"atan\":\n          b = stack.pop();\n          a = stack.pop();\n          a = Math.atan2(a, b) / Math.PI * 180;\n          if (a < 0) {\n            a += 360;\n          }\n          stack.push(a);\n          break;\n        case \"bitshift\":\n          b = stack.pop();\n          a = stack.pop();\n          if (a > 0) {\n            stack.push(a << b);\n          } else {\n            stack.push(a >> b);\n          }\n          break;\n        case \"ceiling\":\n          a = stack.pop();\n          stack.push(Math.ceil(a));\n          break;\n        case \"copy\":\n          a = stack.pop();\n          stack.copy(a);\n          break;\n        case \"cos\":\n          a = stack.pop();\n          stack.push(Math.cos(a % 360 / 180 * Math.PI));\n          break;\n        case \"cvi\":\n          a = stack.pop() | 0;\n          stack.push(a);\n          break;\n        case \"cvr\":\n          break;\n        case \"div\":\n          b = stack.pop();\n          a = stack.pop();\n          stack.push(a / b);\n          break;\n        case \"dup\":\n          stack.copy(1);\n          break;\n        case \"eq\":\n          b = stack.pop();\n          a = stack.pop();\n          stack.push(a === b);\n          break;\n        case \"exch\":\n          stack.roll(2, 1);\n          break;\n        case \"exp\":\n          b = stack.pop();\n          a = stack.pop();\n          stack.push(a ** b);\n          break;\n        case \"false\":\n          stack.push(false);\n          break;\n        case \"floor\":\n          a = stack.pop();\n          stack.push(Math.floor(a));\n          break;\n        case \"ge\":\n          b = stack.pop();\n          a = stack.pop();\n          stack.push(a >= b);\n          break;\n        case \"gt\":\n          b = stack.pop();\n          a = stack.pop();\n          stack.push(a > b);\n          break;\n        case \"idiv\":\n          b = stack.pop();\n          a = stack.pop();\n          stack.push(a / b | 0);\n          break;\n        case \"index\":\n          a = stack.pop();\n          stack.index(a);\n          break;\n        case \"le\":\n          b = stack.pop();\n          a = stack.pop();\n          stack.push(a <= b);\n          break;\n        case \"ln\":\n          a = stack.pop();\n          stack.push(Math.log(a));\n          break;\n        case \"log\":\n          a = stack.pop();\n          stack.push(Math.log10(a));\n          break;\n        case \"lt\":\n          b = stack.pop();\n          a = stack.pop();\n          stack.push(a < b);\n          break;\n        case \"mod\":\n          b = stack.pop();\n          a = stack.pop();\n          stack.push(a % b);\n          break;\n        case \"mul\":\n          b = stack.pop();\n          a = stack.pop();\n          stack.push(a * b);\n          break;\n        case \"ne\":\n          b = stack.pop();\n          a = stack.pop();\n          stack.push(a !== b);\n          break;\n        case \"neg\":\n          a = stack.pop();\n          stack.push(-a);\n          break;\n        case \"not\":\n          a = stack.pop();\n          if (typeof a === \"boolean\") {\n            stack.push(!a);\n          } else {\n            stack.push(~a);\n          }\n          break;\n        case \"or\":\n          b = stack.pop();\n          a = stack.pop();\n          if (typeof a === \"boolean\" && typeof b === \"boolean\") {\n            stack.push(a || b);\n          } else {\n            stack.push(a | b);\n          }\n          break;\n        case \"pop\":\n          stack.pop();\n          break;\n        case \"roll\":\n          b = stack.pop();\n          a = stack.pop();\n          stack.roll(a, b);\n          break;\n        case \"round\":\n          a = stack.pop();\n          stack.push(Math.round(a));\n          break;\n        case \"sin\":\n          a = stack.pop();\n          stack.push(Math.sin(a % 360 / 180 * Math.PI));\n          break;\n        case \"sqrt\":\n          a = stack.pop();\n          stack.push(Math.sqrt(a));\n          break;\n        case \"sub\":\n          b = stack.pop();\n          a = stack.pop();\n          stack.push(a - b);\n          break;\n        case \"true\":\n          stack.push(true);\n          break;\n        case \"truncate\":\n          a = stack.pop();\n          a = a < 0 ? Math.ceil(a) : Math.floor(a);\n          stack.push(a);\n          break;\n        case \"xor\":\n          b = stack.pop();\n          a = stack.pop();\n          if (typeof a === \"boolean\" && typeof b === \"boolean\") {\n            stack.push(a !== b);\n          } else {\n            stack.push(a ^ b);\n          }\n          break;\n        default:\n          throw new FormatError(`Unknown operator ${operator}`);\n      }\n    }\n    return stack.stack;\n  }\n}\nclass AstNode {\n  constructor(type) {\n    this.type = type;\n  }\n  visit(visitor) {\n    unreachable(\"abstract method\");\n  }\n}\nclass AstArgument extends AstNode {\n  constructor(index, min, max) {\n    super(\"args\");\n    this.index = index;\n    this.min = min;\n    this.max = max;\n  }\n  visit(visitor) {\n    visitor.visitArgument(this);\n  }\n}\nclass AstLiteral extends AstNode {\n  constructor(number) {\n    super(\"literal\");\n    this.number = number;\n    this.min = number;\n    this.max = number;\n  }\n  visit(visitor) {\n    visitor.visitLiteral(this);\n  }\n}\nclass AstBinaryOperation extends AstNode {\n  constructor(op, arg1, arg2, min, max) {\n    super(\"binary\");\n    this.op = op;\n    this.arg1 = arg1;\n    this.arg2 = arg2;\n    this.min = min;\n    this.max = max;\n  }\n  visit(visitor) {\n    visitor.visitBinaryOperation(this);\n  }\n}\nclass AstMin extends AstNode {\n  constructor(arg, max) {\n    super(\"max\");\n    this.arg = arg;\n    this.min = arg.min;\n    this.max = max;\n  }\n  visit(visitor) {\n    visitor.visitMin(this);\n  }\n}\nclass AstVariable extends AstNode {\n  constructor(index, min, max) {\n    super(\"var\");\n    this.index = index;\n    this.min = min;\n    this.max = max;\n  }\n  visit(visitor) {\n    visitor.visitVariable(this);\n  }\n}\nclass AstVariableDefinition extends AstNode {\n  constructor(variable, arg) {\n    super(\"definition\");\n    this.variable = variable;\n    this.arg = arg;\n  }\n  visit(visitor) {\n    visitor.visitVariableDefinition(this);\n  }\n}\nclass ExpressionBuilderVisitor {\n  constructor() {\n    this.parts = [];\n  }\n  visitArgument(arg) {\n    this.parts.push(\"Math.max(\", arg.min, \", Math.min(\", arg.max, \", src[srcOffset + \", arg.index, \"]))\");\n  }\n  visitVariable(variable) {\n    this.parts.push(\"v\", variable.index);\n  }\n  visitLiteral(literal) {\n    this.parts.push(literal.number);\n  }\n  visitBinaryOperation(operation) {\n    this.parts.push(\"(\");\n    operation.arg1.visit(this);\n    this.parts.push(\" \", operation.op, \" \");\n    operation.arg2.visit(this);\n    this.parts.push(\")\");\n  }\n  visitVariableDefinition(definition) {\n    this.parts.push(\"var \");\n    definition.variable.visit(this);\n    this.parts.push(\" = \");\n    definition.arg.visit(this);\n    this.parts.push(\";\");\n  }\n  visitMin(max) {\n    this.parts.push(\"Math.min(\");\n    max.arg.visit(this);\n    this.parts.push(\", \", max.max, \")\");\n  }\n  toString() {\n    return this.parts.join(\"\");\n  }\n}\nfunction buildAddOperation(num1, num2) {\n  if (num2.type === \"literal\" && num2.number === 0) {\n    return num1;\n  }\n  if (num1.type === \"literal\" && num1.number === 0) {\n    return num2;\n  }\n  if (num2.type === \"literal\" && num1.type === \"literal\") {\n    return new AstLiteral(num1.number + num2.number);\n  }\n  return new AstBinaryOperation(\"+\", num1, num2, num1.min + num2.min, num1.max + num2.max);\n}\nfunction buildMulOperation(num1, num2) {\n  if (num2.type === \"literal\") {\n    if (num2.number === 0) {\n      return new AstLiteral(0);\n    } else if (num2.number === 1) {\n      return num1;\n    } else if (num1.type === \"literal\") {\n      return new AstLiteral(num1.number * num2.number);\n    }\n  }\n  if (num1.type === \"literal\") {\n    if (num1.number === 0) {\n      return new AstLiteral(0);\n    } else if (num1.number === 1) {\n      return num2;\n    }\n  }\n  const min = Math.min(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);\n  const max = Math.max(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);\n  return new AstBinaryOperation(\"*\", num1, num2, min, max);\n}\nfunction buildSubOperation(num1, num2) {\n  if (num2.type === \"literal\") {\n    if (num2.number === 0) {\n      return num1;\n    } else if (num1.type === \"literal\") {\n      return new AstLiteral(num1.number - num2.number);\n    }\n  }\n  if (num2.type === \"binary\" && num2.op === \"-\" && num1.type === \"literal\" && num1.number === 1 && num2.arg1.type === \"literal\" && num2.arg1.number === 1) {\n    return num2.arg2;\n  }\n  return new AstBinaryOperation(\"-\", num1, num2, num1.min - num2.max, num1.max - num2.min);\n}\nfunction buildMinOperation(num1, max) {\n  if (num1.min >= max) {\n    return new AstLiteral(max);\n  } else if (num1.max <= max) {\n    return num1;\n  }\n  return new AstMin(num1, max);\n}\nclass PostScriptCompiler {\n  compile(code, domain, range) {\n    const stack = [];\n    const instructions = [];\n    const inputSize = domain.length >> 1,\n      outputSize = range.length >> 1;\n    let lastRegister = 0;\n    let n, j;\n    let num1, num2, ast1, ast2, tmpVar, item;\n    for (let i = 0; i < inputSize; i++) {\n      stack.push(new AstArgument(i, domain[i * 2], domain[i * 2 + 1]));\n    }\n    for (let i = 0, ii = code.length; i < ii; i++) {\n      item = code[i];\n      if (typeof item === \"number\") {\n        stack.push(new AstLiteral(item));\n        continue;\n      }\n      switch (item) {\n        case \"add\":\n          if (stack.length < 2) {\n            return null;\n          }\n          num2 = stack.pop();\n          num1 = stack.pop();\n          stack.push(buildAddOperation(num1, num2));\n          break;\n        case \"cvr\":\n          if (stack.length < 1) {\n            return null;\n          }\n          break;\n        case \"mul\":\n          if (stack.length < 2) {\n            return null;\n          }\n          num2 = stack.pop();\n          num1 = stack.pop();\n          stack.push(buildMulOperation(num1, num2));\n          break;\n        case \"sub\":\n          if (stack.length < 2) {\n            return null;\n          }\n          num2 = stack.pop();\n          num1 = stack.pop();\n          stack.push(buildSubOperation(num1, num2));\n          break;\n        case \"exch\":\n          if (stack.length < 2) {\n            return null;\n          }\n          ast1 = stack.pop();\n          ast2 = stack.pop();\n          stack.push(ast1, ast2);\n          break;\n        case \"pop\":\n          if (stack.length < 1) {\n            return null;\n          }\n          stack.pop();\n          break;\n        case \"index\":\n          if (stack.length < 1) {\n            return null;\n          }\n          num1 = stack.pop();\n          if (num1.type !== \"literal\") {\n            return null;\n          }\n          n = num1.number;\n          if (n < 0 || !Number.isInteger(n) || stack.length < n) {\n            return null;\n          }\n          ast1 = stack[stack.length - n - 1];\n          if (ast1.type === \"literal\" || ast1.type === \"var\") {\n            stack.push(ast1);\n            break;\n          }\n          tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);\n          stack[stack.length - n - 1] = tmpVar;\n          stack.push(tmpVar);\n          instructions.push(new AstVariableDefinition(tmpVar, ast1));\n          break;\n        case \"dup\":\n          if (stack.length < 1) {\n            return null;\n          }\n          if (typeof code[i + 1] === \"number\" && code[i + 2] === \"gt\" && code[i + 3] === i + 7 && code[i + 4] === \"jz\" && code[i + 5] === \"pop\" && code[i + 6] === code[i + 1]) {\n            num1 = stack.pop();\n            stack.push(buildMinOperation(num1, code[i + 1]));\n            i += 6;\n            break;\n          }\n          ast1 = stack.at(-1);\n          if (ast1.type === \"literal\" || ast1.type === \"var\") {\n            stack.push(ast1);\n            break;\n          }\n          tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);\n          stack[stack.length - 1] = tmpVar;\n          stack.push(tmpVar);\n          instructions.push(new AstVariableDefinition(tmpVar, ast1));\n          break;\n        case \"roll\":\n          if (stack.length < 2) {\n            return null;\n          }\n          num2 = stack.pop();\n          num1 = stack.pop();\n          if (num2.type !== \"literal\" || num1.type !== \"literal\") {\n            return null;\n          }\n          j = num2.number;\n          n = num1.number;\n          if (n <= 0 || !Number.isInteger(n) || !Number.isInteger(j) || stack.length < n) {\n            return null;\n          }\n          j = (j % n + n) % n;\n          if (j === 0) {\n            break;\n          }\n          stack.push(...stack.splice(stack.length - n, n - j));\n          break;\n        default:\n          return null;\n      }\n    }\n    if (stack.length !== outputSize) {\n      return null;\n    }\n    const result = [];\n    for (const instruction of instructions) {\n      const statementBuilder = new ExpressionBuilderVisitor();\n      instruction.visit(statementBuilder);\n      result.push(statementBuilder.toString());\n    }\n    for (let i = 0, ii = stack.length; i < ii; i++) {\n      const expr = stack[i],\n        statementBuilder = new ExpressionBuilderVisitor();\n      expr.visit(statementBuilder);\n      const min = range[i * 2],\n        max = range[i * 2 + 1];\n      const out = [statementBuilder.toString()];\n      if (min > expr.min) {\n        out.unshift(\"Math.max(\", min, \", \");\n        out.push(\")\");\n      }\n      if (max < expr.max) {\n        out.unshift(\"Math.min(\", max, \", \");\n        out.push(\")\");\n      }\n      out.unshift(\"dest[destOffset + \", i, \"] = \");\n      out.push(\";\");\n      result.push(out.join(\"\"));\n    }\n    return result.join(\"\\n\");\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/bidi.js\n\nconst baseTypes = [\"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"S\", \"B\", \"S\", \"WS\", \"B\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"B\", \"B\", \"B\", \"S\", \"WS\", \"ON\", \"ON\", \"ET\", \"ET\", \"ET\", \"ON\", \"ON\", \"ON\", \"ON\", \"ON\", \"ES\", \"CS\", \"ES\", \"CS\", \"CS\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"CS\", \"ON\", \"ON\", \"ON\", \"ON\", \"ON\", \"ON\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"ON\", \"ON\", \"ON\", \"ON\", \"ON\", \"ON\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"ON\", \"ON\", \"ON\", \"ON\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"B\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"CS\", \"ON\", \"ET\", \"ET\", \"ET\", \"ET\", \"ON\", \"ON\", \"ON\", \"ON\", \"L\", \"ON\", \"ON\", \"BN\", \"ON\", \"ON\", \"ET\", \"ET\", \"EN\", \"EN\", \"ON\", \"L\", \"ON\", \"ON\", \"ON\", \"EN\", \"L\", \"ON\", \"ON\", \"ON\", \"ON\", \"ON\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"ON\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"ON\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"];\nconst arabicTypes = [\"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"ON\", \"ON\", \"AL\", \"ET\", \"ET\", \"AL\", \"CS\", \"AL\", \"ON\", \"ON\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AL\", \"AL\", \"\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"ET\", \"AN\", \"AN\", \"AL\", \"AL\", \"AL\", \"NSM\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AN\", \"ON\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AL\", \"AL\", \"NSM\", \"NSM\", \"ON\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AL\", \"AL\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\"];\nfunction isOdd(i) {\n  return (i & 1) !== 0;\n}\nfunction isEven(i) {\n  return (i & 1) === 0;\n}\nfunction findUnequal(arr, start, value) {\n  let j, jj;\n  for (j = start, jj = arr.length; j < jj; ++j) {\n    if (arr[j] !== value) {\n      return j;\n    }\n  }\n  return j;\n}\nfunction setValues(arr, start, end, value) {\n  for (let j = start; j < end; ++j) {\n    arr[j] = value;\n  }\n}\nfunction reverseValues(arr, start, end) {\n  for (let i = start, j = end - 1; i < j; ++i, --j) {\n    const temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n}\nfunction createBidiText(str, isLTR, vertical = false) {\n  let dir = \"ltr\";\n  if (vertical) {\n    dir = \"ttb\";\n  } else if (!isLTR) {\n    dir = \"rtl\";\n  }\n  return {\n    str,\n    dir\n  };\n}\nconst chars = [];\nconst types = [];\nfunction bidi(str, startLevel = -1, vertical = false) {\n  let isLTR = true;\n  const strLength = str.length;\n  if (strLength === 0 || vertical) {\n    return createBidiText(str, isLTR, vertical);\n  }\n  chars.length = strLength;\n  types.length = strLength;\n  let numBidi = 0;\n  let i, ii;\n  for (i = 0; i < strLength; ++i) {\n    chars[i] = str.charAt(i);\n    const charCode = str.charCodeAt(i);\n    let charType = \"L\";\n    if (charCode <= 0x00ff) {\n      charType = baseTypes[charCode];\n    } else if (0x0590 <= charCode && charCode <= 0x05f4) {\n      charType = \"R\";\n    } else if (0x0600 <= charCode && charCode <= 0x06ff) {\n      charType = arabicTypes[charCode & 0xff];\n      if (!charType) {\n        warn(\"Bidi: invalid Unicode character \" + charCode.toString(16));\n      }\n    } else if (0x0700 <= charCode && charCode <= 0x08ac || 0xfb50 <= charCode && charCode <= 0xfdff || 0xfe70 <= charCode && charCode <= 0xfeff) {\n      charType = \"AL\";\n    }\n    if (charType === \"R\" || charType === \"AL\" || charType === \"AN\") {\n      numBidi++;\n    }\n    types[i] = charType;\n  }\n  if (numBidi === 0) {\n    isLTR = true;\n    return createBidiText(str, isLTR);\n  }\n  if (startLevel === -1) {\n    if (numBidi / strLength < 0.3 && strLength > 4) {\n      isLTR = true;\n      startLevel = 0;\n    } else {\n      isLTR = false;\n      startLevel = 1;\n    }\n  }\n  const levels = [];\n  for (i = 0; i < strLength; ++i) {\n    levels[i] = startLevel;\n  }\n  const e = isOdd(startLevel) ? \"R\" : \"L\";\n  const sor = e;\n  const eor = sor;\n  let lastType = sor;\n  for (i = 0; i < strLength; ++i) {\n    if (types[i] === \"NSM\") {\n      types[i] = lastType;\n    } else {\n      lastType = types[i];\n    }\n  }\n  lastType = sor;\n  let t;\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n    if (t === \"EN\") {\n      types[i] = lastType === \"AL\" ? \"AN\" : \"EN\";\n    } else if (t === \"R\" || t === \"L\" || t === \"AL\") {\n      lastType = t;\n    }\n  }\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n    if (t === \"AL\") {\n      types[i] = \"R\";\n    }\n  }\n  for (i = 1; i < strLength - 1; ++i) {\n    if (types[i] === \"ES\" && types[i - 1] === \"EN\" && types[i + 1] === \"EN\") {\n      types[i] = \"EN\";\n    }\n    if (types[i] === \"CS\" && (types[i - 1] === \"EN\" || types[i - 1] === \"AN\") && types[i + 1] === types[i - 1]) {\n      types[i] = types[i - 1];\n    }\n  }\n  for (i = 0; i < strLength; ++i) {\n    if (types[i] === \"EN\") {\n      for (let j = i - 1; j >= 0; --j) {\n        if (types[j] !== \"ET\") {\n          break;\n        }\n        types[j] = \"EN\";\n      }\n      for (let j = i + 1; j < strLength; ++j) {\n        if (types[j] !== \"ET\") {\n          break;\n        }\n        types[j] = \"EN\";\n      }\n    }\n  }\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n    if (t === \"WS\" || t === \"ES\" || t === \"ET\" || t === \"CS\") {\n      types[i] = \"ON\";\n    }\n  }\n  lastType = sor;\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n    if (t === \"EN\") {\n      types[i] = lastType === \"L\" ? \"L\" : \"EN\";\n    } else if (t === \"R\" || t === \"L\") {\n      lastType = t;\n    }\n  }\n  for (i = 0; i < strLength; ++i) {\n    if (types[i] === \"ON\") {\n      const end = findUnequal(types, i + 1, \"ON\");\n      let before = sor;\n      if (i > 0) {\n        before = types[i - 1];\n      }\n      let after = eor;\n      if (end + 1 < strLength) {\n        after = types[end + 1];\n      }\n      if (before !== \"L\") {\n        before = \"R\";\n      }\n      if (after !== \"L\") {\n        after = \"R\";\n      }\n      if (before === after) {\n        setValues(types, i, end, before);\n      }\n      i = end - 1;\n    }\n  }\n  for (i = 0; i < strLength; ++i) {\n    if (types[i] === \"ON\") {\n      types[i] = e;\n    }\n  }\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n    if (isEven(levels[i])) {\n      if (t === \"R\") {\n        levels[i] += 1;\n      } else if (t === \"AN\" || t === \"EN\") {\n        levels[i] += 2;\n      }\n    } else if (t === \"L\" || t === \"AN\" || t === \"EN\") {\n      levels[i] += 1;\n    }\n  }\n  let highestLevel = -1;\n  let lowestOddLevel = 99;\n  let level;\n  for (i = 0, ii = levels.length; i < ii; ++i) {\n    level = levels[i];\n    if (highestLevel < level) {\n      highestLevel = level;\n    }\n    if (lowestOddLevel > level && isOdd(level)) {\n      lowestOddLevel = level;\n    }\n  }\n  for (level = highestLevel; level >= lowestOddLevel; --level) {\n    let start = -1;\n    for (i = 0, ii = levels.length; i < ii; ++i) {\n      if (levels[i] < level) {\n        if (start >= 0) {\n          reverseValues(chars, start, i);\n          start = -1;\n        }\n      } else if (start < 0) {\n        start = i;\n      }\n    }\n    if (start >= 0) {\n      reverseValues(chars, start, levels.length);\n    }\n  }\n  for (i = 0, ii = chars.length; i < ii; ++i) {\n    const ch = chars[i];\n    if (ch === \"<\" || ch === \">\") {\n      chars[i] = \"\";\n    }\n  }\n  return createBidiText(chars.join(\"\"), isLTR);\n}\n\n;// CONCATENATED MODULE: ./src/core/font_substitutions.js\n\n\n\nconst NORMAL = {\n  style: \"normal\",\n  weight: \"normal\"\n};\nconst BOLD = {\n  style: \"normal\",\n  weight: \"bold\"\n};\nconst ITALIC = {\n  style: \"italic\",\n  weight: \"normal\"\n};\nconst BOLDITALIC = {\n  style: \"italic\",\n  weight: \"bold\"\n};\nconst substitutionMap = new Map([[\"Times-Roman\", {\n  local: [\"Times New Roman\", \"Times-Roman\", \"Times\", \"Liberation Serif\", \"Nimbus Roman\", \"Nimbus Roman L\", \"Tinos\", \"Thorndale\", \"TeX Gyre Termes\", \"FreeSerif\", \"Linux Libertine O\", \"Libertinus Serif\", \"DejaVu Serif\", \"Bitstream Vera Serif\", \"Ubuntu\"],\n  style: NORMAL,\n  ultimate: \"serif\"\n}], [\"Times-Bold\", {\n  alias: \"Times-Roman\",\n  style: BOLD,\n  ultimate: \"serif\"\n}], [\"Times-Italic\", {\n  alias: \"Times-Roman\",\n  style: ITALIC,\n  ultimate: \"serif\"\n}], [\"Times-BoldItalic\", {\n  alias: \"Times-Roman\",\n  style: BOLDITALIC,\n  ultimate: \"serif\"\n}], [\"Helvetica\", {\n  local: [\"Helvetica\", \"Helvetica Neue\", \"Arial\", \"Arial Nova\", \"Liberation Sans\", \"Arimo\", \"Nimbus Sans\", \"Nimbus Sans L\", \"A030\", \"TeX Gyre Heros\", \"FreeSans\", \"DejaVu Sans\", \"Albany\", \"Bitstream Vera Sans\", \"Arial Unicode MS\", \"Microsoft Sans Serif\", \"Apple Symbols\", \"Cantarell\"],\n  path: \"LiberationSans-Regular.ttf\",\n  style: NORMAL,\n  ultimate: \"sans-serif\"\n}], [\"Helvetica-Bold\", {\n  alias: \"Helvetica\",\n  path: \"LiberationSans-Bold.ttf\",\n  style: BOLD,\n  ultimate: \"sans-serif\"\n}], [\"Helvetica-Oblique\", {\n  alias: \"Helvetica\",\n  path: \"LiberationSans-Italic.ttf\",\n  style: ITALIC,\n  ultimate: \"sans-serif\"\n}], [\"Helvetica-BoldOblique\", {\n  alias: \"Helvetica\",\n  path: \"LiberationSans-BoldItalic.ttf\",\n  style: BOLDITALIC,\n  ultimate: \"sans-serif\"\n}], [\"Courier\", {\n  local: [\"Courier\", \"Courier New\", \"Liberation Mono\", \"Nimbus Mono\", \"Nimbus Mono L\", \"Cousine\", \"Cumberland\", \"TeX Gyre Cursor\", \"FreeMono\", \"Linux Libertine Mono O\", \"Libertinus Mono\"],\n  style: NORMAL,\n  ultimate: \"monospace\"\n}], [\"Courier-Bold\", {\n  alias: \"Courier\",\n  style: BOLD,\n  ultimate: \"monospace\"\n}], [\"Courier-Oblique\", {\n  alias: \"Courier\",\n  style: ITALIC,\n  ultimate: \"monospace\"\n}], [\"Courier-BoldOblique\", {\n  alias: \"Courier\",\n  style: BOLDITALIC,\n  ultimate: \"monospace\"\n}], [\"ArialBlack\", {\n  local: [\"Arial Black\"],\n  style: {\n    style: \"normal\",\n    weight: \"900\"\n  },\n  fallback: \"Helvetica-Bold\"\n}], [\"ArialBlack-Bold\", {\n  alias: \"ArialBlack\"\n}], [\"ArialBlack-Italic\", {\n  alias: \"ArialBlack\",\n  style: {\n    style: \"italic\",\n    weight: \"900\"\n  },\n  fallback: \"Helvetica-BoldOblique\"\n}], [\"ArialBlack-BoldItalic\", {\n  alias: \"ArialBlack-Italic\"\n}], [\"ArialNarrow\", {\n  local: [\"Arial Narrow\", \"Liberation Sans Narrow\", \"Helvetica Condensed\", \"Nimbus Sans Narrow\", \"TeX Gyre Heros Cn\"],\n  style: NORMAL,\n  fallback: \"Helvetica\"\n}], [\"ArialNarrow-Bold\", {\n  alias: \"ArialNarrow\",\n  style: BOLD,\n  fallback: \"Helvetica-Bold\"\n}], [\"ArialNarrow-Italic\", {\n  alias: \"ArialNarrow\",\n  style: ITALIC,\n  fallback: \"Helvetica-Oblique\"\n}], [\"ArialNarrow-BoldItalic\", {\n  alias: \"ArialNarrow\",\n  style: BOLDITALIC,\n  fallback: \"Helvetica-BoldOblique\"\n}], [\"Calibri\", {\n  local: [\"Calibri\", \"Carlito\"],\n  style: NORMAL,\n  fallback: \"Helvetica\"\n}], [\"Calibri-Bold\", {\n  alias: \"Calibri\",\n  style: BOLD,\n  fallback: \"Helvetica-Bold\"\n}], [\"Calibri-Italic\", {\n  alias: \"Calibri\",\n  style: ITALIC,\n  fallback: \"Helvetica-Oblique\"\n}], [\"Calibri-BoldItalic\", {\n  alias: \"Calibri\",\n  style: BOLDITALIC,\n  fallback: \"Helvetica-BoldOblique\"\n}], [\"Wingdings\", {\n  local: [\"Wingdings\", \"URW Dingbats\"],\n  style: NORMAL\n}], [\"Wingdings-Regular\", {\n  alias: \"Wingdings\"\n}], [\"Wingdings-Bold\", {\n  alias: \"Wingdings\"\n}]]);\nconst fontAliases = new Map([[\"Arial-Black\", \"ArialBlack\"]]);\nfunction getStyleToAppend(style) {\n  switch (style) {\n    case BOLD:\n      return \"Bold\";\n    case ITALIC:\n      return \"Italic\";\n    case BOLDITALIC:\n      return \"Bold Italic\";\n    default:\n      if (style?.weight === \"bold\") {\n        return \"Bold\";\n      }\n      if (style?.style === \"italic\") {\n        return \"Italic\";\n      }\n  }\n  return \"\";\n}\nfunction getFamilyName(str) {\n  const keywords = new Set([\"thin\", \"extralight\", \"ultralight\", \"demilight\", \"semilight\", \"light\", \"book\", \"regular\", \"normal\", \"medium\", \"demibold\", \"semibold\", \"bold\", \"extrabold\", \"ultrabold\", \"black\", \"heavy\", \"extrablack\", \"ultrablack\", \"roman\", \"italic\", \"oblique\", \"ultracondensed\", \"extracondensed\", \"condensed\", \"semicondensed\", \"normal\", \"semiexpanded\", \"expanded\", \"extraexpanded\", \"ultraexpanded\", \"bolditalic\"]);\n  return str.split(/[- ,+]+/g).filter(tok => !keywords.has(tok.toLowerCase())).join(\" \");\n}\nfunction generateFont({\n  alias,\n  local,\n  path,\n  fallback,\n  style,\n  ultimate\n}, src, localFontPath, useFallback = true, usePath = true, append = \"\") {\n  const result = {\n    style: null,\n    ultimate: null\n  };\n  if (local) {\n    const extra = append ? ` ${append}` : \"\";\n    for (const name of local) {\n      src.push(`local(${name}${extra})`);\n    }\n  }\n  if (alias) {\n    const substitution = substitutionMap.get(alias);\n    const aliasAppend = append || getStyleToAppend(style);\n    Object.assign(result, generateFont(substitution, src, localFontPath, useFallback && !fallback, usePath && !path, aliasAppend));\n  }\n  if (style) {\n    result.style = style;\n  }\n  if (ultimate) {\n    result.ultimate = ultimate;\n  }\n  if (useFallback && fallback) {\n    const fallbackInfo = substitutionMap.get(fallback);\n    const {\n      ultimate: fallbackUltimate\n    } = generateFont(fallbackInfo, src, localFontPath, useFallback, usePath && !path, append);\n    result.ultimate ||= fallbackUltimate;\n  }\n  if (usePath && path && localFontPath) {\n    src.push(`url(${localFontPath}${path})`);\n  }\n  return result;\n}\nfunction getFontSubstitution(systemFontCache, idFactory, localFontPath, baseFontName, standardFontName, type) {\n  if (baseFontName.startsWith(\"InvalidPDFjsFont_\")) {\n    return null;\n  }\n  if ((type === \"TrueType\" || type === \"Type1\") && /^[A-Z]{6}\\+/.test(baseFontName)) {\n    baseFontName = baseFontName.slice(7);\n  }\n  baseFontName = normalizeFontName(baseFontName);\n  const key = baseFontName;\n  let substitutionInfo = systemFontCache.get(key);\n  if (substitutionInfo) {\n    return substitutionInfo;\n  }\n  let substitution = substitutionMap.get(baseFontName);\n  if (!substitution) {\n    for (const [alias, subst] of fontAliases) {\n      if (baseFontName.startsWith(alias)) {\n        baseFontName = `${subst}${baseFontName.substring(alias.length)}`;\n        substitution = substitutionMap.get(baseFontName);\n        break;\n      }\n    }\n  }\n  let mustAddBaseFont = false;\n  if (!substitution) {\n    substitution = substitutionMap.get(standardFontName);\n    mustAddBaseFont = true;\n  }\n  const loadedName = `${idFactory.getDocId()}_s${idFactory.createFontId()}`;\n  if (!substitution) {\n    if (!validateFontName(baseFontName)) {\n      warn(`Cannot substitute the font because of its name: ${baseFontName}`);\n      systemFontCache.set(key, null);\n      return null;\n    }\n    const bold = /bold/gi.test(baseFontName);\n    const italic = /oblique|italic/gi.test(baseFontName);\n    const style = bold && italic && BOLDITALIC || bold && BOLD || italic && ITALIC || NORMAL;\n    substitutionInfo = {\n      css: `\"${getFamilyName(baseFontName)}\",${loadedName}`,\n      guessFallback: true,\n      loadedName,\n      baseFontName,\n      src: `local(${baseFontName})`,\n      style\n    };\n    systemFontCache.set(key, substitutionInfo);\n    return substitutionInfo;\n  }\n  const src = [];\n  if (mustAddBaseFont && validateFontName(baseFontName)) {\n    src.push(`local(${baseFontName})`);\n  }\n  const {\n    style,\n    ultimate\n  } = generateFont(substitution, src, localFontPath);\n  const guessFallback = ultimate === null;\n  const fallback = guessFallback ? \"\" : `,${ultimate}`;\n  substitutionInfo = {\n    css: `\"${getFamilyName(baseFontName)}\",${loadedName}${fallback}`,\n    guessFallback,\n    loadedName,\n    baseFontName,\n    src: src.join(\",\"),\n    style\n  };\n  systemFontCache.set(key, substitutionInfo);\n  return substitutionInfo;\n}\n\n;// CONCATENATED MODULE: ./src/core/image_resizer.js\n\nconst MIN_IMAGE_DIM = 2048;\nconst MAX_IMAGE_DIM = 65537;\nconst MAX_ERROR = 128;\nclass ImageResizer {\n  constructor(imgData, isMask) {\n    this._imgData = imgData;\n    this._isMask = isMask;\n  }\n  static needsToBeResized(width, height) {\n    if (width <= this._goodSquareLength && height <= this._goodSquareLength) {\n      return false;\n    }\n    const {\n      MAX_DIM\n    } = this;\n    if (width > MAX_DIM || height > MAX_DIM) {\n      return true;\n    }\n    const area = width * height;\n    if (this._hasMaxArea) {\n      return area > this.MAX_AREA;\n    }\n    if (area < this._goodSquareLength ** 2) {\n      return false;\n    }\n    if (this._areGoodDims(width, height)) {\n      this._goodSquareLength = Math.max(this._goodSquareLength, Math.floor(Math.sqrt(width * height)));\n      return false;\n    }\n    this._goodSquareLength = this._guessMax(this._goodSquareLength, MAX_DIM, MAX_ERROR, 0);\n    const maxArea = this.MAX_AREA = this._goodSquareLength ** 2;\n    return area > maxArea;\n  }\n  static get MAX_DIM() {\n    return shadow(this, \"MAX_DIM\", this._guessMax(MIN_IMAGE_DIM, MAX_IMAGE_DIM, 0, 1));\n  }\n  static get MAX_AREA() {\n    this._hasMaxArea = true;\n    return shadow(this, \"MAX_AREA\", this._guessMax(ImageResizer._goodSquareLength, this.MAX_DIM, MAX_ERROR, 0) ** 2);\n  }\n  static set MAX_AREA(area) {\n    if (area >= 0) {\n      this._hasMaxArea = true;\n      shadow(this, \"MAX_AREA\", area);\n    }\n  }\n  static setMaxArea(area) {\n    if (!this._hasMaxArea) {\n      this.MAX_AREA = area >> 2;\n    }\n  }\n  static _areGoodDims(width, height) {\n    try {\n      const canvas = new OffscreenCanvas(width, height);\n      const ctx = canvas.getContext(\"2d\");\n      ctx.fillRect(0, 0, 1, 1);\n      const opacity = ctx.getImageData(0, 0, 1, 1).data[3];\n      canvas.width = canvas.height = 1;\n      return opacity !== 0;\n    } catch {\n      return false;\n    }\n  }\n  static _guessMax(start, end, tolerance, defaultHeight) {\n    while (start + tolerance + 1 < end) {\n      const middle = Math.floor((start + end) / 2);\n      const height = defaultHeight || middle;\n      if (this._areGoodDims(middle, height)) {\n        start = middle;\n      } else {\n        end = middle;\n      }\n    }\n    return start;\n  }\n  static async createImage(imgData, isMask = false) {\n    return new ImageResizer(imgData, isMask)._createImage();\n  }\n  async _createImage() {\n    const data = this._encodeBMP();\n    const blob = new Blob([data.buffer], {\n      type: \"image/bmp\"\n    });\n    const bitmapPromise = createImageBitmap(blob);\n    const {\n      MAX_AREA,\n      MAX_DIM\n    } = ImageResizer;\n    const {\n      _imgData: imgData\n    } = this;\n    const {\n      width,\n      height\n    } = imgData;\n    const minFactor = Math.max(width / MAX_DIM, height / MAX_DIM, Math.sqrt(width * height / MAX_AREA));\n    const firstFactor = Math.max(minFactor, 2);\n    const factor = Math.round(10 * (minFactor + 1.25)) / 10 / firstFactor;\n    const N = Math.floor(Math.log2(factor));\n    const steps = new Array(N + 2).fill(2);\n    steps[0] = firstFactor;\n    steps.splice(-1, 1, factor / (1 << N));\n    let newWidth = width;\n    let newHeight = height;\n    let bitmap = await bitmapPromise;\n    for (const step of steps) {\n      const prevWidth = newWidth;\n      const prevHeight = newHeight;\n      newWidth = Math.floor(newWidth / step) - 1;\n      newHeight = Math.floor(newHeight / step) - 1;\n      const canvas = new OffscreenCanvas(newWidth, newHeight);\n      const ctx = canvas.getContext(\"2d\");\n      ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n      bitmap = canvas.transferToImageBitmap();\n    }\n    imgData.data = null;\n    imgData.bitmap = bitmap;\n    imgData.width = newWidth;\n    imgData.height = newHeight;\n    return imgData;\n  }\n  _encodeBMP() {\n    const {\n      width,\n      height,\n      kind\n    } = this._imgData;\n    let data = this._imgData.data;\n    let bitPerPixel;\n    let colorTable = new Uint8Array(0);\n    let maskTable = colorTable;\n    let compression = 0;\n    switch (kind) {\n      case ImageKind.GRAYSCALE_1BPP:\n        {\n          bitPerPixel = 1;\n          colorTable = new Uint8Array(this._isMask ? [255, 255, 255, 255, 0, 0, 0, 0] : [0, 0, 0, 0, 255, 255, 255, 255]);\n          const rowLen = width + 7 >> 3;\n          const rowSize = rowLen + 3 & -4;\n          if (rowLen !== rowSize) {\n            const newData = new Uint8Array(rowSize * height);\n            let k = 0;\n            for (let i = 0, ii = height * rowLen; i < ii; i += rowLen, k += rowSize) {\n              newData.set(data.subarray(i, i + rowLen), k);\n            }\n            data = newData;\n          }\n          break;\n        }\n      case ImageKind.RGB_24BPP:\n        {\n          bitPerPixel = 24;\n          if (width & 3) {\n            const rowLen = 3 * width;\n            const rowSize = rowLen + 3 & -4;\n            const extraLen = rowSize - rowLen;\n            const newData = new Uint8Array(rowSize * height);\n            let k = 0;\n            for (let i = 0, ii = height * rowLen; i < ii; i += rowLen) {\n              const row = data.subarray(i, i + rowLen);\n              for (let j = 0; j < rowLen; j += 3) {\n                newData[k++] = row[j + 2];\n                newData[k++] = row[j + 1];\n                newData[k++] = row[j];\n              }\n              k += extraLen;\n            }\n            data = newData;\n          } else {\n            for (let i = 0, ii = data.length; i < ii; i += 3) {\n              const tmp = data[i];\n              data[i] = data[i + 2];\n              data[i + 2] = tmp;\n            }\n          }\n          break;\n        }\n      case ImageKind.RGBA_32BPP:\n        bitPerPixel = 32;\n        compression = 3;\n        maskTable = new Uint8Array(4 + 4 + 4 + 4 + 52);\n        const view = new DataView(maskTable.buffer);\n        if (FeatureTest.isLittleEndian) {\n          view.setUint32(0, 0x000000ff, true);\n          view.setUint32(4, 0x0000ff00, true);\n          view.setUint32(8, 0x00ff0000, true);\n          view.setUint32(12, 0xff000000, true);\n        } else {\n          view.setUint32(0, 0xff000000, true);\n          view.setUint32(4, 0x00ff0000, true);\n          view.setUint32(8, 0x0000ff00, true);\n          view.setUint32(12, 0x000000ff, true);\n        }\n        break;\n      default:\n        throw new Error(\"invalid format\");\n    }\n    let i = 0;\n    const headerLength = 40 + maskTable.length;\n    const fileLength = 14 + headerLength + colorTable.length + data.length;\n    const bmpData = new Uint8Array(fileLength);\n    const view = new DataView(bmpData.buffer);\n    view.setUint16(i, 0x4d42, true);\n    i += 2;\n    view.setUint32(i, fileLength, true);\n    i += 4;\n    view.setUint32(i, 0, true);\n    i += 4;\n    view.setUint32(i, 14 + headerLength + colorTable.length, true);\n    i += 4;\n    view.setUint32(i, headerLength, true);\n    i += 4;\n    view.setInt32(i, width, true);\n    i += 4;\n    view.setInt32(i, -height, true);\n    i += 4;\n    view.setUint16(i, 1, true);\n    i += 2;\n    view.setUint16(i, bitPerPixel, true);\n    i += 2;\n    view.setUint32(i, compression, true);\n    i += 4;\n    view.setUint32(i, 0, true);\n    i += 4;\n    view.setInt32(i, 0, true);\n    i += 4;\n    view.setInt32(i, 0, true);\n    i += 4;\n    view.setUint32(i, colorTable.length / 4, true);\n    i += 4;\n    view.setUint32(i, 0, true);\n    i += 4;\n    bmpData.set(maskTable, i);\n    i += maskTable.length;\n    bmpData.set(colorTable, i);\n    i += colorTable.length;\n    bmpData.set(data, i);\n    return bmpData;\n  }\n}\nImageResizer._goodSquareLength = MIN_IMAGE_DIM;\n\n;// CONCATENATED MODULE: ./src/shared/murmurhash3.js\nconst SEED = 0xc3d2e1f0;\nconst MASK_HIGH = 0xffff0000;\nconst MASK_LOW = 0xffff;\nclass MurmurHash3_64 {\n  constructor(seed) {\n    this.h1 = seed ? seed & 0xffffffff : SEED;\n    this.h2 = seed ? seed & 0xffffffff : SEED;\n  }\n  update(input) {\n    let data, length;\n    if (typeof input === \"string\") {\n      data = new Uint8Array(input.length * 2);\n      length = 0;\n      for (let i = 0, ii = input.length; i < ii; i++) {\n        const code = input.charCodeAt(i);\n        if (code <= 0xff) {\n          data[length++] = code;\n        } else {\n          data[length++] = code >>> 8;\n          data[length++] = code & 0xff;\n        }\n      }\n    } else if (ArrayBuffer.isView(input)) {\n      data = input.slice();\n      length = data.byteLength;\n    } else {\n      throw new Error(\"Invalid data format, must be a string or TypedArray.\");\n    }\n    const blockCounts = length >> 2;\n    const tailLength = length - blockCounts * 4;\n    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);\n    let k1 = 0,\n      k2 = 0;\n    let h1 = this.h1,\n      h2 = this.h2;\n    const C1 = 0xcc9e2d51,\n      C2 = 0x1b873593;\n    const C1_LOW = C1 & MASK_LOW,\n      C2_LOW = C2 & MASK_LOW;\n    for (let i = 0; i < blockCounts; i++) {\n      if (i & 1) {\n        k1 = dataUint32[i];\n        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n        k1 = k1 << 15 | k1 >>> 17;\n        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n        h1 ^= k1;\n        h1 = h1 << 13 | h1 >>> 19;\n        h1 = h1 * 5 + 0xe6546b64;\n      } else {\n        k2 = dataUint32[i];\n        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;\n        k2 = k2 << 15 | k2 >>> 17;\n        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;\n        h2 ^= k2;\n        h2 = h2 << 13 | h2 >>> 19;\n        h2 = h2 * 5 + 0xe6546b64;\n      }\n    }\n    k1 = 0;\n    switch (tailLength) {\n      case 3:\n        k1 ^= data[blockCounts * 4 + 2] << 16;\n      case 2:\n        k1 ^= data[blockCounts * 4 + 1] << 8;\n      case 1:\n        k1 ^= data[blockCounts * 4];\n        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n        k1 = k1 << 15 | k1 >>> 17;\n        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n        if (blockCounts & 1) {\n          h1 ^= k1;\n        } else {\n          h2 ^= k1;\n        }\n    }\n    this.h1 = h1;\n    this.h2 = h2;\n  }\n  hexdigest() {\n    let h1 = this.h1,\n      h2 = this.h2;\n    h1 ^= h2 >>> 1;\n    h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;\n    h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;\n    h1 ^= h2 >>> 1;\n    h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;\n    h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;\n    h1 ^= h2 >>> 1;\n    return (h1 >>> 0).toString(16).padStart(8, \"0\") + (h2 >>> 0).toString(16).padStart(8, \"0\");\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/operator_list.js\n\nfunction addState(parentState, pattern, checkFn, iterateFn, processFn) {\n  let state = parentState;\n  for (let i = 0, ii = pattern.length - 1; i < ii; i++) {\n    const item = pattern[i];\n    state = state[item] ||= [];\n  }\n  state[pattern.at(-1)] = {\n    checkFn,\n    iterateFn,\n    processFn\n  };\n}\nconst InitialState = [];\naddState(InitialState, [OPS.save, OPS.transform, OPS.paintInlineImageXObject, OPS.restore], null, function iterateInlineImageGroup(context, i) {\n  const fnArray = context.fnArray;\n  const iFirstSave = context.iCurr - 3;\n  const pos = (i - iFirstSave) % 4;\n  switch (pos) {\n    case 0:\n      return fnArray[i] === OPS.save;\n    case 1:\n      return fnArray[i] === OPS.transform;\n    case 2:\n      return fnArray[i] === OPS.paintInlineImageXObject;\n    case 3:\n      return fnArray[i] === OPS.restore;\n  }\n  throw new Error(`iterateInlineImageGroup - invalid pos: ${pos}`);\n}, function foundInlineImageGroup(context, i) {\n  const MIN_IMAGES_IN_INLINE_IMAGES_BLOCK = 10;\n  const MAX_IMAGES_IN_INLINE_IMAGES_BLOCK = 200;\n  const MAX_WIDTH = 1000;\n  const IMAGE_PADDING = 1;\n  const fnArray = context.fnArray,\n    argsArray = context.argsArray;\n  const curr = context.iCurr;\n  const iFirstSave = curr - 3;\n  const iFirstTransform = curr - 2;\n  const iFirstPIIXO = curr - 1;\n  const count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_INLINE_IMAGES_BLOCK);\n  if (count < MIN_IMAGES_IN_INLINE_IMAGES_BLOCK) {\n    return i - (i - iFirstSave) % 4;\n  }\n  let maxX = 0;\n  const map = [];\n  let maxLineHeight = 0;\n  let currentX = IMAGE_PADDING,\n    currentY = IMAGE_PADDING;\n  for (let q = 0; q < count; q++) {\n    const transform = argsArray[iFirstTransform + (q << 2)];\n    const img = argsArray[iFirstPIIXO + (q << 2)][0];\n    if (currentX + img.width > MAX_WIDTH) {\n      maxX = Math.max(maxX, currentX);\n      currentY += maxLineHeight + 2 * IMAGE_PADDING;\n      currentX = 0;\n      maxLineHeight = 0;\n    }\n    map.push({\n      transform,\n      x: currentX,\n      y: currentY,\n      w: img.width,\n      h: img.height\n    });\n    currentX += img.width + 2 * IMAGE_PADDING;\n    maxLineHeight = Math.max(maxLineHeight, img.height);\n  }\n  const imgWidth = Math.max(maxX, currentX) + IMAGE_PADDING;\n  const imgHeight = currentY + maxLineHeight + IMAGE_PADDING;\n  const imgData = new Uint8Array(imgWidth * imgHeight * 4);\n  const imgRowSize = imgWidth << 2;\n  for (let q = 0; q < count; q++) {\n    const data = argsArray[iFirstPIIXO + (q << 2)][0].data;\n    const rowSize = map[q].w << 2;\n    let dataOffset = 0;\n    let offset = map[q].x + map[q].y * imgWidth << 2;\n    imgData.set(data.subarray(0, rowSize), offset - imgRowSize);\n    for (let k = 0, kk = map[q].h; k < kk; k++) {\n      imgData.set(data.subarray(dataOffset, dataOffset + rowSize), offset);\n      dataOffset += rowSize;\n      offset += imgRowSize;\n    }\n    imgData.set(data.subarray(dataOffset - rowSize, dataOffset), offset);\n    while (offset >= 0) {\n      data[offset - 4] = data[offset];\n      data[offset - 3] = data[offset + 1];\n      data[offset - 2] = data[offset + 2];\n      data[offset - 1] = data[offset + 3];\n      data[offset + rowSize] = data[offset + rowSize - 4];\n      data[offset + rowSize + 1] = data[offset + rowSize - 3];\n      data[offset + rowSize + 2] = data[offset + rowSize - 2];\n      data[offset + rowSize + 3] = data[offset + rowSize - 1];\n      offset -= imgRowSize;\n    }\n  }\n  const img = {\n    width: imgWidth,\n    height: imgHeight\n  };\n  if (context.isOffscreenCanvasSupported) {\n    const canvas = new OffscreenCanvas(imgWidth, imgHeight);\n    const ctx = canvas.getContext(\"2d\");\n    ctx.putImageData(new ImageData(new Uint8ClampedArray(imgData.buffer), imgWidth, imgHeight), 0, 0);\n    img.bitmap = canvas.transferToImageBitmap();\n    img.data = null;\n  } else {\n    img.kind = ImageKind.RGBA_32BPP;\n    img.data = imgData;\n  }\n  fnArray.splice(iFirstSave, count * 4, OPS.paintInlineImageXObjectGroup);\n  argsArray.splice(iFirstSave, count * 4, [img, map]);\n  return iFirstSave + 1;\n});\naddState(InitialState, [OPS.save, OPS.transform, OPS.paintImageMaskXObject, OPS.restore], null, function iterateImageMaskGroup(context, i) {\n  const fnArray = context.fnArray;\n  const iFirstSave = context.iCurr - 3;\n  const pos = (i - iFirstSave) % 4;\n  switch (pos) {\n    case 0:\n      return fnArray[i] === OPS.save;\n    case 1:\n      return fnArray[i] === OPS.transform;\n    case 2:\n      return fnArray[i] === OPS.paintImageMaskXObject;\n    case 3:\n      return fnArray[i] === OPS.restore;\n  }\n  throw new Error(`iterateImageMaskGroup - invalid pos: ${pos}`);\n}, function foundImageMaskGroup(context, i) {\n  const MIN_IMAGES_IN_MASKS_BLOCK = 10;\n  const MAX_IMAGES_IN_MASKS_BLOCK = 100;\n  const MAX_SAME_IMAGES_IN_MASKS_BLOCK = 1000;\n  const fnArray = context.fnArray,\n    argsArray = context.argsArray;\n  const curr = context.iCurr;\n  const iFirstSave = curr - 3;\n  const iFirstTransform = curr - 2;\n  const iFirstPIMXO = curr - 1;\n  let count = Math.floor((i - iFirstSave) / 4);\n  if (count < MIN_IMAGES_IN_MASKS_BLOCK) {\n    return i - (i - iFirstSave) % 4;\n  }\n  let isSameImage = false;\n  let iTransform, transformArgs;\n  const firstPIMXOArg0 = argsArray[iFirstPIMXO][0];\n  const firstTransformArg0 = argsArray[iFirstTransform][0],\n    firstTransformArg1 = argsArray[iFirstTransform][1],\n    firstTransformArg2 = argsArray[iFirstTransform][2],\n    firstTransformArg3 = argsArray[iFirstTransform][3];\n  if (firstTransformArg1 === firstTransformArg2) {\n    isSameImage = true;\n    iTransform = iFirstTransform + 4;\n    let iPIMXO = iFirstPIMXO + 4;\n    for (let q = 1; q < count; q++, iTransform += 4, iPIMXO += 4) {\n      transformArgs = argsArray[iTransform];\n      if (argsArray[iPIMXO][0] !== firstPIMXOArg0 || transformArgs[0] !== firstTransformArg0 || transformArgs[1] !== firstTransformArg1 || transformArgs[2] !== firstTransformArg2 || transformArgs[3] !== firstTransformArg3) {\n        if (q < MIN_IMAGES_IN_MASKS_BLOCK) {\n          isSameImage = false;\n        } else {\n          count = q;\n        }\n        break;\n      }\n    }\n  }\n  if (isSameImage) {\n    count = Math.min(count, MAX_SAME_IMAGES_IN_MASKS_BLOCK);\n    const positions = new Float32Array(count * 2);\n    iTransform = iFirstTransform;\n    for (let q = 0; q < count; q++, iTransform += 4) {\n      transformArgs = argsArray[iTransform];\n      positions[q << 1] = transformArgs[4];\n      positions[(q << 1) + 1] = transformArgs[5];\n    }\n    fnArray.splice(iFirstSave, count * 4, OPS.paintImageMaskXObjectRepeat);\n    argsArray.splice(iFirstSave, count * 4, [firstPIMXOArg0, firstTransformArg0, firstTransformArg1, firstTransformArg2, firstTransformArg3, positions]);\n  } else {\n    count = Math.min(count, MAX_IMAGES_IN_MASKS_BLOCK);\n    const images = [];\n    for (let q = 0; q < count; q++) {\n      transformArgs = argsArray[iFirstTransform + (q << 2)];\n      const maskParams = argsArray[iFirstPIMXO + (q << 2)][0];\n      images.push({\n        data: maskParams.data,\n        width: maskParams.width,\n        height: maskParams.height,\n        interpolate: maskParams.interpolate,\n        count: maskParams.count,\n        transform: transformArgs\n      });\n    }\n    fnArray.splice(iFirstSave, count * 4, OPS.paintImageMaskXObjectGroup);\n    argsArray.splice(iFirstSave, count * 4, [images]);\n  }\n  return iFirstSave + 1;\n});\naddState(InitialState, [OPS.save, OPS.transform, OPS.paintImageXObject, OPS.restore], function (context) {\n  const argsArray = context.argsArray;\n  const iFirstTransform = context.iCurr - 2;\n  return argsArray[iFirstTransform][1] === 0 && argsArray[iFirstTransform][2] === 0;\n}, function iterateImageGroup(context, i) {\n  const fnArray = context.fnArray,\n    argsArray = context.argsArray;\n  const iFirstSave = context.iCurr - 3;\n  const pos = (i - iFirstSave) % 4;\n  switch (pos) {\n    case 0:\n      return fnArray[i] === OPS.save;\n    case 1:\n      if (fnArray[i] !== OPS.transform) {\n        return false;\n      }\n      const iFirstTransform = context.iCurr - 2;\n      const firstTransformArg0 = argsArray[iFirstTransform][0];\n      const firstTransformArg3 = argsArray[iFirstTransform][3];\n      if (argsArray[i][0] !== firstTransformArg0 || argsArray[i][1] !== 0 || argsArray[i][2] !== 0 || argsArray[i][3] !== firstTransformArg3) {\n        return false;\n      }\n      return true;\n    case 2:\n      if (fnArray[i] !== OPS.paintImageXObject) {\n        return false;\n      }\n      const iFirstPIXO = context.iCurr - 1;\n      const firstPIXOArg0 = argsArray[iFirstPIXO][0];\n      if (argsArray[i][0] !== firstPIXOArg0) {\n        return false;\n      }\n      return true;\n    case 3:\n      return fnArray[i] === OPS.restore;\n  }\n  throw new Error(`iterateImageGroup - invalid pos: ${pos}`);\n}, function (context, i) {\n  const MIN_IMAGES_IN_BLOCK = 3;\n  const MAX_IMAGES_IN_BLOCK = 1000;\n  const fnArray = context.fnArray,\n    argsArray = context.argsArray;\n  const curr = context.iCurr;\n  const iFirstSave = curr - 3;\n  const iFirstTransform = curr - 2;\n  const iFirstPIXO = curr - 1;\n  const firstPIXOArg0 = argsArray[iFirstPIXO][0];\n  const firstTransformArg0 = argsArray[iFirstTransform][0];\n  const firstTransformArg3 = argsArray[iFirstTransform][3];\n  const count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_BLOCK);\n  if (count < MIN_IMAGES_IN_BLOCK) {\n    return i - (i - iFirstSave) % 4;\n  }\n  const positions = new Float32Array(count * 2);\n  let iTransform = iFirstTransform;\n  for (let q = 0; q < count; q++, iTransform += 4) {\n    const transformArgs = argsArray[iTransform];\n    positions[q << 1] = transformArgs[4];\n    positions[(q << 1) + 1] = transformArgs[5];\n  }\n  const args = [firstPIXOArg0, firstTransformArg0, firstTransformArg3, positions];\n  fnArray.splice(iFirstSave, count * 4, OPS.paintImageXObjectRepeat);\n  argsArray.splice(iFirstSave, count * 4, args);\n  return iFirstSave + 1;\n});\naddState(InitialState, [OPS.beginText, OPS.setFont, OPS.setTextMatrix, OPS.showText, OPS.endText], null, function iterateShowTextGroup(context, i) {\n  const fnArray = context.fnArray,\n    argsArray = context.argsArray;\n  const iFirstSave = context.iCurr - 4;\n  const pos = (i - iFirstSave) % 5;\n  switch (pos) {\n    case 0:\n      return fnArray[i] === OPS.beginText;\n    case 1:\n      return fnArray[i] === OPS.setFont;\n    case 2:\n      return fnArray[i] === OPS.setTextMatrix;\n    case 3:\n      if (fnArray[i] !== OPS.showText) {\n        return false;\n      }\n      const iFirstSetFont = context.iCurr - 3;\n      const firstSetFontArg0 = argsArray[iFirstSetFont][0];\n      const firstSetFontArg1 = argsArray[iFirstSetFont][1];\n      if (argsArray[i][0] !== firstSetFontArg0 || argsArray[i][1] !== firstSetFontArg1) {\n        return false;\n      }\n      return true;\n    case 4:\n      return fnArray[i] === OPS.endText;\n  }\n  throw new Error(`iterateShowTextGroup - invalid pos: ${pos}`);\n}, function (context, i) {\n  const MIN_CHARS_IN_BLOCK = 3;\n  const MAX_CHARS_IN_BLOCK = 1000;\n  const fnArray = context.fnArray,\n    argsArray = context.argsArray;\n  const curr = context.iCurr;\n  const iFirstBeginText = curr - 4;\n  const iFirstSetFont = curr - 3;\n  const iFirstSetTextMatrix = curr - 2;\n  const iFirstShowText = curr - 1;\n  const iFirstEndText = curr;\n  const firstSetFontArg0 = argsArray[iFirstSetFont][0];\n  const firstSetFontArg1 = argsArray[iFirstSetFont][1];\n  let count = Math.min(Math.floor((i - iFirstBeginText) / 5), MAX_CHARS_IN_BLOCK);\n  if (count < MIN_CHARS_IN_BLOCK) {\n    return i - (i - iFirstBeginText) % 5;\n  }\n  let iFirst = iFirstBeginText;\n  if (iFirstBeginText >= 4 && fnArray[iFirstBeginText - 4] === fnArray[iFirstSetFont] && fnArray[iFirstBeginText - 3] === fnArray[iFirstSetTextMatrix] && fnArray[iFirstBeginText - 2] === fnArray[iFirstShowText] && fnArray[iFirstBeginText - 1] === fnArray[iFirstEndText] && argsArray[iFirstBeginText - 4][0] === firstSetFontArg0 && argsArray[iFirstBeginText - 4][1] === firstSetFontArg1) {\n    count++;\n    iFirst -= 5;\n  }\n  let iEndText = iFirst + 4;\n  for (let q = 1; q < count; q++) {\n    fnArray.splice(iEndText, 3);\n    argsArray.splice(iEndText, 3);\n    iEndText += 2;\n  }\n  return iEndText + 1;\n});\nclass NullOptimizer {\n  constructor(queue) {\n    this.queue = queue;\n  }\n  _optimize() {}\n  push(fn, args) {\n    this.queue.fnArray.push(fn);\n    this.queue.argsArray.push(args);\n    this._optimize();\n  }\n  flush() {}\n  reset() {}\n}\nclass QueueOptimizer extends NullOptimizer {\n  constructor(queue) {\n    super(queue);\n    this.state = null;\n    this.context = {\n      iCurr: 0,\n      fnArray: queue.fnArray,\n      argsArray: queue.argsArray,\n      isOffscreenCanvasSupported: false\n    };\n    this.match = null;\n    this.lastProcessed = 0;\n  }\n  set isOffscreenCanvasSupported(value) {\n    this.context.isOffscreenCanvasSupported = value;\n  }\n  _optimize() {\n    const fnArray = this.queue.fnArray;\n    let i = this.lastProcessed,\n      ii = fnArray.length;\n    let state = this.state;\n    let match = this.match;\n    if (!state && !match && i + 1 === ii && !InitialState[fnArray[i]]) {\n      this.lastProcessed = ii;\n      return;\n    }\n    const context = this.context;\n    while (i < ii) {\n      if (match) {\n        const iterate = (0, match.iterateFn)(context, i);\n        if (iterate) {\n          i++;\n          continue;\n        }\n        i = (0, match.processFn)(context, i + 1);\n        ii = fnArray.length;\n        match = null;\n        state = null;\n        if (i >= ii) {\n          break;\n        }\n      }\n      state = (state || InitialState)[fnArray[i]];\n      if (!state || Array.isArray(state)) {\n        i++;\n        continue;\n      }\n      context.iCurr = i;\n      i++;\n      if (state.checkFn && !(0, state.checkFn)(context)) {\n        state = null;\n        continue;\n      }\n      match = state;\n      state = null;\n    }\n    this.state = state;\n    this.match = match;\n    this.lastProcessed = i;\n  }\n  flush() {\n    while (this.match) {\n      const length = this.queue.fnArray.length;\n      this.lastProcessed = (0, this.match.processFn)(this.context, length);\n      this.match = null;\n      this.state = null;\n      this._optimize();\n    }\n  }\n  reset() {\n    this.state = null;\n    this.match = null;\n    this.lastProcessed = 0;\n  }\n}\nclass OperatorList {\n  static CHUNK_SIZE = 1000;\n  static CHUNK_SIZE_ABOUT = this.CHUNK_SIZE - 5;\n  constructor(intent = 0, streamSink) {\n    this._streamSink = streamSink;\n    this.fnArray = [];\n    this.argsArray = [];\n    this.optimizer = streamSink && !(intent & RenderingIntentFlag.OPLIST) ? new QueueOptimizer(this) : new NullOptimizer(this);\n    this.dependencies = new Set();\n    this._totalLength = 0;\n    this.weight = 0;\n    this._resolved = streamSink ? null : Promise.resolve();\n  }\n  set isOffscreenCanvasSupported(value) {\n    this.optimizer.isOffscreenCanvasSupported = value;\n  }\n  get length() {\n    return this.argsArray.length;\n  }\n  get ready() {\n    return this._resolved || this._streamSink.ready;\n  }\n  get totalLength() {\n    return this._totalLength + this.length;\n  }\n  addOp(fn, args) {\n    this.optimizer.push(fn, args);\n    this.weight++;\n    if (this._streamSink) {\n      if (this.weight >= OperatorList.CHUNK_SIZE) {\n        this.flush();\n      } else if (this.weight >= OperatorList.CHUNK_SIZE_ABOUT && (fn === OPS.restore || fn === OPS.endText)) {\n        this.flush();\n      }\n    }\n  }\n  addImageOps(fn, args, optionalContent) {\n    if (optionalContent !== undefined) {\n      this.addOp(OPS.beginMarkedContentProps, [\"OC\", optionalContent]);\n    }\n    this.addOp(fn, args);\n    if (optionalContent !== undefined) {\n      this.addOp(OPS.endMarkedContent, []);\n    }\n  }\n  addDependency(dependency) {\n    if (this.dependencies.has(dependency)) {\n      return;\n    }\n    this.dependencies.add(dependency);\n    this.addOp(OPS.dependency, [dependency]);\n  }\n  addDependencies(dependencies) {\n    for (const dependency of dependencies) {\n      this.addDependency(dependency);\n    }\n  }\n  addOpList(opList) {\n    if (!(opList instanceof OperatorList)) {\n      warn('addOpList - ignoring invalid \"opList\" parameter.');\n      return;\n    }\n    for (const dependency of opList.dependencies) {\n      this.dependencies.add(dependency);\n    }\n    for (let i = 0, ii = opList.length; i < ii; i++) {\n      this.addOp(opList.fnArray[i], opList.argsArray[i]);\n    }\n  }\n  getIR() {\n    return {\n      fnArray: this.fnArray,\n      argsArray: this.argsArray,\n      length: this.length\n    };\n  }\n  get _transfers() {\n    const transfers = [];\n    const {\n      fnArray,\n      argsArray,\n      length\n    } = this;\n    for (let i = 0; i < length; i++) {\n      switch (fnArray[i]) {\n        case OPS.paintInlineImageXObject:\n        case OPS.paintInlineImageXObjectGroup:\n        case OPS.paintImageMaskXObject:\n          const arg = argsArray[i][0];\n          if (!arg.cached && arg.data?.buffer instanceof ArrayBuffer) {\n            transfers.push(arg.data.buffer);\n          }\n          break;\n      }\n    }\n    return transfers;\n  }\n  flush(lastChunk = false, separateAnnots = null) {\n    this.optimizer.flush();\n    const length = this.length;\n    this._totalLength += length;\n    this._streamSink.enqueue({\n      fnArray: this.fnArray,\n      argsArray: this.argsArray,\n      lastChunk,\n      separateAnnots,\n      length\n    }, 1, this._transfers);\n    this.dependencies.clear();\n    this.fnArray.length = 0;\n    this.argsArray.length = 0;\n    this.weight = 0;\n    this.optimizer.reset();\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/image.js\n\n\n\n\n\n\n\n\n\nfunction decodeAndClamp(value, addend, coefficient, max) {\n  value = addend + value * coefficient;\n  if (value < 0) {\n    value = 0;\n  } else if (value > max) {\n    value = max;\n  }\n  return value;\n}\nfunction resizeImageMask(src, bpc, w1, h1, w2, h2) {\n  const length = w2 * h2;\n  let dest;\n  if (bpc <= 8) {\n    dest = new Uint8Array(length);\n  } else if (bpc <= 16) {\n    dest = new Uint16Array(length);\n  } else {\n    dest = new Uint32Array(length);\n  }\n  const xRatio = w1 / w2;\n  const yRatio = h1 / h2;\n  let i,\n    j,\n    py,\n    newIndex = 0,\n    oldIndex;\n  const xScaled = new Uint16Array(w2);\n  const w1Scanline = w1;\n  for (i = 0; i < w2; i++) {\n    xScaled[i] = Math.floor(i * xRatio);\n  }\n  for (i = 0; i < h2; i++) {\n    py = Math.floor(i * yRatio) * w1Scanline;\n    for (j = 0; j < w2; j++) {\n      oldIndex = py + xScaled[j];\n      dest[newIndex++] = src[oldIndex];\n    }\n  }\n  return dest;\n}\nclass PDFImage {\n  constructor({\n    xref,\n    res,\n    image,\n    isInline = false,\n    smask = null,\n    mask = null,\n    isMask = false,\n    pdfFunctionFactory,\n    localColorSpaceCache\n  }) {\n    this.image = image;\n    let jpxDecode = false;\n    const dict = image.dict;\n    const filter = dict.get(\"F\", \"Filter\");\n    let filterName;\n    if (filter instanceof Name) {\n      filterName = filter.name;\n    } else if (Array.isArray(filter)) {\n      const filterZero = xref.fetchIfRef(filter[0]);\n      if (filterZero instanceof Name) {\n        filterName = filterZero.name;\n      }\n    }\n    switch (filterName) {\n      case \"JPXDecode\":\n        ({\n          width: image.width,\n          height: image.height,\n          componentsCount: image.numComps,\n          bitsPerComponent: image.bitsPerComponent\n        } = JpxImage.parseImageProperties(image.stream));\n        image.stream.reset();\n        jpxDecode = true;\n        break;\n      case \"JBIG2Decode\":\n        image.bitsPerComponent = 1;\n        image.numComps = 1;\n        break;\n    }\n    let width = dict.get(\"W\", \"Width\");\n    let height = dict.get(\"H\", \"Height\");\n    if (Number.isInteger(image.width) && image.width > 0 && Number.isInteger(image.height) && image.height > 0 && (image.width !== width || image.height !== height)) {\n      warn(\"PDFImage - using the Width/Height of the image data, \" + \"rather than the image dictionary.\");\n      width = image.width;\n      height = image.height;\n    }\n    if (width < 1 || height < 1) {\n      throw new FormatError(`Invalid image width: ${width} or height: ${height}`);\n    }\n    this.width = width;\n    this.height = height;\n    this.interpolate = dict.get(\"I\", \"Interpolate\");\n    this.imageMask = dict.get(\"IM\", \"ImageMask\") || false;\n    this.matte = dict.get(\"Matte\") || false;\n    let bitsPerComponent = image.bitsPerComponent;\n    if (!bitsPerComponent) {\n      bitsPerComponent = dict.get(\"BPC\", \"BitsPerComponent\");\n      if (!bitsPerComponent) {\n        if (this.imageMask) {\n          bitsPerComponent = 1;\n        } else {\n          throw new FormatError(`Bits per component missing in image: ${this.imageMask}`);\n        }\n      }\n    }\n    this.bpc = bitsPerComponent;\n    if (!this.imageMask) {\n      let colorSpace = dict.getRaw(\"CS\") || dict.getRaw(\"ColorSpace\");\n      if (!colorSpace) {\n        info(\"JPX images (which do not require color spaces)\");\n        switch (image.numComps) {\n          case 1:\n            colorSpace = Name.get(\"DeviceGray\");\n            break;\n          case 3:\n            colorSpace = Name.get(\"DeviceRGB\");\n            break;\n          case 4:\n            colorSpace = Name.get(\"DeviceCMYK\");\n            break;\n          default:\n            throw new Error(`JPX images with ${image.numComps} color components not supported.`);\n        }\n      }\n      this.colorSpace = ColorSpace.parse({\n        cs: colorSpace,\n        xref,\n        resources: isInline ? res : null,\n        pdfFunctionFactory,\n        localColorSpaceCache\n      });\n      this.numComps = this.colorSpace.numComps;\n      this.ignoreColorSpace = jpxDecode && this.colorSpace.name === \"Indexed\";\n    }\n    this.decode = dict.getArray(\"D\", \"Decode\");\n    this.needsDecode = false;\n    if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, bitsPerComponent) || isMask && !ColorSpace.isDefaultDecode(this.decode, 1))) {\n      this.needsDecode = true;\n      const max = (1 << bitsPerComponent) - 1;\n      this.decodeCoefficients = [];\n      this.decodeAddends = [];\n      const isIndexed = this.colorSpace?.name === \"Indexed\";\n      for (let i = 0, j = 0; i < this.decode.length; i += 2, ++j) {\n        const dmin = this.decode[i];\n        const dmax = this.decode[i + 1];\n        this.decodeCoefficients[j] = isIndexed ? (dmax - dmin) / max : dmax - dmin;\n        this.decodeAddends[j] = isIndexed ? dmin : max * dmin;\n      }\n    }\n    if (smask) {\n      this.smask = new PDFImage({\n        xref,\n        res,\n        image: smask,\n        isInline,\n        pdfFunctionFactory,\n        localColorSpaceCache\n      });\n    } else if (mask) {\n      if (mask instanceof BaseStream) {\n        const maskDict = mask.dict,\n          imageMask = maskDict.get(\"IM\", \"ImageMask\");\n        if (!imageMask) {\n          warn(\"Ignoring /Mask in image without /ImageMask.\");\n        } else {\n          this.mask = new PDFImage({\n            xref,\n            res,\n            image: mask,\n            isInline,\n            isMask: true,\n            pdfFunctionFactory,\n            localColorSpaceCache\n          });\n        }\n      } else {\n        this.mask = mask;\n      }\n    }\n  }\n  static async buildImage({\n    xref,\n    res,\n    image,\n    isInline = false,\n    pdfFunctionFactory,\n    localColorSpaceCache\n  }) {\n    const imageData = image;\n    let smaskData = null;\n    let maskData = null;\n    const smask = image.dict.get(\"SMask\");\n    const mask = image.dict.get(\"Mask\");\n    if (smask) {\n      if (smask instanceof BaseStream) {\n        smaskData = smask;\n      } else {\n        warn(\"Unsupported /SMask format.\");\n      }\n    } else if (mask) {\n      if (mask instanceof BaseStream || Array.isArray(mask)) {\n        maskData = mask;\n      } else {\n        warn(\"Unsupported /Mask format.\");\n      }\n    }\n    return new PDFImage({\n      xref,\n      res,\n      image: imageData,\n      isInline,\n      smask: smaskData,\n      mask: maskData,\n      pdfFunctionFactory,\n      localColorSpaceCache\n    });\n  }\n  static createRawMask({\n    imgArray,\n    width,\n    height,\n    imageIsFromDecodeStream,\n    inverseDecode,\n    interpolate\n  }) {\n    const computedLength = (width + 7 >> 3) * height;\n    const actualLength = imgArray.byteLength;\n    const haveFullData = computedLength === actualLength;\n    let data, i;\n    if (imageIsFromDecodeStream && (!inverseDecode || haveFullData)) {\n      data = imgArray;\n    } else if (!inverseDecode) {\n      data = new Uint8Array(imgArray);\n    } else {\n      data = new Uint8Array(computedLength);\n      data.set(imgArray);\n      data.fill(0xff, actualLength);\n    }\n    if (inverseDecode) {\n      for (i = 0; i < actualLength; i++) {\n        data[i] ^= 0xff;\n      }\n    }\n    return {\n      data,\n      width,\n      height,\n      interpolate\n    };\n  }\n  static async createMask({\n    imgArray,\n    width,\n    height,\n    imageIsFromDecodeStream,\n    inverseDecode,\n    interpolate,\n    isOffscreenCanvasSupported = false\n  }) {\n    const isSingleOpaquePixel = width === 1 && height === 1 && inverseDecode === (imgArray.length === 0 || !!(imgArray[0] & 128));\n    if (isSingleOpaquePixel) {\n      return {\n        isSingleOpaquePixel\n      };\n    }\n    if (isOffscreenCanvasSupported) {\n      if (ImageResizer.needsToBeResized(width, height)) {\n        const data = new Uint8ClampedArray(width * height * 4);\n        convertBlackAndWhiteToRGBA({\n          src: imgArray,\n          dest: data,\n          width,\n          height,\n          nonBlackColor: 0,\n          inverseDecode\n        });\n        return ImageResizer.createImage({\n          kind: ImageKind.RGBA_32BPP,\n          data,\n          width,\n          height,\n          interpolate\n        });\n      }\n      const canvas = new OffscreenCanvas(width, height);\n      const ctx = canvas.getContext(\"2d\");\n      const imgData = ctx.createImageData(width, height);\n      convertBlackAndWhiteToRGBA({\n        src: imgArray,\n        dest: imgData.data,\n        width,\n        height,\n        nonBlackColor: 0,\n        inverseDecode\n      });\n      ctx.putImageData(imgData, 0, 0);\n      const bitmap = canvas.transferToImageBitmap();\n      return {\n        data: null,\n        width,\n        height,\n        interpolate,\n        bitmap\n      };\n    }\n    return this.createRawMask({\n      imgArray,\n      width,\n      height,\n      inverseDecode,\n      imageIsFromDecodeStream,\n      interpolate\n    });\n  }\n  get drawWidth() {\n    return Math.max(this.width, this.smask?.width || 0, this.mask?.width || 0);\n  }\n  get drawHeight() {\n    return Math.max(this.height, this.smask?.height || 0, this.mask?.height || 0);\n  }\n  decodeBuffer(buffer) {\n    const bpc = this.bpc;\n    const numComps = this.numComps;\n    const decodeAddends = this.decodeAddends;\n    const decodeCoefficients = this.decodeCoefficients;\n    const max = (1 << bpc) - 1;\n    let i, ii;\n    if (bpc === 1) {\n      for (i = 0, ii = buffer.length; i < ii; i++) {\n        buffer[i] = +!buffer[i];\n      }\n      return;\n    }\n    let index = 0;\n    for (i = 0, ii = this.width * this.height; i < ii; i++) {\n      for (let j = 0; j < numComps; j++) {\n        buffer[index] = decodeAndClamp(buffer[index], decodeAddends[j], decodeCoefficients[j], max);\n        index++;\n      }\n    }\n  }\n  getComponents(buffer) {\n    const bpc = this.bpc;\n    if (bpc === 8) {\n      return buffer;\n    }\n    const width = this.width;\n    const height = this.height;\n    const numComps = this.numComps;\n    const length = width * height * numComps;\n    let bufferPos = 0;\n    let output;\n    if (bpc <= 8) {\n      output = new Uint8Array(length);\n    } else if (bpc <= 16) {\n      output = new Uint16Array(length);\n    } else {\n      output = new Uint32Array(length);\n    }\n    const rowComps = width * numComps;\n    const max = (1 << bpc) - 1;\n    let i = 0,\n      ii,\n      buf;\n    if (bpc === 1) {\n      let mask, loop1End, loop2End;\n      for (let j = 0; j < height; j++) {\n        loop1End = i + (rowComps & ~7);\n        loop2End = i + rowComps;\n        while (i < loop1End) {\n          buf = buffer[bufferPos++];\n          output[i] = buf >> 7 & 1;\n          output[i + 1] = buf >> 6 & 1;\n          output[i + 2] = buf >> 5 & 1;\n          output[i + 3] = buf >> 4 & 1;\n          output[i + 4] = buf >> 3 & 1;\n          output[i + 5] = buf >> 2 & 1;\n          output[i + 6] = buf >> 1 & 1;\n          output[i + 7] = buf & 1;\n          i += 8;\n        }\n        if (i < loop2End) {\n          buf = buffer[bufferPos++];\n          mask = 128;\n          while (i < loop2End) {\n            output[i++] = +!!(buf & mask);\n            mask >>= 1;\n          }\n        }\n      }\n    } else {\n      let bits = 0;\n      buf = 0;\n      for (i = 0, ii = length; i < ii; ++i) {\n        if (i % rowComps === 0) {\n          buf = 0;\n          bits = 0;\n        }\n        while (bits < bpc) {\n          buf = buf << 8 | buffer[bufferPos++];\n          bits += 8;\n        }\n        const remainingBits = bits - bpc;\n        let value = buf >> remainingBits;\n        if (value < 0) {\n          value = 0;\n        } else if (value > max) {\n          value = max;\n        }\n        output[i] = value;\n        buf &= (1 << remainingBits) - 1;\n        bits = remainingBits;\n      }\n    }\n    return output;\n  }\n  fillOpacity(rgbaBuf, width, height, actualHeight, image) {\n    const smask = this.smask;\n    const mask = this.mask;\n    let alphaBuf, sw, sh, i, ii, j;\n    if (smask) {\n      sw = smask.width;\n      sh = smask.height;\n      alphaBuf = new Uint8ClampedArray(sw * sh);\n      smask.fillGrayBuffer(alphaBuf);\n      if (sw !== width || sh !== height) {\n        alphaBuf = resizeImageMask(alphaBuf, smask.bpc, sw, sh, width, height);\n      }\n    } else if (mask) {\n      if (mask instanceof PDFImage) {\n        sw = mask.width;\n        sh = mask.height;\n        alphaBuf = new Uint8ClampedArray(sw * sh);\n        mask.numComps = 1;\n        mask.fillGrayBuffer(alphaBuf);\n        for (i = 0, ii = sw * sh; i < ii; ++i) {\n          alphaBuf[i] = 255 - alphaBuf[i];\n        }\n        if (sw !== width || sh !== height) {\n          alphaBuf = resizeImageMask(alphaBuf, mask.bpc, sw, sh, width, height);\n        }\n      } else if (Array.isArray(mask)) {\n        alphaBuf = new Uint8ClampedArray(width * height);\n        const numComps = this.numComps;\n        for (i = 0, ii = width * height; i < ii; ++i) {\n          let opacity = 0;\n          const imageOffset = i * numComps;\n          for (j = 0; j < numComps; ++j) {\n            const color = image[imageOffset + j];\n            const maskOffset = j * 2;\n            if (color < mask[maskOffset] || color > mask[maskOffset + 1]) {\n              opacity = 255;\n              break;\n            }\n          }\n          alphaBuf[i] = opacity;\n        }\n      } else {\n        throw new FormatError(\"Unknown mask format.\");\n      }\n    }\n    if (alphaBuf) {\n      for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {\n        rgbaBuf[j] = alphaBuf[i];\n      }\n    } else {\n      for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {\n        rgbaBuf[j] = 255;\n      }\n    }\n  }\n  undoPreblend(buffer, width, height) {\n    const matte = this.smask?.matte;\n    if (!matte) {\n      return;\n    }\n    const matteRgb = this.colorSpace.getRgb(matte, 0);\n    const matteR = matteRgb[0];\n    const matteG = matteRgb[1];\n    const matteB = matteRgb[2];\n    const length = width * height * 4;\n    for (let i = 0; i < length; i += 4) {\n      const alpha = buffer[i + 3];\n      if (alpha === 0) {\n        buffer[i] = 255;\n        buffer[i + 1] = 255;\n        buffer[i + 2] = 255;\n        continue;\n      }\n      const k = 255 / alpha;\n      buffer[i] = (buffer[i] - matteR) * k + matteR;\n      buffer[i + 1] = (buffer[i + 1] - matteG) * k + matteG;\n      buffer[i + 2] = (buffer[i + 2] - matteB) * k + matteB;\n    }\n  }\n  async createImageData(forceRGBA = false, isOffscreenCanvasSupported = false) {\n    const drawWidth = this.drawWidth;\n    const drawHeight = this.drawHeight;\n    const imgData = {\n      width: drawWidth,\n      height: drawHeight,\n      interpolate: this.interpolate,\n      kind: 0,\n      data: null\n    };\n    const numComps = this.numComps;\n    const originalWidth = this.width;\n    const originalHeight = this.height;\n    const bpc = this.bpc;\n    const rowBytes = originalWidth * numComps * bpc + 7 >> 3;\n    const mustBeResized = isOffscreenCanvasSupported && ImageResizer.needsToBeResized(drawWidth, drawHeight);\n    if (!forceRGBA) {\n      let kind;\n      if (this.colorSpace.name === \"DeviceGray\" && bpc === 1) {\n        kind = ImageKind.GRAYSCALE_1BPP;\n      } else if (this.colorSpace.name === \"DeviceRGB\" && bpc === 8 && !this.needsDecode) {\n        kind = ImageKind.RGB_24BPP;\n      }\n      if (kind && !this.smask && !this.mask && drawWidth === originalWidth && drawHeight === originalHeight) {\n        const data = this.getImageBytes(originalHeight * rowBytes, {});\n        if (isOffscreenCanvasSupported) {\n          if (mustBeResized) {\n            return ImageResizer.createImage({\n              data,\n              kind,\n              width: drawWidth,\n              height: drawHeight,\n              interpolate: this.interpolate\n            }, this.needsDecode);\n          }\n          return this.createBitmap(kind, originalWidth, originalHeight, data);\n        }\n        imgData.kind = kind;\n        imgData.data = data;\n        if (this.needsDecode) {\n          assert(kind === ImageKind.GRAYSCALE_1BPP, \"PDFImage.createImageData: The image must be grayscale.\");\n          const buffer = imgData.data;\n          for (let i = 0, ii = buffer.length; i < ii; i++) {\n            buffer[i] ^= 0xff;\n          }\n        }\n        return imgData;\n      }\n      if (this.image instanceof JpegStream && !this.smask && !this.mask && !this.needsDecode) {\n        let imageLength = originalHeight * rowBytes;\n        if (isOffscreenCanvasSupported && !mustBeResized) {\n          let isHandled = false;\n          switch (this.colorSpace.name) {\n            case \"DeviceGray\":\n              imageLength *= 4;\n              isHandled = true;\n              break;\n            case \"DeviceRGB\":\n              imageLength = imageLength / 3 * 4;\n              isHandled = true;\n              break;\n            case \"DeviceCMYK\":\n              isHandled = true;\n              break;\n          }\n          if (isHandled) {\n            const rgba = this.getImageBytes(imageLength, {\n              drawWidth,\n              drawHeight,\n              forceRGBA: true\n            });\n            return this.createBitmap(ImageKind.RGBA_32BPP, drawWidth, drawHeight, rgba);\n          }\n        } else {\n          switch (this.colorSpace.name) {\n            case \"DeviceGray\":\n              imageLength *= 3;\n            case \"DeviceRGB\":\n            case \"DeviceCMYK\":\n              imgData.kind = ImageKind.RGB_24BPP;\n              imgData.data = this.getImageBytes(imageLength, {\n                drawWidth,\n                drawHeight,\n                forceRGB: true\n              });\n              if (mustBeResized) {\n                return ImageResizer.createImage(imgData);\n              }\n              return imgData;\n          }\n        }\n      }\n    }\n    const imgArray = this.getImageBytes(originalHeight * rowBytes, {\n      internal: true\n    });\n    const actualHeight = 0 | imgArray.length / rowBytes * drawHeight / originalHeight;\n    const comps = this.getComponents(imgArray);\n    let alpha01, maybeUndoPreblend;\n    let canvas, ctx, canvasImgData, data;\n    if (isOffscreenCanvasSupported && !mustBeResized) {\n      canvas = new OffscreenCanvas(drawWidth, drawHeight);\n      ctx = canvas.getContext(\"2d\");\n      canvasImgData = ctx.createImageData(drawWidth, drawHeight);\n      data = canvasImgData.data;\n    }\n    imgData.kind = ImageKind.RGBA_32BPP;\n    if (!forceRGBA && !this.smask && !this.mask) {\n      if (!isOffscreenCanvasSupported || mustBeResized) {\n        imgData.kind = ImageKind.RGB_24BPP;\n        data = new Uint8ClampedArray(drawWidth * drawHeight * 3);\n        alpha01 = 0;\n      } else {\n        const arr = new Uint32Array(data.buffer);\n        arr.fill(FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff);\n        alpha01 = 1;\n      }\n      maybeUndoPreblend = false;\n    } else {\n      if (!isOffscreenCanvasSupported || mustBeResized) {\n        data = new Uint8ClampedArray(drawWidth * drawHeight * 4);\n      }\n      alpha01 = 1;\n      maybeUndoPreblend = true;\n      this.fillOpacity(data, drawWidth, drawHeight, actualHeight, comps);\n    }\n    if (this.needsDecode) {\n      this.decodeBuffer(comps);\n    }\n    this.colorSpace.fillRgb(data, originalWidth, originalHeight, drawWidth, drawHeight, actualHeight, bpc, comps, alpha01);\n    if (maybeUndoPreblend) {\n      this.undoPreblend(data, drawWidth, actualHeight);\n    }\n    if (isOffscreenCanvasSupported && !mustBeResized) {\n      ctx.putImageData(canvasImgData, 0, 0);\n      const bitmap = canvas.transferToImageBitmap();\n      return {\n        data: null,\n        width: drawWidth,\n        height: drawHeight,\n        bitmap,\n        interpolate: this.interpolate\n      };\n    }\n    imgData.data = data;\n    if (mustBeResized) {\n      return ImageResizer.createImage(imgData);\n    }\n    return imgData;\n  }\n  fillGrayBuffer(buffer) {\n    const numComps = this.numComps;\n    if (numComps !== 1) {\n      throw new FormatError(`Reading gray scale from a color image: ${numComps}`);\n    }\n    const width = this.width;\n    const height = this.height;\n    const bpc = this.bpc;\n    const rowBytes = width * numComps * bpc + 7 >> 3;\n    const imgArray = this.getImageBytes(height * rowBytes, {\n      internal: true\n    });\n    const comps = this.getComponents(imgArray);\n    let i, length;\n    if (bpc === 1) {\n      length = width * height;\n      if (this.needsDecode) {\n        for (i = 0; i < length; ++i) {\n          buffer[i] = comps[i] - 1 & 255;\n        }\n      } else {\n        for (i = 0; i < length; ++i) {\n          buffer[i] = -comps[i] & 255;\n        }\n      }\n      return;\n    }\n    if (this.needsDecode) {\n      this.decodeBuffer(comps);\n    }\n    length = width * height;\n    const scale = 255 / ((1 << bpc) - 1);\n    for (i = 0; i < length; ++i) {\n      buffer[i] = scale * comps[i];\n    }\n  }\n  createBitmap(kind, width, height, src) {\n    const canvas = new OffscreenCanvas(width, height);\n    const ctx = canvas.getContext(\"2d\");\n    let imgData;\n    if (kind === ImageKind.RGBA_32BPP) {\n      imgData = new ImageData(src, width, height);\n    } else {\n      imgData = ctx.createImageData(width, height);\n      convertToRGBA({\n        kind,\n        src,\n        dest: new Uint32Array(imgData.data.buffer),\n        width,\n        height,\n        inverseDecode: this.needsDecode\n      });\n    }\n    ctx.putImageData(imgData, 0, 0);\n    const bitmap = canvas.transferToImageBitmap();\n    return {\n      data: null,\n      width,\n      height,\n      bitmap,\n      interpolate: this.interpolate\n    };\n  }\n  getImageBytes(length, {\n    drawWidth,\n    drawHeight,\n    forceRGBA = false,\n    forceRGB = false,\n    internal = false\n  }) {\n    this.image.reset();\n    this.image.drawWidth = drawWidth || this.width;\n    this.image.drawHeight = drawHeight || this.height;\n    this.image.forceRGBA = !!forceRGBA;\n    this.image.forceRGB = !!forceRGB;\n    const imageBytes = this.image.getBytes(length, this.ignoreColorSpace);\n    if (internal || this.image instanceof DecodeStream) {\n      return imageBytes;\n    }\n    assert(imageBytes instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported \"imageBytes\" type.');\n    return new Uint8Array(imageBytes);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/evaluator.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst DefaultPartialEvaluatorOptions = Object.freeze({\n  maxImageSize: -1,\n  disableFontFace: false,\n  ignoreErrors: false,\n  isEvalSupported: true,\n  isOffscreenCanvasSupported: false,\n  canvasMaxAreaInBytes: -1,\n  fontExtraProperties: false,\n  useSystemFonts: true,\n  cMapUrl: null,\n  standardFontDataUrl: null\n});\nconst PatternType = {\n  TILING: 1,\n  SHADING: 2\n};\nconst TEXT_CHUNK_BATCH_SIZE = 10;\nconst deferred = Promise.resolve();\nfunction normalizeBlendMode(value, parsingArray = false) {\n  if (Array.isArray(value)) {\n    for (const val of value) {\n      const maybeBM = normalizeBlendMode(val, true);\n      if (maybeBM) {\n        return maybeBM;\n      }\n    }\n    warn(`Unsupported blend mode Array: ${value}`);\n    return \"source-over\";\n  }\n  if (!(value instanceof Name)) {\n    if (parsingArray) {\n      return null;\n    }\n    return \"source-over\";\n  }\n  switch (value.name) {\n    case \"Normal\":\n    case \"Compatible\":\n      return \"source-over\";\n    case \"Multiply\":\n      return \"multiply\";\n    case \"Screen\":\n      return \"screen\";\n    case \"Overlay\":\n      return \"overlay\";\n    case \"Darken\":\n      return \"darken\";\n    case \"Lighten\":\n      return \"lighten\";\n    case \"ColorDodge\":\n      return \"color-dodge\";\n    case \"ColorBurn\":\n      return \"color-burn\";\n    case \"HardLight\":\n      return \"hard-light\";\n    case \"SoftLight\":\n      return \"soft-light\";\n    case \"Difference\":\n      return \"difference\";\n    case \"Exclusion\":\n      return \"exclusion\";\n    case \"Hue\":\n      return \"hue\";\n    case \"Saturation\":\n      return \"saturation\";\n    case \"Color\":\n      return \"color\";\n    case \"Luminosity\":\n      return \"luminosity\";\n  }\n  if (parsingArray) {\n    return null;\n  }\n  warn(`Unsupported blend mode: ${value.name}`);\n  return \"source-over\";\n}\nfunction incrementCachedImageMaskCount(data) {\n  if (data.fn === OPS.paintImageMaskXObject && data.args[0]?.count > 0) {\n    data.args[0].count++;\n  }\n}\nclass TimeSlotManager {\n  static TIME_SLOT_DURATION_MS = 20;\n  static CHECK_TIME_EVERY = 100;\n  constructor() {\n    this.reset();\n  }\n  check() {\n    if (++this.checked < TimeSlotManager.CHECK_TIME_EVERY) {\n      return false;\n    }\n    this.checked = 0;\n    return this.endTime <= Date.now();\n  }\n  reset() {\n    this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS;\n    this.checked = 0;\n  }\n}\nclass PartialEvaluator {\n  constructor({\n    xref,\n    handler,\n    pageIndex,\n    idFactory,\n    fontCache,\n    builtInCMapCache,\n    standardFontDataCache,\n    globalImageCache,\n    systemFontCache,\n    options = null\n  }) {\n    this.xref = xref;\n    this.handler = handler;\n    this.pageIndex = pageIndex;\n    this.idFactory = idFactory;\n    this.fontCache = fontCache;\n    this.builtInCMapCache = builtInCMapCache;\n    this.standardFontDataCache = standardFontDataCache;\n    this.globalImageCache = globalImageCache;\n    this.systemFontCache = systemFontCache;\n    this.options = options || DefaultPartialEvaluatorOptions;\n    this.parsingType3Font = false;\n    this._regionalImageCache = new RegionalImageCache();\n    this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);\n    ImageResizer.setMaxArea(this.options.canvasMaxAreaInBytes);\n  }\n  get _pdfFunctionFactory() {\n    const pdfFunctionFactory = new PDFFunctionFactory({\n      xref: this.xref,\n      isEvalSupported: this.options.isEvalSupported\n    });\n    return shadow(this, \"_pdfFunctionFactory\", pdfFunctionFactory);\n  }\n  clone(newOptions = null) {\n    const newEvaluator = Object.create(this);\n    newEvaluator.options = Object.assign(Object.create(null), this.options, newOptions);\n    return newEvaluator;\n  }\n  hasBlendModes(resources, nonBlendModesSet) {\n    if (!(resources instanceof Dict)) {\n      return false;\n    }\n    if (resources.objId && nonBlendModesSet.has(resources.objId)) {\n      return false;\n    }\n    const processed = new RefSet(nonBlendModesSet);\n    if (resources.objId) {\n      processed.put(resources.objId);\n    }\n    const nodes = [resources],\n      xref = this.xref;\n    while (nodes.length) {\n      const node = nodes.shift();\n      const graphicStates = node.get(\"ExtGState\");\n      if (graphicStates instanceof Dict) {\n        for (let graphicState of graphicStates.getRawValues()) {\n          if (graphicState instanceof Ref) {\n            if (processed.has(graphicState)) {\n              continue;\n            }\n            try {\n              graphicState = xref.fetch(graphicState);\n            } catch (ex) {\n              processed.put(graphicState);\n              info(`hasBlendModes - ignoring ExtGState: \"${ex}\".`);\n              continue;\n            }\n          }\n          if (!(graphicState instanceof Dict)) {\n            continue;\n          }\n          if (graphicState.objId) {\n            processed.put(graphicState.objId);\n          }\n          const bm = graphicState.get(\"BM\");\n          if (bm instanceof Name) {\n            if (bm.name !== \"Normal\") {\n              return true;\n            }\n            continue;\n          }\n          if (bm !== undefined && Array.isArray(bm)) {\n            for (const element of bm) {\n              if (element instanceof Name && element.name !== \"Normal\") {\n                return true;\n              }\n            }\n          }\n        }\n      }\n      const xObjects = node.get(\"XObject\");\n      if (!(xObjects instanceof Dict)) {\n        continue;\n      }\n      for (let xObject of xObjects.getRawValues()) {\n        if (xObject instanceof Ref) {\n          if (processed.has(xObject)) {\n            continue;\n          }\n          try {\n            xObject = xref.fetch(xObject);\n          } catch (ex) {\n            processed.put(xObject);\n            info(`hasBlendModes - ignoring XObject: \"${ex}\".`);\n            continue;\n          }\n        }\n        if (!(xObject instanceof BaseStream)) {\n          continue;\n        }\n        if (xObject.dict.objId) {\n          processed.put(xObject.dict.objId);\n        }\n        const xResources = xObject.dict.get(\"Resources\");\n        if (!(xResources instanceof Dict)) {\n          continue;\n        }\n        if (xResources.objId && processed.has(xResources.objId)) {\n          continue;\n        }\n        nodes.push(xResources);\n        if (xResources.objId) {\n          processed.put(xResources.objId);\n        }\n      }\n    }\n    for (const ref of processed) {\n      nonBlendModesSet.put(ref);\n    }\n    return false;\n  }\n  async fetchBuiltInCMap(name) {\n    const cachedData = this.builtInCMapCache.get(name);\n    if (cachedData) {\n      return cachedData;\n    }\n    let data;\n    if (this.options.cMapUrl !== null) {\n      const url = `${this.options.cMapUrl}${name}.bcmap`;\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`fetchBuiltInCMap: failed to fetch file \"${url}\" with \"${response.statusText}\".`);\n      }\n      data = {\n        cMapData: new Uint8Array(await response.arrayBuffer()),\n        compressionType: CMapCompressionType.BINARY\n      };\n    } else {\n      data = await this.handler.sendWithPromise(\"FetchBuiltInCMap\", {\n        name\n      });\n    }\n    if (data.compressionType !== CMapCompressionType.NONE) {\n      this.builtInCMapCache.set(name, data);\n    }\n    return data;\n  }\n  async fetchStandardFontData(name) {\n    const cachedData = this.standardFontDataCache.get(name);\n    if (cachedData) {\n      return new Stream(cachedData);\n    }\n    if (this.options.useSystemFonts && name !== \"Symbol\" && name !== \"ZapfDingbats\") {\n      return null;\n    }\n    const standardFontNameToFileName = getFontNameToFileMap(),\n      filename = standardFontNameToFileName[name];\n    let data;\n    if (this.options.standardFontDataUrl !== null) {\n      const url = `${this.options.standardFontDataUrl}${filename}`;\n      const response = await fetch(url);\n      if (!response.ok) {\n        warn(`fetchStandardFontData: failed to fetch file \"${url}\" with \"${response.statusText}\".`);\n      } else {\n        data = new Uint8Array(await response.arrayBuffer());\n      }\n    } else {\n      try {\n        data = await this.handler.sendWithPromise(\"FetchStandardFontData\", {\n          filename\n        });\n      } catch (e) {\n        warn(`fetchStandardFontData: failed to fetch file \"${filename}\" with \"${e}\".`);\n      }\n    }\n    if (!data) {\n      return null;\n    }\n    this.standardFontDataCache.set(name, data);\n    return new Stream(data);\n  }\n  async buildFormXObject(resources, xobj, smask, operatorList, task, initialState, localColorSpaceCache) {\n    const dict = xobj.dict;\n    const matrix = dict.getArray(\"Matrix\");\n    let bbox = dict.getArray(\"BBox\");\n    bbox = Array.isArray(bbox) && bbox.length === 4 ? Util.normalizeRect(bbox) : null;\n    let optionalContent, groupOptions;\n    if (dict.has(\"OC\")) {\n      optionalContent = await this.parseMarkedContentProps(dict.get(\"OC\"), resources);\n    }\n    if (optionalContent !== undefined) {\n      operatorList.addOp(OPS.beginMarkedContentProps, [\"OC\", optionalContent]);\n    }\n    const group = dict.get(\"Group\");\n    if (group) {\n      groupOptions = {\n        matrix,\n        bbox,\n        smask,\n        isolated: false,\n        knockout: false\n      };\n      const groupSubtype = group.get(\"S\");\n      let colorSpace = null;\n      if (isName(groupSubtype, \"Transparency\")) {\n        groupOptions.isolated = group.get(\"I\") || false;\n        groupOptions.knockout = group.get(\"K\") || false;\n        if (group.has(\"CS\")) {\n          const cs = group.getRaw(\"CS\");\n          const cachedColorSpace = ColorSpace.getCached(cs, this.xref, localColorSpaceCache);\n          if (cachedColorSpace) {\n            colorSpace = cachedColorSpace;\n          } else {\n            colorSpace = await this.parseColorSpace({\n              cs,\n              resources,\n              localColorSpaceCache\n            });\n          }\n        }\n      }\n      if (smask?.backdrop) {\n        colorSpace ||= ColorSpace.singletons.rgb;\n        smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);\n      }\n      operatorList.addOp(OPS.beginGroup, [groupOptions]);\n    }\n    const args = group ? [matrix, null] : [matrix, bbox];\n    operatorList.addOp(OPS.paintFormXObjectBegin, args);\n    await this.getOperatorList({\n      stream: xobj,\n      task,\n      resources: dict.get(\"Resources\") || resources,\n      operatorList,\n      initialState\n    });\n    operatorList.addOp(OPS.paintFormXObjectEnd, []);\n    if (group) {\n      operatorList.addOp(OPS.endGroup, [groupOptions]);\n    }\n    if (optionalContent !== undefined) {\n      operatorList.addOp(OPS.endMarkedContent, []);\n    }\n  }\n  _sendImgData(objId, imgData, cacheGlobally = false) {\n    const transfers = imgData ? [imgData.bitmap || imgData.data.buffer] : null;\n    if (this.parsingType3Font || cacheGlobally) {\n      return this.handler.send(\"commonobj\", [objId, \"Image\", imgData], transfers);\n    }\n    return this.handler.send(\"obj\", [objId, this.pageIndex, \"Image\", imgData], transfers);\n  }\n  async buildPaintImageXObject({\n    resources,\n    image,\n    isInline = false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache\n  }) {\n    const dict = image.dict;\n    const imageRef = dict.objId;\n    const w = dict.get(\"W\", \"Width\");\n    const h = dict.get(\"H\", \"Height\");\n    if (!(w && typeof w === \"number\") || !(h && typeof h === \"number\")) {\n      warn(\"Image dimensions are missing, or not numbers.\");\n      return;\n    }\n    const maxImageSize = this.options.maxImageSize;\n    if (maxImageSize !== -1 && w * h > maxImageSize) {\n      const msg = \"Image exceeded maximum allowed size and was removed.\";\n      if (this.options.ignoreErrors) {\n        warn(msg);\n        return;\n      }\n      throw new Error(msg);\n    }\n    let optionalContent;\n    if (dict.has(\"OC\")) {\n      optionalContent = await this.parseMarkedContentProps(dict.get(\"OC\"), resources);\n    }\n    const imageMask = dict.get(\"IM\", \"ImageMask\") || false;\n    let imgData, args;\n    if (imageMask) {\n      const interpolate = dict.get(\"I\", \"Interpolate\");\n      const bitStrideLength = w + 7 >> 3;\n      const imgArray = image.getBytes(bitStrideLength * h);\n      const decode = dict.getArray(\"D\", \"Decode\");\n      if (this.parsingType3Font) {\n        imgData = PDFImage.createRawMask({\n          imgArray,\n          width: w,\n          height: h,\n          imageIsFromDecodeStream: image instanceof DecodeStream,\n          inverseDecode: decode?.[0] > 0,\n          interpolate\n        });\n        imgData.cached = !!cacheKey;\n        args = [imgData];\n        operatorList.addImageOps(OPS.paintImageMaskXObject, args, optionalContent);\n        if (cacheKey) {\n          const cacheData = {\n            fn: OPS.paintImageMaskXObject,\n            args,\n            optionalContent\n          };\n          localImageCache.set(cacheKey, imageRef, cacheData);\n          if (imageRef) {\n            this._regionalImageCache.set(null, imageRef, cacheData);\n          }\n        }\n        return;\n      }\n      imgData = await PDFImage.createMask({\n        imgArray,\n        width: w,\n        height: h,\n        imageIsFromDecodeStream: image instanceof DecodeStream,\n        inverseDecode: decode?.[0] > 0,\n        interpolate,\n        isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported\n      });\n      if (imgData.isSingleOpaquePixel) {\n        operatorList.addImageOps(OPS.paintSolidColorImageMask, [], optionalContent);\n        if (cacheKey) {\n          const cacheData = {\n            fn: OPS.paintSolidColorImageMask,\n            args: [],\n            optionalContent\n          };\n          localImageCache.set(cacheKey, imageRef, cacheData);\n          if (imageRef) {\n            this._regionalImageCache.set(null, imageRef, cacheData);\n          }\n        }\n        return;\n      }\n      const objId = `mask_${this.idFactory.createObjId()}`;\n      operatorList.addDependency(objId);\n      imgData.dataLen = imgData.bitmap ? imgData.width * imgData.height * 4 : imgData.data.length;\n      this._sendImgData(objId, imgData);\n      args = [{\n        data: objId,\n        width: imgData.width,\n        height: imgData.height,\n        interpolate: imgData.interpolate,\n        count: 1\n      }];\n      operatorList.addImageOps(OPS.paintImageMaskXObject, args, optionalContent);\n      if (cacheKey) {\n        const cacheData = {\n          fn: OPS.paintImageMaskXObject,\n          args,\n          optionalContent\n        };\n        localImageCache.set(cacheKey, imageRef, cacheData);\n        if (imageRef) {\n          this._regionalImageCache.set(null, imageRef, cacheData);\n        }\n      }\n      return;\n    }\n    const SMALL_IMAGE_DIMENSIONS = 200;\n    if (isInline && w + h < SMALL_IMAGE_DIMENSIONS && !dict.has(\"SMask\") && !dict.has(\"Mask\")) {\n      try {\n        const imageObj = new PDFImage({\n          xref: this.xref,\n          res: resources,\n          image,\n          isInline,\n          pdfFunctionFactory: this._pdfFunctionFactory,\n          localColorSpaceCache\n        });\n        imgData = await imageObj.createImageData(true, false);\n        operatorList.isOffscreenCanvasSupported = this.options.isOffscreenCanvasSupported;\n        operatorList.addImageOps(OPS.paintInlineImageXObject, [imgData], optionalContent);\n      } catch (reason) {\n        const msg = `Unable to decode inline image: \"${reason}\".`;\n        if (!this.options.ignoreErrors) {\n          throw new Error(msg);\n        }\n        warn(msg);\n      }\n      return;\n    }\n    let objId = `img_${this.idFactory.createObjId()}`,\n      cacheGlobally = false;\n    if (this.parsingType3Font) {\n      objId = `${this.idFactory.getDocId()}_type3_${objId}`;\n    } else if (cacheKey && imageRef) {\n      cacheGlobally = this.globalImageCache.shouldCache(imageRef, this.pageIndex);\n      if (cacheGlobally) {\n        assert(!isInline, \"Cannot cache an inline image globally.\");\n        objId = `${this.idFactory.getDocId()}_${objId}`;\n      }\n    }\n    operatorList.addDependency(objId);\n    args = [objId, w, h];\n    operatorList.addImageOps(OPS.paintImageXObject, args, optionalContent);\n    if (cacheGlobally && (w * h > 250000 || dict.has(\"SMask\") || dict.has(\"Mask\"))) {\n      const localLength = await this.handler.sendWithPromise(\"commonobj\", [objId, \"CopyLocalImage\", {\n        imageRef\n      }]);\n      if (localLength) {\n        this.globalImageCache.setData(imageRef, {\n          objId,\n          fn: OPS.paintImageXObject,\n          args,\n          optionalContent,\n          byteSize: 0\n        });\n        this.globalImageCache.addByteSize(imageRef, localLength);\n        return;\n      }\n    }\n    PDFImage.buildImage({\n      xref: this.xref,\n      res: resources,\n      image,\n      isInline,\n      pdfFunctionFactory: this._pdfFunctionFactory,\n      localColorSpaceCache\n    }).then(async imageObj => {\n      imgData = await imageObj.createImageData(false, this.options.isOffscreenCanvasSupported);\n      imgData.dataLen = imgData.bitmap ? imgData.width * imgData.height * 4 : imgData.data.length;\n      imgData.ref = imageRef;\n      if (cacheGlobally) {\n        this.globalImageCache.addByteSize(imageRef, imgData.dataLen);\n      }\n      return this._sendImgData(objId, imgData, cacheGlobally);\n    }).catch(reason => {\n      warn(`Unable to decode image \"${objId}\": \"${reason}\".`);\n      return this._sendImgData(objId, null, cacheGlobally);\n    });\n    if (cacheKey) {\n      const cacheData = {\n        fn: OPS.paintImageXObject,\n        args,\n        optionalContent\n      };\n      localImageCache.set(cacheKey, imageRef, cacheData);\n      if (imageRef) {\n        this._regionalImageCache.set(null, imageRef, cacheData);\n        if (cacheGlobally) {\n          this.globalImageCache.setData(imageRef, {\n            objId,\n            fn: OPS.paintImageXObject,\n            args,\n            optionalContent,\n            byteSize: 0\n          });\n        }\n      }\n    }\n  }\n  handleSMask(smask, resources, operatorList, task, stateManager, localColorSpaceCache) {\n    const smaskContent = smask.get(\"G\");\n    const smaskOptions = {\n      subtype: smask.get(\"S\").name,\n      backdrop: smask.get(\"BC\")\n    };\n    const transferObj = smask.get(\"TR\");\n    if (isPDFFunction(transferObj)) {\n      const transferFn = this._pdfFunctionFactory.create(transferObj);\n      const transferMap = new Uint8Array(256);\n      const tmp = new Float32Array(1);\n      for (let i = 0; i < 256; i++) {\n        tmp[0] = i / 255;\n        transferFn(tmp, 0, tmp, 0);\n        transferMap[i] = tmp[0] * 255 | 0;\n      }\n      smaskOptions.transferMap = transferMap;\n    }\n    return this.buildFormXObject(resources, smaskContent, smaskOptions, operatorList, task, stateManager.state.clone(), localColorSpaceCache);\n  }\n  handleTransferFunction(tr) {\n    let transferArray;\n    if (Array.isArray(tr)) {\n      transferArray = tr;\n    } else if (isPDFFunction(tr)) {\n      transferArray = [tr];\n    } else {\n      return null;\n    }\n    const transferMaps = [];\n    let numFns = 0,\n      numEffectfulFns = 0;\n    for (const entry of transferArray) {\n      const transferObj = this.xref.fetchIfRef(entry);\n      numFns++;\n      if (isName(transferObj, \"Identity\")) {\n        transferMaps.push(null);\n        continue;\n      } else if (!isPDFFunction(transferObj)) {\n        return null;\n      }\n      const transferFn = this._pdfFunctionFactory.create(transferObj);\n      const transferMap = new Uint8Array(256),\n        tmp = new Float32Array(1);\n      for (let j = 0; j < 256; j++) {\n        tmp[0] = j / 255;\n        transferFn(tmp, 0, tmp, 0);\n        transferMap[j] = tmp[0] * 255 | 0;\n      }\n      transferMaps.push(transferMap);\n      numEffectfulFns++;\n    }\n    if (!(numFns === 1 || numFns === 4)) {\n      return null;\n    }\n    if (numEffectfulFns === 0) {\n      return null;\n    }\n    return transferMaps;\n  }\n  handleTilingType(fn, color, resources, pattern, patternDict, operatorList, task, localTilingPatternCache) {\n    const tilingOpList = new OperatorList();\n    const patternResources = Dict.merge({\n      xref: this.xref,\n      dictArray: [patternDict.get(\"Resources\"), resources]\n    });\n    return this.getOperatorList({\n      stream: pattern,\n      task,\n      resources: patternResources,\n      operatorList: tilingOpList\n    }).then(function () {\n      const operatorListIR = tilingOpList.getIR();\n      const tilingPatternIR = getTilingPatternIR(operatorListIR, patternDict, color);\n      operatorList.addDependencies(tilingOpList.dependencies);\n      operatorList.addOp(fn, tilingPatternIR);\n      if (patternDict.objId) {\n        localTilingPatternCache.set(null, patternDict.objId, {\n          operatorListIR,\n          dict: patternDict\n        });\n      }\n    }).catch(reason => {\n      if (reason instanceof AbortException) {\n        return;\n      }\n      if (this.options.ignoreErrors) {\n        warn(`handleTilingType - ignoring pattern: \"${reason}\".`);\n        return;\n      }\n      throw reason;\n    });\n  }\n  async handleSetFont(resources, fontArgs, fontRef, operatorList, task, state, fallbackFontDict = null, cssFontInfo = null) {\n    const fontName = fontArgs?.[0] instanceof Name ? fontArgs[0].name : null;\n    let translated = await this.loadFont(fontName, fontRef, resources, fallbackFontDict, cssFontInfo);\n    if (translated.font.isType3Font) {\n      try {\n        await translated.loadType3Data(this, resources, task);\n        operatorList.addDependencies(translated.type3Dependencies);\n      } catch (reason) {\n        translated = new TranslatedFont({\n          loadedName: \"g_font_error\",\n          font: new ErrorFont(`Type3 font load error: ${reason}`),\n          dict: translated.font,\n          evaluatorOptions: this.options\n        });\n      }\n    }\n    state.font = translated.font;\n    translated.send(this.handler);\n    return translated.loadedName;\n  }\n  handleText(chars, state) {\n    const font = state.font;\n    const glyphs = font.charsToGlyphs(chars);\n    if (font.data) {\n      const isAddToPathSet = !!(state.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);\n      if (isAddToPathSet || state.fillColorSpace.name === \"Pattern\" || font.disableFontFace || this.options.disableFontFace) {\n        PartialEvaluator.buildFontPaths(font, glyphs, this.handler, this.options);\n      }\n    }\n    return glyphs;\n  }\n  ensureStateFont(state) {\n    if (state.font) {\n      return;\n    }\n    const reason = new FormatError(\"Missing setFont (Tf) operator before text rendering operator.\");\n    if (this.options.ignoreErrors) {\n      warn(`ensureStateFont: \"${reason}\".`);\n      return;\n    }\n    throw reason;\n  }\n  async setGState({\n    resources,\n    gState,\n    operatorList,\n    cacheKey,\n    task,\n    stateManager,\n    localGStateCache,\n    localColorSpaceCache\n  }) {\n    const gStateRef = gState.objId;\n    let isSimpleGState = true;\n    const gStateObj = [];\n    let promise = Promise.resolve();\n    for (const key of gState.getKeys()) {\n      const value = gState.get(key);\n      switch (key) {\n        case \"Type\":\n          break;\n        case \"LW\":\n        case \"LC\":\n        case \"LJ\":\n        case \"ML\":\n        case \"D\":\n        case \"RI\":\n        case \"FL\":\n        case \"CA\":\n        case \"ca\":\n          gStateObj.push([key, value]);\n          break;\n        case \"Font\":\n          isSimpleGState = false;\n          promise = promise.then(() => this.handleSetFont(resources, null, value[0], operatorList, task, stateManager.state).then(function (loadedName) {\n            operatorList.addDependency(loadedName);\n            gStateObj.push([key, [loadedName, value[1]]]);\n          }));\n          break;\n        case \"BM\":\n          gStateObj.push([key, normalizeBlendMode(value)]);\n          break;\n        case \"SMask\":\n          if (isName(value, \"None\")) {\n            gStateObj.push([key, false]);\n            break;\n          }\n          if (value instanceof Dict) {\n            isSimpleGState = false;\n            promise = promise.then(() => this.handleSMask(value, resources, operatorList, task, stateManager, localColorSpaceCache));\n            gStateObj.push([key, true]);\n          } else {\n            warn(\"Unsupported SMask type\");\n          }\n          break;\n        case \"TR\":\n          const transferMaps = this.handleTransferFunction(value);\n          gStateObj.push([key, transferMaps]);\n          break;\n        case \"OP\":\n        case \"op\":\n        case \"OPM\":\n        case \"BG\":\n        case \"BG2\":\n        case \"UCR\":\n        case \"UCR2\":\n        case \"TR2\":\n        case \"HT\":\n        case \"SM\":\n        case \"SA\":\n        case \"AIS\":\n        case \"TK\":\n          info(\"graphic state operator \" + key);\n          break;\n        default:\n          info(\"Unknown graphic state operator \" + key);\n          break;\n      }\n    }\n    await promise;\n    if (gStateObj.length > 0) {\n      operatorList.addOp(OPS.setGState, [gStateObj]);\n    }\n    if (isSimpleGState) {\n      localGStateCache.set(cacheKey, gStateRef, gStateObj);\n    }\n  }\n  loadFont(fontName, font, resources, fallbackFontDict = null, cssFontInfo = null) {\n    const errorFont = async () => {\n      return new TranslatedFont({\n        loadedName: \"g_font_error\",\n        font: new ErrorFont(`Font \"${fontName}\" is not available.`),\n        dict: font,\n        evaluatorOptions: this.options\n      });\n    };\n    let fontRef;\n    if (font) {\n      if (font instanceof Ref) {\n        fontRef = font;\n      }\n    } else {\n      const fontRes = resources.get(\"Font\");\n      if (fontRes) {\n        fontRef = fontRes.getRaw(fontName);\n      }\n    }\n    if (fontRef) {\n      if (this.parsingType3Font && this.type3FontRefs.has(fontRef)) {\n        return errorFont();\n      }\n      if (this.fontCache.has(fontRef)) {\n        return this.fontCache.get(fontRef);\n      }\n      font = this.xref.fetchIfRef(fontRef);\n    }\n    if (!(font instanceof Dict)) {\n      if (!this.options.ignoreErrors && !this.parsingType3Font) {\n        warn(`Font \"${fontName}\" is not available.`);\n        return errorFont();\n      }\n      warn(`Font \"${fontName}\" is not available -- attempting to fallback to a default font.`);\n      font = fallbackFontDict || PartialEvaluator.fallbackFontDict;\n    }\n    if (font.cacheKey && this.fontCache.has(font.cacheKey)) {\n      return this.fontCache.get(font.cacheKey);\n    }\n    const {\n      promise,\n      resolve\n    } = Promise.withResolvers();\n    let preEvaluatedFont;\n    try {\n      preEvaluatedFont = this.preEvaluateFont(font);\n      preEvaluatedFont.cssFontInfo = cssFontInfo;\n    } catch (reason) {\n      warn(`loadFont - preEvaluateFont failed: \"${reason}\".`);\n      return errorFont();\n    }\n    const {\n      descriptor,\n      hash\n    } = preEvaluatedFont;\n    const fontRefIsRef = fontRef instanceof Ref;\n    let fontID;\n    if (hash && descriptor instanceof Dict) {\n      const fontAliases = descriptor.fontAliases ||= Object.create(null);\n      if (fontAliases[hash]) {\n        const aliasFontRef = fontAliases[hash].aliasRef;\n        if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {\n          this.fontCache.putAlias(fontRef, aliasFontRef);\n          return this.fontCache.get(fontRef);\n        }\n      } else {\n        fontAliases[hash] = {\n          fontID: this.idFactory.createFontId()\n        };\n      }\n      if (fontRefIsRef) {\n        fontAliases[hash].aliasRef = fontRef;\n      }\n      fontID = fontAliases[hash].fontID;\n    } else {\n      fontID = this.idFactory.createFontId();\n    }\n    assert(fontID?.startsWith(\"f\"), 'The \"fontID\" must be (correctly) defined.');\n    if (fontRefIsRef) {\n      this.fontCache.put(fontRef, promise);\n    } else {\n      font.cacheKey = `cacheKey_${fontID}`;\n      this.fontCache.put(font.cacheKey, promise);\n    }\n    font.loadedName = `${this.idFactory.getDocId()}_${fontID}`;\n    this.translateFont(preEvaluatedFont).then(translatedFont => {\n      resolve(new TranslatedFont({\n        loadedName: font.loadedName,\n        font: translatedFont,\n        dict: font,\n        evaluatorOptions: this.options\n      }));\n    }).catch(reason => {\n      warn(`loadFont - translateFont failed: \"${reason}\".`);\n      resolve(new TranslatedFont({\n        loadedName: font.loadedName,\n        font: new ErrorFont(reason instanceof Error ? reason.message : reason),\n        dict: font,\n        evaluatorOptions: this.options\n      }));\n    });\n    return promise;\n  }\n  buildPath(operatorList, fn, args, parsingText = false) {\n    const lastIndex = operatorList.length - 1;\n    if (!args) {\n      args = [];\n    }\n    if (lastIndex < 0 || operatorList.fnArray[lastIndex] !== OPS.constructPath) {\n      if (parsingText) {\n        warn(`Encountered path operator \"${fn}\" inside of a text object.`);\n        operatorList.addOp(OPS.save, null);\n      }\n      let minMax;\n      switch (fn) {\n        case OPS.rectangle:\n          const x = args[0] + args[2];\n          const y = args[1] + args[3];\n          minMax = [Math.min(args[0], x), Math.min(args[1], y), Math.max(args[0], x), Math.max(args[1], y)];\n          break;\n        case OPS.moveTo:\n        case OPS.lineTo:\n          minMax = [args[0], args[1], args[0], args[1]];\n          break;\n        default:\n          minMax = [Infinity, Infinity, -Infinity, -Infinity];\n          break;\n      }\n      operatorList.addOp(OPS.constructPath, [[fn], args, minMax]);\n      if (parsingText) {\n        operatorList.addOp(OPS.restore, null);\n      }\n    } else {\n      const opArgs = operatorList.argsArray[lastIndex];\n      opArgs[0].push(fn);\n      opArgs[1].push(...args);\n      const minMax = opArgs[2];\n      switch (fn) {\n        case OPS.rectangle:\n          const x = args[0] + args[2];\n          const y = args[1] + args[3];\n          minMax[0] = Math.min(minMax[0], args[0], x);\n          minMax[1] = Math.min(minMax[1], args[1], y);\n          minMax[2] = Math.max(minMax[2], args[0], x);\n          minMax[3] = Math.max(minMax[3], args[1], y);\n          break;\n        case OPS.moveTo:\n        case OPS.lineTo:\n          minMax[0] = Math.min(minMax[0], args[0]);\n          minMax[1] = Math.min(minMax[1], args[1]);\n          minMax[2] = Math.max(minMax[2], args[0]);\n          minMax[3] = Math.max(minMax[3], args[1]);\n          break;\n      }\n    }\n  }\n  parseColorSpace({\n    cs,\n    resources,\n    localColorSpaceCache\n  }) {\n    return ColorSpace.parseAsync({\n      cs,\n      xref: this.xref,\n      resources,\n      pdfFunctionFactory: this._pdfFunctionFactory,\n      localColorSpaceCache\n    }).catch(reason => {\n      if (reason instanceof AbortException) {\n        return null;\n      }\n      if (this.options.ignoreErrors) {\n        warn(`parseColorSpace - ignoring ColorSpace: \"${reason}\".`);\n        return null;\n      }\n      throw reason;\n    });\n  }\n  parseShading({\n    shading,\n    resources,\n    localColorSpaceCache,\n    localShadingPatternCache\n  }) {\n    let id = localShadingPatternCache.get(shading);\n    if (id) {\n      return id;\n    }\n    let patternIR;\n    try {\n      const shadingFill = Pattern.parseShading(shading, this.xref, resources, this._pdfFunctionFactory, localColorSpaceCache);\n      patternIR = shadingFill.getIR();\n    } catch (reason) {\n      if (reason instanceof AbortException) {\n        return null;\n      }\n      if (this.options.ignoreErrors) {\n        warn(`parseShading - ignoring shading: \"${reason}\".`);\n        localShadingPatternCache.set(shading, null);\n        return null;\n      }\n      throw reason;\n    }\n    id = `pattern_${this.idFactory.createObjId()}`;\n    if (this.parsingType3Font) {\n      id = `${this.idFactory.getDocId()}_type3_${id}`;\n    }\n    localShadingPatternCache.set(shading, id);\n    if (this.parsingType3Font) {\n      this.handler.send(\"commonobj\", [id, \"Pattern\", patternIR]);\n    } else {\n      this.handler.send(\"obj\", [id, this.pageIndex, \"Pattern\", patternIR]);\n    }\n    return id;\n  }\n  handleColorN(operatorList, fn, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache) {\n    const patternName = args.pop();\n    if (patternName instanceof Name) {\n      const rawPattern = patterns.getRaw(patternName.name);\n      const localTilingPattern = rawPattern instanceof Ref && localTilingPatternCache.getByRef(rawPattern);\n      if (localTilingPattern) {\n        try {\n          const color = cs.base ? cs.base.getRgb(args, 0) : null;\n          const tilingPatternIR = getTilingPatternIR(localTilingPattern.operatorListIR, localTilingPattern.dict, color);\n          operatorList.addOp(fn, tilingPatternIR);\n          return undefined;\n        } catch {}\n      }\n      const pattern = this.xref.fetchIfRef(rawPattern);\n      if (pattern) {\n        const dict = pattern instanceof BaseStream ? pattern.dict : pattern;\n        const typeNum = dict.get(\"PatternType\");\n        if (typeNum === PatternType.TILING) {\n          const color = cs.base ? cs.base.getRgb(args, 0) : null;\n          return this.handleTilingType(fn, color, resources, pattern, dict, operatorList, task, localTilingPatternCache);\n        } else if (typeNum === PatternType.SHADING) {\n          const shading = dict.get(\"Shading\");\n          const objId = this.parseShading({\n            shading,\n            resources,\n            localColorSpaceCache,\n            localShadingPatternCache\n          });\n          if (objId) {\n            const matrix = dict.getArray(\"Matrix\");\n            operatorList.addOp(fn, [\"Shading\", objId, matrix]);\n          }\n          return undefined;\n        }\n        throw new FormatError(`Unknown PatternType: ${typeNum}`);\n      }\n    }\n    throw new FormatError(`Unknown PatternName: ${patternName}`);\n  }\n  _parseVisibilityExpression(array, nestingCounter, currentResult) {\n    const MAX_NESTING = 10;\n    if (++nestingCounter > MAX_NESTING) {\n      warn(\"Visibility expression is too deeply nested\");\n      return;\n    }\n    const length = array.length;\n    const operator = this.xref.fetchIfRef(array[0]);\n    if (length < 2 || !(operator instanceof Name)) {\n      warn(\"Invalid visibility expression\");\n      return;\n    }\n    switch (operator.name) {\n      case \"And\":\n      case \"Or\":\n      case \"Not\":\n        currentResult.push(operator.name);\n        break;\n      default:\n        warn(`Invalid operator ${operator.name} in visibility expression`);\n        return;\n    }\n    for (let i = 1; i < length; i++) {\n      const raw = array[i];\n      const object = this.xref.fetchIfRef(raw);\n      if (Array.isArray(object)) {\n        const nestedResult = [];\n        currentResult.push(nestedResult);\n        this._parseVisibilityExpression(object, nestingCounter, nestedResult);\n      } else if (raw instanceof Ref) {\n        currentResult.push(raw.toString());\n      }\n    }\n  }\n  async parseMarkedContentProps(contentProperties, resources) {\n    let optionalContent;\n    if (contentProperties instanceof Name) {\n      const properties = resources.get(\"Properties\");\n      optionalContent = properties.get(contentProperties.name);\n    } else if (contentProperties instanceof Dict) {\n      optionalContent = contentProperties;\n    } else {\n      throw new FormatError(\"Optional content properties malformed.\");\n    }\n    const optionalContentType = optionalContent.get(\"Type\")?.name;\n    if (optionalContentType === \"OCG\") {\n      return {\n        type: optionalContentType,\n        id: optionalContent.objId\n      };\n    } else if (optionalContentType === \"OCMD\") {\n      const expression = optionalContent.get(\"VE\");\n      if (Array.isArray(expression)) {\n        const result = [];\n        this._parseVisibilityExpression(expression, 0, result);\n        if (result.length > 0) {\n          return {\n            type: \"OCMD\",\n            expression: result\n          };\n        }\n      }\n      const optionalContentGroups = optionalContent.get(\"OCGs\");\n      if (Array.isArray(optionalContentGroups) || optionalContentGroups instanceof Dict) {\n        const groupIds = [];\n        if (Array.isArray(optionalContentGroups)) {\n          for (const ocg of optionalContentGroups) {\n            groupIds.push(ocg.toString());\n          }\n        } else {\n          groupIds.push(optionalContentGroups.objId);\n        }\n        return {\n          type: optionalContentType,\n          ids: groupIds,\n          policy: optionalContent.get(\"P\") instanceof Name ? optionalContent.get(\"P\").name : null,\n          expression: null\n        };\n      } else if (optionalContentGroups instanceof Ref) {\n        return {\n          type: optionalContentType,\n          id: optionalContentGroups.toString()\n        };\n      }\n    }\n    return null;\n  }\n  getOperatorList({\n    stream,\n    task,\n    resources,\n    operatorList,\n    initialState = null,\n    fallbackFontDict = null\n  }) {\n    resources ||= Dict.empty;\n    initialState ||= new EvalState();\n    if (!operatorList) {\n      throw new Error('getOperatorList: missing \"operatorList\" parameter');\n    }\n    const self = this;\n    const xref = this.xref;\n    let parsingText = false;\n    const localImageCache = new LocalImageCache();\n    const localColorSpaceCache = new LocalColorSpaceCache();\n    const localGStateCache = new LocalGStateCache();\n    const localTilingPatternCache = new LocalTilingPatternCache();\n    const localShadingPatternCache = new Map();\n    const xobjs = resources.get(\"XObject\") || Dict.empty;\n    const patterns = resources.get(\"Pattern\") || Dict.empty;\n    const stateManager = new StateManager(initialState);\n    const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);\n    const timeSlotManager = new TimeSlotManager();\n    function closePendingRestoreOPS(argument) {\n      for (let i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {\n        operatorList.addOp(OPS.restore, []);\n      }\n    }\n    return new Promise(function promiseBody(resolve, reject) {\n      const next = function (promise) {\n        Promise.all([promise, operatorList.ready]).then(function () {\n          try {\n            promiseBody(resolve, reject);\n          } catch (ex) {\n            reject(ex);\n          }\n        }, reject);\n      };\n      task.ensureNotTerminated();\n      timeSlotManager.reset();\n      const operation = {};\n      let stop, i, ii, cs, name, isValidName;\n      while (!(stop = timeSlotManager.check())) {\n        operation.args = null;\n        if (!preprocessor.read(operation)) {\n          break;\n        }\n        let args = operation.args;\n        let fn = operation.fn;\n        switch (fn | 0) {\n          case OPS.paintXObject:\n            isValidName = args[0] instanceof Name;\n            name = args[0].name;\n            if (isValidName) {\n              const localImage = localImageCache.getByName(name);\n              if (localImage) {\n                operatorList.addImageOps(localImage.fn, localImage.args, localImage.optionalContent);\n                incrementCachedImageMaskCount(localImage);\n                args = null;\n                continue;\n              }\n            }\n            next(new Promise(function (resolveXObject, rejectXObject) {\n              if (!isValidName) {\n                throw new FormatError(\"XObject must be referred to by name.\");\n              }\n              let xobj = xobjs.getRaw(name);\n              if (xobj instanceof Ref) {\n                const localImage = localImageCache.getByRef(xobj) || self._regionalImageCache.getByRef(xobj);\n                if (localImage) {\n                  operatorList.addImageOps(localImage.fn, localImage.args, localImage.optionalContent);\n                  incrementCachedImageMaskCount(localImage);\n                  resolveXObject();\n                  return;\n                }\n                const globalImage = self.globalImageCache.getData(xobj, self.pageIndex);\n                if (globalImage) {\n                  operatorList.addDependency(globalImage.objId);\n                  operatorList.addImageOps(globalImage.fn, globalImage.args, globalImage.optionalContent);\n                  resolveXObject();\n                  return;\n                }\n                xobj = xref.fetch(xobj);\n              }\n              if (!(xobj instanceof BaseStream)) {\n                throw new FormatError(\"XObject should be a stream\");\n              }\n              const type = xobj.dict.get(\"Subtype\");\n              if (!(type instanceof Name)) {\n                throw new FormatError(\"XObject should have a Name subtype\");\n              }\n              if (type.name === \"Form\") {\n                stateManager.save();\n                self.buildFormXObject(resources, xobj, null, operatorList, task, stateManager.state.clone(), localColorSpaceCache).then(function () {\n                  stateManager.restore();\n                  resolveXObject();\n                }, rejectXObject);\n                return;\n              } else if (type.name === \"Image\") {\n                self.buildPaintImageXObject({\n                  resources,\n                  image: xobj,\n                  operatorList,\n                  cacheKey: name,\n                  localImageCache,\n                  localColorSpaceCache\n                }).then(resolveXObject, rejectXObject);\n                return;\n              } else if (type.name === \"PS\") {\n                info(\"Ignored XObject subtype PS\");\n              } else {\n                throw new FormatError(`Unhandled XObject subtype ${type.name}`);\n              }\n              resolveXObject();\n            }).catch(function (reason) {\n              if (reason instanceof AbortException) {\n                return;\n              }\n              if (self.options.ignoreErrors) {\n                warn(`getOperatorList - ignoring XObject: \"${reason}\".`);\n                return;\n              }\n              throw reason;\n            }));\n            return;\n          case OPS.setFont:\n            var fontSize = args[1];\n            next(self.handleSetFont(resources, args, null, operatorList, task, stateManager.state, fallbackFontDict).then(function (loadedName) {\n              operatorList.addDependency(loadedName);\n              operatorList.addOp(OPS.setFont, [loadedName, fontSize]);\n            }));\n            return;\n          case OPS.beginText:\n            parsingText = true;\n            break;\n          case OPS.endText:\n            parsingText = false;\n            break;\n          case OPS.endInlineImage:\n            var cacheKey = args[0].cacheKey;\n            if (cacheKey) {\n              const localImage = localImageCache.getByName(cacheKey);\n              if (localImage) {\n                operatorList.addImageOps(localImage.fn, localImage.args, localImage.optionalContent);\n                incrementCachedImageMaskCount(localImage);\n                args = null;\n                continue;\n              }\n            }\n            next(self.buildPaintImageXObject({\n              resources,\n              image: args[0],\n              isInline: true,\n              operatorList,\n              cacheKey,\n              localImageCache,\n              localColorSpaceCache\n            }));\n            return;\n          case OPS.showText:\n            if (!stateManager.state.font) {\n              self.ensureStateFont(stateManager.state);\n              continue;\n            }\n            args[0] = self.handleText(args[0], stateManager.state);\n            break;\n          case OPS.showSpacedText:\n            if (!stateManager.state.font) {\n              self.ensureStateFont(stateManager.state);\n              continue;\n            }\n            var combinedGlyphs = [];\n            var state = stateManager.state;\n            for (const arrItem of args[0]) {\n              if (typeof arrItem === \"string\") {\n                combinedGlyphs.push(...self.handleText(arrItem, state));\n              } else if (typeof arrItem === \"number\") {\n                combinedGlyphs.push(arrItem);\n              }\n            }\n            args[0] = combinedGlyphs;\n            fn = OPS.showText;\n            break;\n          case OPS.nextLineShowText:\n            if (!stateManager.state.font) {\n              self.ensureStateFont(stateManager.state);\n              continue;\n            }\n            operatorList.addOp(OPS.nextLine);\n            args[0] = self.handleText(args[0], stateManager.state);\n            fn = OPS.showText;\n            break;\n          case OPS.nextLineSetSpacingShowText:\n            if (!stateManager.state.font) {\n              self.ensureStateFont(stateManager.state);\n              continue;\n            }\n            operatorList.addOp(OPS.nextLine);\n            operatorList.addOp(OPS.setWordSpacing, [args.shift()]);\n            operatorList.addOp(OPS.setCharSpacing, [args.shift()]);\n            args[0] = self.handleText(args[0], stateManager.state);\n            fn = OPS.showText;\n            break;\n          case OPS.setTextRenderingMode:\n            stateManager.state.textRenderingMode = args[0];\n            break;\n          case OPS.setFillColorSpace:\n            {\n              const cachedColorSpace = ColorSpace.getCached(args[0], xref, localColorSpaceCache);\n              if (cachedColorSpace) {\n                stateManager.state.fillColorSpace = cachedColorSpace;\n                continue;\n              }\n              next(self.parseColorSpace({\n                cs: args[0],\n                resources,\n                localColorSpaceCache\n              }).then(function (colorSpace) {\n                if (colorSpace) {\n                  stateManager.state.fillColorSpace = colorSpace;\n                }\n              }));\n              return;\n            }\n          case OPS.setStrokeColorSpace:\n            {\n              const cachedColorSpace = ColorSpace.getCached(args[0], xref, localColorSpaceCache);\n              if (cachedColorSpace) {\n                stateManager.state.strokeColorSpace = cachedColorSpace;\n                continue;\n              }\n              next(self.parseColorSpace({\n                cs: args[0],\n                resources,\n                localColorSpaceCache\n              }).then(function (colorSpace) {\n                if (colorSpace) {\n                  stateManager.state.strokeColorSpace = colorSpace;\n                }\n              }));\n              return;\n            }\n          case OPS.setFillColor:\n            cs = stateManager.state.fillColorSpace;\n            args = cs.getRgb(args, 0);\n            fn = OPS.setFillRGBColor;\n            break;\n          case OPS.setStrokeColor:\n            cs = stateManager.state.strokeColorSpace;\n            args = cs.getRgb(args, 0);\n            fn = OPS.setStrokeRGBColor;\n            break;\n          case OPS.setFillGray:\n            stateManager.state.fillColorSpace = ColorSpace.singletons.gray;\n            args = ColorSpace.singletons.gray.getRgb(args, 0);\n            fn = OPS.setFillRGBColor;\n            break;\n          case OPS.setStrokeGray:\n            stateManager.state.strokeColorSpace = ColorSpace.singletons.gray;\n            args = ColorSpace.singletons.gray.getRgb(args, 0);\n            fn = OPS.setStrokeRGBColor;\n            break;\n          case OPS.setFillCMYKColor:\n            stateManager.state.fillColorSpace = ColorSpace.singletons.cmyk;\n            args = ColorSpace.singletons.cmyk.getRgb(args, 0);\n            fn = OPS.setFillRGBColor;\n            break;\n          case OPS.setStrokeCMYKColor:\n            stateManager.state.strokeColorSpace = ColorSpace.singletons.cmyk;\n            args = ColorSpace.singletons.cmyk.getRgb(args, 0);\n            fn = OPS.setStrokeRGBColor;\n            break;\n          case OPS.setFillRGBColor:\n            stateManager.state.fillColorSpace = ColorSpace.singletons.rgb;\n            args = ColorSpace.singletons.rgb.getRgb(args, 0);\n            break;\n          case OPS.setStrokeRGBColor:\n            stateManager.state.strokeColorSpace = ColorSpace.singletons.rgb;\n            args = ColorSpace.singletons.rgb.getRgb(args, 0);\n            break;\n          case OPS.setFillColorN:\n            cs = stateManager.state.fillColorSpace;\n            if (cs.name === \"Pattern\") {\n              next(self.handleColorN(operatorList, OPS.setFillColorN, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache));\n              return;\n            }\n            args = cs.getRgb(args, 0);\n            fn = OPS.setFillRGBColor;\n            break;\n          case OPS.setStrokeColorN:\n            cs = stateManager.state.strokeColorSpace;\n            if (cs.name === \"Pattern\") {\n              next(self.handleColorN(operatorList, OPS.setStrokeColorN, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache));\n              return;\n            }\n            args = cs.getRgb(args, 0);\n            fn = OPS.setStrokeRGBColor;\n            break;\n          case OPS.shadingFill:\n            var shadingRes = resources.get(\"Shading\");\n            if (!shadingRes) {\n              throw new FormatError(\"No shading resource found\");\n            }\n            var shading = shadingRes.get(args[0].name);\n            if (!shading) {\n              throw new FormatError(\"No shading object found\");\n            }\n            const patternId = self.parseShading({\n              shading,\n              resources,\n              localColorSpaceCache,\n              localShadingPatternCache\n            });\n            if (!patternId) {\n              continue;\n            }\n            args = [patternId];\n            fn = OPS.shadingFill;\n            break;\n          case OPS.setGState:\n            isValidName = args[0] instanceof Name;\n            name = args[0].name;\n            if (isValidName) {\n              const localGStateObj = localGStateCache.getByName(name);\n              if (localGStateObj) {\n                if (localGStateObj.length > 0) {\n                  operatorList.addOp(OPS.setGState, [localGStateObj]);\n                }\n                args = null;\n                continue;\n              }\n            }\n            next(new Promise(function (resolveGState, rejectGState) {\n              if (!isValidName) {\n                throw new FormatError(\"GState must be referred to by name.\");\n              }\n              const extGState = resources.get(\"ExtGState\");\n              if (!(extGState instanceof Dict)) {\n                throw new FormatError(\"ExtGState should be a dictionary.\");\n              }\n              const gState = extGState.get(name);\n              if (!(gState instanceof Dict)) {\n                throw new FormatError(\"GState should be a dictionary.\");\n              }\n              self.setGState({\n                resources,\n                gState,\n                operatorList,\n                cacheKey: name,\n                task,\n                stateManager,\n                localGStateCache,\n                localColorSpaceCache\n              }).then(resolveGState, rejectGState);\n            }).catch(function (reason) {\n              if (reason instanceof AbortException) {\n                return;\n              }\n              if (self.options.ignoreErrors) {\n                warn(`getOperatorList - ignoring ExtGState: \"${reason}\".`);\n                return;\n              }\n              throw reason;\n            }));\n            return;\n          case OPS.moveTo:\n          case OPS.lineTo:\n          case OPS.curveTo:\n          case OPS.curveTo2:\n          case OPS.curveTo3:\n          case OPS.closePath:\n          case OPS.rectangle:\n            self.buildPath(operatorList, fn, args, parsingText);\n            continue;\n          case OPS.markPoint:\n          case OPS.markPointProps:\n          case OPS.beginCompat:\n          case OPS.endCompat:\n            continue;\n          case OPS.beginMarkedContentProps:\n            if (!(args[0] instanceof Name)) {\n              warn(`Expected name for beginMarkedContentProps arg0=${args[0]}`);\n              operatorList.addOp(OPS.beginMarkedContentProps, [\"OC\", null]);\n              continue;\n            }\n            if (args[0].name === \"OC\") {\n              next(self.parseMarkedContentProps(args[1], resources).then(data => {\n                operatorList.addOp(OPS.beginMarkedContentProps, [\"OC\", data]);\n              }).catch(reason => {\n                if (reason instanceof AbortException) {\n                  return;\n                }\n                if (self.options.ignoreErrors) {\n                  warn(`getOperatorList - ignoring beginMarkedContentProps: \"${reason}\".`);\n                  operatorList.addOp(OPS.beginMarkedContentProps, [\"OC\", null]);\n                  return;\n                }\n                throw reason;\n              }));\n              return;\n            }\n            args = [args[0].name, args[1] instanceof Dict ? args[1].get(\"MCID\") : null];\n            break;\n          case OPS.beginMarkedContent:\n          case OPS.endMarkedContent:\n          default:\n            if (args !== null) {\n              for (i = 0, ii = args.length; i < ii; i++) {\n                if (args[i] instanceof Dict) {\n                  break;\n                }\n              }\n              if (i < ii) {\n                warn(\"getOperatorList - ignoring operator: \" + fn);\n                continue;\n              }\n            }\n        }\n        operatorList.addOp(fn, args);\n      }\n      if (stop) {\n        next(deferred);\n        return;\n      }\n      closePendingRestoreOPS();\n      resolve();\n    }).catch(reason => {\n      if (reason instanceof AbortException) {\n        return;\n      }\n      if (this.options.ignoreErrors) {\n        warn(`getOperatorList - ignoring errors during \"${task.name}\" ` + `task: \"${reason}\".`);\n        closePendingRestoreOPS();\n        return;\n      }\n      throw reason;\n    });\n  }\n  getTextContent({\n    stream,\n    task,\n    resources,\n    stateManager = null,\n    includeMarkedContent = false,\n    sink,\n    seenStyles = new Set(),\n    viewBox,\n    markedContentData = null,\n    disableNormalization = false,\n    keepWhiteSpace = false\n  }) {\n    resources ||= Dict.empty;\n    stateManager ||= new StateManager(new TextState());\n    if (includeMarkedContent) {\n      markedContentData ||= {\n        level: 0\n      };\n    }\n    const textContent = {\n      items: [],\n      styles: Object.create(null)\n    };\n    const textContentItem = {\n      initialized: false,\n      str: [],\n      totalWidth: 0,\n      totalHeight: 0,\n      width: 0,\n      height: 0,\n      vertical: false,\n      prevTransform: null,\n      textAdvanceScale: 0,\n      spaceInFlowMin: 0,\n      spaceInFlowMax: 0,\n      trackingSpaceMin: Infinity,\n      negativeSpaceMax: -Infinity,\n      notASpace: -Infinity,\n      transform: null,\n      fontName: null,\n      hasEOL: false\n    };\n    const twoLastChars = [\" \", \" \"];\n    let twoLastCharsPos = 0;\n    function saveLastChar(char) {\n      const nextPos = (twoLastCharsPos + 1) % 2;\n      const ret = twoLastChars[twoLastCharsPos] !== \" \" && twoLastChars[nextPos] === \" \";\n      twoLastChars[twoLastCharsPos] = char;\n      twoLastCharsPos = nextPos;\n      return !keepWhiteSpace && ret;\n    }\n    function shouldAddWhitepsace() {\n      return !keepWhiteSpace && twoLastChars[twoLastCharsPos] !== \" \" && twoLastChars[(twoLastCharsPos + 1) % 2] === \" \";\n    }\n    function resetLastChars() {\n      twoLastChars[0] = twoLastChars[1] = \" \";\n      twoLastCharsPos = 0;\n    }\n    const TRACKING_SPACE_FACTOR = 0.102;\n    const NOT_A_SPACE_FACTOR = 0.03;\n    const NEGATIVE_SPACE_FACTOR = -0.2;\n    const SPACE_IN_FLOW_MIN_FACTOR = 0.102;\n    const SPACE_IN_FLOW_MAX_FACTOR = 0.6;\n    const VERTICAL_SHIFT_RATIO = 0.25;\n    const self = this;\n    const xref = this.xref;\n    const showSpacedTextBuffer = [];\n    let xobjs = null;\n    const emptyXObjectCache = new LocalImageCache();\n    const emptyGStateCache = new LocalGStateCache();\n    const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);\n    let textState;\n    function pushWhitespace({\n      width = 0,\n      height = 0,\n      transform = textContentItem.prevTransform,\n      fontName = textContentItem.fontName\n    }) {\n      textContent.items.push({\n        str: \" \",\n        dir: \"ltr\",\n        width,\n        height,\n        transform,\n        fontName,\n        hasEOL: false\n      });\n    }\n    function getCurrentTextTransform() {\n      const font = textState.font;\n      const tsm = [textState.fontSize * textState.textHScale, 0, 0, textState.fontSize, 0, textState.textRise];\n      if (font.isType3Font && (textState.fontSize <= 1 || font.isCharBBox) && !isArrayEqual(textState.fontMatrix, FONT_IDENTITY_MATRIX)) {\n        const glyphHeight = font.bbox[3] - font.bbox[1];\n        if (glyphHeight > 0) {\n          tsm[3] *= glyphHeight * textState.fontMatrix[3];\n        }\n      }\n      return Util.transform(textState.ctm, Util.transform(textState.textMatrix, tsm));\n    }\n    function ensureTextContentItem() {\n      if (textContentItem.initialized) {\n        return textContentItem;\n      }\n      const {\n        font,\n        loadedName\n      } = textState;\n      if (!seenStyles.has(loadedName)) {\n        seenStyles.add(loadedName);\n        textContent.styles[loadedName] = {\n          fontFamily: font.fallbackName,\n          ascent: font.ascent,\n          descent: font.descent,\n          vertical: font.vertical\n        };\n        if (self.options.fontExtraProperties && font.systemFontInfo) {\n          const style = textContent.styles[loadedName];\n          style.fontSubstitution = font.systemFontInfo.css;\n          style.fontSubstitutionLoadedName = font.systemFontInfo.loadedName;\n        }\n      }\n      textContentItem.fontName = loadedName;\n      const trm = textContentItem.transform = getCurrentTextTransform();\n      if (!font.vertical) {\n        textContentItem.width = textContentItem.totalWidth = 0;\n        textContentItem.height = textContentItem.totalHeight = Math.hypot(trm[2], trm[3]);\n        textContentItem.vertical = false;\n      } else {\n        textContentItem.width = textContentItem.totalWidth = Math.hypot(trm[0], trm[1]);\n        textContentItem.height = textContentItem.totalHeight = 0;\n        textContentItem.vertical = true;\n      }\n      const scaleLineX = Math.hypot(textState.textLineMatrix[0], textState.textLineMatrix[1]);\n      const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);\n      textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;\n      const {\n        fontSize\n      } = textState;\n      textContentItem.trackingSpaceMin = fontSize * TRACKING_SPACE_FACTOR;\n      textContentItem.notASpace = fontSize * NOT_A_SPACE_FACTOR;\n      textContentItem.negativeSpaceMax = fontSize * NEGATIVE_SPACE_FACTOR;\n      textContentItem.spaceInFlowMin = fontSize * SPACE_IN_FLOW_MIN_FACTOR;\n      textContentItem.spaceInFlowMax = fontSize * SPACE_IN_FLOW_MAX_FACTOR;\n      textContentItem.hasEOL = false;\n      textContentItem.initialized = true;\n      return textContentItem;\n    }\n    function updateAdvanceScale() {\n      if (!textContentItem.initialized) {\n        return;\n      }\n      const scaleLineX = Math.hypot(textState.textLineMatrix[0], textState.textLineMatrix[1]);\n      const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);\n      const scaleFactor = scaleCtmX * scaleLineX;\n      if (scaleFactor === textContentItem.textAdvanceScale) {\n        return;\n      }\n      if (!textContentItem.vertical) {\n        textContentItem.totalWidth += textContentItem.width * textContentItem.textAdvanceScale;\n        textContentItem.width = 0;\n      } else {\n        textContentItem.totalHeight += textContentItem.height * textContentItem.textAdvanceScale;\n        textContentItem.height = 0;\n      }\n      textContentItem.textAdvanceScale = scaleFactor;\n    }\n    function runBidiTransform(textChunk) {\n      let text = textChunk.str.join(\"\");\n      if (!disableNormalization) {\n        text = normalizeUnicode(text);\n      }\n      const bidiResult = bidi(text, -1, textChunk.vertical);\n      return {\n        str: bidiResult.str,\n        dir: bidiResult.dir,\n        width: Math.abs(textChunk.totalWidth),\n        height: Math.abs(textChunk.totalHeight),\n        transform: textChunk.transform,\n        fontName: textChunk.fontName,\n        hasEOL: textChunk.hasEOL\n      };\n    }\n    async function handleSetFont(fontName, fontRef) {\n      const translated = await self.loadFont(fontName, fontRef, resources);\n      if (translated.font.isType3Font) {\n        try {\n          await translated.loadType3Data(self, resources, task);\n        } catch {}\n      }\n      textState.loadedName = translated.loadedName;\n      textState.font = translated.font;\n      textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;\n    }\n    function applyInverseRotation(x, y, matrix) {\n      const scale = Math.hypot(matrix[0], matrix[1]);\n      return [(matrix[0] * x + matrix[1] * y) / scale, (matrix[2] * x + matrix[3] * y) / scale];\n    }\n    function compareWithLastPosition(glyphWidth) {\n      const currentTransform = getCurrentTextTransform();\n      let posX = currentTransform[4];\n      let posY = currentTransform[5];\n      if (textState.font?.vertical) {\n        if (posX < viewBox[0] || posX > viewBox[2] || posY + glyphWidth < viewBox[1] || posY > viewBox[3]) {\n          return false;\n        }\n      } else if (posX + glyphWidth < viewBox[0] || posX > viewBox[2] || posY < viewBox[1] || posY > viewBox[3]) {\n        return false;\n      }\n      if (!textState.font || !textContentItem.prevTransform) {\n        return true;\n      }\n      let lastPosX = textContentItem.prevTransform[4];\n      let lastPosY = textContentItem.prevTransform[5];\n      if (lastPosX === posX && lastPosY === posY) {\n        return true;\n      }\n      let rotate = -1;\n      if (currentTransform[0] && currentTransform[1] === 0 && currentTransform[2] === 0) {\n        rotate = currentTransform[0] > 0 ? 0 : 180;\n      } else if (currentTransform[1] && currentTransform[0] === 0 && currentTransform[3] === 0) {\n        rotate = currentTransform[1] > 0 ? 90 : 270;\n      }\n      switch (rotate) {\n        case 0:\n          break;\n        case 90:\n          [posX, posY] = [posY, posX];\n          [lastPosX, lastPosY] = [lastPosY, lastPosX];\n          break;\n        case 180:\n          [posX, posY, lastPosX, lastPosY] = [-posX, -posY, -lastPosX, -lastPosY];\n          break;\n        case 270:\n          [posX, posY] = [-posY, -posX];\n          [lastPosX, lastPosY] = [-lastPosY, -lastPosX];\n          break;\n        default:\n          [posX, posY] = applyInverseRotation(posX, posY, currentTransform);\n          [lastPosX, lastPosY] = applyInverseRotation(lastPosX, lastPosY, textContentItem.prevTransform);\n      }\n      if (textState.font.vertical) {\n        const advanceY = (lastPosY - posY) / textContentItem.textAdvanceScale;\n        const advanceX = posX - lastPosX;\n        const textOrientation = Math.sign(textContentItem.height);\n        if (advanceY < textOrientation * textContentItem.negativeSpaceMax) {\n          if (Math.abs(advanceX) > 0.5 * textContentItem.width) {\n            appendEOL();\n            return true;\n          }\n          resetLastChars();\n          flushTextContentItem();\n          return true;\n        }\n        if (Math.abs(advanceX) > textContentItem.width) {\n          appendEOL();\n          return true;\n        }\n        if (advanceY <= textOrientation * textContentItem.notASpace) {\n          resetLastChars();\n        }\n        if (advanceY <= textOrientation * textContentItem.trackingSpaceMin) {\n          if (shouldAddWhitepsace()) {\n            resetLastChars();\n            flushTextContentItem();\n            pushWhitespace({\n              height: Math.abs(advanceY)\n            });\n          } else {\n            textContentItem.height += advanceY;\n          }\n        } else if (!addFakeSpaces(advanceY, textContentItem.prevTransform, textOrientation)) {\n          if (textContentItem.str.length === 0) {\n            resetLastChars();\n            pushWhitespace({\n              height: Math.abs(advanceY)\n            });\n          } else {\n            textContentItem.height += advanceY;\n          }\n        }\n        if (Math.abs(advanceX) > textContentItem.width * VERTICAL_SHIFT_RATIO) {\n          flushTextContentItem();\n        }\n        return true;\n      }\n      const advanceX = (posX - lastPosX) / textContentItem.textAdvanceScale;\n      const advanceY = posY - lastPosY;\n      const textOrientation = Math.sign(textContentItem.width);\n      if (advanceX < textOrientation * textContentItem.negativeSpaceMax) {\n        if (Math.abs(advanceY) > 0.5 * textContentItem.height) {\n          appendEOL();\n          return true;\n        }\n        resetLastChars();\n        flushTextContentItem();\n        return true;\n      }\n      if (Math.abs(advanceY) > textContentItem.height) {\n        appendEOL();\n        return true;\n      }\n      if (advanceX <= textOrientation * textContentItem.notASpace) {\n        resetLastChars();\n      }\n      if (advanceX <= textOrientation * textContentItem.trackingSpaceMin) {\n        if (shouldAddWhitepsace()) {\n          resetLastChars();\n          flushTextContentItem();\n          pushWhitespace({\n            width: Math.abs(advanceX)\n          });\n        } else {\n          textContentItem.width += advanceX;\n        }\n      } else if (!addFakeSpaces(advanceX, textContentItem.prevTransform, textOrientation)) {\n        if (textContentItem.str.length === 0) {\n          resetLastChars();\n          pushWhitespace({\n            width: Math.abs(advanceX)\n          });\n        } else {\n          textContentItem.width += advanceX;\n        }\n      }\n      if (Math.abs(advanceY) > textContentItem.height * VERTICAL_SHIFT_RATIO) {\n        flushTextContentItem();\n      }\n      return true;\n    }\n    function buildTextContentItem({\n      chars,\n      extraSpacing\n    }) {\n      const font = textState.font;\n      if (!chars) {\n        const charSpacing = textState.charSpacing + extraSpacing;\n        if (charSpacing) {\n          if (!font.vertical) {\n            textState.translateTextMatrix(charSpacing * textState.textHScale, 0);\n          } else {\n            textState.translateTextMatrix(0, -charSpacing);\n          }\n        }\n        if (keepWhiteSpace) {\n          compareWithLastPosition(0);\n        }\n        return;\n      }\n      const glyphs = font.charsToGlyphs(chars);\n      const scale = textState.fontMatrix[0] * textState.fontSize;\n      for (let i = 0, ii = glyphs.length; i < ii; i++) {\n        const glyph = glyphs[i];\n        const {\n          category\n        } = glyph;\n        if (category.isInvisibleFormatMark) {\n          continue;\n        }\n        let charSpacing = textState.charSpacing + (i + 1 === ii ? extraSpacing : 0);\n        let glyphWidth = glyph.width;\n        if (font.vertical) {\n          glyphWidth = glyph.vmetric ? glyph.vmetric[0] : -glyphWidth;\n        }\n        let scaledDim = glyphWidth * scale;\n        if (!keepWhiteSpace && category.isWhitespace) {\n          if (!font.vertical) {\n            charSpacing += scaledDim + textState.wordSpacing;\n            textState.translateTextMatrix(charSpacing * textState.textHScale, 0);\n          } else {\n            charSpacing += -scaledDim + textState.wordSpacing;\n            textState.translateTextMatrix(0, -charSpacing);\n          }\n          saveLastChar(\" \");\n          continue;\n        }\n        if (!category.isZeroWidthDiacritic && !compareWithLastPosition(scaledDim)) {\n          if (!font.vertical) {\n            textState.translateTextMatrix(scaledDim * textState.textHScale, 0);\n          } else {\n            textState.translateTextMatrix(0, scaledDim);\n          }\n          continue;\n        }\n        const textChunk = ensureTextContentItem();\n        if (category.isZeroWidthDiacritic) {\n          scaledDim = 0;\n        }\n        if (!font.vertical) {\n          scaledDim *= textState.textHScale;\n          textState.translateTextMatrix(scaledDim, 0);\n          textChunk.width += scaledDim;\n        } else {\n          textState.translateTextMatrix(0, scaledDim);\n          scaledDim = Math.abs(scaledDim);\n          textChunk.height += scaledDim;\n        }\n        if (scaledDim) {\n          textChunk.prevTransform = getCurrentTextTransform();\n        }\n        const glyphUnicode = glyph.unicode;\n        if (saveLastChar(glyphUnicode)) {\n          textChunk.str.push(\" \");\n        }\n        textChunk.str.push(glyphUnicode);\n        if (charSpacing) {\n          if (!font.vertical) {\n            textState.translateTextMatrix(charSpacing * textState.textHScale, 0);\n          } else {\n            textState.translateTextMatrix(0, -charSpacing);\n          }\n        }\n      }\n    }\n    function appendEOL() {\n      resetLastChars();\n      if (textContentItem.initialized) {\n        textContentItem.hasEOL = true;\n        flushTextContentItem();\n      } else {\n        textContent.items.push({\n          str: \"\",\n          dir: \"ltr\",\n          width: 0,\n          height: 0,\n          transform: getCurrentTextTransform(),\n          fontName: textState.loadedName,\n          hasEOL: true\n        });\n      }\n    }\n    function addFakeSpaces(width, transf, textOrientation) {\n      if (textOrientation * textContentItem.spaceInFlowMin <= width && width <= textOrientation * textContentItem.spaceInFlowMax) {\n        if (textContentItem.initialized) {\n          resetLastChars();\n          textContentItem.str.push(\" \");\n        }\n        return false;\n      }\n      const fontName = textContentItem.fontName;\n      let height = 0;\n      if (textContentItem.vertical) {\n        height = width;\n        width = 0;\n      }\n      flushTextContentItem();\n      resetLastChars();\n      pushWhitespace({\n        width: Math.abs(width),\n        height: Math.abs(height),\n        transform: transf || getCurrentTextTransform(),\n        fontName\n      });\n      return true;\n    }\n    function flushTextContentItem() {\n      if (!textContentItem.initialized || !textContentItem.str) {\n        return;\n      }\n      if (!textContentItem.vertical) {\n        textContentItem.totalWidth += textContentItem.width * textContentItem.textAdvanceScale;\n      } else {\n        textContentItem.totalHeight += textContentItem.height * textContentItem.textAdvanceScale;\n      }\n      textContent.items.push(runBidiTransform(textContentItem));\n      textContentItem.initialized = false;\n      textContentItem.str.length = 0;\n    }\n    function enqueueChunk(batch = false) {\n      const length = textContent.items.length;\n      if (length === 0) {\n        return;\n      }\n      if (batch && length < TEXT_CHUNK_BATCH_SIZE) {\n        return;\n      }\n      sink.enqueue(textContent, length);\n      textContent.items = [];\n      textContent.styles = Object.create(null);\n    }\n    const timeSlotManager = new TimeSlotManager();\n    return new Promise(function promiseBody(resolve, reject) {\n      const next = function (promise) {\n        enqueueChunk(true);\n        Promise.all([promise, sink.ready]).then(function () {\n          try {\n            promiseBody(resolve, reject);\n          } catch (ex) {\n            reject(ex);\n          }\n        }, reject);\n      };\n      task.ensureNotTerminated();\n      timeSlotManager.reset();\n      const operation = {};\n      let stop,\n        args = [];\n      while (!(stop = timeSlotManager.check())) {\n        args.length = 0;\n        operation.args = args;\n        if (!preprocessor.read(operation)) {\n          break;\n        }\n        const previousState = textState;\n        textState = stateManager.state;\n        const fn = operation.fn;\n        args = operation.args;\n        switch (fn | 0) {\n          case OPS.setFont:\n            var fontNameArg = args[0].name,\n              fontSizeArg = args[1];\n            if (textState.font && fontNameArg === textState.fontName && fontSizeArg === textState.fontSize) {\n              break;\n            }\n            flushTextContentItem();\n            textState.fontName = fontNameArg;\n            textState.fontSize = fontSizeArg;\n            next(handleSetFont(fontNameArg, null));\n            return;\n          case OPS.setTextRise:\n            textState.textRise = args[0];\n            break;\n          case OPS.setHScale:\n            textState.textHScale = args[0] / 100;\n            break;\n          case OPS.setLeading:\n            textState.leading = args[0];\n            break;\n          case OPS.moveText:\n            textState.translateTextLineMatrix(args[0], args[1]);\n            textState.textMatrix = textState.textLineMatrix.slice();\n            break;\n          case OPS.setLeadingMoveText:\n            textState.leading = -args[1];\n            textState.translateTextLineMatrix(args[0], args[1]);\n            textState.textMatrix = textState.textLineMatrix.slice();\n            break;\n          case OPS.nextLine:\n            textState.carriageReturn();\n            break;\n          case OPS.setTextMatrix:\n            textState.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);\n            textState.setTextLineMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);\n            updateAdvanceScale();\n            break;\n          case OPS.setCharSpacing:\n            textState.charSpacing = args[0];\n            break;\n          case OPS.setWordSpacing:\n            textState.wordSpacing = args[0];\n            break;\n          case OPS.beginText:\n            textState.textMatrix = IDENTITY_MATRIX.slice();\n            textState.textLineMatrix = IDENTITY_MATRIX.slice();\n            break;\n          case OPS.showSpacedText:\n            if (!stateManager.state.font) {\n              self.ensureStateFont(stateManager.state);\n              continue;\n            }\n            const spaceFactor = (textState.font.vertical ? 1 : -1) * textState.fontSize / 1000;\n            const elements = args[0];\n            for (let i = 0, ii = elements.length; i < ii; i++) {\n              const item = elements[i];\n              if (typeof item === \"string\") {\n                showSpacedTextBuffer.push(item);\n              } else if (typeof item === \"number\" && item !== 0) {\n                const str = showSpacedTextBuffer.join(\"\");\n                showSpacedTextBuffer.length = 0;\n                buildTextContentItem({\n                  chars: str,\n                  extraSpacing: item * spaceFactor\n                });\n              }\n            }\n            if (showSpacedTextBuffer.length > 0) {\n              const str = showSpacedTextBuffer.join(\"\");\n              showSpacedTextBuffer.length = 0;\n              buildTextContentItem({\n                chars: str,\n                extraSpacing: 0\n              });\n            }\n            break;\n          case OPS.showText:\n            if (!stateManager.state.font) {\n              self.ensureStateFont(stateManager.state);\n              continue;\n            }\n            buildTextContentItem({\n              chars: args[0],\n              extraSpacing: 0\n            });\n            break;\n          case OPS.nextLineShowText:\n            if (!stateManager.state.font) {\n              self.ensureStateFont(stateManager.state);\n              continue;\n            }\n            textState.carriageReturn();\n            buildTextContentItem({\n              chars: args[0],\n              extraSpacing: 0\n            });\n            break;\n          case OPS.nextLineSetSpacingShowText:\n            if (!stateManager.state.font) {\n              self.ensureStateFont(stateManager.state);\n              continue;\n            }\n            textState.wordSpacing = args[0];\n            textState.charSpacing = args[1];\n            textState.carriageReturn();\n            buildTextContentItem({\n              chars: args[2],\n              extraSpacing: 0\n            });\n            break;\n          case OPS.paintXObject:\n            flushTextContentItem();\n            if (!xobjs) {\n              xobjs = resources.get(\"XObject\") || Dict.empty;\n            }\n            var isValidName = args[0] instanceof Name;\n            var name = args[0].name;\n            if (isValidName && emptyXObjectCache.getByName(name)) {\n              break;\n            }\n            next(new Promise(function (resolveXObject, rejectXObject) {\n              if (!isValidName) {\n                throw new FormatError(\"XObject must be referred to by name.\");\n              }\n              let xobj = xobjs.getRaw(name);\n              if (xobj instanceof Ref) {\n                if (emptyXObjectCache.getByRef(xobj)) {\n                  resolveXObject();\n                  return;\n                }\n                const globalImage = self.globalImageCache.getData(xobj, self.pageIndex);\n                if (globalImage) {\n                  resolveXObject();\n                  return;\n                }\n                xobj = xref.fetch(xobj);\n              }\n              if (!(xobj instanceof BaseStream)) {\n                throw new FormatError(\"XObject should be a stream\");\n              }\n              const type = xobj.dict.get(\"Subtype\");\n              if (!(type instanceof Name)) {\n                throw new FormatError(\"XObject should have a Name subtype\");\n              }\n              if (type.name !== \"Form\") {\n                emptyXObjectCache.set(name, xobj.dict.objId, true);\n                resolveXObject();\n                return;\n              }\n              const currentState = stateManager.state.clone();\n              const xObjStateManager = new StateManager(currentState);\n              const matrix = xobj.dict.getArray(\"Matrix\");\n              if (Array.isArray(matrix) && matrix.length === 6) {\n                xObjStateManager.transform(matrix);\n              }\n              enqueueChunk();\n              const sinkWrapper = {\n                enqueueInvoked: false,\n                enqueue(chunk, size) {\n                  this.enqueueInvoked = true;\n                  sink.enqueue(chunk, size);\n                },\n                get desiredSize() {\n                  return sink.desiredSize;\n                },\n                get ready() {\n                  return sink.ready;\n                }\n              };\n              self.getTextContent({\n                stream: xobj,\n                task,\n                resources: xobj.dict.get(\"Resources\") || resources,\n                stateManager: xObjStateManager,\n                includeMarkedContent,\n                sink: sinkWrapper,\n                seenStyles,\n                viewBox,\n                markedContentData,\n                disableNormalization,\n                keepWhiteSpace\n              }).then(function () {\n                if (!sinkWrapper.enqueueInvoked) {\n                  emptyXObjectCache.set(name, xobj.dict.objId, true);\n                }\n                resolveXObject();\n              }, rejectXObject);\n            }).catch(function (reason) {\n              if (reason instanceof AbortException) {\n                return;\n              }\n              if (self.options.ignoreErrors) {\n                warn(`getTextContent - ignoring XObject: \"${reason}\".`);\n                return;\n              }\n              throw reason;\n            }));\n            return;\n          case OPS.setGState:\n            isValidName = args[0] instanceof Name;\n            name = args[0].name;\n            if (isValidName && emptyGStateCache.getByName(name)) {\n              break;\n            }\n            next(new Promise(function (resolveGState, rejectGState) {\n              if (!isValidName) {\n                throw new FormatError(\"GState must be referred to by name.\");\n              }\n              const extGState = resources.get(\"ExtGState\");\n              if (!(extGState instanceof Dict)) {\n                throw new FormatError(\"ExtGState should be a dictionary.\");\n              }\n              const gState = extGState.get(name);\n              if (!(gState instanceof Dict)) {\n                throw new FormatError(\"GState should be a dictionary.\");\n              }\n              const gStateFont = gState.get(\"Font\");\n              if (!gStateFont) {\n                emptyGStateCache.set(name, gState.objId, true);\n                resolveGState();\n                return;\n              }\n              flushTextContentItem();\n              textState.fontName = null;\n              textState.fontSize = gStateFont[1];\n              handleSetFont(null, gStateFont[0]).then(resolveGState, rejectGState);\n            }).catch(function (reason) {\n              if (reason instanceof AbortException) {\n                return;\n              }\n              if (self.options.ignoreErrors) {\n                warn(`getTextContent - ignoring ExtGState: \"${reason}\".`);\n                return;\n              }\n              throw reason;\n            }));\n            return;\n          case OPS.beginMarkedContent:\n            flushTextContentItem();\n            if (includeMarkedContent) {\n              markedContentData.level++;\n              textContent.items.push({\n                type: \"beginMarkedContent\",\n                tag: args[0] instanceof Name ? args[0].name : null\n              });\n            }\n            break;\n          case OPS.beginMarkedContentProps:\n            flushTextContentItem();\n            if (includeMarkedContent) {\n              markedContentData.level++;\n              let mcid = null;\n              if (args[1] instanceof Dict) {\n                mcid = args[1].get(\"MCID\");\n              }\n              textContent.items.push({\n                type: \"beginMarkedContentProps\",\n                id: Number.isInteger(mcid) ? `${self.idFactory.getPageObjId()}_mc${mcid}` : null,\n                tag: args[0] instanceof Name ? args[0].name : null\n              });\n            }\n            break;\n          case OPS.endMarkedContent:\n            flushTextContentItem();\n            if (includeMarkedContent) {\n              if (markedContentData.level === 0) {\n                break;\n              }\n              markedContentData.level--;\n              textContent.items.push({\n                type: \"endMarkedContent\"\n              });\n            }\n            break;\n          case OPS.restore:\n            if (previousState && (previousState.font !== textState.font || previousState.fontSize !== textState.fontSize || previousState.fontName !== textState.fontName)) {\n              flushTextContentItem();\n            }\n            break;\n        }\n        if (textContent.items.length >= sink.desiredSize) {\n          stop = true;\n          break;\n        }\n      }\n      if (stop) {\n        next(deferred);\n        return;\n      }\n      flushTextContentItem();\n      enqueueChunk();\n      resolve();\n    }).catch(reason => {\n      if (reason instanceof AbortException) {\n        return;\n      }\n      if (this.options.ignoreErrors) {\n        warn(`getTextContent - ignoring errors during \"${task.name}\" ` + `task: \"${reason}\".`);\n        flushTextContentItem();\n        enqueueChunk();\n        return;\n      }\n      throw reason;\n    });\n  }\n  async extractDataStructures(dict, properties) {\n    const xref = this.xref;\n    let cidToGidBytes;\n    const toUnicodePromise = this.readToUnicode(properties.toUnicode);\n    if (properties.composite) {\n      const cidSystemInfo = dict.get(\"CIDSystemInfo\");\n      if (cidSystemInfo instanceof Dict) {\n        properties.cidSystemInfo = {\n          registry: stringToPDFString(cidSystemInfo.get(\"Registry\")),\n          ordering: stringToPDFString(cidSystemInfo.get(\"Ordering\")),\n          supplement: cidSystemInfo.get(\"Supplement\")\n        };\n      }\n      try {\n        const cidToGidMap = dict.get(\"CIDToGIDMap\");\n        if (cidToGidMap instanceof BaseStream) {\n          cidToGidBytes = cidToGidMap.getBytes();\n        }\n      } catch (ex) {\n        if (!this.options.ignoreErrors) {\n          throw ex;\n        }\n        warn(`extractDataStructures - ignoring CIDToGIDMap data: \"${ex}\".`);\n      }\n    }\n    const differences = [];\n    let baseEncodingName = null;\n    let encoding;\n    if (dict.has(\"Encoding\")) {\n      encoding = dict.get(\"Encoding\");\n      if (encoding instanceof Dict) {\n        baseEncodingName = encoding.get(\"BaseEncoding\");\n        baseEncodingName = baseEncodingName instanceof Name ? baseEncodingName.name : null;\n        if (encoding.has(\"Differences\")) {\n          const diffEncoding = encoding.get(\"Differences\");\n          let index = 0;\n          for (const entry of diffEncoding) {\n            const data = xref.fetchIfRef(entry);\n            if (typeof data === \"number\") {\n              index = data;\n            } else if (data instanceof Name) {\n              differences[index++] = data.name;\n            } else {\n              throw new FormatError(`Invalid entry in 'Differences' array: ${data}`);\n            }\n          }\n        }\n      } else if (encoding instanceof Name) {\n        baseEncodingName = encoding.name;\n      } else {\n        const msg = \"Encoding is not a Name nor a Dict\";\n        if (!this.options.ignoreErrors) {\n          throw new FormatError(msg);\n        }\n        warn(msg);\n      }\n      if (baseEncodingName !== \"MacRomanEncoding\" && baseEncodingName !== \"MacExpertEncoding\" && baseEncodingName !== \"WinAnsiEncoding\") {\n        baseEncodingName = null;\n      }\n    }\n    const nonEmbeddedFont = !properties.file || properties.isInternalFont,\n      isSymbolsFontName = getSymbolsFonts()[properties.name];\n    if (baseEncodingName && nonEmbeddedFont && isSymbolsFontName) {\n      baseEncodingName = null;\n    }\n    if (baseEncodingName) {\n      properties.defaultEncoding = getEncoding(baseEncodingName);\n    } else {\n      const isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);\n      const isNonsymbolicFont = !!(properties.flags & FontFlags.Nonsymbolic);\n      encoding = StandardEncoding;\n      if (properties.type === \"TrueType\" && !isNonsymbolicFont) {\n        encoding = WinAnsiEncoding;\n      }\n      if (isSymbolicFont || isSymbolsFontName) {\n        encoding = MacRomanEncoding;\n        if (nonEmbeddedFont) {\n          if (/Symbol/i.test(properties.name)) {\n            encoding = SymbolSetEncoding;\n          } else if (/Dingbats/i.test(properties.name)) {\n            encoding = ZapfDingbatsEncoding;\n          } else if (/Wingdings/i.test(properties.name)) {\n            encoding = WinAnsiEncoding;\n          }\n        }\n      }\n      properties.defaultEncoding = encoding;\n    }\n    properties.differences = differences;\n    properties.baseEncodingName = baseEncodingName;\n    properties.hasEncoding = !!baseEncodingName || differences.length > 0;\n    properties.dict = dict;\n    properties.toUnicode = await toUnicodePromise;\n    const builtToUnicode = await this.buildToUnicode(properties);\n    properties.toUnicode = builtToUnicode;\n    if (cidToGidBytes) {\n      properties.cidToGidMap = this.readCidToGidMap(cidToGidBytes, builtToUnicode);\n    }\n    return properties;\n  }\n  _simpleFontToUnicode(properties, forceGlyphs = false) {\n    assert(!properties.composite, \"Must be a simple font.\");\n    const toUnicode = [];\n    const encoding = properties.defaultEncoding.slice();\n    const baseEncodingName = properties.baseEncodingName;\n    const differences = properties.differences;\n    for (const charcode in differences) {\n      const glyphName = differences[charcode];\n      if (glyphName === \".notdef\") {\n        continue;\n      }\n      encoding[charcode] = glyphName;\n    }\n    const glyphsUnicodeMap = getGlyphsUnicode();\n    for (const charcode in encoding) {\n      let glyphName = encoding[charcode];\n      if (glyphName === \"\") {\n        continue;\n      }\n      let unicode = glyphsUnicodeMap[glyphName];\n      if (unicode !== undefined) {\n        toUnicode[charcode] = String.fromCharCode(unicode);\n        continue;\n      }\n      let code = 0;\n      switch (glyphName[0]) {\n        case \"G\":\n          if (glyphName.length === 3) {\n            code = parseInt(glyphName.substring(1), 16);\n          }\n          break;\n        case \"g\":\n          if (glyphName.length === 5) {\n            code = parseInt(glyphName.substring(1), 16);\n          }\n          break;\n        case \"C\":\n        case \"c\":\n          if (glyphName.length >= 3 && glyphName.length <= 4) {\n            const codeStr = glyphName.substring(1);\n            if (forceGlyphs) {\n              code = parseInt(codeStr, 16);\n              break;\n            }\n            code = +codeStr;\n            if (Number.isNaN(code) && Number.isInteger(parseInt(codeStr, 16))) {\n              return this._simpleFontToUnicode(properties, true);\n            }\n          }\n          break;\n        case \"u\":\n          unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);\n          if (unicode !== -1) {\n            code = unicode;\n          }\n          break;\n        default:\n          switch (glyphName) {\n            case \"f_h\":\n            case \"f_t\":\n            case \"T_h\":\n              toUnicode[charcode] = glyphName.replaceAll(\"_\", \"\");\n              continue;\n          }\n          break;\n      }\n      if (code > 0 && code <= 0x10ffff && Number.isInteger(code)) {\n        if (baseEncodingName && code === +charcode) {\n          const baseEncoding = getEncoding(baseEncodingName);\n          if (baseEncoding && (glyphName = baseEncoding[charcode])) {\n            toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]);\n            continue;\n          }\n        }\n        toUnicode[charcode] = String.fromCodePoint(code);\n      }\n    }\n    return toUnicode;\n  }\n  async buildToUnicode(properties) {\n    properties.hasIncludedToUnicodeMap = properties.toUnicode?.length > 0;\n    if (properties.hasIncludedToUnicodeMap) {\n      if (!properties.composite && properties.hasEncoding) {\n        properties.fallbackToUnicode = this._simpleFontToUnicode(properties);\n      }\n      return properties.toUnicode;\n    }\n    if (!properties.composite) {\n      return new ToUnicodeMap(this._simpleFontToUnicode(properties));\n    }\n    if (properties.composite && (properties.cMap.builtInCMap && !(properties.cMap instanceof IdentityCMap) || properties.cidSystemInfo?.registry === \"Adobe\" && (properties.cidSystemInfo.ordering === \"GB1\" || properties.cidSystemInfo.ordering === \"CNS1\" || properties.cidSystemInfo.ordering === \"Japan1\" || properties.cidSystemInfo.ordering === \"Korea1\"))) {\n      const {\n        registry,\n        ordering\n      } = properties.cidSystemInfo;\n      const ucs2CMapName = Name.get(`${registry}-${ordering}-UCS2`);\n      const ucs2CMap = await CMapFactory.create({\n        encoding: ucs2CMapName,\n        fetchBuiltInCMap: this._fetchBuiltInCMapBound,\n        useCMap: null\n      });\n      const toUnicode = [],\n        buf = [];\n      properties.cMap.forEach(function (charcode, cid) {\n        if (cid > 0xffff) {\n          throw new FormatError(\"Max size of CID is 65,535\");\n        }\n        const ucs2 = ucs2CMap.lookup(cid);\n        if (ucs2) {\n          buf.length = 0;\n          for (let i = 0, ii = ucs2.length; i < ii; i += 2) {\n            buf.push((ucs2.charCodeAt(i) << 8) + ucs2.charCodeAt(i + 1));\n          }\n          toUnicode[charcode] = String.fromCharCode(...buf);\n        }\n      });\n      return new ToUnicodeMap(toUnicode);\n    }\n    return new IdentityToUnicodeMap(properties.firstChar, properties.lastChar);\n  }\n  async readToUnicode(cmapObj) {\n    if (!cmapObj) {\n      return null;\n    }\n    if (cmapObj instanceof Name) {\n      const cmap = await CMapFactory.create({\n        encoding: cmapObj,\n        fetchBuiltInCMap: this._fetchBuiltInCMapBound,\n        useCMap: null\n      });\n      if (cmap instanceof IdentityCMap) {\n        return new IdentityToUnicodeMap(0, 0xffff);\n      }\n      return new ToUnicodeMap(cmap.getMap());\n    }\n    if (cmapObj instanceof BaseStream) {\n      try {\n        const cmap = await CMapFactory.create({\n          encoding: cmapObj,\n          fetchBuiltInCMap: this._fetchBuiltInCMapBound,\n          useCMap: null\n        });\n        if (cmap instanceof IdentityCMap) {\n          return new IdentityToUnicodeMap(0, 0xffff);\n        }\n        const map = new Array(cmap.length);\n        cmap.forEach(function (charCode, token) {\n          if (typeof token === \"number\") {\n            map[charCode] = String.fromCodePoint(token);\n            return;\n          }\n          const str = [];\n          for (let k = 0; k < token.length; k += 2) {\n            const w1 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);\n            if ((w1 & 0xf800) !== 0xd800) {\n              str.push(w1);\n              continue;\n            }\n            k += 2;\n            const w2 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);\n            str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);\n          }\n          map[charCode] = String.fromCodePoint(...str);\n        });\n        return new ToUnicodeMap(map);\n      } catch (reason) {\n        if (reason instanceof AbortException) {\n          return null;\n        }\n        if (this.options.ignoreErrors) {\n          warn(`readToUnicode - ignoring ToUnicode data: \"${reason}\".`);\n          return null;\n        }\n        throw reason;\n      }\n    }\n    return null;\n  }\n  readCidToGidMap(glyphsData, toUnicode) {\n    const result = [];\n    for (let j = 0, jj = glyphsData.length; j < jj; j++) {\n      const glyphID = glyphsData[j++] << 8 | glyphsData[j];\n      const code = j >> 1;\n      if (glyphID === 0 && !toUnicode.has(code)) {\n        continue;\n      }\n      result[code] = glyphID;\n    }\n    return result;\n  }\n  extractWidths(dict, descriptor, properties) {\n    const xref = this.xref;\n    let glyphsWidths = [];\n    let defaultWidth = 0;\n    const glyphsVMetrics = [];\n    let defaultVMetrics;\n    if (properties.composite) {\n      const dw = dict.get(\"DW\");\n      defaultWidth = Number.isInteger(dw) ? dw : 1000;\n      const widths = dict.get(\"W\");\n      if (Array.isArray(widths)) {\n        for (let i = 0, ii = widths.length; i < ii; i++) {\n          let start = xref.fetchIfRef(widths[i++]);\n          if (!Number.isInteger(start)) {\n            break;\n          }\n          const code = xref.fetchIfRef(widths[i]);\n          if (Array.isArray(code)) {\n            for (const c of code) {\n              const width = xref.fetchIfRef(c);\n              if (typeof width === \"number\") {\n                glyphsWidths[start] = width;\n              }\n              start++;\n            }\n          } else if (Number.isInteger(code)) {\n            const width = xref.fetchIfRef(widths[++i]);\n            if (typeof width !== \"number\") {\n              continue;\n            }\n            for (let j = start; j <= code; j++) {\n              glyphsWidths[j] = width;\n            }\n          } else {\n            break;\n          }\n        }\n      }\n      if (properties.vertical) {\n        const dw2 = dict.getArray(\"DW2\");\n        let vmetrics = isNumberArray(dw2, 2) ? dw2 : [880, -1000];\n        defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];\n        vmetrics = dict.get(\"W2\");\n        if (Array.isArray(vmetrics)) {\n          for (let i = 0, ii = vmetrics.length; i < ii; i++) {\n            let start = xref.fetchIfRef(vmetrics[i++]);\n            if (!Number.isInteger(start)) {\n              break;\n            }\n            const code = xref.fetchIfRef(vmetrics[i]);\n            if (Array.isArray(code)) {\n              for (let j = 0, jj = code.length; j < jj; j++) {\n                const vmetric = [xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j])];\n                if (isNumberArray(vmetric, null)) {\n                  glyphsVMetrics[start] = vmetric;\n                }\n                start++;\n              }\n            } else if (Number.isInteger(code)) {\n              const vmetric = [xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i])];\n              if (!isNumberArray(vmetric, null)) {\n                continue;\n              }\n              for (let j = start; j <= code; j++) {\n                glyphsVMetrics[j] = vmetric;\n              }\n            } else {\n              break;\n            }\n          }\n        }\n      }\n    } else {\n      const widths = dict.get(\"Widths\");\n      if (Array.isArray(widths)) {\n        let j = properties.firstChar;\n        for (const w of widths) {\n          const width = xref.fetchIfRef(w);\n          if (typeof width === \"number\") {\n            glyphsWidths[j] = width;\n          }\n          j++;\n        }\n        const missingWidth = descriptor.get(\"MissingWidth\");\n        defaultWidth = typeof missingWidth === \"number\" ? missingWidth : 0;\n      } else {\n        const baseFontName = dict.get(\"BaseFont\");\n        if (baseFontName instanceof Name) {\n          const metrics = this.getBaseFontMetrics(baseFontName.name);\n          glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);\n          defaultWidth = metrics.defaultWidth;\n        }\n      }\n    }\n    let isMonospace = true;\n    let firstWidth = defaultWidth;\n    for (const glyph in glyphsWidths) {\n      const glyphWidth = glyphsWidths[glyph];\n      if (!glyphWidth) {\n        continue;\n      }\n      if (!firstWidth) {\n        firstWidth = glyphWidth;\n        continue;\n      }\n      if (firstWidth !== glyphWidth) {\n        isMonospace = false;\n        break;\n      }\n    }\n    if (isMonospace) {\n      properties.flags |= FontFlags.FixedPitch;\n    } else {\n      properties.flags &= ~FontFlags.FixedPitch;\n    }\n    properties.defaultWidth = defaultWidth;\n    properties.widths = glyphsWidths;\n    properties.defaultVMetrics = defaultVMetrics;\n    properties.vmetrics = glyphsVMetrics;\n  }\n  isSerifFont(baseFontName) {\n    const fontNameWoStyle = baseFontName.split(\"-\", 1)[0];\n    return fontNameWoStyle in getSerifFonts() || /serif/gi.test(fontNameWoStyle);\n  }\n  getBaseFontMetrics(name) {\n    let defaultWidth = 0;\n    let widths = Object.create(null);\n    let monospace = false;\n    const stdFontMap = getStdFontMap();\n    let lookupName = stdFontMap[name] || name;\n    const Metrics = getMetrics();\n    if (!(lookupName in Metrics)) {\n      lookupName = this.isSerifFont(name) ? \"Times-Roman\" : \"Helvetica\";\n    }\n    const glyphWidths = Metrics[lookupName];\n    if (typeof glyphWidths === \"number\") {\n      defaultWidth = glyphWidths;\n      monospace = true;\n    } else {\n      widths = glyphWidths();\n    }\n    return {\n      defaultWidth,\n      monospace,\n      widths\n    };\n  }\n  buildCharCodeToWidth(widthsByGlyphName, properties) {\n    const widths = Object.create(null);\n    const differences = properties.differences;\n    const encoding = properties.defaultEncoding;\n    for (let charCode = 0; charCode < 256; charCode++) {\n      if (charCode in differences && widthsByGlyphName[differences[charCode]]) {\n        widths[charCode] = widthsByGlyphName[differences[charCode]];\n        continue;\n      }\n      if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {\n        widths[charCode] = widthsByGlyphName[encoding[charCode]];\n        continue;\n      }\n    }\n    return widths;\n  }\n  preEvaluateFont(dict) {\n    const baseDict = dict;\n    let type = dict.get(\"Subtype\");\n    if (!(type instanceof Name)) {\n      throw new FormatError(\"invalid font Subtype\");\n    }\n    let composite = false;\n    let hash;\n    if (type.name === \"Type0\") {\n      const df = dict.get(\"DescendantFonts\");\n      if (!df) {\n        throw new FormatError(\"Descendant fonts are not specified\");\n      }\n      dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;\n      if (!(dict instanceof Dict)) {\n        throw new FormatError(\"Descendant font is not a dictionary.\");\n      }\n      type = dict.get(\"Subtype\");\n      if (!(type instanceof Name)) {\n        throw new FormatError(\"invalid font Subtype\");\n      }\n      composite = true;\n    }\n    let firstChar = dict.get(\"FirstChar\");\n    if (!Number.isInteger(firstChar)) {\n      firstChar = 0;\n    }\n    let lastChar = dict.get(\"LastChar\");\n    if (!Number.isInteger(lastChar)) {\n      lastChar = composite ? 0xffff : 0xff;\n    }\n    const descriptor = dict.get(\"FontDescriptor\");\n    const toUnicode = dict.get(\"ToUnicode\") || baseDict.get(\"ToUnicode\");\n    if (descriptor) {\n      hash = new MurmurHash3_64();\n      const encoding = baseDict.getRaw(\"Encoding\");\n      if (encoding instanceof Name) {\n        hash.update(encoding.name);\n      } else if (encoding instanceof Ref) {\n        hash.update(encoding.toString());\n      } else if (encoding instanceof Dict) {\n        for (const entry of encoding.getRawValues()) {\n          if (entry instanceof Name) {\n            hash.update(entry.name);\n          } else if (entry instanceof Ref) {\n            hash.update(entry.toString());\n          } else if (Array.isArray(entry)) {\n            const diffLength = entry.length,\n              diffBuf = new Array(diffLength);\n            for (let j = 0; j < diffLength; j++) {\n              const diffEntry = entry[j];\n              if (diffEntry instanceof Name) {\n                diffBuf[j] = diffEntry.name;\n              } else if (typeof diffEntry === \"number\" || diffEntry instanceof Ref) {\n                diffBuf[j] = diffEntry.toString();\n              }\n            }\n            hash.update(diffBuf.join());\n          }\n        }\n      }\n      hash.update(`${firstChar}-${lastChar}`);\n      if (toUnicode instanceof BaseStream) {\n        const stream = toUnicode.str || toUnicode;\n        const uint8array = stream.buffer ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength) : new Uint8Array(stream.bytes.buffer, stream.start, stream.end - stream.start);\n        hash.update(uint8array);\n      } else if (toUnicode instanceof Name) {\n        hash.update(toUnicode.name);\n      }\n      const widths = dict.get(\"Widths\") || baseDict.get(\"Widths\");\n      if (Array.isArray(widths)) {\n        const widthsBuf = [];\n        for (const entry of widths) {\n          if (typeof entry === \"number\" || entry instanceof Ref) {\n            widthsBuf.push(entry.toString());\n          }\n        }\n        hash.update(widthsBuf.join());\n      }\n      if (composite) {\n        hash.update(\"compositeFont\");\n        const compositeWidths = dict.get(\"W\") || baseDict.get(\"W\");\n        if (Array.isArray(compositeWidths)) {\n          const widthsBuf = [];\n          for (const entry of compositeWidths) {\n            if (typeof entry === \"number\" || entry instanceof Ref) {\n              widthsBuf.push(entry.toString());\n            } else if (Array.isArray(entry)) {\n              const subWidthsBuf = [];\n              for (const element of entry) {\n                if (typeof element === \"number\" || element instanceof Ref) {\n                  subWidthsBuf.push(element.toString());\n                }\n              }\n              widthsBuf.push(`[${subWidthsBuf.join()}]`);\n            }\n          }\n          hash.update(widthsBuf.join());\n        }\n        const cidToGidMap = dict.getRaw(\"CIDToGIDMap\") || baseDict.getRaw(\"CIDToGIDMap\");\n        if (cidToGidMap instanceof Name) {\n          hash.update(cidToGidMap.name);\n        } else if (cidToGidMap instanceof Ref) {\n          hash.update(cidToGidMap.toString());\n        } else if (cidToGidMap instanceof BaseStream) {\n          hash.update(cidToGidMap.peekBytes());\n        }\n      }\n    }\n    return {\n      descriptor,\n      dict,\n      baseDict,\n      composite,\n      type: type.name,\n      firstChar,\n      lastChar,\n      toUnicode,\n      hash: hash ? hash.hexdigest() : \"\"\n    };\n  }\n  async translateFont({\n    descriptor,\n    dict,\n    baseDict,\n    composite,\n    type,\n    firstChar,\n    lastChar,\n    toUnicode,\n    cssFontInfo\n  }) {\n    const isType3Font = type === \"Type3\";\n    if (!descriptor) {\n      if (isType3Font) {\n        let bbox = dict.getArray(\"FontBBox\");\n        if (!isNumberArray(bbox, 4)) {\n          bbox = [0, 0, 0, 0];\n        }\n        descriptor = new Dict(null);\n        descriptor.set(\"FontName\", Name.get(type));\n        descriptor.set(\"FontBBox\", bbox);\n      } else {\n        let baseFontName = dict.get(\"BaseFont\");\n        if (!(baseFontName instanceof Name)) {\n          throw new FormatError(\"Base font is not specified\");\n        }\n        baseFontName = baseFontName.name.replaceAll(/[,_]/g, \"-\");\n        const metrics = this.getBaseFontMetrics(baseFontName);\n        const fontNameWoStyle = baseFontName.split(\"-\", 1)[0];\n        const flags = (this.isSerifFont(fontNameWoStyle) ? FontFlags.Serif : 0) | (metrics.monospace ? FontFlags.FixedPitch : 0) | (getSymbolsFonts()[fontNameWoStyle] ? FontFlags.Symbolic : FontFlags.Nonsymbolic);\n        const properties = {\n          type,\n          name: baseFontName,\n          loadedName: baseDict.loadedName,\n          systemFontInfo: null,\n          widths: metrics.widths,\n          defaultWidth: metrics.defaultWidth,\n          isSimulatedFlags: true,\n          flags,\n          firstChar,\n          lastChar,\n          toUnicode,\n          xHeight: 0,\n          capHeight: 0,\n          italicAngle: 0,\n          isType3Font\n        };\n        const widths = dict.get(\"Widths\");\n        const standardFontName = getStandardFontName(baseFontName);\n        let file = null;\n        if (standardFontName) {\n          file = await this.fetchStandardFontData(standardFontName);\n          properties.isInternalFont = !!file;\n        }\n        if (!properties.isInternalFont && this.options.useSystemFonts) {\n          properties.systemFontInfo = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, baseFontName, standardFontName, type);\n        }\n        const newProperties = await this.extractDataStructures(dict, properties);\n        if (widths) {\n          const glyphWidths = [];\n          let j = firstChar;\n          for (const width of widths) {\n            glyphWidths[j++] = this.xref.fetchIfRef(width);\n          }\n          newProperties.widths = glyphWidths;\n        } else {\n          newProperties.widths = this.buildCharCodeToWidth(metrics.widths, newProperties);\n        }\n        return new Font(baseFontName, file, newProperties);\n      }\n    }\n    let fontName = descriptor.get(\"FontName\");\n    let baseFont = dict.get(\"BaseFont\");\n    if (typeof fontName === \"string\") {\n      fontName = Name.get(fontName);\n    }\n    if (typeof baseFont === \"string\") {\n      baseFont = Name.get(baseFont);\n    }\n    const fontNameStr = fontName?.name;\n    const baseFontStr = baseFont?.name;\n    if (!isType3Font && fontNameStr !== baseFontStr) {\n      info(`The FontDescriptor's FontName is \"${fontNameStr}\" but ` + `should be the same as the Font's BaseFont \"${baseFontStr}\".`);\n      if (fontNameStr && baseFontStr && (baseFontStr.startsWith(fontNameStr) || !isKnownFontName(fontNameStr) && isKnownFontName(baseFontStr))) {\n        fontName = null;\n      }\n    }\n    fontName ||= baseFont;\n    if (!(fontName instanceof Name)) {\n      throw new FormatError(\"invalid font name\");\n    }\n    let fontFile, subtype, length1, length2, length3;\n    try {\n      fontFile = descriptor.get(\"FontFile\", \"FontFile2\", \"FontFile3\");\n    } catch (ex) {\n      if (!this.options.ignoreErrors) {\n        throw ex;\n      }\n      warn(`translateFont - fetching \"${fontName.name}\" font file: \"${ex}\".`);\n      fontFile = new NullStream();\n    }\n    let isInternalFont = false;\n    let glyphScaleFactors = null;\n    let systemFontInfo = null;\n    if (fontFile) {\n      if (fontFile.dict) {\n        const subtypeEntry = fontFile.dict.get(\"Subtype\");\n        if (subtypeEntry instanceof Name) {\n          subtype = subtypeEntry.name;\n        }\n        length1 = fontFile.dict.get(\"Length1\");\n        length2 = fontFile.dict.get(\"Length2\");\n        length3 = fontFile.dict.get(\"Length3\");\n      }\n    } else if (cssFontInfo) {\n      const standardFontName = getXfaFontName(fontName.name);\n      if (standardFontName) {\n        cssFontInfo.fontFamily = `${cssFontInfo.fontFamily}-PdfJS-XFA`;\n        cssFontInfo.metrics = standardFontName.metrics || null;\n        glyphScaleFactors = standardFontName.factors || null;\n        fontFile = await this.fetchStandardFontData(standardFontName.name);\n        isInternalFont = !!fontFile;\n        baseDict = dict = getXfaFontDict(fontName.name);\n        composite = true;\n      }\n    } else if (!isType3Font) {\n      const standardFontName = getStandardFontName(fontName.name);\n      if (standardFontName) {\n        fontFile = await this.fetchStandardFontData(standardFontName);\n        isInternalFont = !!fontFile;\n      }\n      if (!isInternalFont && this.options.useSystemFonts) {\n        systemFontInfo = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, fontName.name, standardFontName, type);\n      }\n    }\n    let fontMatrix = dict.getArray(\"FontMatrix\");\n    if (!isNumberArray(fontMatrix, 6)) {\n      fontMatrix = FONT_IDENTITY_MATRIX;\n    }\n    let bbox = descriptor.getArray(\"FontBBox\") || dict.getArray(\"FontBBox\");\n    if (!isNumberArray(bbox, 4)) {\n      bbox = undefined;\n    }\n    let ascent = descriptor.get(\"Ascent\");\n    if (typeof ascent !== \"number\") {\n      ascent = undefined;\n    }\n    let descent = descriptor.get(\"Descent\");\n    if (typeof descent !== \"number\") {\n      descent = undefined;\n    }\n    let xHeight = descriptor.get(\"XHeight\");\n    if (typeof xHeight !== \"number\") {\n      xHeight = 0;\n    }\n    let capHeight = descriptor.get(\"CapHeight\");\n    if (typeof capHeight !== \"number\") {\n      capHeight = 0;\n    }\n    let flags = descriptor.get(\"Flags\");\n    if (!Number.isInteger(flags)) {\n      flags = 0;\n    }\n    let italicAngle = descriptor.get(\"ItalicAngle\");\n    if (typeof italicAngle !== \"number\") {\n      italicAngle = 0;\n    }\n    const properties = {\n      type,\n      name: fontName.name,\n      subtype,\n      file: fontFile,\n      length1,\n      length2,\n      length3,\n      isInternalFont,\n      loadedName: baseDict.loadedName,\n      composite,\n      fixedPitch: false,\n      fontMatrix,\n      firstChar,\n      lastChar,\n      toUnicode,\n      bbox,\n      ascent,\n      descent,\n      xHeight,\n      capHeight,\n      flags,\n      italicAngle,\n      isType3Font,\n      cssFontInfo,\n      scaleFactors: glyphScaleFactors,\n      systemFontInfo\n    };\n    if (composite) {\n      const cidEncoding = baseDict.get(\"Encoding\");\n      if (cidEncoding instanceof Name) {\n        properties.cidEncoding = cidEncoding.name;\n      }\n      const cMap = await CMapFactory.create({\n        encoding: cidEncoding,\n        fetchBuiltInCMap: this._fetchBuiltInCMapBound,\n        useCMap: null\n      });\n      properties.cMap = cMap;\n      properties.vertical = properties.cMap.vertical;\n    }\n    const newProperties = await this.extractDataStructures(dict, properties);\n    this.extractWidths(dict, descriptor, newProperties);\n    return new Font(fontName.name, fontFile, newProperties);\n  }\n  static buildFontPaths(font, glyphs, handler, evaluatorOptions) {\n    function buildPath(fontChar) {\n      const glyphName = `${font.loadedName}_path_${fontChar}`;\n      try {\n        if (font.renderer.hasBuiltPath(fontChar)) {\n          return;\n        }\n        handler.send(\"commonobj\", [glyphName, \"FontPath\", font.renderer.getPathJs(fontChar)]);\n      } catch (reason) {\n        if (evaluatorOptions.ignoreErrors) {\n          warn(`buildFontPaths - ignoring ${glyphName} glyph: \"${reason}\".`);\n          return;\n        }\n        throw reason;\n      }\n    }\n    for (const glyph of glyphs) {\n      buildPath(glyph.fontChar);\n      const accent = glyph.accent;\n      if (accent?.fontChar) {\n        buildPath(accent.fontChar);\n      }\n    }\n  }\n  static get fallbackFontDict() {\n    const dict = new Dict();\n    dict.set(\"BaseFont\", Name.get(\"Helvetica\"));\n    dict.set(\"Type\", Name.get(\"FallbackType\"));\n    dict.set(\"Subtype\", Name.get(\"FallbackType\"));\n    dict.set(\"Encoding\", Name.get(\"WinAnsiEncoding\"));\n    return shadow(this, \"fallbackFontDict\", dict);\n  }\n}\nclass TranslatedFont {\n  constructor({\n    loadedName,\n    font,\n    dict,\n    evaluatorOptions\n  }) {\n    this.loadedName = loadedName;\n    this.font = font;\n    this.dict = dict;\n    this._evaluatorOptions = evaluatorOptions || DefaultPartialEvaluatorOptions;\n    this.type3Loaded = null;\n    this.type3Dependencies = font.isType3Font ? new Set() : null;\n    this.sent = false;\n  }\n  send(handler) {\n    if (this.sent) {\n      return;\n    }\n    this.sent = true;\n    handler.send(\"commonobj\", [this.loadedName, \"Font\", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]);\n  }\n  fallback(handler) {\n    if (!this.font.data) {\n      return;\n    }\n    this.font.disableFontFace = true;\n    PartialEvaluator.buildFontPaths(this.font, this.font.glyphCacheValues, handler, this._evaluatorOptions);\n  }\n  loadType3Data(evaluator, resources, task) {\n    if (this.type3Loaded) {\n      return this.type3Loaded;\n    }\n    if (!this.font.isType3Font) {\n      throw new Error(\"Must be a Type3 font.\");\n    }\n    const type3Evaluator = evaluator.clone({\n      ignoreErrors: false\n    });\n    type3Evaluator.parsingType3Font = true;\n    const type3FontRefs = new RefSet(evaluator.type3FontRefs);\n    if (this.dict.objId && !type3FontRefs.has(this.dict.objId)) {\n      type3FontRefs.put(this.dict.objId);\n    }\n    type3Evaluator.type3FontRefs = type3FontRefs;\n    const translatedFont = this.font,\n      type3Dependencies = this.type3Dependencies;\n    let loadCharProcsPromise = Promise.resolve();\n    const charProcs = this.dict.get(\"CharProcs\");\n    const fontResources = this.dict.get(\"Resources\") || resources;\n    const charProcOperatorList = Object.create(null);\n    const fontBBox = Util.normalizeRect(translatedFont.bbox || [0, 0, 0, 0]),\n      width = fontBBox[2] - fontBBox[0],\n      height = fontBBox[3] - fontBBox[1];\n    const fontBBoxSize = Math.hypot(width, height);\n    for (const key of charProcs.getKeys()) {\n      loadCharProcsPromise = loadCharProcsPromise.then(() => {\n        const glyphStream = charProcs.get(key);\n        const operatorList = new OperatorList();\n        return type3Evaluator.getOperatorList({\n          stream: glyphStream,\n          task,\n          resources: fontResources,\n          operatorList\n        }).then(() => {\n          if (operatorList.fnArray[0] === OPS.setCharWidthAndBounds) {\n            this._removeType3ColorOperators(operatorList, fontBBoxSize);\n          }\n          charProcOperatorList[key] = operatorList.getIR();\n          for (const dependency of operatorList.dependencies) {\n            type3Dependencies.add(dependency);\n          }\n        }).catch(function (reason) {\n          warn(`Type3 font resource \"${key}\" is not available.`);\n          const dummyOperatorList = new OperatorList();\n          charProcOperatorList[key] = dummyOperatorList.getIR();\n        });\n      });\n    }\n    this.type3Loaded = loadCharProcsPromise.then(() => {\n      translatedFont.charProcOperatorList = charProcOperatorList;\n      if (this._bbox) {\n        translatedFont.isCharBBox = true;\n        translatedFont.bbox = this._bbox;\n      }\n    });\n    return this.type3Loaded;\n  }\n  _removeType3ColorOperators(operatorList, fontBBoxSize = NaN) {\n    const charBBox = Util.normalizeRect(operatorList.argsArray[0].slice(2)),\n      width = charBBox[2] - charBBox[0],\n      height = charBBox[3] - charBBox[1];\n    const charBBoxSize = Math.hypot(width, height);\n    if (width === 0 || height === 0) {\n      operatorList.fnArray.splice(0, 1);\n      operatorList.argsArray.splice(0, 1);\n    } else if (fontBBoxSize === 0 || Math.round(charBBoxSize / fontBBoxSize) >= 10) {\n      if (!this._bbox) {\n        this._bbox = [Infinity, Infinity, -Infinity, -Infinity];\n      }\n      this._bbox[0] = Math.min(this._bbox[0], charBBox[0]);\n      this._bbox[1] = Math.min(this._bbox[1], charBBox[1]);\n      this._bbox[2] = Math.max(this._bbox[2], charBBox[2]);\n      this._bbox[3] = Math.max(this._bbox[3], charBBox[3]);\n    }\n    let i = 0,\n      ii = operatorList.length;\n    while (i < ii) {\n      switch (operatorList.fnArray[i]) {\n        case OPS.setCharWidthAndBounds:\n          break;\n        case OPS.setStrokeColorSpace:\n        case OPS.setFillColorSpace:\n        case OPS.setStrokeColor:\n        case OPS.setStrokeColorN:\n        case OPS.setFillColor:\n        case OPS.setFillColorN:\n        case OPS.setStrokeGray:\n        case OPS.setFillGray:\n        case OPS.setStrokeRGBColor:\n        case OPS.setFillRGBColor:\n        case OPS.setStrokeCMYKColor:\n        case OPS.setFillCMYKColor:\n        case OPS.shadingFill:\n        case OPS.setRenderingIntent:\n          operatorList.fnArray.splice(i, 1);\n          operatorList.argsArray.splice(i, 1);\n          ii--;\n          continue;\n        case OPS.setGState:\n          const [gStateObj] = operatorList.argsArray[i];\n          let j = 0,\n            jj = gStateObj.length;\n          while (j < jj) {\n            const [gStateKey] = gStateObj[j];\n            switch (gStateKey) {\n              case \"TR\":\n              case \"TR2\":\n              case \"HT\":\n              case \"BG\":\n              case \"BG2\":\n              case \"UCR\":\n              case \"UCR2\":\n                gStateObj.splice(j, 1);\n                jj--;\n                continue;\n            }\n            j++;\n          }\n          break;\n      }\n      i++;\n    }\n  }\n}\nclass StateManager {\n  constructor(initialState = new EvalState()) {\n    this.state = initialState;\n    this.stateStack = [];\n  }\n  save() {\n    const old = this.state;\n    this.stateStack.push(this.state);\n    this.state = old.clone();\n  }\n  restore() {\n    const prev = this.stateStack.pop();\n    if (prev) {\n      this.state = prev;\n    }\n  }\n  transform(args) {\n    this.state.ctm = Util.transform(this.state.ctm, args);\n  }\n}\nclass TextState {\n  constructor() {\n    this.ctm = new Float32Array(IDENTITY_MATRIX);\n    this.fontName = null;\n    this.fontSize = 0;\n    this.loadedName = null;\n    this.font = null;\n    this.fontMatrix = FONT_IDENTITY_MATRIX;\n    this.textMatrix = IDENTITY_MATRIX.slice();\n    this.textLineMatrix = IDENTITY_MATRIX.slice();\n    this.charSpacing = 0;\n    this.wordSpacing = 0;\n    this.leading = 0;\n    this.textHScale = 1;\n    this.textRise = 0;\n  }\n  setTextMatrix(a, b, c, d, e, f) {\n    const m = this.textMatrix;\n    m[0] = a;\n    m[1] = b;\n    m[2] = c;\n    m[3] = d;\n    m[4] = e;\n    m[5] = f;\n  }\n  setTextLineMatrix(a, b, c, d, e, f) {\n    const m = this.textLineMatrix;\n    m[0] = a;\n    m[1] = b;\n    m[2] = c;\n    m[3] = d;\n    m[4] = e;\n    m[5] = f;\n  }\n  translateTextMatrix(x, y) {\n    const m = this.textMatrix;\n    m[4] = m[0] * x + m[2] * y + m[4];\n    m[5] = m[1] * x + m[3] * y + m[5];\n  }\n  translateTextLineMatrix(x, y) {\n    const m = this.textLineMatrix;\n    m[4] = m[0] * x + m[2] * y + m[4];\n    m[5] = m[1] * x + m[3] * y + m[5];\n  }\n  carriageReturn() {\n    this.translateTextLineMatrix(0, -this.leading);\n    this.textMatrix = this.textLineMatrix.slice();\n  }\n  clone() {\n    const clone = Object.create(this);\n    clone.textMatrix = this.textMatrix.slice();\n    clone.textLineMatrix = this.textLineMatrix.slice();\n    clone.fontMatrix = this.fontMatrix.slice();\n    return clone;\n  }\n}\nclass EvalState {\n  constructor() {\n    this.ctm = new Float32Array(IDENTITY_MATRIX);\n    this.font = null;\n    this.textRenderingMode = TextRenderingMode.FILL;\n    this.fillColorSpace = ColorSpace.singletons.gray;\n    this.strokeColorSpace = ColorSpace.singletons.gray;\n  }\n  clone() {\n    return Object.create(this);\n  }\n}\nclass EvaluatorPreprocessor {\n  static get opMap() {\n    return shadow(this, \"opMap\", Object.assign(Object.create(null), {\n      w: {\n        id: OPS.setLineWidth,\n        numArgs: 1,\n        variableArgs: false\n      },\n      J: {\n        id: OPS.setLineCap,\n        numArgs: 1,\n        variableArgs: false\n      },\n      j: {\n        id: OPS.setLineJoin,\n        numArgs: 1,\n        variableArgs: false\n      },\n      M: {\n        id: OPS.setMiterLimit,\n        numArgs: 1,\n        variableArgs: false\n      },\n      d: {\n        id: OPS.setDash,\n        numArgs: 2,\n        variableArgs: false\n      },\n      ri: {\n        id: OPS.setRenderingIntent,\n        numArgs: 1,\n        variableArgs: false\n      },\n      i: {\n        id: OPS.setFlatness,\n        numArgs: 1,\n        variableArgs: false\n      },\n      gs: {\n        id: OPS.setGState,\n        numArgs: 1,\n        variableArgs: false\n      },\n      q: {\n        id: OPS.save,\n        numArgs: 0,\n        variableArgs: false\n      },\n      Q: {\n        id: OPS.restore,\n        numArgs: 0,\n        variableArgs: false\n      },\n      cm: {\n        id: OPS.transform,\n        numArgs: 6,\n        variableArgs: false\n      },\n      m: {\n        id: OPS.moveTo,\n        numArgs: 2,\n        variableArgs: false\n      },\n      l: {\n        id: OPS.lineTo,\n        numArgs: 2,\n        variableArgs: false\n      },\n      c: {\n        id: OPS.curveTo,\n        numArgs: 6,\n        variableArgs: false\n      },\n      v: {\n        id: OPS.curveTo2,\n        numArgs: 4,\n        variableArgs: false\n      },\n      y: {\n        id: OPS.curveTo3,\n        numArgs: 4,\n        variableArgs: false\n      },\n      h: {\n        id: OPS.closePath,\n        numArgs: 0,\n        variableArgs: false\n      },\n      re: {\n        id: OPS.rectangle,\n        numArgs: 4,\n        variableArgs: false\n      },\n      S: {\n        id: OPS.stroke,\n        numArgs: 0,\n        variableArgs: false\n      },\n      s: {\n        id: OPS.closeStroke,\n        numArgs: 0,\n        variableArgs: false\n      },\n      f: {\n        id: OPS.fill,\n        numArgs: 0,\n        variableArgs: false\n      },\n      F: {\n        id: OPS.fill,\n        numArgs: 0,\n        variableArgs: false\n      },\n      \"f*\": {\n        id: OPS.eoFill,\n        numArgs: 0,\n        variableArgs: false\n      },\n      B: {\n        id: OPS.fillStroke,\n        numArgs: 0,\n        variableArgs: false\n      },\n      \"B*\": {\n        id: OPS.eoFillStroke,\n        numArgs: 0,\n        variableArgs: false\n      },\n      b: {\n        id: OPS.closeFillStroke,\n        numArgs: 0,\n        variableArgs: false\n      },\n      \"b*\": {\n        id: OPS.closeEOFillStroke,\n        numArgs: 0,\n        variableArgs: false\n      },\n      n: {\n        id: OPS.endPath,\n        numArgs: 0,\n        variableArgs: false\n      },\n      W: {\n        id: OPS.clip,\n        numArgs: 0,\n        variableArgs: false\n      },\n      \"W*\": {\n        id: OPS.eoClip,\n        numArgs: 0,\n        variableArgs: false\n      },\n      BT: {\n        id: OPS.beginText,\n        numArgs: 0,\n        variableArgs: false\n      },\n      ET: {\n        id: OPS.endText,\n        numArgs: 0,\n        variableArgs: false\n      },\n      Tc: {\n        id: OPS.setCharSpacing,\n        numArgs: 1,\n        variableArgs: false\n      },\n      Tw: {\n        id: OPS.setWordSpacing,\n        numArgs: 1,\n        variableArgs: false\n      },\n      Tz: {\n        id: OPS.setHScale,\n        numArgs: 1,\n        variableArgs: false\n      },\n      TL: {\n        id: OPS.setLeading,\n        numArgs: 1,\n        variableArgs: false\n      },\n      Tf: {\n        id: OPS.setFont,\n        numArgs: 2,\n        variableArgs: false\n      },\n      Tr: {\n        id: OPS.setTextRenderingMode,\n        numArgs: 1,\n        variableArgs: false\n      },\n      Ts: {\n        id: OPS.setTextRise,\n        numArgs: 1,\n        variableArgs: false\n      },\n      Td: {\n        id: OPS.moveText,\n        numArgs: 2,\n        variableArgs: false\n      },\n      TD: {\n        id: OPS.setLeadingMoveText,\n        numArgs: 2,\n        variableArgs: false\n      },\n      Tm: {\n        id: OPS.setTextMatrix,\n        numArgs: 6,\n        variableArgs: false\n      },\n      \"T*\": {\n        id: OPS.nextLine,\n        numArgs: 0,\n        variableArgs: false\n      },\n      Tj: {\n        id: OPS.showText,\n        numArgs: 1,\n        variableArgs: false\n      },\n      TJ: {\n        id: OPS.showSpacedText,\n        numArgs: 1,\n        variableArgs: false\n      },\n      \"'\": {\n        id: OPS.nextLineShowText,\n        numArgs: 1,\n        variableArgs: false\n      },\n      '\"': {\n        id: OPS.nextLineSetSpacingShowText,\n        numArgs: 3,\n        variableArgs: false\n      },\n      d0: {\n        id: OPS.setCharWidth,\n        numArgs: 2,\n        variableArgs: false\n      },\n      d1: {\n        id: OPS.setCharWidthAndBounds,\n        numArgs: 6,\n        variableArgs: false\n      },\n      CS: {\n        id: OPS.setStrokeColorSpace,\n        numArgs: 1,\n        variableArgs: false\n      },\n      cs: {\n        id: OPS.setFillColorSpace,\n        numArgs: 1,\n        variableArgs: false\n      },\n      SC: {\n        id: OPS.setStrokeColor,\n        numArgs: 4,\n        variableArgs: true\n      },\n      SCN: {\n        id: OPS.setStrokeColorN,\n        numArgs: 33,\n        variableArgs: true\n      },\n      sc: {\n        id: OPS.setFillColor,\n        numArgs: 4,\n        variableArgs: true\n      },\n      scn: {\n        id: OPS.setFillColorN,\n        numArgs: 33,\n        variableArgs: true\n      },\n      G: {\n        id: OPS.setStrokeGray,\n        numArgs: 1,\n        variableArgs: false\n      },\n      g: {\n        id: OPS.setFillGray,\n        numArgs: 1,\n        variableArgs: false\n      },\n      RG: {\n        id: OPS.setStrokeRGBColor,\n        numArgs: 3,\n        variableArgs: false\n      },\n      rg: {\n        id: OPS.setFillRGBColor,\n        numArgs: 3,\n        variableArgs: false\n      },\n      K: {\n        id: OPS.setStrokeCMYKColor,\n        numArgs: 4,\n        variableArgs: false\n      },\n      k: {\n        id: OPS.setFillCMYKColor,\n        numArgs: 4,\n        variableArgs: false\n      },\n      sh: {\n        id: OPS.shadingFill,\n        numArgs: 1,\n        variableArgs: false\n      },\n      BI: {\n        id: OPS.beginInlineImage,\n        numArgs: 0,\n        variableArgs: false\n      },\n      ID: {\n        id: OPS.beginImageData,\n        numArgs: 0,\n        variableArgs: false\n      },\n      EI: {\n        id: OPS.endInlineImage,\n        numArgs: 1,\n        variableArgs: false\n      },\n      Do: {\n        id: OPS.paintXObject,\n        numArgs: 1,\n        variableArgs: false\n      },\n      MP: {\n        id: OPS.markPoint,\n        numArgs: 1,\n        variableArgs: false\n      },\n      DP: {\n        id: OPS.markPointProps,\n        numArgs: 2,\n        variableArgs: false\n      },\n      BMC: {\n        id: OPS.beginMarkedContent,\n        numArgs: 1,\n        variableArgs: false\n      },\n      BDC: {\n        id: OPS.beginMarkedContentProps,\n        numArgs: 2,\n        variableArgs: false\n      },\n      EMC: {\n        id: OPS.endMarkedContent,\n        numArgs: 0,\n        variableArgs: false\n      },\n      BX: {\n        id: OPS.beginCompat,\n        numArgs: 0,\n        variableArgs: false\n      },\n      EX: {\n        id: OPS.endCompat,\n        numArgs: 0,\n        variableArgs: false\n      },\n      BM: null,\n      BD: null,\n      true: null,\n      fa: null,\n      fal: null,\n      fals: null,\n      false: null,\n      nu: null,\n      nul: null,\n      null: null\n    }));\n  }\n  static MAX_INVALID_PATH_OPS = 10;\n  constructor(stream, xref, stateManager = new StateManager()) {\n    this.parser = new Parser({\n      lexer: new Lexer(stream, EvaluatorPreprocessor.opMap),\n      xref\n    });\n    this.stateManager = stateManager;\n    this.nonProcessedArgs = [];\n    this._isPathOp = false;\n    this._numInvalidPathOPS = 0;\n  }\n  get savedStatesDepth() {\n    return this.stateManager.stateStack.length;\n  }\n  read(operation) {\n    let args = operation.args;\n    while (true) {\n      const obj = this.parser.getObj();\n      if (obj instanceof Cmd) {\n        const cmd = obj.cmd;\n        const opSpec = EvaluatorPreprocessor.opMap[cmd];\n        if (!opSpec) {\n          warn(`Unknown command \"${cmd}\".`);\n          continue;\n        }\n        const fn = opSpec.id;\n        const numArgs = opSpec.numArgs;\n        let argsLength = args !== null ? args.length : 0;\n        if (!this._isPathOp) {\n          this._numInvalidPathOPS = 0;\n        }\n        this._isPathOp = fn >= OPS.moveTo && fn <= OPS.endPath;\n        if (!opSpec.variableArgs) {\n          if (argsLength !== numArgs) {\n            const nonProcessedArgs = this.nonProcessedArgs;\n            while (argsLength > numArgs) {\n              nonProcessedArgs.push(args.shift());\n              argsLength--;\n            }\n            while (argsLength < numArgs && nonProcessedArgs.length !== 0) {\n              if (args === null) {\n                args = [];\n              }\n              args.unshift(nonProcessedArgs.pop());\n              argsLength++;\n            }\n          }\n          if (argsLength < numArgs) {\n            const partialMsg = `command ${cmd}: expected ${numArgs} args, ` + `but received ${argsLength} args.`;\n            if (this._isPathOp && ++this._numInvalidPathOPS > EvaluatorPreprocessor.MAX_INVALID_PATH_OPS) {\n              throw new FormatError(`Invalid ${partialMsg}`);\n            }\n            warn(`Skipping ${partialMsg}`);\n            if (args !== null) {\n              args.length = 0;\n            }\n            continue;\n          }\n        } else if (argsLength > numArgs) {\n          info(`Command ${cmd}: expected [0, ${numArgs}] args, ` + `but received ${argsLength} args.`);\n        }\n        this.preprocessCommand(fn, args);\n        operation.fn = fn;\n        operation.args = args;\n        return true;\n      }\n      if (obj === EOF) {\n        return false;\n      }\n      if (obj !== null) {\n        if (args === null) {\n          args = [];\n        }\n        args.push(obj);\n        if (args.length > 33) {\n          throw new FormatError(\"Too many arguments\");\n        }\n      }\n    }\n  }\n  preprocessCommand(fn, args) {\n    switch (fn | 0) {\n      case OPS.save:\n        this.stateManager.save();\n        break;\n      case OPS.restore:\n        this.stateManager.restore();\n        break;\n      case OPS.transform:\n        this.stateManager.transform(args);\n        break;\n    }\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/default_appearance.js\n\n\n\n\n\n\n\n\nclass DefaultAppearanceEvaluator extends EvaluatorPreprocessor {\n  constructor(str) {\n    super(new StringStream(str));\n  }\n  parse() {\n    const operation = {\n      fn: 0,\n      args: []\n    };\n    const result = {\n      fontSize: 0,\n      fontName: \"\",\n      fontColor: new Uint8ClampedArray(3)\n    };\n    try {\n      while (true) {\n        operation.args.length = 0;\n        if (!this.read(operation)) {\n          break;\n        }\n        if (this.savedStatesDepth !== 0) {\n          continue;\n        }\n        const {\n          fn,\n          args\n        } = operation;\n        switch (fn | 0) {\n          case OPS.setFont:\n            const [fontName, fontSize] = args;\n            if (fontName instanceof Name) {\n              result.fontName = fontName.name;\n            }\n            if (typeof fontSize === \"number\" && fontSize > 0) {\n              result.fontSize = fontSize;\n            }\n            break;\n          case OPS.setFillRGBColor:\n            ColorSpace.singletons.rgb.getRgbItem(args, 0, result.fontColor, 0);\n            break;\n          case OPS.setFillGray:\n            ColorSpace.singletons.gray.getRgbItem(args, 0, result.fontColor, 0);\n            break;\n          case OPS.setFillCMYKColor:\n            ColorSpace.singletons.cmyk.getRgbItem(args, 0, result.fontColor, 0);\n            break;\n        }\n      }\n    } catch (reason) {\n      warn(`parseDefaultAppearance - ignoring errors: \"${reason}\".`);\n    }\n    return result;\n  }\n}\nfunction parseDefaultAppearance(str) {\n  return new DefaultAppearanceEvaluator(str).parse();\n}\nclass AppearanceStreamEvaluator extends EvaluatorPreprocessor {\n  constructor(stream, evaluatorOptions, xref) {\n    super(stream);\n    this.stream = stream;\n    this.evaluatorOptions = evaluatorOptions;\n    this.xref = xref;\n    this.resources = stream.dict?.get(\"Resources\");\n  }\n  parse() {\n    const operation = {\n      fn: 0,\n      args: []\n    };\n    let result = {\n      scaleFactor: 1,\n      fontSize: 0,\n      fontName: \"\",\n      fontColor: new Uint8ClampedArray(3),\n      fillColorSpace: ColorSpace.singletons.gray\n    };\n    let breakLoop = false;\n    const stack = [];\n    try {\n      while (true) {\n        operation.args.length = 0;\n        if (breakLoop || !this.read(operation)) {\n          break;\n        }\n        const {\n          fn,\n          args\n        } = operation;\n        switch (fn | 0) {\n          case OPS.save:\n            stack.push({\n              scaleFactor: result.scaleFactor,\n              fontSize: result.fontSize,\n              fontName: result.fontName,\n              fontColor: result.fontColor.slice(),\n              fillColorSpace: result.fillColorSpace\n            });\n            break;\n          case OPS.restore:\n            result = stack.pop() || result;\n            break;\n          case OPS.setTextMatrix:\n            result.scaleFactor *= Math.hypot(args[0], args[1]);\n            break;\n          case OPS.setFont:\n            const [fontName, fontSize] = args;\n            if (fontName instanceof Name) {\n              result.fontName = fontName.name;\n            }\n            if (typeof fontSize === \"number\" && fontSize > 0) {\n              result.fontSize = fontSize * result.scaleFactor;\n            }\n            break;\n          case OPS.setFillColorSpace:\n            result.fillColorSpace = ColorSpace.parse({\n              cs: args[0],\n              xref: this.xref,\n              resources: this.resources,\n              pdfFunctionFactory: this._pdfFunctionFactory,\n              localColorSpaceCache: this._localColorSpaceCache\n            });\n            break;\n          case OPS.setFillColor:\n            const cs = result.fillColorSpace;\n            cs.getRgbItem(args, 0, result.fontColor, 0);\n            break;\n          case OPS.setFillRGBColor:\n            ColorSpace.singletons.rgb.getRgbItem(args, 0, result.fontColor, 0);\n            break;\n          case OPS.setFillGray:\n            ColorSpace.singletons.gray.getRgbItem(args, 0, result.fontColor, 0);\n            break;\n          case OPS.setFillCMYKColor:\n            ColorSpace.singletons.cmyk.getRgbItem(args, 0, result.fontColor, 0);\n            break;\n          case OPS.showText:\n          case OPS.showSpacedText:\n          case OPS.nextLineShowText:\n          case OPS.nextLineSetSpacingShowText:\n            breakLoop = true;\n            break;\n        }\n      }\n    } catch (reason) {\n      warn(`parseAppearanceStream - ignoring errors: \"${reason}\".`);\n    }\n    this.stream.reset();\n    delete result.scaleFactor;\n    delete result.fillColorSpace;\n    return result;\n  }\n  get _localColorSpaceCache() {\n    return shadow(this, \"_localColorSpaceCache\", new LocalColorSpaceCache());\n  }\n  get _pdfFunctionFactory() {\n    const pdfFunctionFactory = new PDFFunctionFactory({\n      xref: this.xref,\n      isEvalSupported: this.evaluatorOptions.isEvalSupported\n    });\n    return shadow(this, \"_pdfFunctionFactory\", pdfFunctionFactory);\n  }\n}\nfunction parseAppearanceStream(stream, evaluatorOptions, xref) {\n  return new AppearanceStreamEvaluator(stream, evaluatorOptions, xref).parse();\n}\nfunction getPdfColor(color, isFill) {\n  if (color[0] === color[1] && color[1] === color[2]) {\n    const gray = color[0] / 255;\n    return `${numberToString(gray)} ${isFill ? \"g\" : \"G\"}`;\n  }\n  return Array.from(color, c => numberToString(c / 255)).join(\" \") + ` ${isFill ? \"rg\" : \"RG\"}`;\n}\nfunction createDefaultAppearance({\n  fontSize,\n  fontName,\n  fontColor\n}) {\n  return `/${escapePDFName(fontName)} ${fontSize} Tf ${getPdfColor(fontColor, true)}`;\n}\nclass FakeUnicodeFont {\n  constructor(xref, fontFamily) {\n    this.xref = xref;\n    this.widths = null;\n    this.firstChar = Infinity;\n    this.lastChar = -Infinity;\n    this.fontFamily = fontFamily;\n    const canvas = new OffscreenCanvas(1, 1);\n    this.ctxMeasure = canvas.getContext(\"2d\");\n    if (!FakeUnicodeFont._fontNameId) {\n      FakeUnicodeFont._fontNameId = 1;\n    }\n    this.fontName = Name.get(`InvalidPDFjsFont_${fontFamily}_${FakeUnicodeFont._fontNameId++}`);\n  }\n  get fontDescriptorRef() {\n    if (!FakeUnicodeFont._fontDescriptorRef) {\n      const fontDescriptor = new Dict(this.xref);\n      fontDescriptor.set(\"Type\", Name.get(\"FontDescriptor\"));\n      fontDescriptor.set(\"FontName\", this.fontName);\n      fontDescriptor.set(\"FontFamily\", \"MyriadPro Regular\");\n      fontDescriptor.set(\"FontBBox\", [0, 0, 0, 0]);\n      fontDescriptor.set(\"FontStretch\", Name.get(\"Normal\"));\n      fontDescriptor.set(\"FontWeight\", 400);\n      fontDescriptor.set(\"ItalicAngle\", 0);\n      FakeUnicodeFont._fontDescriptorRef = this.xref.getNewPersistentRef(fontDescriptor);\n    }\n    return FakeUnicodeFont._fontDescriptorRef;\n  }\n  get descendantFontRef() {\n    const descendantFont = new Dict(this.xref);\n    descendantFont.set(\"BaseFont\", this.fontName);\n    descendantFont.set(\"Type\", Name.get(\"Font\"));\n    descendantFont.set(\"Subtype\", Name.get(\"CIDFontType0\"));\n    descendantFont.set(\"CIDToGIDMap\", Name.get(\"Identity\"));\n    descendantFont.set(\"FirstChar\", this.firstChar);\n    descendantFont.set(\"LastChar\", this.lastChar);\n    descendantFont.set(\"FontDescriptor\", this.fontDescriptorRef);\n    descendantFont.set(\"DW\", 1000);\n    const widths = [];\n    const chars = [...this.widths.entries()].sort();\n    let currentChar = null;\n    let currentWidths = null;\n    for (const [char, width] of chars) {\n      if (!currentChar) {\n        currentChar = char;\n        currentWidths = [width];\n        continue;\n      }\n      if (char === currentChar + currentWidths.length) {\n        currentWidths.push(width);\n      } else {\n        widths.push(currentChar, currentWidths);\n        currentChar = char;\n        currentWidths = [width];\n      }\n    }\n    if (currentChar) {\n      widths.push(currentChar, currentWidths);\n    }\n    descendantFont.set(\"W\", widths);\n    const cidSystemInfo = new Dict(this.xref);\n    cidSystemInfo.set(\"Ordering\", \"Identity\");\n    cidSystemInfo.set(\"Registry\", \"Adobe\");\n    cidSystemInfo.set(\"Supplement\", 0);\n    descendantFont.set(\"CIDSystemInfo\", cidSystemInfo);\n    return this.xref.getNewPersistentRef(descendantFont);\n  }\n  get baseFontRef() {\n    const baseFont = new Dict(this.xref);\n    baseFont.set(\"BaseFont\", this.fontName);\n    baseFont.set(\"Type\", Name.get(\"Font\"));\n    baseFont.set(\"Subtype\", Name.get(\"Type0\"));\n    baseFont.set(\"Encoding\", Name.get(\"Identity-H\"));\n    baseFont.set(\"DescendantFonts\", [this.descendantFontRef]);\n    baseFont.set(\"ToUnicode\", Name.get(\"Identity-H\"));\n    return this.xref.getNewPersistentRef(baseFont);\n  }\n  get resources() {\n    const resources = new Dict(this.xref);\n    const font = new Dict(this.xref);\n    font.set(this.fontName.name, this.baseFontRef);\n    resources.set(\"Font\", font);\n    return resources;\n  }\n  _createContext() {\n    this.widths = new Map();\n    this.ctxMeasure.font = `1000px ${this.fontFamily}`;\n    return this.ctxMeasure;\n  }\n  createFontResources(text) {\n    const ctx = this._createContext();\n    for (const line of text.split(/\\r\\n?|\\n/)) {\n      for (const char of line.split(\"\")) {\n        const code = char.charCodeAt(0);\n        if (this.widths.has(code)) {\n          continue;\n        }\n        const metrics = ctx.measureText(char);\n        const width = Math.ceil(metrics.width);\n        this.widths.set(code, width);\n        this.firstChar = Math.min(code, this.firstChar);\n        this.lastChar = Math.max(code, this.lastChar);\n      }\n    }\n    return this.resources;\n  }\n  static getFirstPositionInfo(rect, rotation, fontSize) {\n    const [x1, y1, x2, y2] = rect;\n    let w = x2 - x1;\n    let h = y2 - y1;\n    if (rotation % 180 !== 0) {\n      [w, h] = [h, w];\n    }\n    const lineHeight = LINE_FACTOR * fontSize;\n    const lineDescent = LINE_DESCENT_FACTOR * fontSize;\n    return {\n      coords: [0, h + lineDescent - lineHeight],\n      bbox: [0, 0, w, h],\n      matrix: rotation !== 0 ? getRotationMatrix(rotation, h, lineHeight) : undefined\n    };\n  }\n  createAppearance(text, rect, rotation, fontSize, bgColor, strokeAlpha) {\n    const ctx = this._createContext();\n    const lines = [];\n    let maxWidth = -Infinity;\n    for (const line of text.split(/\\r\\n?|\\n/)) {\n      lines.push(line);\n      const lineWidth = ctx.measureText(line).width;\n      maxWidth = Math.max(maxWidth, lineWidth);\n      for (const code of codePointIter(line)) {\n        const char = String.fromCodePoint(code);\n        let width = this.widths.get(code);\n        if (width === undefined) {\n          const metrics = ctx.measureText(char);\n          width = Math.ceil(metrics.width);\n          this.widths.set(code, width);\n          this.firstChar = Math.min(code, this.firstChar);\n          this.lastChar = Math.max(code, this.lastChar);\n        }\n      }\n    }\n    maxWidth *= fontSize / 1000;\n    const [x1, y1, x2, y2] = rect;\n    let w = x2 - x1;\n    let h = y2 - y1;\n    if (rotation % 180 !== 0) {\n      [w, h] = [h, w];\n    }\n    let hscale = 1;\n    if (maxWidth > w) {\n      hscale = w / maxWidth;\n    }\n    let vscale = 1;\n    const lineHeight = LINE_FACTOR * fontSize;\n    const lineDescent = LINE_DESCENT_FACTOR * fontSize;\n    const maxHeight = lineHeight * lines.length;\n    if (maxHeight > h) {\n      vscale = h / maxHeight;\n    }\n    const fscale = Math.min(hscale, vscale);\n    const newFontSize = fontSize * fscale;\n    const buffer = [\"q\", `0 0 ${numberToString(w)} ${numberToString(h)} re W n`, `BT`, `1 0 0 1 0 ${numberToString(h + lineDescent)} Tm 0 Tc ${getPdfColor(bgColor, true)}`, `/${this.fontName.name} ${numberToString(newFontSize)} Tf`];\n    const {\n      resources\n    } = this;\n    strokeAlpha = typeof strokeAlpha === \"number\" && strokeAlpha >= 0 && strokeAlpha <= 1 ? strokeAlpha : 1;\n    if (strokeAlpha !== 1) {\n      buffer.push(\"/R0 gs\");\n      const extGState = new Dict(this.xref);\n      const r0 = new Dict(this.xref);\n      r0.set(\"ca\", strokeAlpha);\n      r0.set(\"CA\", strokeAlpha);\n      r0.set(\"Type\", Name.get(\"ExtGState\"));\n      extGState.set(\"R0\", r0);\n      resources.set(\"ExtGState\", extGState);\n    }\n    const vShift = numberToString(lineHeight);\n    for (const line of lines) {\n      buffer.push(`0 -${vShift} Td <${stringToUTF16HexString(line)}> Tj`);\n    }\n    buffer.push(\"ET\", \"Q\");\n    const appearance = buffer.join(\"\\n\");\n    const appearanceStreamDict = new Dict(this.xref);\n    appearanceStreamDict.set(\"Subtype\", Name.get(\"Form\"));\n    appearanceStreamDict.set(\"Type\", Name.get(\"XObject\"));\n    appearanceStreamDict.set(\"BBox\", [0, 0, w, h]);\n    appearanceStreamDict.set(\"Length\", appearance.length);\n    appearanceStreamDict.set(\"Resources\", resources);\n    if (rotation) {\n      const matrix = getRotationMatrix(rotation, w, h);\n      appearanceStreamDict.set(\"Matrix\", matrix);\n    }\n    const ap = new StringStream(appearance);\n    ap.dict = appearanceStreamDict;\n    return ap;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/name_number_tree.js\n\n\nclass NameOrNumberTree {\n  constructor(root, xref, type) {\n    if (this.constructor === NameOrNumberTree) {\n      unreachable(\"Cannot initialize NameOrNumberTree.\");\n    }\n    this.root = root;\n    this.xref = xref;\n    this._type = type;\n  }\n  getAll() {\n    const map = new Map();\n    if (!this.root) {\n      return map;\n    }\n    const xref = this.xref;\n    const processed = new RefSet();\n    processed.put(this.root);\n    const queue = [this.root];\n    while (queue.length > 0) {\n      const obj = xref.fetchIfRef(queue.shift());\n      if (!(obj instanceof Dict)) {\n        continue;\n      }\n      if (obj.has(\"Kids\")) {\n        const kids = obj.get(\"Kids\");\n        if (!Array.isArray(kids)) {\n          continue;\n        }\n        for (const kid of kids) {\n          if (processed.has(kid)) {\n            throw new FormatError(`Duplicate entry in \"${this._type}\" tree.`);\n          }\n          queue.push(kid);\n          processed.put(kid);\n        }\n        continue;\n      }\n      const entries = obj.get(this._type);\n      if (!Array.isArray(entries)) {\n        continue;\n      }\n      for (let i = 0, ii = entries.length; i < ii; i += 2) {\n        map.set(xref.fetchIfRef(entries[i]), xref.fetchIfRef(entries[i + 1]));\n      }\n    }\n    return map;\n  }\n  get(key) {\n    if (!this.root) {\n      return null;\n    }\n    const xref = this.xref;\n    let kidsOrEntries = xref.fetchIfRef(this.root);\n    let loopCount = 0;\n    const MAX_LEVELS = 10;\n    while (kidsOrEntries.has(\"Kids\")) {\n      if (++loopCount > MAX_LEVELS) {\n        warn(`Search depth limit reached for \"${this._type}\" tree.`);\n        return null;\n      }\n      const kids = kidsOrEntries.get(\"Kids\");\n      if (!Array.isArray(kids)) {\n        return null;\n      }\n      let l = 0,\n        r = kids.length - 1;\n      while (l <= r) {\n        const m = l + r >> 1;\n        const kid = xref.fetchIfRef(kids[m]);\n        const limits = kid.get(\"Limits\");\n        if (key < xref.fetchIfRef(limits[0])) {\n          r = m - 1;\n        } else if (key > xref.fetchIfRef(limits[1])) {\n          l = m + 1;\n        } else {\n          kidsOrEntries = kid;\n          break;\n        }\n      }\n      if (l > r) {\n        return null;\n      }\n    }\n    const entries = kidsOrEntries.get(this._type);\n    if (Array.isArray(entries)) {\n      let l = 0,\n        r = entries.length - 2;\n      while (l <= r) {\n        const tmp = l + r >> 1,\n          m = tmp + (tmp & 1);\n        const currentKey = xref.fetchIfRef(entries[m]);\n        if (key < currentKey) {\n          r = m - 2;\n        } else if (key > currentKey) {\n          l = m + 2;\n        } else {\n          return xref.fetchIfRef(entries[m + 1]);\n        }\n      }\n    }\n    return null;\n  }\n}\nclass NameTree extends NameOrNumberTree {\n  constructor(root, xref) {\n    super(root, xref, \"Names\");\n  }\n}\nclass NumberTree extends NameOrNumberTree {\n  constructor(root, xref) {\n    super(root, xref, \"Nums\");\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/cleanup_helper.js\n\n\n\n\nfunction clearGlobalCaches() {\n  clearPatternCaches();\n  clearPrimitiveCaches();\n  clearUnicodeCaches();\n  JpxImage.cleanup();\n}\n\n;// CONCATENATED MODULE: ./src/core/file_spec.js\n\n\n\nfunction pickPlatformItem(dict) {\n  if (dict.has(\"UF\")) {\n    return dict.get(\"UF\");\n  } else if (dict.has(\"F\")) {\n    return dict.get(\"F\");\n  } else if (dict.has(\"Unix\")) {\n    return dict.get(\"Unix\");\n  } else if (dict.has(\"Mac\")) {\n    return dict.get(\"Mac\");\n  } else if (dict.has(\"DOS\")) {\n    return dict.get(\"DOS\");\n  }\n  return null;\n}\nclass FileSpec {\n  #contentAvailable = false;\n  constructor(root, xref, skipContent = false) {\n    if (!(root instanceof Dict)) {\n      return;\n    }\n    this.xref = xref;\n    this.root = root;\n    if (root.has(\"FS\")) {\n      this.fs = root.get(\"FS\");\n    }\n    this.description = root.has(\"Desc\") ? stringToPDFString(root.get(\"Desc\")) : \"\";\n    if (root.has(\"RF\")) {\n      warn(\"Related file specifications are not supported\");\n    }\n    if (!skipContent) {\n      if (root.has(\"EF\")) {\n        this.#contentAvailable = true;\n      } else {\n        warn(\"Non-embedded file specifications are not supported\");\n      }\n    }\n  }\n  get filename() {\n    if (!this._filename && this.root) {\n      const filename = pickPlatformItem(this.root) || \"unnamed\";\n      this._filename = stringToPDFString(filename).replaceAll(\"\\\\\\\\\", \"\\\\\").replaceAll(\"\\\\/\", \"/\").replaceAll(\"\\\\\", \"/\");\n    }\n    return this._filename;\n  }\n  get content() {\n    if (!this.#contentAvailable) {\n      return null;\n    }\n    if (!this.contentRef && this.root) {\n      this.contentRef = pickPlatformItem(this.root.get(\"EF\"));\n    }\n    let content = null;\n    if (this.contentRef) {\n      const fileObj = this.xref.fetchIfRef(this.contentRef);\n      if (fileObj instanceof BaseStream) {\n        content = fileObj.getBytes();\n      } else {\n        warn(\"Embedded file specification points to non-existing/invalid content\");\n      }\n    } else {\n      warn(\"Embedded file specification does not have a content\");\n    }\n    return content;\n  }\n  get serializable() {\n    return {\n      filename: this.filename,\n      content: this.content\n    };\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xml_parser.js\n\nconst XMLParserErrorCode = {\n  NoError: 0,\n  EndOfDocument: -1,\n  UnterminatedCdat: -2,\n  UnterminatedXmlDeclaration: -3,\n  UnterminatedDoctypeDeclaration: -4,\n  UnterminatedComment: -5,\n  MalformedElement: -6,\n  OutOfMemory: -7,\n  UnterminatedAttributeValue: -8,\n  UnterminatedElement: -9,\n  ElementNeverBegun: -10\n};\nfunction isWhitespace(s, index) {\n  const ch = s[index];\n  return ch === \" \" || ch === \"\\n\" || ch === \"\\r\" || ch === \"\\t\";\n}\nfunction isWhitespaceString(s) {\n  for (let i = 0, ii = s.length; i < ii; i++) {\n    if (!isWhitespace(s, i)) {\n      return false;\n    }\n  }\n  return true;\n}\nclass XMLParserBase {\n  _resolveEntities(s) {\n    return s.replaceAll(/&([^;]+);/g, (all, entity) => {\n      if (entity.substring(0, 2) === \"#x\") {\n        return String.fromCodePoint(parseInt(entity.substring(2), 16));\n      } else if (entity.substring(0, 1) === \"#\") {\n        return String.fromCodePoint(parseInt(entity.substring(1), 10));\n      }\n      switch (entity) {\n        case \"lt\":\n          return \"<\";\n        case \"gt\":\n          return \">\";\n        case \"amp\":\n          return \"&\";\n        case \"quot\":\n          return '\"';\n        case \"apos\":\n          return \"'\";\n      }\n      return this.onResolveEntity(entity);\n    });\n  }\n  _parseContent(s, start) {\n    const attributes = [];\n    let pos = start;\n    function skipWs() {\n      while (pos < s.length && isWhitespace(s, pos)) {\n        ++pos;\n      }\n    }\n    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== \">\" && s[pos] !== \"/\") {\n      ++pos;\n    }\n    const name = s.substring(start, pos);\n    skipWs();\n    while (pos < s.length && s[pos] !== \">\" && s[pos] !== \"/\" && s[pos] !== \"?\") {\n      skipWs();\n      let attrName = \"\",\n        attrValue = \"\";\n      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== \"=\") {\n        attrName += s[pos];\n        ++pos;\n      }\n      skipWs();\n      if (s[pos] !== \"=\") {\n        return null;\n      }\n      ++pos;\n      skipWs();\n      const attrEndChar = s[pos];\n      if (attrEndChar !== '\"' && attrEndChar !== \"'\") {\n        return null;\n      }\n      const attrEndIndex = s.indexOf(attrEndChar, ++pos);\n      if (attrEndIndex < 0) {\n        return null;\n      }\n      attrValue = s.substring(pos, attrEndIndex);\n      attributes.push({\n        name: attrName,\n        value: this._resolveEntities(attrValue)\n      });\n      pos = attrEndIndex + 1;\n      skipWs();\n    }\n    return {\n      name,\n      attributes,\n      parsed: pos - start\n    };\n  }\n  _parseProcessingInstruction(s, start) {\n    let pos = start;\n    function skipWs() {\n      while (pos < s.length && isWhitespace(s, pos)) {\n        ++pos;\n      }\n    }\n    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== \">\" && s[pos] !== \"?\" && s[pos] !== \"/\") {\n      ++pos;\n    }\n    const name = s.substring(start, pos);\n    skipWs();\n    const attrStart = pos;\n    while (pos < s.length && (s[pos] !== \"?\" || s[pos + 1] !== \">\")) {\n      ++pos;\n    }\n    const value = s.substring(attrStart, pos);\n    return {\n      name,\n      value,\n      parsed: pos - start\n    };\n  }\n  parseXml(s) {\n    let i = 0;\n    while (i < s.length) {\n      const ch = s[i];\n      let j = i;\n      if (ch === \"<\") {\n        ++j;\n        const ch2 = s[j];\n        let q;\n        switch (ch2) {\n          case \"/\":\n            ++j;\n            q = s.indexOf(\">\", j);\n            if (q < 0) {\n              this.onError(XMLParserErrorCode.UnterminatedElement);\n              return;\n            }\n            this.onEndElement(s.substring(j, q));\n            j = q + 1;\n            break;\n          case \"?\":\n            ++j;\n            const pi = this._parseProcessingInstruction(s, j);\n            if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== \"?>\") {\n              this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);\n              return;\n            }\n            this.onPi(pi.name, pi.value);\n            j += pi.parsed + 2;\n            break;\n          case \"!\":\n            if (s.substring(j + 1, j + 3) === \"--\") {\n              q = s.indexOf(\"-->\", j + 3);\n              if (q < 0) {\n                this.onError(XMLParserErrorCode.UnterminatedComment);\n                return;\n              }\n              this.onComment(s.substring(j + 3, q));\n              j = q + 3;\n            } else if (s.substring(j + 1, j + 8) === \"[CDATA[\") {\n              q = s.indexOf(\"]]>\", j + 8);\n              if (q < 0) {\n                this.onError(XMLParserErrorCode.UnterminatedCdat);\n                return;\n              }\n              this.onCdata(s.substring(j + 8, q));\n              j = q + 3;\n            } else if (s.substring(j + 1, j + 8) === \"DOCTYPE\") {\n              const q2 = s.indexOf(\"[\", j + 8);\n              let complexDoctype = false;\n              q = s.indexOf(\">\", j + 8);\n              if (q < 0) {\n                this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);\n                return;\n              }\n              if (q2 > 0 && q > q2) {\n                q = s.indexOf(\"]>\", j + 8);\n                if (q < 0) {\n                  this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);\n                  return;\n                }\n                complexDoctype = true;\n              }\n              const doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));\n              this.onDoctype(doctypeContent);\n              j = q + (complexDoctype ? 2 : 1);\n            } else {\n              this.onError(XMLParserErrorCode.MalformedElement);\n              return;\n            }\n            break;\n          default:\n            const content = this._parseContent(s, j);\n            if (content === null) {\n              this.onError(XMLParserErrorCode.MalformedElement);\n              return;\n            }\n            let isClosed = false;\n            if (s.substring(j + content.parsed, j + content.parsed + 2) === \"/>\") {\n              isClosed = true;\n            } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== \">\") {\n              this.onError(XMLParserErrorCode.UnterminatedElement);\n              return;\n            }\n            this.onBeginElement(content.name, content.attributes, isClosed);\n            j += content.parsed + (isClosed ? 2 : 1);\n            break;\n        }\n      } else {\n        while (j < s.length && s[j] !== \"<\") {\n          j++;\n        }\n        const text = s.substring(i, j);\n        this.onText(this._resolveEntities(text));\n      }\n      i = j;\n    }\n  }\n  onResolveEntity(name) {\n    return `&${name};`;\n  }\n  onPi(name, value) {}\n  onComment(text) {}\n  onCdata(text) {}\n  onDoctype(doctypeContent) {}\n  onText(text) {}\n  onBeginElement(name, attributes, isEmpty) {}\n  onEndElement(name) {}\n  onError(code) {}\n}\nclass SimpleDOMNode {\n  constructor(nodeName, nodeValue) {\n    this.nodeName = nodeName;\n    this.nodeValue = nodeValue;\n    Object.defineProperty(this, \"parentNode\", {\n      value: null,\n      writable: true\n    });\n  }\n  get firstChild() {\n    return this.childNodes?.[0];\n  }\n  get nextSibling() {\n    const childNodes = this.parentNode.childNodes;\n    if (!childNodes) {\n      return undefined;\n    }\n    const index = childNodes.indexOf(this);\n    if (index === -1) {\n      return undefined;\n    }\n    return childNodes[index + 1];\n  }\n  get textContent() {\n    if (!this.childNodes) {\n      return this.nodeValue || \"\";\n    }\n    return this.childNodes.map(function (child) {\n      return child.textContent;\n    }).join(\"\");\n  }\n  get children() {\n    return this.childNodes || [];\n  }\n  hasChildNodes() {\n    return this.childNodes?.length > 0;\n  }\n  searchNode(paths, pos) {\n    if (pos >= paths.length) {\n      return this;\n    }\n    const component = paths[pos];\n    if (component.name.startsWith(\"#\") && pos < paths.length - 1) {\n      return this.searchNode(paths, pos + 1);\n    }\n    const stack = [];\n    let node = this;\n    while (true) {\n      if (component.name === node.nodeName) {\n        if (component.pos === 0) {\n          const res = node.searchNode(paths, pos + 1);\n          if (res !== null) {\n            return res;\n          }\n        } else if (stack.length === 0) {\n          return null;\n        } else {\n          const [parent] = stack.pop();\n          let siblingPos = 0;\n          for (const child of parent.childNodes) {\n            if (component.name === child.nodeName) {\n              if (siblingPos === component.pos) {\n                return child.searchNode(paths, pos + 1);\n              }\n              siblingPos++;\n            }\n          }\n          return node.searchNode(paths, pos + 1);\n        }\n      }\n      if (node.childNodes?.length > 0) {\n        stack.push([node, 0]);\n        node = node.childNodes[0];\n      } else if (stack.length === 0) {\n        return null;\n      } else {\n        while (stack.length !== 0) {\n          const [parent, currentPos] = stack.pop();\n          const newPos = currentPos + 1;\n          if (newPos < parent.childNodes.length) {\n            stack.push([parent, newPos]);\n            node = parent.childNodes[newPos];\n            break;\n          }\n        }\n        if (stack.length === 0) {\n          return null;\n        }\n      }\n    }\n  }\n  dump(buffer) {\n    if (this.nodeName === \"#text\") {\n      buffer.push(encodeToXmlString(this.nodeValue));\n      return;\n    }\n    buffer.push(`<${this.nodeName}`);\n    if (this.attributes) {\n      for (const attribute of this.attributes) {\n        buffer.push(` ${attribute.name}=\"${encodeToXmlString(attribute.value)}\"`);\n      }\n    }\n    if (this.hasChildNodes()) {\n      buffer.push(\">\");\n      for (const child of this.childNodes) {\n        child.dump(buffer);\n      }\n      buffer.push(`</${this.nodeName}>`);\n    } else if (this.nodeValue) {\n      buffer.push(`>${encodeToXmlString(this.nodeValue)}</${this.nodeName}>`);\n    } else {\n      buffer.push(\"/>\");\n    }\n  }\n}\nclass SimpleXMLParser extends XMLParserBase {\n  constructor({\n    hasAttributes = false,\n    lowerCaseName = false\n  }) {\n    super();\n    this._currentFragment = null;\n    this._stack = null;\n    this._errorCode = XMLParserErrorCode.NoError;\n    this._hasAttributes = hasAttributes;\n    this._lowerCaseName = lowerCaseName;\n  }\n  parseFromString(data) {\n    this._currentFragment = [];\n    this._stack = [];\n    this._errorCode = XMLParserErrorCode.NoError;\n    this.parseXml(data);\n    if (this._errorCode !== XMLParserErrorCode.NoError) {\n      return undefined;\n    }\n    const [documentElement] = this._currentFragment;\n    if (!documentElement) {\n      return undefined;\n    }\n    return {\n      documentElement\n    };\n  }\n  onText(text) {\n    if (isWhitespaceString(text)) {\n      return;\n    }\n    const node = new SimpleDOMNode(\"#text\", text);\n    this._currentFragment.push(node);\n  }\n  onCdata(text) {\n    const node = new SimpleDOMNode(\"#text\", text);\n    this._currentFragment.push(node);\n  }\n  onBeginElement(name, attributes, isEmpty) {\n    if (this._lowerCaseName) {\n      name = name.toLowerCase();\n    }\n    const node = new SimpleDOMNode(name);\n    node.childNodes = [];\n    if (this._hasAttributes) {\n      node.attributes = attributes;\n    }\n    this._currentFragment.push(node);\n    if (isEmpty) {\n      return;\n    }\n    this._stack.push(this._currentFragment);\n    this._currentFragment = node.childNodes;\n  }\n  onEndElement(name) {\n    this._currentFragment = this._stack.pop() || [];\n    const lastElement = this._currentFragment.at(-1);\n    if (!lastElement) {\n      return null;\n    }\n    for (const childNode of lastElement.childNodes) {\n      childNode.parentNode = lastElement;\n    }\n    return lastElement;\n  }\n  onError(code) {\n    this._errorCode = code;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/metadata_parser.js\n\nclass MetadataParser {\n  constructor(data) {\n    data = this._repair(data);\n    const parser = new SimpleXMLParser({\n      lowerCaseName: true\n    });\n    const xmlDocument = parser.parseFromString(data);\n    this._metadataMap = new Map();\n    this._data = data;\n    if (xmlDocument) {\n      this._parse(xmlDocument);\n    }\n  }\n  _repair(data) {\n    return data.replace(/^[^<]+/, \"\").replaceAll(/>\\\\376\\\\377([^<]+)/g, function (all, codes) {\n      const bytes = codes.replaceAll(/\\\\([0-3])([0-7])([0-7])/g, function (code, d1, d2, d3) {\n        return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);\n      }).replaceAll(/&(amp|apos|gt|lt|quot);/g, function (str, name) {\n        switch (name) {\n          case \"amp\":\n            return \"&\";\n          case \"apos\":\n            return \"'\";\n          case \"gt\":\n            return \">\";\n          case \"lt\":\n            return \"<\";\n          case \"quot\":\n            return '\"';\n        }\n        throw new Error(`_repair: ${name} isn't defined.`);\n      });\n      const charBuf = [\">\"];\n      for (let i = 0, ii = bytes.length; i < ii; i += 2) {\n        const code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);\n        if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) {\n          charBuf.push(String.fromCharCode(code));\n        } else {\n          charBuf.push(\"&#x\" + (0x10000 + code).toString(16).substring(1) + \";\");\n        }\n      }\n      return charBuf.join(\"\");\n    });\n  }\n  _getSequence(entry) {\n    const name = entry.nodeName;\n    if (name !== \"rdf:bag\" && name !== \"rdf:seq\" && name !== \"rdf:alt\") {\n      return null;\n    }\n    return entry.childNodes.filter(node => node.nodeName === \"rdf:li\");\n  }\n  _parseArray(entry) {\n    if (!entry.hasChildNodes()) {\n      return;\n    }\n    const [seqNode] = entry.childNodes;\n    const sequence = this._getSequence(seqNode) || [];\n    this._metadataMap.set(entry.nodeName, sequence.map(node => node.textContent.trim()));\n  }\n  _parse(xmlDocument) {\n    let rdf = xmlDocument.documentElement;\n    if (rdf.nodeName !== \"rdf:rdf\") {\n      rdf = rdf.firstChild;\n      while (rdf && rdf.nodeName !== \"rdf:rdf\") {\n        rdf = rdf.nextSibling;\n      }\n    }\n    if (!rdf || rdf.nodeName !== \"rdf:rdf\" || !rdf.hasChildNodes()) {\n      return;\n    }\n    for (const desc of rdf.childNodes) {\n      if (desc.nodeName !== \"rdf:description\") {\n        continue;\n      }\n      for (const entry of desc.childNodes) {\n        const name = entry.nodeName;\n        switch (name) {\n          case \"#text\":\n            continue;\n          case \"dc:creator\":\n          case \"dc:subject\":\n            this._parseArray(entry);\n            continue;\n        }\n        this._metadataMap.set(name, entry.textContent.trim());\n      }\n    }\n  }\n  get serializable() {\n    return {\n      parsedData: this._metadataMap,\n      rawData: this._data\n    };\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/decrypt_stream.js\n\nconst chunkSize = 512;\nclass DecryptStream extends DecodeStream {\n  constructor(str, maybeLength, decrypt) {\n    super(maybeLength);\n    this.str = str;\n    this.dict = str.dict;\n    this.decrypt = decrypt;\n    this.nextChunk = null;\n    this.initialized = false;\n  }\n  readBlock() {\n    let chunk;\n    if (this.initialized) {\n      chunk = this.nextChunk;\n    } else {\n      chunk = this.str.getBytes(chunkSize);\n      this.initialized = true;\n    }\n    if (!chunk || chunk.length === 0) {\n      this.eof = true;\n      return;\n    }\n    this.nextChunk = this.str.getBytes(chunkSize);\n    const hasMoreData = this.nextChunk?.length > 0;\n    const decrypt = this.decrypt;\n    chunk = decrypt(chunk, !hasMoreData);\n    const bufferLength = this.bufferLength,\n      newLength = bufferLength + chunk.length,\n      buffer = this.ensureBuffer(newLength);\n    buffer.set(chunk, bufferLength);\n    this.bufferLength = newLength;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/crypto.js\n\n\n\nclass ARCFourCipher {\n  constructor(key) {\n    this.a = 0;\n    this.b = 0;\n    const s = new Uint8Array(256);\n    const keyLength = key.length;\n    for (let i = 0; i < 256; ++i) {\n      s[i] = i;\n    }\n    for (let i = 0, j = 0; i < 256; ++i) {\n      const tmp = s[i];\n      j = j + tmp + key[i % keyLength] & 0xff;\n      s[i] = s[j];\n      s[j] = tmp;\n    }\n    this.s = s;\n  }\n  encryptBlock(data) {\n    let a = this.a,\n      b = this.b;\n    const s = this.s;\n    const n = data.length;\n    const output = new Uint8Array(n);\n    for (let i = 0; i < n; ++i) {\n      a = a + 1 & 0xff;\n      const tmp = s[a];\n      b = b + tmp & 0xff;\n      const tmp2 = s[b];\n      s[a] = tmp2;\n      s[b] = tmp;\n      output[i] = data[i] ^ s[tmp + tmp2 & 0xff];\n    }\n    this.a = a;\n    this.b = b;\n    return output;\n  }\n  decryptBlock(data) {\n    return this.encryptBlock(data);\n  }\n  encrypt(data) {\n    return this.encryptBlock(data);\n  }\n}\nconst calculateMD5 = function calculateMD5Closure() {\n  const r = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);\n  const k = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);\n  function hash(data, offset, length) {\n    let h0 = 1732584193,\n      h1 = -271733879,\n      h2 = -1732584194,\n      h3 = 271733878;\n    const paddedLength = length + 72 & ~63;\n    const padded = new Uint8Array(paddedLength);\n    let i, j;\n    for (i = 0; i < length; ++i) {\n      padded[i] = data[offset++];\n    }\n    padded[i++] = 0x80;\n    const n = paddedLength - 8;\n    while (i < n) {\n      padded[i++] = 0;\n    }\n    padded[i++] = length << 3 & 0xff;\n    padded[i++] = length >> 5 & 0xff;\n    padded[i++] = length >> 13 & 0xff;\n    padded[i++] = length >> 21 & 0xff;\n    padded[i++] = length >>> 29 & 0xff;\n    padded[i++] = 0;\n    padded[i++] = 0;\n    padded[i++] = 0;\n    const w = new Int32Array(16);\n    for (i = 0; i < paddedLength;) {\n      for (j = 0; j < 16; ++j, i += 4) {\n        w[j] = padded[i] | padded[i + 1] << 8 | padded[i + 2] << 16 | padded[i + 3] << 24;\n      }\n      let a = h0,\n        b = h1,\n        c = h2,\n        d = h3,\n        f,\n        g;\n      for (j = 0; j < 64; ++j) {\n        if (j < 16) {\n          f = b & c | ~b & d;\n          g = j;\n        } else if (j < 32) {\n          f = d & b | ~d & c;\n          g = 5 * j + 1 & 15;\n        } else if (j < 48) {\n          f = b ^ c ^ d;\n          g = 3 * j + 5 & 15;\n        } else {\n          f = c ^ (b | ~d);\n          g = 7 * j & 15;\n        }\n        const tmp = d,\n          rotateArg = a + f + k[j] + w[g] | 0,\n          rotate = r[j];\n        d = c;\n        c = b;\n        b = b + (rotateArg << rotate | rotateArg >>> 32 - rotate) | 0;\n        a = tmp;\n      }\n      h0 = h0 + a | 0;\n      h1 = h1 + b | 0;\n      h2 = h2 + c | 0;\n      h3 = h3 + d | 0;\n    }\n    return new Uint8Array([h0 & 0xFF, h0 >> 8 & 0xFF, h0 >> 16 & 0xFF, h0 >>> 24 & 0xFF, h1 & 0xFF, h1 >> 8 & 0xFF, h1 >> 16 & 0xFF, h1 >>> 24 & 0xFF, h2 & 0xFF, h2 >> 8 & 0xFF, h2 >> 16 & 0xFF, h2 >>> 24 & 0xFF, h3 & 0xFF, h3 >> 8 & 0xFF, h3 >> 16 & 0xFF, h3 >>> 24 & 0xFF]);\n  }\n  return hash;\n}();\nclass Word64 {\n  constructor(highInteger, lowInteger) {\n    this.high = highInteger | 0;\n    this.low = lowInteger | 0;\n  }\n  and(word) {\n    this.high &= word.high;\n    this.low &= word.low;\n  }\n  xor(word) {\n    this.high ^= word.high;\n    this.low ^= word.low;\n  }\n  or(word) {\n    this.high |= word.high;\n    this.low |= word.low;\n  }\n  shiftRight(places) {\n    if (places >= 32) {\n      this.low = this.high >>> places - 32 | 0;\n      this.high = 0;\n    } else {\n      this.low = this.low >>> places | this.high << 32 - places;\n      this.high = this.high >>> places | 0;\n    }\n  }\n  shiftLeft(places) {\n    if (places >= 32) {\n      this.high = this.low << places - 32;\n      this.low = 0;\n    } else {\n      this.high = this.high << places | this.low >>> 32 - places;\n      this.low <<= places;\n    }\n  }\n  rotateRight(places) {\n    let low, high;\n    if (places & 32) {\n      high = this.low;\n      low = this.high;\n    } else {\n      low = this.low;\n      high = this.high;\n    }\n    places &= 31;\n    this.low = low >>> places | high << 32 - places;\n    this.high = high >>> places | low << 32 - places;\n  }\n  not() {\n    this.high = ~this.high;\n    this.low = ~this.low;\n  }\n  add(word) {\n    const lowAdd = (this.low >>> 0) + (word.low >>> 0);\n    let highAdd = (this.high >>> 0) + (word.high >>> 0);\n    if (lowAdd > 0xffffffff) {\n      highAdd += 1;\n    }\n    this.low = lowAdd | 0;\n    this.high = highAdd | 0;\n  }\n  copyTo(bytes, offset) {\n    bytes[offset] = this.high >>> 24 & 0xff;\n    bytes[offset + 1] = this.high >> 16 & 0xff;\n    bytes[offset + 2] = this.high >> 8 & 0xff;\n    bytes[offset + 3] = this.high & 0xff;\n    bytes[offset + 4] = this.low >>> 24 & 0xff;\n    bytes[offset + 5] = this.low >> 16 & 0xff;\n    bytes[offset + 6] = this.low >> 8 & 0xff;\n    bytes[offset + 7] = this.low & 0xff;\n  }\n  assign(word) {\n    this.high = word.high;\n    this.low = word.low;\n  }\n}\nconst calculateSHA256 = function calculateSHA256Closure() {\n  function rotr(x, n) {\n    return x >>> n | x << 32 - n;\n  }\n  function ch(x, y, z) {\n    return x & y ^ ~x & z;\n  }\n  function maj(x, y, z) {\n    return x & y ^ x & z ^ y & z;\n  }\n  function sigma(x) {\n    return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);\n  }\n  function sigmaPrime(x) {\n    return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);\n  }\n  function littleSigma(x) {\n    return rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3;\n  }\n  function littleSigmaPrime(x) {\n    return rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10;\n  }\n  const k = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n  function hash(data, offset, length) {\n    let h0 = 0x6a09e667,\n      h1 = 0xbb67ae85,\n      h2 = 0x3c6ef372,\n      h3 = 0xa54ff53a,\n      h4 = 0x510e527f,\n      h5 = 0x9b05688c,\n      h6 = 0x1f83d9ab,\n      h7 = 0x5be0cd19;\n    const paddedLength = Math.ceil((length + 9) / 64) * 64;\n    const padded = new Uint8Array(paddedLength);\n    let i, j;\n    for (i = 0; i < length; ++i) {\n      padded[i] = data[offset++];\n    }\n    padded[i++] = 0x80;\n    const n = paddedLength - 8;\n    while (i < n) {\n      padded[i++] = 0;\n    }\n    padded[i++] = 0;\n    padded[i++] = 0;\n    padded[i++] = 0;\n    padded[i++] = length >>> 29 & 0xff;\n    padded[i++] = length >> 21 & 0xff;\n    padded[i++] = length >> 13 & 0xff;\n    padded[i++] = length >> 5 & 0xff;\n    padded[i++] = length << 3 & 0xff;\n    const w = new Uint32Array(64);\n    for (i = 0; i < paddedLength;) {\n      for (j = 0; j < 16; ++j) {\n        w[j] = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];\n        i += 4;\n      }\n      for (j = 16; j < 64; ++j) {\n        w[j] = littleSigmaPrime(w[j - 2]) + w[j - 7] + littleSigma(w[j - 15]) + w[j - 16] | 0;\n      }\n      let a = h0,\n        b = h1,\n        c = h2,\n        d = h3,\n        e = h4,\n        f = h5,\n        g = h6,\n        h = h7,\n        t1,\n        t2;\n      for (j = 0; j < 64; ++j) {\n        t1 = h + sigmaPrime(e) + ch(e, f, g) + k[j] + w[j];\n        t2 = sigma(a) + maj(a, b, c);\n        h = g;\n        g = f;\n        f = e;\n        e = d + t1 | 0;\n        d = c;\n        c = b;\n        b = a;\n        a = t1 + t2 | 0;\n      }\n      h0 = h0 + a | 0;\n      h1 = h1 + b | 0;\n      h2 = h2 + c | 0;\n      h3 = h3 + d | 0;\n      h4 = h4 + e | 0;\n      h5 = h5 + f | 0;\n      h6 = h6 + g | 0;\n      h7 = h7 + h | 0;\n    }\n    return new Uint8Array([h0 >> 24 & 0xFF, h0 >> 16 & 0xFF, h0 >> 8 & 0xFF, h0 & 0xFF, h1 >> 24 & 0xFF, h1 >> 16 & 0xFF, h1 >> 8 & 0xFF, h1 & 0xFF, h2 >> 24 & 0xFF, h2 >> 16 & 0xFF, h2 >> 8 & 0xFF, h2 & 0xFF, h3 >> 24 & 0xFF, h3 >> 16 & 0xFF, h3 >> 8 & 0xFF, h3 & 0xFF, h4 >> 24 & 0xFF, h4 >> 16 & 0xFF, h4 >> 8 & 0xFF, h4 & 0xFF, h5 >> 24 & 0xFF, h5 >> 16 & 0xFF, h5 >> 8 & 0xFF, h5 & 0xFF, h6 >> 24 & 0xFF, h6 >> 16 & 0xFF, h6 >> 8 & 0xFF, h6 & 0xFF, h7 >> 24 & 0xFF, h7 >> 16 & 0xFF, h7 >> 8 & 0xFF, h7 & 0xFF]);\n  }\n  return hash;\n}();\nconst calculateSHA512 = function calculateSHA512Closure() {\n  function ch(result, x, y, z, tmp) {\n    result.assign(x);\n    result.and(y);\n    tmp.assign(x);\n    tmp.not();\n    tmp.and(z);\n    result.xor(tmp);\n  }\n  function maj(result, x, y, z, tmp) {\n    result.assign(x);\n    result.and(y);\n    tmp.assign(x);\n    tmp.and(z);\n    result.xor(tmp);\n    tmp.assign(y);\n    tmp.and(z);\n    result.xor(tmp);\n  }\n  function sigma(result, x, tmp) {\n    result.assign(x);\n    result.rotateRight(28);\n    tmp.assign(x);\n    tmp.rotateRight(34);\n    result.xor(tmp);\n    tmp.assign(x);\n    tmp.rotateRight(39);\n    result.xor(tmp);\n  }\n  function sigmaPrime(result, x, tmp) {\n    result.assign(x);\n    result.rotateRight(14);\n    tmp.assign(x);\n    tmp.rotateRight(18);\n    result.xor(tmp);\n    tmp.assign(x);\n    tmp.rotateRight(41);\n    result.xor(tmp);\n  }\n  function littleSigma(result, x, tmp) {\n    result.assign(x);\n    result.rotateRight(1);\n    tmp.assign(x);\n    tmp.rotateRight(8);\n    result.xor(tmp);\n    tmp.assign(x);\n    tmp.shiftRight(7);\n    result.xor(tmp);\n  }\n  function littleSigmaPrime(result, x, tmp) {\n    result.assign(x);\n    result.rotateRight(19);\n    tmp.assign(x);\n    tmp.rotateRight(61);\n    result.xor(tmp);\n    tmp.assign(x);\n    tmp.shiftRight(6);\n    result.xor(tmp);\n  }\n  const k = [new Word64(0x428a2f98, 0xd728ae22), new Word64(0x71374491, 0x23ef65cd), new Word64(0xb5c0fbcf, 0xec4d3b2f), new Word64(0xe9b5dba5, 0x8189dbbc), new Word64(0x3956c25b, 0xf348b538), new Word64(0x59f111f1, 0xb605d019), new Word64(0x923f82a4, 0xaf194f9b), new Word64(0xab1c5ed5, 0xda6d8118), new Word64(0xd807aa98, 0xa3030242), new Word64(0x12835b01, 0x45706fbe), new Word64(0x243185be, 0x4ee4b28c), new Word64(0x550c7dc3, 0xd5ffb4e2), new Word64(0x72be5d74, 0xf27b896f), new Word64(0x80deb1fe, 0x3b1696b1), new Word64(0x9bdc06a7, 0x25c71235), new Word64(0xc19bf174, 0xcf692694), new Word64(0xe49b69c1, 0x9ef14ad2), new Word64(0xefbe4786, 0x384f25e3), new Word64(0x0fc19dc6, 0x8b8cd5b5), new Word64(0x240ca1cc, 0x77ac9c65), new Word64(0x2de92c6f, 0x592b0275), new Word64(0x4a7484aa, 0x6ea6e483), new Word64(0x5cb0a9dc, 0xbd41fbd4), new Word64(0x76f988da, 0x831153b5), new Word64(0x983e5152, 0xee66dfab), new Word64(0xa831c66d, 0x2db43210), new Word64(0xb00327c8, 0x98fb213f), new Word64(0xbf597fc7, 0xbeef0ee4), new Word64(0xc6e00bf3, 0x3da88fc2), new Word64(0xd5a79147, 0x930aa725), new Word64(0x06ca6351, 0xe003826f), new Word64(0x14292967, 0x0a0e6e70), new Word64(0x27b70a85, 0x46d22ffc), new Word64(0x2e1b2138, 0x5c26c926), new Word64(0x4d2c6dfc, 0x5ac42aed), new Word64(0x53380d13, 0x9d95b3df), new Word64(0x650a7354, 0x8baf63de), new Word64(0x766a0abb, 0x3c77b2a8), new Word64(0x81c2c92e, 0x47edaee6), new Word64(0x92722c85, 0x1482353b), new Word64(0xa2bfe8a1, 0x4cf10364), new Word64(0xa81a664b, 0xbc423001), new Word64(0xc24b8b70, 0xd0f89791), new Word64(0xc76c51a3, 0x0654be30), new Word64(0xd192e819, 0xd6ef5218), new Word64(0xd6990624, 0x5565a910), new Word64(0xf40e3585, 0x5771202a), new Word64(0x106aa070, 0x32bbd1b8), new Word64(0x19a4c116, 0xb8d2d0c8), new Word64(0x1e376c08, 0x5141ab53), new Word64(0x2748774c, 0xdf8eeb99), new Word64(0x34b0bcb5, 0xe19b48a8), new Word64(0x391c0cb3, 0xc5c95a63), new Word64(0x4ed8aa4a, 0xe3418acb), new Word64(0x5b9cca4f, 0x7763e373), new Word64(0x682e6ff3, 0xd6b2b8a3), new Word64(0x748f82ee, 0x5defb2fc), new Word64(0x78a5636f, 0x43172f60), new Word64(0x84c87814, 0xa1f0ab72), new Word64(0x8cc70208, 0x1a6439ec), new Word64(0x90befffa, 0x23631e28), new Word64(0xa4506ceb, 0xde82bde9), new Word64(0xbef9a3f7, 0xb2c67915), new Word64(0xc67178f2, 0xe372532b), new Word64(0xca273ece, 0xea26619c), new Word64(0xd186b8c7, 0x21c0c207), new Word64(0xeada7dd6, 0xcde0eb1e), new Word64(0xf57d4f7f, 0xee6ed178), new Word64(0x06f067aa, 0x72176fba), new Word64(0x0a637dc5, 0xa2c898a6), new Word64(0x113f9804, 0xbef90dae), new Word64(0x1b710b35, 0x131c471b), new Word64(0x28db77f5, 0x23047d84), new Word64(0x32caab7b, 0x40c72493), new Word64(0x3c9ebe0a, 0x15c9bebc), new Word64(0x431d67c4, 0x9c100d4c), new Word64(0x4cc5d4be, 0xcb3e42b6), new Word64(0x597f299c, 0xfc657e2a), new Word64(0x5fcb6fab, 0x3ad6faec), new Word64(0x6c44198c, 0x4a475817)];\n  function hash(data, offset, length, mode384 = false) {\n    let h0, h1, h2, h3, h4, h5, h6, h7;\n    if (!mode384) {\n      h0 = new Word64(0x6a09e667, 0xf3bcc908);\n      h1 = new Word64(0xbb67ae85, 0x84caa73b);\n      h2 = new Word64(0x3c6ef372, 0xfe94f82b);\n      h3 = new Word64(0xa54ff53a, 0x5f1d36f1);\n      h4 = new Word64(0x510e527f, 0xade682d1);\n      h5 = new Word64(0x9b05688c, 0x2b3e6c1f);\n      h6 = new Word64(0x1f83d9ab, 0xfb41bd6b);\n      h7 = new Word64(0x5be0cd19, 0x137e2179);\n    } else {\n      h0 = new Word64(0xcbbb9d5d, 0xc1059ed8);\n      h1 = new Word64(0x629a292a, 0x367cd507);\n      h2 = new Word64(0x9159015a, 0x3070dd17);\n      h3 = new Word64(0x152fecd8, 0xf70e5939);\n      h4 = new Word64(0x67332667, 0xffc00b31);\n      h5 = new Word64(0x8eb44a87, 0x68581511);\n      h6 = new Word64(0xdb0c2e0d, 0x64f98fa7);\n      h7 = new Word64(0x47b5481d, 0xbefa4fa4);\n    }\n    const paddedLength = Math.ceil((length + 17) / 128) * 128;\n    const padded = new Uint8Array(paddedLength);\n    let i, j;\n    for (i = 0; i < length; ++i) {\n      padded[i] = data[offset++];\n    }\n    padded[i++] = 0x80;\n    const n = paddedLength - 16;\n    while (i < n) {\n      padded[i++] = 0;\n    }\n    padded[i++] = 0;\n    padded[i++] = 0;\n    padded[i++] = 0;\n    padded[i++] = 0;\n    padded[i++] = 0;\n    padded[i++] = 0;\n    padded[i++] = 0;\n    padded[i++] = 0;\n    padded[i++] = 0;\n    padded[i++] = 0;\n    padded[i++] = 0;\n    padded[i++] = length >>> 29 & 0xff;\n    padded[i++] = length >> 21 & 0xff;\n    padded[i++] = length >> 13 & 0xff;\n    padded[i++] = length >> 5 & 0xff;\n    padded[i++] = length << 3 & 0xff;\n    const w = new Array(80);\n    for (i = 0; i < 80; i++) {\n      w[i] = new Word64(0, 0);\n    }\n    let a = new Word64(0, 0),\n      b = new Word64(0, 0),\n      c = new Word64(0, 0);\n    let d = new Word64(0, 0),\n      e = new Word64(0, 0),\n      f = new Word64(0, 0);\n    let g = new Word64(0, 0),\n      h = new Word64(0, 0);\n    const t1 = new Word64(0, 0),\n      t2 = new Word64(0, 0);\n    const tmp1 = new Word64(0, 0),\n      tmp2 = new Word64(0, 0);\n    let tmp3;\n    for (i = 0; i < paddedLength;) {\n      for (j = 0; j < 16; ++j) {\n        w[j].high = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];\n        w[j].low = padded[i + 4] << 24 | padded[i + 5] << 16 | padded[i + 6] << 8 | padded[i + 7];\n        i += 8;\n      }\n      for (j = 16; j < 80; ++j) {\n        tmp3 = w[j];\n        littleSigmaPrime(tmp3, w[j - 2], tmp2);\n        tmp3.add(w[j - 7]);\n        littleSigma(tmp1, w[j - 15], tmp2);\n        tmp3.add(tmp1);\n        tmp3.add(w[j - 16]);\n      }\n      a.assign(h0);\n      b.assign(h1);\n      c.assign(h2);\n      d.assign(h3);\n      e.assign(h4);\n      f.assign(h5);\n      g.assign(h6);\n      h.assign(h7);\n      for (j = 0; j < 80; ++j) {\n        t1.assign(h);\n        sigmaPrime(tmp1, e, tmp2);\n        t1.add(tmp1);\n        ch(tmp1, e, f, g, tmp2);\n        t1.add(tmp1);\n        t1.add(k[j]);\n        t1.add(w[j]);\n        sigma(t2, a, tmp2);\n        maj(tmp1, a, b, c, tmp2);\n        t2.add(tmp1);\n        tmp3 = h;\n        h = g;\n        g = f;\n        f = e;\n        d.add(t1);\n        e = d;\n        d = c;\n        c = b;\n        b = a;\n        tmp3.assign(t1);\n        tmp3.add(t2);\n        a = tmp3;\n      }\n      h0.add(a);\n      h1.add(b);\n      h2.add(c);\n      h3.add(d);\n      h4.add(e);\n      h5.add(f);\n      h6.add(g);\n      h7.add(h);\n    }\n    let result;\n    if (!mode384) {\n      result = new Uint8Array(64);\n      h0.copyTo(result, 0);\n      h1.copyTo(result, 8);\n      h2.copyTo(result, 16);\n      h3.copyTo(result, 24);\n      h4.copyTo(result, 32);\n      h5.copyTo(result, 40);\n      h6.copyTo(result, 48);\n      h7.copyTo(result, 56);\n    } else {\n      result = new Uint8Array(48);\n      h0.copyTo(result, 0);\n      h1.copyTo(result, 8);\n      h2.copyTo(result, 16);\n      h3.copyTo(result, 24);\n      h4.copyTo(result, 32);\n      h5.copyTo(result, 40);\n    }\n    return result;\n  }\n  return hash;\n}();\nfunction calculateSHA384(data, offset, length) {\n  return calculateSHA512(data, offset, length, true);\n}\nclass NullCipher {\n  decryptBlock(data) {\n    return data;\n  }\n  encrypt(data) {\n    return data;\n  }\n}\nclass AESBaseCipher {\n  constructor() {\n    if (this.constructor === AESBaseCipher) {\n      unreachable(\"Cannot initialize AESBaseCipher.\");\n    }\n    this._s = new Uint8Array([0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]);\n    this._inv_s = new Uint8Array([0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]);\n    this._mix = new Uint32Array([0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3]);\n    this._mixCol = new Uint8Array(256);\n    for (let i = 0; i < 256; i++) {\n      this._mixCol[i] = i < 128 ? i << 1 : i << 1 ^ 0x1b;\n    }\n    this.buffer = new Uint8Array(16);\n    this.bufferPosition = 0;\n  }\n  _expandKey(cipherKey) {\n    unreachable(\"Cannot call `_expandKey` on the base class\");\n  }\n  _decrypt(input, key) {\n    let t, u, v;\n    const state = new Uint8Array(16);\n    state.set(input);\n    for (let j = 0, k = this._keySize; j < 16; ++j, ++k) {\n      state[j] ^= key[k];\n    }\n    for (let i = this._cyclesOfRepetition - 1; i >= 1; --i) {\n      t = state[13];\n      state[13] = state[9];\n      state[9] = state[5];\n      state[5] = state[1];\n      state[1] = t;\n      t = state[14];\n      u = state[10];\n      state[14] = state[6];\n      state[10] = state[2];\n      state[6] = t;\n      state[2] = u;\n      t = state[15];\n      u = state[11];\n      v = state[7];\n      state[15] = state[3];\n      state[11] = t;\n      state[7] = u;\n      state[3] = v;\n      for (let j = 0; j < 16; ++j) {\n        state[j] = this._inv_s[state[j]];\n      }\n      for (let j = 0, k = i * 16; j < 16; ++j, ++k) {\n        state[j] ^= key[k];\n      }\n      for (let j = 0; j < 16; j += 4) {\n        const s0 = this._mix[state[j]];\n        const s1 = this._mix[state[j + 1]];\n        const s2 = this._mix[state[j + 2]];\n        const s3 = this._mix[state[j + 3]];\n        t = s0 ^ s1 >>> 8 ^ s1 << 24 ^ s2 >>> 16 ^ s2 << 16 ^ s3 >>> 24 ^ s3 << 8;\n        state[j] = t >>> 24 & 0xff;\n        state[j + 1] = t >> 16 & 0xff;\n        state[j + 2] = t >> 8 & 0xff;\n        state[j + 3] = t & 0xff;\n      }\n    }\n    t = state[13];\n    state[13] = state[9];\n    state[9] = state[5];\n    state[5] = state[1];\n    state[1] = t;\n    t = state[14];\n    u = state[10];\n    state[14] = state[6];\n    state[10] = state[2];\n    state[6] = t;\n    state[2] = u;\n    t = state[15];\n    u = state[11];\n    v = state[7];\n    state[15] = state[3];\n    state[11] = t;\n    state[7] = u;\n    state[3] = v;\n    for (let j = 0; j < 16; ++j) {\n      state[j] = this._inv_s[state[j]];\n      state[j] ^= key[j];\n    }\n    return state;\n  }\n  _encrypt(input, key) {\n    const s = this._s;\n    let t, u, v;\n    const state = new Uint8Array(16);\n    state.set(input);\n    for (let j = 0; j < 16; ++j) {\n      state[j] ^= key[j];\n    }\n    for (let i = 1; i < this._cyclesOfRepetition; i++) {\n      for (let j = 0; j < 16; ++j) {\n        state[j] = s[state[j]];\n      }\n      v = state[1];\n      state[1] = state[5];\n      state[5] = state[9];\n      state[9] = state[13];\n      state[13] = v;\n      v = state[2];\n      u = state[6];\n      state[2] = state[10];\n      state[6] = state[14];\n      state[10] = v;\n      state[14] = u;\n      v = state[3];\n      u = state[7];\n      t = state[11];\n      state[3] = state[15];\n      state[7] = v;\n      state[11] = u;\n      state[15] = t;\n      for (let j = 0; j < 16; j += 4) {\n        const s0 = state[j + 0];\n        const s1 = state[j + 1];\n        const s2 = state[j + 2];\n        const s3 = state[j + 3];\n        t = s0 ^ s1 ^ s2 ^ s3;\n        state[j + 0] ^= t ^ this._mixCol[s0 ^ s1];\n        state[j + 1] ^= t ^ this._mixCol[s1 ^ s2];\n        state[j + 2] ^= t ^ this._mixCol[s2 ^ s3];\n        state[j + 3] ^= t ^ this._mixCol[s3 ^ s0];\n      }\n      for (let j = 0, k = i * 16; j < 16; ++j, ++k) {\n        state[j] ^= key[k];\n      }\n    }\n    for (let j = 0; j < 16; ++j) {\n      state[j] = s[state[j]];\n    }\n    v = state[1];\n    state[1] = state[5];\n    state[5] = state[9];\n    state[9] = state[13];\n    state[13] = v;\n    v = state[2];\n    u = state[6];\n    state[2] = state[10];\n    state[6] = state[14];\n    state[10] = v;\n    state[14] = u;\n    v = state[3];\n    u = state[7];\n    t = state[11];\n    state[3] = state[15];\n    state[7] = v;\n    state[11] = u;\n    state[15] = t;\n    for (let j = 0, k = this._keySize; j < 16; ++j, ++k) {\n      state[j] ^= key[k];\n    }\n    return state;\n  }\n  _decryptBlock2(data, finalize) {\n    const sourceLength = data.length;\n    let buffer = this.buffer,\n      bufferLength = this.bufferPosition;\n    const result = [];\n    let iv = this.iv;\n    for (let i = 0; i < sourceLength; ++i) {\n      buffer[bufferLength] = data[i];\n      ++bufferLength;\n      if (bufferLength < 16) {\n        continue;\n      }\n      const plain = this._decrypt(buffer, this._key);\n      for (let j = 0; j < 16; ++j) {\n        plain[j] ^= iv[j];\n      }\n      iv = buffer;\n      result.push(plain);\n      buffer = new Uint8Array(16);\n      bufferLength = 0;\n    }\n    this.buffer = buffer;\n    this.bufferLength = bufferLength;\n    this.iv = iv;\n    if (result.length === 0) {\n      return new Uint8Array(0);\n    }\n    let outputLength = 16 * result.length;\n    if (finalize) {\n      const lastBlock = result.at(-1);\n      let psLen = lastBlock[15];\n      if (psLen <= 16) {\n        for (let i = 15, ii = 16 - psLen; i >= ii; --i) {\n          if (lastBlock[i] !== psLen) {\n            psLen = 0;\n            break;\n          }\n        }\n        outputLength -= psLen;\n        result[result.length - 1] = lastBlock.subarray(0, 16 - psLen);\n      }\n    }\n    const output = new Uint8Array(outputLength);\n    for (let i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {\n      output.set(result[i], j);\n    }\n    return output;\n  }\n  decryptBlock(data, finalize, iv = null) {\n    const sourceLength = data.length;\n    const buffer = this.buffer;\n    let bufferLength = this.bufferPosition;\n    if (iv) {\n      this.iv = iv;\n    } else {\n      for (let i = 0; bufferLength < 16 && i < sourceLength; ++i, ++bufferLength) {\n        buffer[bufferLength] = data[i];\n      }\n      if (bufferLength < 16) {\n        this.bufferLength = bufferLength;\n        return new Uint8Array(0);\n      }\n      this.iv = buffer;\n      data = data.subarray(16);\n    }\n    this.buffer = new Uint8Array(16);\n    this.bufferLength = 0;\n    this.decryptBlock = this._decryptBlock2;\n    return this.decryptBlock(data, finalize);\n  }\n  encrypt(data, iv) {\n    const sourceLength = data.length;\n    let buffer = this.buffer,\n      bufferLength = this.bufferPosition;\n    const result = [];\n    if (!iv) {\n      iv = new Uint8Array(16);\n    }\n    for (let i = 0; i < sourceLength; ++i) {\n      buffer[bufferLength] = data[i];\n      ++bufferLength;\n      if (bufferLength < 16) {\n        continue;\n      }\n      for (let j = 0; j < 16; ++j) {\n        buffer[j] ^= iv[j];\n      }\n      const cipher = this._encrypt(buffer, this._key);\n      iv = cipher;\n      result.push(cipher);\n      buffer = new Uint8Array(16);\n      bufferLength = 0;\n    }\n    this.buffer = buffer;\n    this.bufferLength = bufferLength;\n    this.iv = iv;\n    if (result.length === 0) {\n      return new Uint8Array(0);\n    }\n    const outputLength = 16 * result.length;\n    const output = new Uint8Array(outputLength);\n    for (let i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {\n      output.set(result[i], j);\n    }\n    return output;\n  }\n}\nclass AES128Cipher extends AESBaseCipher {\n  constructor(key) {\n    super();\n    this._cyclesOfRepetition = 10;\n    this._keySize = 160;\n    this._rcon = new Uint8Array([0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d]);\n    this._key = this._expandKey(key);\n  }\n  _expandKey(cipherKey) {\n    const b = 176;\n    const s = this._s;\n    const rcon = this._rcon;\n    const result = new Uint8Array(b);\n    result.set(cipherKey);\n    for (let j = 16, i = 1; j < b; ++i) {\n      let t1 = result[j - 3];\n      let t2 = result[j - 2];\n      let t3 = result[j - 1];\n      let t4 = result[j - 4];\n      t1 = s[t1];\n      t2 = s[t2];\n      t3 = s[t3];\n      t4 = s[t4];\n      t1 ^= rcon[i];\n      for (let n = 0; n < 4; ++n) {\n        result[j] = t1 ^= result[j - 16];\n        j++;\n        result[j] = t2 ^= result[j - 16];\n        j++;\n        result[j] = t3 ^= result[j - 16];\n        j++;\n        result[j] = t4 ^= result[j - 16];\n        j++;\n      }\n    }\n    return result;\n  }\n}\nclass AES256Cipher extends AESBaseCipher {\n  constructor(key) {\n    super();\n    this._cyclesOfRepetition = 14;\n    this._keySize = 224;\n    this._key = this._expandKey(key);\n  }\n  _expandKey(cipherKey) {\n    const b = 240;\n    const s = this._s;\n    const result = new Uint8Array(b);\n    result.set(cipherKey);\n    let r = 1;\n    let t1, t2, t3, t4;\n    for (let j = 32, i = 1; j < b; ++i) {\n      if (j % 32 === 16) {\n        t1 = s[t1];\n        t2 = s[t2];\n        t3 = s[t3];\n        t4 = s[t4];\n      } else if (j % 32 === 0) {\n        t1 = result[j - 3];\n        t2 = result[j - 2];\n        t3 = result[j - 1];\n        t4 = result[j - 4];\n        t1 = s[t1];\n        t2 = s[t2];\n        t3 = s[t3];\n        t4 = s[t4];\n        t1 ^= r;\n        if ((r <<= 1) >= 256) {\n          r = (r ^ 0x1b) & 0xff;\n        }\n      }\n      for (let n = 0; n < 4; ++n) {\n        result[j] = t1 ^= result[j - 32];\n        j++;\n        result[j] = t2 ^= result[j - 32];\n        j++;\n        result[j] = t3 ^= result[j - 32];\n        j++;\n        result[j] = t4 ^= result[j - 32];\n        j++;\n      }\n    }\n    return result;\n  }\n}\nclass PDF17 {\n  checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {\n    const hashData = new Uint8Array(password.length + 56);\n    hashData.set(password, 0);\n    hashData.set(ownerValidationSalt, password.length);\n    hashData.set(userBytes, password.length + ownerValidationSalt.length);\n    const result = calculateSHA256(hashData, 0, hashData.length);\n    return isArrayEqual(result, ownerPassword);\n  }\n  checkUserPassword(password, userValidationSalt, userPassword) {\n    const hashData = new Uint8Array(password.length + 8);\n    hashData.set(password, 0);\n    hashData.set(userValidationSalt, password.length);\n    const result = calculateSHA256(hashData, 0, hashData.length);\n    return isArrayEqual(result, userPassword);\n  }\n  getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {\n    const hashData = new Uint8Array(password.length + 56);\n    hashData.set(password, 0);\n    hashData.set(ownerKeySalt, password.length);\n    hashData.set(userBytes, password.length + ownerKeySalt.length);\n    const key = calculateSHA256(hashData, 0, hashData.length);\n    const cipher = new AES256Cipher(key);\n    return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));\n  }\n  getUserKey(password, userKeySalt, userEncryption) {\n    const hashData = new Uint8Array(password.length + 8);\n    hashData.set(password, 0);\n    hashData.set(userKeySalt, password.length);\n    const key = calculateSHA256(hashData, 0, hashData.length);\n    const cipher = new AES256Cipher(key);\n    return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));\n  }\n}\nclass PDF20 {\n  _hash(password, input, userBytes) {\n    let k = calculateSHA256(input, 0, input.length).subarray(0, 32);\n    let e = [0];\n    let i = 0;\n    while (i < 64 || e.at(-1) > i - 32) {\n      const combinedLength = password.length + k.length + userBytes.length,\n        combinedArray = new Uint8Array(combinedLength);\n      let writeOffset = 0;\n      combinedArray.set(password, writeOffset);\n      writeOffset += password.length;\n      combinedArray.set(k, writeOffset);\n      writeOffset += k.length;\n      combinedArray.set(userBytes, writeOffset);\n      const k1 = new Uint8Array(combinedLength * 64);\n      for (let j = 0, pos = 0; j < 64; j++, pos += combinedLength) {\n        k1.set(combinedArray, pos);\n      }\n      const cipher = new AES128Cipher(k.subarray(0, 16));\n      e = cipher.encrypt(k1, k.subarray(16, 32));\n      const remainder = e.slice(0, 16).reduce((a, b) => a + b, 0) % 3;\n      if (remainder === 0) {\n        k = calculateSHA256(e, 0, e.length);\n      } else if (remainder === 1) {\n        k = calculateSHA384(e, 0, e.length);\n      } else if (remainder === 2) {\n        k = calculateSHA512(e, 0, e.length);\n      }\n      i++;\n    }\n    return k.subarray(0, 32);\n  }\n  checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {\n    const hashData = new Uint8Array(password.length + 56);\n    hashData.set(password, 0);\n    hashData.set(ownerValidationSalt, password.length);\n    hashData.set(userBytes, password.length + ownerValidationSalt.length);\n    const result = this._hash(password, hashData, userBytes);\n    return isArrayEqual(result, ownerPassword);\n  }\n  checkUserPassword(password, userValidationSalt, userPassword) {\n    const hashData = new Uint8Array(password.length + 8);\n    hashData.set(password, 0);\n    hashData.set(userValidationSalt, password.length);\n    const result = this._hash(password, hashData, []);\n    return isArrayEqual(result, userPassword);\n  }\n  getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {\n    const hashData = new Uint8Array(password.length + 56);\n    hashData.set(password, 0);\n    hashData.set(ownerKeySalt, password.length);\n    hashData.set(userBytes, password.length + ownerKeySalt.length);\n    const key = this._hash(password, hashData, userBytes);\n    const cipher = new AES256Cipher(key);\n    return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));\n  }\n  getUserKey(password, userKeySalt, userEncryption) {\n    const hashData = new Uint8Array(password.length + 8);\n    hashData.set(password, 0);\n    hashData.set(userKeySalt, password.length);\n    const key = this._hash(password, hashData, []);\n    const cipher = new AES256Cipher(key);\n    return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));\n  }\n}\nclass CipherTransform {\n  constructor(stringCipherConstructor, streamCipherConstructor) {\n    this.StringCipherConstructor = stringCipherConstructor;\n    this.StreamCipherConstructor = streamCipherConstructor;\n  }\n  createStream(stream, length) {\n    const cipher = new this.StreamCipherConstructor();\n    return new DecryptStream(stream, length, function cipherTransformDecryptStream(data, finalize) {\n      return cipher.decryptBlock(data, finalize);\n    });\n  }\n  decryptString(s) {\n    const cipher = new this.StringCipherConstructor();\n    let data = stringToBytes(s);\n    data = cipher.decryptBlock(data, true);\n    return bytesToString(data);\n  }\n  encryptString(s) {\n    const cipher = new this.StringCipherConstructor();\n    if (cipher instanceof AESBaseCipher) {\n      const strLen = s.length;\n      const pad = 16 - strLen % 16;\n      s += String.fromCharCode(pad).repeat(pad);\n      const iv = new Uint8Array(16);\n      if (typeof crypto !== \"undefined\") {\n        crypto.getRandomValues(iv);\n      } else {\n        for (let i = 0; i < 16; i++) {\n          iv[i] = Math.floor(256 * Math.random());\n        }\n      }\n      let data = stringToBytes(s);\n      data = cipher.encrypt(data, iv);\n      const buf = new Uint8Array(16 + data.length);\n      buf.set(iv);\n      buf.set(data, 16);\n      return bytesToString(buf);\n    }\n    let data = stringToBytes(s);\n    data = cipher.encrypt(data);\n    return bytesToString(data);\n  }\n}\nclass CipherTransformFactory {\n  static #defaultPasswordBytes = new Uint8Array([0x28, 0xbf, 0x4e, 0x5e, 0x4e, 0x75, 0x8a, 0x41, 0x64, 0x00, 0x4e, 0x56, 0xff, 0xfa, 0x01, 0x08, 0x2e, 0x2e, 0x00, 0xb6, 0xd0, 0x68, 0x3e, 0x80, 0x2f, 0x0c, 0xa9, 0xfe, 0x64, 0x53, 0x69, 0x7a]);\n  #createEncryptionKey20(revision, password, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms) {\n    if (password) {\n      const passwordLength = Math.min(127, password.length);\n      password = password.subarray(0, passwordLength);\n    } else {\n      password = [];\n    }\n    const pdfAlgorithm = revision === 6 ? new PDF20() : new PDF17();\n    if (pdfAlgorithm.checkUserPassword(password, userValidationSalt, userPassword)) {\n      return pdfAlgorithm.getUserKey(password, userKeySalt, userEncryption);\n    } else if (password.length && pdfAlgorithm.checkOwnerPassword(password, ownerValidationSalt, uBytes, ownerPassword)) {\n      return pdfAlgorithm.getOwnerKey(password, ownerKeySalt, uBytes, ownerEncryption);\n    }\n    return null;\n  }\n  #prepareKeyData(fileId, password, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata) {\n    const hashDataSize = 40 + ownerPassword.length + fileId.length;\n    const hashData = new Uint8Array(hashDataSize);\n    let i = 0,\n      j,\n      n;\n    if (password) {\n      n = Math.min(32, password.length);\n      for (; i < n; ++i) {\n        hashData[i] = password[i];\n      }\n    }\n    j = 0;\n    while (i < 32) {\n      hashData[i++] = CipherTransformFactory.#defaultPasswordBytes[j++];\n    }\n    for (j = 0, n = ownerPassword.length; j < n; ++j) {\n      hashData[i++] = ownerPassword[j];\n    }\n    hashData[i++] = flags & 0xff;\n    hashData[i++] = flags >> 8 & 0xff;\n    hashData[i++] = flags >> 16 & 0xff;\n    hashData[i++] = flags >>> 24 & 0xff;\n    for (j = 0, n = fileId.length; j < n; ++j) {\n      hashData[i++] = fileId[j];\n    }\n    if (revision >= 4 && !encryptMetadata) {\n      hashData[i++] = 0xff;\n      hashData[i++] = 0xff;\n      hashData[i++] = 0xff;\n      hashData[i++] = 0xff;\n    }\n    let hash = calculateMD5(hashData, 0, i);\n    const keyLengthInBytes = keyLength >> 3;\n    if (revision >= 3) {\n      for (j = 0; j < 50; ++j) {\n        hash = calculateMD5(hash, 0, keyLengthInBytes);\n      }\n    }\n    const encryptionKey = hash.subarray(0, keyLengthInBytes);\n    let cipher, checkData;\n    if (revision >= 3) {\n      for (i = 0; i < 32; ++i) {\n        hashData[i] = CipherTransformFactory.#defaultPasswordBytes[i];\n      }\n      for (j = 0, n = fileId.length; j < n; ++j) {\n        hashData[i++] = fileId[j];\n      }\n      cipher = new ARCFourCipher(encryptionKey);\n      checkData = cipher.encryptBlock(calculateMD5(hashData, 0, i));\n      n = encryptionKey.length;\n      const derivedKey = new Uint8Array(n);\n      for (j = 1; j <= 19; ++j) {\n        for (let k = 0; k < n; ++k) {\n          derivedKey[k] = encryptionKey[k] ^ j;\n        }\n        cipher = new ARCFourCipher(derivedKey);\n        checkData = cipher.encryptBlock(checkData);\n      }\n      for (j = 0, n = checkData.length; j < n; ++j) {\n        if (userPassword[j] !== checkData[j]) {\n          return null;\n        }\n      }\n    } else {\n      cipher = new ARCFourCipher(encryptionKey);\n      checkData = cipher.encryptBlock(CipherTransformFactory.#defaultPasswordBytes);\n      for (j = 0, n = checkData.length; j < n; ++j) {\n        if (userPassword[j] !== checkData[j]) {\n          return null;\n        }\n      }\n    }\n    return encryptionKey;\n  }\n  #decodeUserPassword(password, ownerPassword, revision, keyLength) {\n    const hashData = new Uint8Array(32);\n    let i = 0;\n    const n = Math.min(32, password.length);\n    for (; i < n; ++i) {\n      hashData[i] = password[i];\n    }\n    let j = 0;\n    while (i < 32) {\n      hashData[i++] = CipherTransformFactory.#defaultPasswordBytes[j++];\n    }\n    let hash = calculateMD5(hashData, 0, i);\n    const keyLengthInBytes = keyLength >> 3;\n    if (revision >= 3) {\n      for (j = 0; j < 50; ++j) {\n        hash = calculateMD5(hash, 0, hash.length);\n      }\n    }\n    let cipher, userPassword;\n    if (revision >= 3) {\n      userPassword = ownerPassword;\n      const derivedKey = new Uint8Array(keyLengthInBytes);\n      for (j = 19; j >= 0; j--) {\n        for (let k = 0; k < keyLengthInBytes; ++k) {\n          derivedKey[k] = hash[k] ^ j;\n        }\n        cipher = new ARCFourCipher(derivedKey);\n        userPassword = cipher.encryptBlock(userPassword);\n      }\n    } else {\n      cipher = new ARCFourCipher(hash.subarray(0, keyLengthInBytes));\n      userPassword = cipher.encryptBlock(ownerPassword);\n    }\n    return userPassword;\n  }\n  #buildObjectKey(num, gen, encryptionKey, isAes = false) {\n    const key = new Uint8Array(encryptionKey.length + 9);\n    const n = encryptionKey.length;\n    let i;\n    for (i = 0; i < n; ++i) {\n      key[i] = encryptionKey[i];\n    }\n    key[i++] = num & 0xff;\n    key[i++] = num >> 8 & 0xff;\n    key[i++] = num >> 16 & 0xff;\n    key[i++] = gen & 0xff;\n    key[i++] = gen >> 8 & 0xff;\n    if (isAes) {\n      key[i++] = 0x73;\n      key[i++] = 0x41;\n      key[i++] = 0x6c;\n      key[i++] = 0x54;\n    }\n    const hash = calculateMD5(key, 0, i);\n    return hash.subarray(0, Math.min(encryptionKey.length + 5, 16));\n  }\n  #buildCipherConstructor(cf, name, num, gen, key) {\n    if (!(name instanceof Name)) {\n      throw new FormatError(\"Invalid crypt filter name.\");\n    }\n    const self = this;\n    const cryptFilter = cf.get(name.name);\n    const cfm = cryptFilter?.get(\"CFM\");\n    if (!cfm || cfm.name === \"None\") {\n      return function () {\n        return new NullCipher();\n      };\n    }\n    if (cfm.name === \"V2\") {\n      return function () {\n        return new ARCFourCipher(self.#buildObjectKey(num, gen, key, false));\n      };\n    }\n    if (cfm.name === \"AESV2\") {\n      return function () {\n        return new AES128Cipher(self.#buildObjectKey(num, gen, key, true));\n      };\n    }\n    if (cfm.name === \"AESV3\") {\n      return function () {\n        return new AES256Cipher(key);\n      };\n    }\n    throw new FormatError(\"Unknown crypto method\");\n  }\n  constructor(dict, fileId, password) {\n    const filter = dict.get(\"Filter\");\n    if (!isName(filter, \"Standard\")) {\n      throw new FormatError(\"unknown encryption method\");\n    }\n    this.filterName = filter.name;\n    this.dict = dict;\n    const algorithm = dict.get(\"V\");\n    if (!Number.isInteger(algorithm) || algorithm !== 1 && algorithm !== 2 && algorithm !== 4 && algorithm !== 5) {\n      throw new FormatError(\"unsupported encryption algorithm\");\n    }\n    this.algorithm = algorithm;\n    let keyLength = dict.get(\"Length\");\n    if (!keyLength) {\n      if (algorithm <= 3) {\n        keyLength = 40;\n      } else {\n        const cfDict = dict.get(\"CF\");\n        const streamCryptoName = dict.get(\"StmF\");\n        if (cfDict instanceof Dict && streamCryptoName instanceof Name) {\n          cfDict.suppressEncryption = true;\n          const handlerDict = cfDict.get(streamCryptoName.name);\n          keyLength = handlerDict?.get(\"Length\") || 128;\n          if (keyLength < 40) {\n            keyLength <<= 3;\n          }\n        }\n      }\n    }\n    if (!Number.isInteger(keyLength) || keyLength < 40 || keyLength % 8 !== 0) {\n      throw new FormatError(\"invalid key length\");\n    }\n    const ownerBytes = stringToBytes(dict.get(\"O\")),\n      userBytes = stringToBytes(dict.get(\"U\"));\n    const ownerPassword = ownerBytes.subarray(0, 32);\n    const userPassword = userBytes.subarray(0, 32);\n    const flags = dict.get(\"P\");\n    const revision = dict.get(\"R\");\n    const encryptMetadata = (algorithm === 4 || algorithm === 5) && dict.get(\"EncryptMetadata\") !== false;\n    this.encryptMetadata = encryptMetadata;\n    const fileIdBytes = stringToBytes(fileId);\n    let passwordBytes;\n    if (password) {\n      if (revision === 6) {\n        try {\n          password = utf8StringToString(password);\n        } catch {\n          warn(\"CipherTransformFactory: Unable to convert UTF8 encoded password.\");\n        }\n      }\n      passwordBytes = stringToBytes(password);\n    }\n    let encryptionKey;\n    if (algorithm !== 5) {\n      encryptionKey = this.#prepareKeyData(fileIdBytes, passwordBytes, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);\n    } else {\n      const ownerValidationSalt = ownerBytes.subarray(32, 40);\n      const ownerKeySalt = ownerBytes.subarray(40, 48);\n      const uBytes = userBytes.subarray(0, 48);\n      const userValidationSalt = userBytes.subarray(32, 40);\n      const userKeySalt = userBytes.subarray(40, 48);\n      const ownerEncryption = stringToBytes(dict.get(\"OE\"));\n      const userEncryption = stringToBytes(dict.get(\"UE\"));\n      const perms = stringToBytes(dict.get(\"Perms\"));\n      encryptionKey = this.#createEncryptionKey20(revision, passwordBytes, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms);\n    }\n    if (!encryptionKey && !password) {\n      throw new PasswordException(\"No password given\", PasswordResponses.NEED_PASSWORD);\n    } else if (!encryptionKey && password) {\n      const decodedPassword = this.#decodeUserPassword(passwordBytes, ownerPassword, revision, keyLength);\n      encryptionKey = this.#prepareKeyData(fileIdBytes, decodedPassword, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);\n    }\n    if (!encryptionKey) {\n      throw new PasswordException(\"Incorrect Password\", PasswordResponses.INCORRECT_PASSWORD);\n    }\n    this.encryptionKey = encryptionKey;\n    if (algorithm >= 4) {\n      const cf = dict.get(\"CF\");\n      if (cf instanceof Dict) {\n        cf.suppressEncryption = true;\n      }\n      this.cf = cf;\n      this.stmf = dict.get(\"StmF\") || Name.get(\"Identity\");\n      this.strf = dict.get(\"StrF\") || Name.get(\"Identity\");\n      this.eff = dict.get(\"EFF\") || this.stmf;\n    }\n  }\n  createCipherTransform(num, gen) {\n    if (this.algorithm === 4 || this.algorithm === 5) {\n      return new CipherTransform(this.#buildCipherConstructor(this.cf, this.strf, num, gen, this.encryptionKey), this.#buildCipherConstructor(this.cf, this.stmf, num, gen, this.encryptionKey));\n    }\n    const key = this.#buildObjectKey(num, gen, this.encryptionKey, false);\n    const cipherConstructor = function () {\n      return new ARCFourCipher(key);\n    };\n    return new CipherTransform(cipherConstructor, cipherConstructor);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/writer.js\n\n\n\n\n\n\n\nasync function writeObject(ref, obj, buffer, {\n  encrypt = null\n}) {\n  const transform = encrypt?.createCipherTransform(ref.num, ref.gen);\n  buffer.push(`${ref.num} ${ref.gen} obj\\n`);\n  if (obj instanceof Dict) {\n    await writeDict(obj, buffer, transform);\n  } else if (obj instanceof BaseStream) {\n    await writeStream(obj, buffer, transform);\n  } else if (Array.isArray(obj) || ArrayBuffer.isView(obj)) {\n    await writeArray(obj, buffer, transform);\n  }\n  buffer.push(\"\\nendobj\\n\");\n}\nasync function writeDict(dict, buffer, transform) {\n  buffer.push(\"<<\");\n  for (const key of dict.getKeys()) {\n    buffer.push(` /${escapePDFName(key)} `);\n    await writeValue(dict.getRaw(key), buffer, transform);\n  }\n  buffer.push(\">>\");\n}\nasync function writeStream(stream, buffer, transform) {\n  let bytes = stream.getBytes();\n  const {\n    dict\n  } = stream;\n  const [filter, params] = await Promise.all([dict.getAsync(\"Filter\"), dict.getAsync(\"DecodeParms\")]);\n  const filterZero = Array.isArray(filter) ? await dict.xref.fetchIfRefAsync(filter[0]) : filter;\n  const isFilterZeroFlateDecode = isName(filterZero, \"FlateDecode\");\n  const MIN_LENGTH_FOR_COMPRESSING = 256;\n  if (bytes.length >= MIN_LENGTH_FOR_COMPRESSING || isFilterZeroFlateDecode) {\n    try {\n      const cs = new CompressionStream(\"deflate\");\n      const writer = cs.writable.getWriter();\n      writer.write(bytes);\n      writer.close();\n      const buf = await new Response(cs.readable).arrayBuffer();\n      bytes = new Uint8Array(buf);\n      let newFilter, newParams;\n      if (!filter) {\n        newFilter = Name.get(\"FlateDecode\");\n      } else if (!isFilterZeroFlateDecode) {\n        newFilter = Array.isArray(filter) ? [Name.get(\"FlateDecode\"), ...filter] : [Name.get(\"FlateDecode\"), filter];\n        if (params) {\n          newParams = Array.isArray(params) ? [null, ...params] : [null, params];\n        }\n      }\n      if (newFilter) {\n        dict.set(\"Filter\", newFilter);\n      }\n      if (newParams) {\n        dict.set(\"DecodeParms\", newParams);\n      }\n    } catch (ex) {\n      info(`writeStream - cannot compress data: \"${ex}\".`);\n    }\n  }\n  let string = bytesToString(bytes);\n  if (transform) {\n    string = transform.encryptString(string);\n  }\n  dict.set(\"Length\", string.length);\n  await writeDict(dict, buffer, transform);\n  buffer.push(\" stream\\n\", string, \"\\nendstream\");\n}\nasync function writeArray(array, buffer, transform) {\n  buffer.push(\"[\");\n  let first = true;\n  for (const val of array) {\n    if (!first) {\n      buffer.push(\" \");\n    } else {\n      first = false;\n    }\n    await writeValue(val, buffer, transform);\n  }\n  buffer.push(\"]\");\n}\nasync function writeValue(value, buffer, transform) {\n  if (value instanceof Name) {\n    buffer.push(`/${escapePDFName(value.name)}`);\n  } else if (value instanceof Ref) {\n    buffer.push(`${value.num} ${value.gen} R`);\n  } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    await writeArray(value, buffer, transform);\n  } else if (typeof value === \"string\") {\n    if (transform) {\n      value = transform.encryptString(value);\n    }\n    buffer.push(`(${escapeString(value)})`);\n  } else if (typeof value === \"number\") {\n    buffer.push(numberToString(value));\n  } else if (typeof value === \"boolean\") {\n    buffer.push(value.toString());\n  } else if (value instanceof Dict) {\n    await writeDict(value, buffer, transform);\n  } else if (value instanceof BaseStream) {\n    await writeStream(value, buffer, transform);\n  } else if (value === null) {\n    buffer.push(\"null\");\n  } else {\n    warn(`Unhandled value in writer: ${typeof value}, please file a bug.`);\n  }\n}\nfunction writeInt(number, size, offset, buffer) {\n  for (let i = size + offset - 1; i > offset - 1; i--) {\n    buffer[i] = number & 0xff;\n    number >>= 8;\n  }\n  return offset + size;\n}\nfunction writeString(string, offset, buffer) {\n  for (let i = 0, len = string.length; i < len; i++) {\n    buffer[offset + i] = string.charCodeAt(i) & 0xff;\n  }\n}\nfunction computeMD5(filesize, xrefInfo) {\n  const time = Math.floor(Date.now() / 1000);\n  const filename = xrefInfo.filename || \"\";\n  const md5Buffer = [time.toString(), filename, filesize.toString()];\n  let md5BufferLen = md5Buffer.reduce((a, str) => a + str.length, 0);\n  for (const value of Object.values(xrefInfo.info)) {\n    md5Buffer.push(value);\n    md5BufferLen += value.length;\n  }\n  const array = new Uint8Array(md5BufferLen);\n  let offset = 0;\n  for (const str of md5Buffer) {\n    writeString(str, offset, array);\n    offset += str.length;\n  }\n  return bytesToString(calculateMD5(array));\n}\nfunction writeXFADataForAcroform(str, newRefs) {\n  const xml = new SimpleXMLParser({\n    hasAttributes: true\n  }).parseFromString(str);\n  for (const {\n    xfa\n  } of newRefs) {\n    if (!xfa) {\n      continue;\n    }\n    const {\n      path,\n      value\n    } = xfa;\n    if (!path) {\n      continue;\n    }\n    const nodePath = parseXFAPath(path);\n    let node = xml.documentElement.searchNode(nodePath, 0);\n    if (!node && nodePath.length > 1) {\n      node = xml.documentElement.searchNode([nodePath.at(-1)], 0);\n    }\n    if (node) {\n      node.childNodes = Array.isArray(value) ? value.map(val => new SimpleDOMNode(\"value\", val)) : [new SimpleDOMNode(\"#text\", value)];\n    } else {\n      warn(`Node not found for path: ${path}`);\n    }\n  }\n  const buffer = [];\n  xml.documentElement.dump(buffer);\n  return buffer.join(\"\");\n}\nasync function updateAcroform({\n  xref,\n  acroForm,\n  acroFormRef,\n  hasXfa,\n  hasXfaDatasetsEntry,\n  xfaDatasetsRef,\n  needAppearances,\n  newRefs\n}) {\n  if (hasXfa && !hasXfaDatasetsEntry && !xfaDatasetsRef) {\n    warn(\"XFA - Cannot save it\");\n  }\n  if (!needAppearances && (!hasXfa || !xfaDatasetsRef || hasXfaDatasetsEntry)) {\n    return;\n  }\n  const dict = acroForm.clone();\n  if (hasXfa && !hasXfaDatasetsEntry) {\n    const newXfa = acroForm.get(\"XFA\").slice();\n    newXfa.splice(2, 0, \"datasets\");\n    newXfa.splice(3, 0, xfaDatasetsRef);\n    dict.set(\"XFA\", newXfa);\n  }\n  if (needAppearances) {\n    dict.set(\"NeedAppearances\", true);\n  }\n  const buffer = [];\n  await writeObject(acroFormRef, dict, buffer, xref);\n  newRefs.push({\n    ref: acroFormRef,\n    data: buffer.join(\"\")\n  });\n}\nfunction updateXFA({\n  xfaData,\n  xfaDatasetsRef,\n  newRefs,\n  xref\n}) {\n  if (xfaData === null) {\n    const datasets = xref.fetchIfRef(xfaDatasetsRef);\n    xfaData = writeXFADataForAcroform(datasets.getString(), newRefs);\n  }\n  const encrypt = xref.encrypt;\n  if (encrypt) {\n    const transform = encrypt.createCipherTransform(xfaDatasetsRef.num, xfaDatasetsRef.gen);\n    xfaData = transform.encryptString(xfaData);\n  }\n  const data = `${xfaDatasetsRef.num} ${xfaDatasetsRef.gen} obj\\n` + `<< /Type /EmbeddedFile /Length ${xfaData.length}>>\\nstream\\n` + xfaData + \"\\nendstream\\nendobj\\n\";\n  newRefs.push({\n    ref: xfaDatasetsRef,\n    data\n  });\n}\nasync function getXRefTable(xrefInfo, baseOffset, newRefs, newXref, buffer) {\n  buffer.push(\"xref\\n\");\n  const indexes = getIndexes(newRefs);\n  let indexesPosition = 0;\n  for (const {\n    ref,\n    data\n  } of newRefs) {\n    if (ref.num === indexes[indexesPosition]) {\n      buffer.push(`${indexes[indexesPosition]} ${indexes[indexesPosition + 1]}\\n`);\n      indexesPosition += 2;\n    }\n    if (data !== null) {\n      buffer.push(`${baseOffset.toString().padStart(10, \"0\")} ${Math.min(ref.gen, 0xffff).toString().padStart(5, \"0\")} n\\r\\n`);\n      baseOffset += data.length;\n    } else {\n      buffer.push(`0000000000 ${Math.min(ref.gen + 1, 0xffff).toString().padStart(5, \"0\")} f\\r\\n`);\n    }\n  }\n  computeIDs(baseOffset, xrefInfo, newXref);\n  buffer.push(\"trailer\\n\");\n  await writeDict(newXref, buffer);\n  buffer.push(\"\\nstartxref\\n\", baseOffset.toString(), \"\\n%%EOF\\n\");\n}\nfunction getIndexes(newRefs) {\n  const indexes = [];\n  for (const {\n    ref\n  } of newRefs) {\n    if (ref.num === indexes.at(-2) + indexes.at(-1)) {\n      indexes[indexes.length - 1] += 1;\n    } else {\n      indexes.push(ref.num, 1);\n    }\n  }\n  return indexes;\n}\nasync function getXRefStreamTable(xrefInfo, baseOffset, newRefs, newXref, buffer) {\n  const xrefTableData = [];\n  let maxOffset = 0;\n  let maxGen = 0;\n  for (const {\n    ref,\n    data\n  } of newRefs) {\n    let gen;\n    maxOffset = Math.max(maxOffset, baseOffset);\n    if (data !== null) {\n      gen = Math.min(ref.gen, 0xffff);\n      xrefTableData.push([1, baseOffset, gen]);\n      baseOffset += data.length;\n    } else {\n      gen = Math.min(ref.gen + 1, 0xffff);\n      xrefTableData.push([0, 0, gen]);\n    }\n    maxGen = Math.max(maxGen, gen);\n  }\n  newXref.set(\"Index\", getIndexes(newRefs));\n  const offsetSize = getSizeInBytes(maxOffset);\n  const maxGenSize = getSizeInBytes(maxGen);\n  const sizes = [1, offsetSize, maxGenSize];\n  newXref.set(\"W\", sizes);\n  computeIDs(baseOffset, xrefInfo, newXref);\n  const structSize = sizes.reduce((a, x) => a + x, 0);\n  const data = new Uint8Array(structSize * xrefTableData.length);\n  const stream = new Stream(data);\n  stream.dict = newXref;\n  let offset = 0;\n  for (const [type, objOffset, gen] of xrefTableData) {\n    offset = writeInt(type, sizes[0], offset, data);\n    offset = writeInt(objOffset, sizes[1], offset, data);\n    offset = writeInt(gen, sizes[2], offset, data);\n  }\n  await writeObject(xrefInfo.newRef, stream, buffer, {});\n  buffer.push(\"startxref\\n\", baseOffset.toString(), \"\\n%%EOF\\n\");\n}\nfunction computeIDs(baseOffset, xrefInfo, newXref) {\n  if (Array.isArray(xrefInfo.fileIds) && xrefInfo.fileIds.length > 0) {\n    const md5 = computeMD5(baseOffset, xrefInfo);\n    newXref.set(\"ID\", [xrefInfo.fileIds[0], md5]);\n  }\n}\nfunction getTrailerDict(xrefInfo, newRefs, useXrefStream) {\n  const newXref = new Dict(null);\n  newXref.set(\"Prev\", xrefInfo.startXRef);\n  const refForXrefTable = xrefInfo.newRef;\n  if (useXrefStream) {\n    newRefs.push({\n      ref: refForXrefTable,\n      data: \"\"\n    });\n    newXref.set(\"Size\", refForXrefTable.num + 1);\n    newXref.set(\"Type\", Name.get(\"XRef\"));\n  } else {\n    newXref.set(\"Size\", refForXrefTable.num);\n  }\n  if (xrefInfo.rootRef !== null) {\n    newXref.set(\"Root\", xrefInfo.rootRef);\n  }\n  if (xrefInfo.infoRef !== null) {\n    newXref.set(\"Info\", xrefInfo.infoRef);\n  }\n  if (xrefInfo.encryptRef !== null) {\n    newXref.set(\"Encrypt\", xrefInfo.encryptRef);\n  }\n  return newXref;\n}\nasync function incrementalUpdate({\n  originalData,\n  xrefInfo,\n  newRefs,\n  xref = null,\n  hasXfa = false,\n  xfaDatasetsRef = null,\n  hasXfaDatasetsEntry = false,\n  needAppearances,\n  acroFormRef = null,\n  acroForm = null,\n  xfaData = null,\n  useXrefStream = false\n}) {\n  await updateAcroform({\n    xref,\n    acroForm,\n    acroFormRef,\n    hasXfa,\n    hasXfaDatasetsEntry,\n    xfaDatasetsRef,\n    needAppearances,\n    newRefs\n  });\n  if (hasXfa) {\n    updateXFA({\n      xfaData,\n      xfaDatasetsRef,\n      newRefs,\n      xref\n    });\n  }\n  const buffer = [];\n  let baseOffset = originalData.length;\n  const lastByte = originalData.at(-1);\n  if (lastByte !== 0x0a && lastByte !== 0x0d) {\n    buffer.push(\"\\n\");\n    baseOffset += 1;\n  }\n  const newXref = getTrailerDict(xrefInfo, newRefs, useXrefStream);\n  newRefs = newRefs.sort((a, b) => a.ref.num - b.ref.num);\n  for (const {\n    data\n  } of newRefs) {\n    if (data !== null) {\n      buffer.push(data);\n    }\n  }\n  await (useXrefStream ? getXRefStreamTable(xrefInfo, baseOffset, newRefs, newXref, buffer) : getXRefTable(xrefInfo, baseOffset, newRefs, newXref, buffer));\n  const totalLength = buffer.reduce((a, str) => a + str.length, originalData.length);\n  const array = new Uint8Array(totalLength);\n  array.set(originalData);\n  let offset = originalData.length;\n  for (const str of buffer) {\n    writeString(str, offset, array);\n    offset += str.length;\n  }\n  return array;\n}\n\n;// CONCATENATED MODULE: ./src/core/struct_tree.js\n\n\n\n\nconst MAX_DEPTH = 40;\nconst StructElementType = {\n  PAGE_CONTENT: 1,\n  STREAM_CONTENT: 2,\n  OBJECT: 3,\n  ANNOTATION: 4,\n  ELEMENT: 5\n};\nclass StructTreeRoot {\n  constructor(rootDict, rootRef) {\n    this.dict = rootDict;\n    this.ref = rootRef instanceof Ref ? rootRef : null;\n    this.roleMap = new Map();\n    this.structParentIds = null;\n  }\n  init() {\n    this.readRoleMap();\n  }\n  #addIdToPage(pageRef, id, type) {\n    if (!(pageRef instanceof Ref) || id < 0) {\n      return;\n    }\n    this.structParentIds ||= new RefSetCache();\n    let ids = this.structParentIds.get(pageRef);\n    if (!ids) {\n      ids = [];\n      this.structParentIds.put(pageRef, ids);\n    }\n    ids.push([id, type]);\n  }\n  addAnnotationIdToPage(pageRef, id) {\n    this.#addIdToPage(pageRef, id, StructElementType.ANNOTATION);\n  }\n  readRoleMap() {\n    const roleMapDict = this.dict.get(\"RoleMap\");\n    if (!(roleMapDict instanceof Dict)) {\n      return;\n    }\n    roleMapDict.forEach((key, value) => {\n      if (!(value instanceof Name)) {\n        return;\n      }\n      this.roleMap.set(key, value.name);\n    });\n  }\n  static async canCreateStructureTree({\n    catalogRef,\n    pdfManager,\n    newAnnotationsByPage\n  }) {\n    if (!(catalogRef instanceof Ref)) {\n      warn(\"Cannot save the struct tree: no catalog reference.\");\n      return false;\n    }\n    let nextKey = 0;\n    let hasNothingToUpdate = true;\n    for (const [pageIndex, elements] of newAnnotationsByPage) {\n      const {\n        ref: pageRef\n      } = await pdfManager.getPage(pageIndex);\n      if (!(pageRef instanceof Ref)) {\n        warn(`Cannot save the struct tree: page ${pageIndex} has no ref.`);\n        hasNothingToUpdate = true;\n        break;\n      }\n      for (const element of elements) {\n        if (element.accessibilityData?.type) {\n          element.parentTreeId = nextKey++;\n          hasNothingToUpdate = false;\n        }\n      }\n    }\n    if (hasNothingToUpdate) {\n      for (const elements of newAnnotationsByPage.values()) {\n        for (const element of elements) {\n          delete element.parentTreeId;\n        }\n      }\n      return false;\n    }\n    return true;\n  }\n  static async createStructureTree({\n    newAnnotationsByPage,\n    xref,\n    catalogRef,\n    pdfManager,\n    newRefs\n  }) {\n    const root = pdfManager.catalog.cloneDict();\n    const cache = new RefSetCache();\n    cache.put(catalogRef, root);\n    const structTreeRootRef = xref.getNewTemporaryRef();\n    root.set(\"StructTreeRoot\", structTreeRootRef);\n    const structTreeRoot = new Dict(xref);\n    structTreeRoot.set(\"Type\", Name.get(\"StructTreeRoot\"));\n    const parentTreeRef = xref.getNewTemporaryRef();\n    structTreeRoot.set(\"ParentTree\", parentTreeRef);\n    const kids = [];\n    structTreeRoot.set(\"K\", kids);\n    cache.put(structTreeRootRef, structTreeRoot);\n    const parentTree = new Dict(xref);\n    const nums = [];\n    parentTree.set(\"Nums\", nums);\n    const nextKey = await this.#writeKids({\n      newAnnotationsByPage,\n      structTreeRootRef,\n      kids,\n      nums,\n      xref,\n      pdfManager,\n      cache\n    });\n    structTreeRoot.set(\"ParentTreeNextKey\", nextKey);\n    cache.put(parentTreeRef, parentTree);\n    const buffer = [];\n    for (const [ref, obj] of cache.items()) {\n      buffer.length = 0;\n      await writeObject(ref, obj, buffer, xref);\n      newRefs.push({\n        ref,\n        data: buffer.join(\"\")\n      });\n    }\n  }\n  async canUpdateStructTree({\n    pdfManager,\n    xref,\n    newAnnotationsByPage\n  }) {\n    if (!this.ref) {\n      warn(\"Cannot update the struct tree: no root reference.\");\n      return false;\n    }\n    let nextKey = this.dict.get(\"ParentTreeNextKey\");\n    if (!Number.isInteger(nextKey) || nextKey < 0) {\n      warn(\"Cannot update the struct tree: invalid next key.\");\n      return false;\n    }\n    const parentTree = this.dict.get(\"ParentTree\");\n    if (!(parentTree instanceof Dict)) {\n      warn(\"Cannot update the struct tree: ParentTree isn't a dict.\");\n      return false;\n    }\n    const nums = parentTree.get(\"Nums\");\n    if (!Array.isArray(nums)) {\n      warn(\"Cannot update the struct tree: nums isn't an array.\");\n      return false;\n    }\n    const numberTree = new NumberTree(parentTree, xref);\n    for (const pageIndex of newAnnotationsByPage.keys()) {\n      const {\n        pageDict\n      } = await pdfManager.getPage(pageIndex);\n      if (!pageDict.has(\"StructParents\")) {\n        continue;\n      }\n      const id = pageDict.get(\"StructParents\");\n      if (!Number.isInteger(id) || !Array.isArray(numberTree.get(id))) {\n        warn(`Cannot save the struct tree: page ${pageIndex} has a wrong id.`);\n        return false;\n      }\n    }\n    let hasNothingToUpdate = true;\n    for (const [pageIndex, elements] of newAnnotationsByPage) {\n      const {\n        pageDict\n      } = await pdfManager.getPage(pageIndex);\n      StructTreeRoot.#collectParents({\n        elements,\n        xref: this.dict.xref,\n        pageDict,\n        numberTree\n      });\n      for (const element of elements) {\n        if (element.accessibilityData?.type) {\n          element.parentTreeId = nextKey++;\n          hasNothingToUpdate = false;\n        }\n      }\n    }\n    if (hasNothingToUpdate) {\n      for (const elements of newAnnotationsByPage.values()) {\n        for (const element of elements) {\n          delete element.parentTreeId;\n          delete element.structTreeParent;\n        }\n      }\n      return false;\n    }\n    return true;\n  }\n  async updateStructureTree({\n    newAnnotationsByPage,\n    pdfManager,\n    newRefs\n  }) {\n    const xref = this.dict.xref;\n    const structTreeRoot = this.dict.clone();\n    const structTreeRootRef = this.ref;\n    const cache = new RefSetCache();\n    cache.put(structTreeRootRef, structTreeRoot);\n    let parentTreeRef = structTreeRoot.getRaw(\"ParentTree\");\n    let parentTree;\n    if (parentTreeRef instanceof Ref) {\n      parentTree = xref.fetch(parentTreeRef);\n    } else {\n      parentTree = parentTreeRef;\n      parentTreeRef = xref.getNewTemporaryRef();\n      structTreeRoot.set(\"ParentTree\", parentTreeRef);\n    }\n    parentTree = parentTree.clone();\n    cache.put(parentTreeRef, parentTree);\n    let nums = parentTree.getRaw(\"Nums\");\n    let numsRef = null;\n    if (nums instanceof Ref) {\n      numsRef = nums;\n      nums = xref.fetch(numsRef);\n    }\n    nums = nums.slice();\n    if (!numsRef) {\n      parentTree.set(\"Nums\", nums);\n    }\n    const newNextkey = await StructTreeRoot.#writeKids({\n      newAnnotationsByPage,\n      structTreeRootRef,\n      kids: null,\n      nums,\n      xref,\n      pdfManager,\n      cache\n    });\n    structTreeRoot.set(\"ParentTreeNextKey\", newNextkey);\n    if (numsRef) {\n      cache.put(numsRef, nums);\n    }\n    const buffer = [];\n    for (const [ref, obj] of cache.items()) {\n      buffer.length = 0;\n      await writeObject(ref, obj, buffer, xref);\n      newRefs.push({\n        ref,\n        data: buffer.join(\"\")\n      });\n    }\n  }\n  static async #writeKids({\n    newAnnotationsByPage,\n    structTreeRootRef,\n    kids,\n    nums,\n    xref,\n    pdfManager,\n    cache\n  }) {\n    const objr = Name.get(\"OBJR\");\n    let nextKey = -Infinity;\n    for (const [pageIndex, elements] of newAnnotationsByPage) {\n      const {\n        ref: pageRef\n      } = await pdfManager.getPage(pageIndex);\n      const isPageRef = pageRef instanceof Ref;\n      for (const {\n        accessibilityData,\n        ref,\n        parentTreeId,\n        structTreeParent\n      } of elements) {\n        if (!accessibilityData?.type) {\n          continue;\n        }\n        const {\n          type,\n          title,\n          lang,\n          alt,\n          expanded,\n          actualText\n        } = accessibilityData;\n        nextKey = Math.max(nextKey, parentTreeId);\n        const tagRef = xref.getNewTemporaryRef();\n        const tagDict = new Dict(xref);\n        tagDict.set(\"S\", Name.get(type));\n        if (title) {\n          tagDict.set(\"T\", title);\n        }\n        if (lang) {\n          tagDict.set(\"Lang\", lang);\n        }\n        if (alt) {\n          tagDict.set(\"Alt\", alt);\n        }\n        if (expanded) {\n          tagDict.set(\"E\", expanded);\n        }\n        if (actualText) {\n          tagDict.set(\"ActualText\", actualText);\n        }\n        await this.#updateParentTag({\n          structTreeParent,\n          tagDict,\n          newTagRef: tagRef,\n          structTreeRootRef,\n          fallbackKids: kids,\n          xref,\n          cache\n        });\n        const objDict = new Dict(xref);\n        tagDict.set(\"K\", objDict);\n        objDict.set(\"Type\", objr);\n        if (isPageRef) {\n          objDict.set(\"Pg\", pageRef);\n        }\n        objDict.set(\"Obj\", ref);\n        cache.put(tagRef, tagDict);\n        nums.push(parentTreeId, tagRef);\n      }\n    }\n    return nextKey + 1;\n  }\n  static #collectParents({\n    elements,\n    xref,\n    pageDict,\n    numberTree\n  }) {\n    const idToElements = new Map();\n    for (const element of elements) {\n      if (element.structTreeParentId) {\n        const id = parseInt(element.structTreeParentId.split(\"_mc\")[1], 10);\n        let elems = idToElements.get(id);\n        if (!elems) {\n          elems = [];\n          idToElements.set(id, elems);\n        }\n        elems.push(element);\n      }\n    }\n    const id = pageDict.get(\"StructParents\");\n    if (!Number.isInteger(id)) {\n      return;\n    }\n    const parentArray = numberTree.get(id);\n    const updateElement = (kid, pageKid, kidRef) => {\n      const elems = idToElements.get(kid);\n      if (elems) {\n        const parentRef = pageKid.getRaw(\"P\");\n        const parentDict = xref.fetchIfRef(parentRef);\n        if (parentRef instanceof Ref && parentDict instanceof Dict) {\n          const params = {\n            ref: kidRef,\n            dict: pageKid\n          };\n          for (const element of elems) {\n            element.structTreeParent = params;\n          }\n        }\n        return true;\n      }\n      return false;\n    };\n    for (const kidRef of parentArray) {\n      if (!(kidRef instanceof Ref)) {\n        continue;\n      }\n      const pageKid = xref.fetch(kidRef);\n      const k = pageKid.get(\"K\");\n      if (Number.isInteger(k)) {\n        updateElement(k, pageKid, kidRef);\n        continue;\n      }\n      if (!Array.isArray(k)) {\n        continue;\n      }\n      for (let kid of k) {\n        kid = xref.fetchIfRef(kid);\n        if (Number.isInteger(kid) && updateElement(kid, pageKid, kidRef)) {\n          break;\n        }\n        if (!(kid instanceof Dict)) {\n          continue;\n        }\n        if (!isName(kid.get(\"Type\"), \"MCR\")) {\n          break;\n        }\n        const mcid = kid.get(\"MCID\");\n        if (Number.isInteger(mcid) && updateElement(mcid, pageKid, kidRef)) {\n          break;\n        }\n      }\n    }\n  }\n  static async #updateParentTag({\n    structTreeParent,\n    tagDict,\n    newTagRef,\n    structTreeRootRef,\n    fallbackKids,\n    xref,\n    cache\n  }) {\n    let ref = null;\n    let parentRef;\n    if (structTreeParent) {\n      ({\n        ref\n      } = structTreeParent);\n      parentRef = structTreeParent.dict.getRaw(\"P\") || structTreeRootRef;\n    } else {\n      parentRef = structTreeRootRef;\n    }\n    tagDict.set(\"P\", parentRef);\n    const parentDict = xref.fetchIfRef(parentRef);\n    if (!parentDict) {\n      fallbackKids.push(newTagRef);\n      return;\n    }\n    let cachedParentDict = cache.get(parentRef);\n    if (!cachedParentDict) {\n      cachedParentDict = parentDict.clone();\n      cache.put(parentRef, cachedParentDict);\n    }\n    const parentKidsRaw = cachedParentDict.getRaw(\"K\");\n    let cachedParentKids = parentKidsRaw instanceof Ref ? cache.get(parentKidsRaw) : null;\n    if (!cachedParentKids) {\n      cachedParentKids = xref.fetchIfRef(parentKidsRaw);\n      cachedParentKids = Array.isArray(cachedParentKids) ? cachedParentKids.slice() : [parentKidsRaw];\n      const parentKidsRef = xref.getNewTemporaryRef();\n      cachedParentDict.set(\"K\", parentKidsRef);\n      cache.put(parentKidsRef, cachedParentKids);\n    }\n    const index = cachedParentKids.indexOf(ref);\n    cachedParentKids.splice(index >= 0 ? index + 1 : cachedParentKids.length, 0, newTagRef);\n  }\n}\nclass StructElementNode {\n  constructor(tree, dict) {\n    this.tree = tree;\n    this.dict = dict;\n    this.kids = [];\n    this.parseKids();\n  }\n  get role() {\n    const nameObj = this.dict.get(\"S\");\n    const name = nameObj instanceof Name ? nameObj.name : \"\";\n    const {\n      root\n    } = this.tree;\n    if (root.roleMap.has(name)) {\n      return root.roleMap.get(name);\n    }\n    return name;\n  }\n  parseKids() {\n    let pageObjId = null;\n    const objRef = this.dict.getRaw(\"Pg\");\n    if (objRef instanceof Ref) {\n      pageObjId = objRef.toString();\n    }\n    const kids = this.dict.get(\"K\");\n    if (Array.isArray(kids)) {\n      for (const kid of kids) {\n        const element = this.parseKid(pageObjId, kid);\n        if (element) {\n          this.kids.push(element);\n        }\n      }\n    } else {\n      const element = this.parseKid(pageObjId, kids);\n      if (element) {\n        this.kids.push(element);\n      }\n    }\n  }\n  parseKid(pageObjId, kid) {\n    if (Number.isInteger(kid)) {\n      if (this.tree.pageDict.objId !== pageObjId) {\n        return null;\n      }\n      return new StructElement({\n        type: StructElementType.PAGE_CONTENT,\n        mcid: kid,\n        pageObjId\n      });\n    }\n    let kidDict = null;\n    if (kid instanceof Ref) {\n      kidDict = this.dict.xref.fetch(kid);\n    } else if (kid instanceof Dict) {\n      kidDict = kid;\n    }\n    if (!kidDict) {\n      return null;\n    }\n    const pageRef = kidDict.getRaw(\"Pg\");\n    if (pageRef instanceof Ref) {\n      pageObjId = pageRef.toString();\n    }\n    const type = kidDict.get(\"Type\") instanceof Name ? kidDict.get(\"Type\").name : null;\n    if (type === \"MCR\") {\n      if (this.tree.pageDict.objId !== pageObjId) {\n        return null;\n      }\n      const kidRef = kidDict.getRaw(\"Stm\");\n      return new StructElement({\n        type: StructElementType.STREAM_CONTENT,\n        refObjId: kidRef instanceof Ref ? kidRef.toString() : null,\n        pageObjId,\n        mcid: kidDict.get(\"MCID\")\n      });\n    }\n    if (type === \"OBJR\") {\n      if (this.tree.pageDict.objId !== pageObjId) {\n        return null;\n      }\n      const kidRef = kidDict.getRaw(\"Obj\");\n      return new StructElement({\n        type: StructElementType.OBJECT,\n        refObjId: kidRef instanceof Ref ? kidRef.toString() : null,\n        pageObjId\n      });\n    }\n    return new StructElement({\n      type: StructElementType.ELEMENT,\n      dict: kidDict\n    });\n  }\n}\nclass StructElement {\n  constructor({\n    type,\n    dict = null,\n    mcid = null,\n    pageObjId = null,\n    refObjId = null\n  }) {\n    this.type = type;\n    this.dict = dict;\n    this.mcid = mcid;\n    this.pageObjId = pageObjId;\n    this.refObjId = refObjId;\n    this.parentNode = null;\n  }\n}\nclass StructTreePage {\n  constructor(structTreeRoot, pageDict) {\n    this.root = structTreeRoot;\n    this.rootDict = structTreeRoot ? structTreeRoot.dict : null;\n    this.pageDict = pageDict;\n    this.nodes = [];\n  }\n  parse(pageRef) {\n    if (!this.root || !this.rootDict) {\n      return;\n    }\n    const parentTree = this.rootDict.get(\"ParentTree\");\n    if (!parentTree) {\n      return;\n    }\n    const id = this.pageDict.get(\"StructParents\");\n    const ids = pageRef instanceof Ref && this.root.structParentIds?.get(pageRef);\n    if (!Number.isInteger(id) && !ids) {\n      return;\n    }\n    const map = new Map();\n    const numberTree = new NumberTree(parentTree, this.rootDict.xref);\n    if (Number.isInteger(id)) {\n      const parentArray = numberTree.get(id);\n      if (Array.isArray(parentArray)) {\n        for (const ref of parentArray) {\n          if (ref instanceof Ref) {\n            this.addNode(this.rootDict.xref.fetch(ref), map);\n          }\n        }\n      }\n    }\n    if (!ids) {\n      return;\n    }\n    for (const [elemId, type] of ids) {\n      const obj = numberTree.get(elemId);\n      if (obj) {\n        const elem = this.addNode(this.rootDict.xref.fetchIfRef(obj), map);\n        if (elem?.kids?.length === 1 && elem.kids[0].type === StructElementType.OBJECT) {\n          elem.kids[0].type = type;\n        }\n      }\n    }\n  }\n  addNode(dict, map, level = 0) {\n    if (level > MAX_DEPTH) {\n      warn(\"StructTree MAX_DEPTH reached.\");\n      return null;\n    }\n    if (map.has(dict)) {\n      return map.get(dict);\n    }\n    const element = new StructElementNode(this, dict);\n    map.set(dict, element);\n    const parent = dict.get(\"P\");\n    if (!parent || isName(parent.get(\"Type\"), \"StructTreeRoot\")) {\n      if (!this.addTopLevelNode(dict, element)) {\n        map.delete(dict);\n      }\n      return element;\n    }\n    const parentNode = this.addNode(parent, map, level + 1);\n    if (!parentNode) {\n      return element;\n    }\n    let save = false;\n    for (const kid of parentNode.kids) {\n      if (kid.type === StructElementType.ELEMENT && kid.dict === dict) {\n        kid.parentNode = element;\n        save = true;\n      }\n    }\n    if (!save) {\n      map.delete(dict);\n    }\n    return element;\n  }\n  addTopLevelNode(dict, element) {\n    const obj = this.rootDict.get(\"K\");\n    if (!obj) {\n      return false;\n    }\n    if (obj instanceof Dict) {\n      if (obj.objId !== dict.objId) {\n        return false;\n      }\n      this.nodes[0] = element;\n      return true;\n    }\n    if (!Array.isArray(obj)) {\n      return true;\n    }\n    let save = false;\n    for (let i = 0; i < obj.length; i++) {\n      const kidRef = obj[i];\n      if (kidRef?.toString() === dict.objId) {\n        this.nodes[i] = element;\n        save = true;\n      }\n    }\n    return save;\n  }\n  get serializable() {\n    function nodeToSerializable(node, parent, level = 0) {\n      if (level > MAX_DEPTH) {\n        warn(\"StructTree too deep to be fully serialized.\");\n        return;\n      }\n      const obj = Object.create(null);\n      obj.role = node.role;\n      obj.children = [];\n      parent.children.push(obj);\n      const alt = node.dict.get(\"Alt\");\n      if (typeof alt === \"string\") {\n        obj.alt = stringToPDFString(alt);\n      }\n      const lang = node.dict.get(\"Lang\");\n      if (typeof lang === \"string\") {\n        obj.lang = stringToPDFString(lang);\n      }\n      for (const kid of node.kids) {\n        const kidElement = kid.type === StructElementType.ELEMENT ? kid.parentNode : null;\n        if (kidElement) {\n          nodeToSerializable(kidElement, obj, level + 1);\n          continue;\n        } else if (kid.type === StructElementType.PAGE_CONTENT || kid.type === StructElementType.STREAM_CONTENT) {\n          obj.children.push({\n            type: \"content\",\n            id: `p${kid.pageObjId}_mc${kid.mcid}`\n          });\n        } else if (kid.type === StructElementType.OBJECT) {\n          obj.children.push({\n            type: \"object\",\n            id: kid.refObjId\n          });\n        } else if (kid.type === StructElementType.ANNOTATION) {\n          obj.children.push({\n            type: \"annotation\",\n            id: `${AnnotationPrefix}${kid.refObjId}`\n          });\n        }\n      }\n    }\n    const root = Object.create(null);\n    root.children = [];\n    root.role = \"Root\";\n    for (const child of this.nodes) {\n      if (!child) {\n        continue;\n      }\n      nodeToSerializable(child, root);\n    }\n    return root;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/catalog.js\n\n\n\n\n\n\n\n\n\n\n\nfunction isValidExplicitDest(dest) {\n  if (!Array.isArray(dest) || dest.length < 2) {\n    return false;\n  }\n  const [page, zoom, ...args] = dest;\n  if (!(page instanceof Ref) && !Number.isInteger(page)) {\n    return false;\n  }\n  if (!(zoom instanceof Name)) {\n    return false;\n  }\n  let allowNull = true;\n  switch (zoom.name) {\n    case \"XYZ\":\n      if (args.length !== 3) {\n        return false;\n      }\n      break;\n    case \"Fit\":\n    case \"FitB\":\n      return args.length === 0;\n    case \"FitH\":\n    case \"FitBH\":\n    case \"FitV\":\n    case \"FitBV\":\n      if (args.length !== 1) {\n        return false;\n      }\n      break;\n    case \"FitR\":\n      if (args.length !== 4) {\n        return false;\n      }\n      allowNull = false;\n      break;\n    default:\n      return false;\n  }\n  for (const arg of args) {\n    if (!(typeof arg === \"number\" || allowNull && arg === null)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction fetchDest(dest) {\n  if (dest instanceof Dict) {\n    dest = dest.get(\"D\");\n  }\n  return isValidExplicitDest(dest) ? dest : null;\n}\nfunction fetchRemoteDest(action) {\n  let dest = action.get(\"D\");\n  if (dest) {\n    if (dest instanceof Name) {\n      dest = dest.name;\n    }\n    if (typeof dest === \"string\") {\n      return stringToPDFString(dest);\n    } else if (isValidExplicitDest(dest)) {\n      return JSON.stringify(dest);\n    }\n  }\n  return null;\n}\nclass Catalog {\n  constructor(pdfManager, xref) {\n    this.pdfManager = pdfManager;\n    this.xref = xref;\n    this._catDict = xref.getCatalogObj();\n    if (!(this._catDict instanceof Dict)) {\n      throw new FormatError(\"Catalog object is not a dictionary.\");\n    }\n    this.toplevelPagesDict;\n    this._actualNumPages = null;\n    this.fontCache = new RefSetCache();\n    this.builtInCMapCache = new Map();\n    this.standardFontDataCache = new Map();\n    this.globalImageCache = new GlobalImageCache();\n    this.pageKidsCountCache = new RefSetCache();\n    this.pageIndexCache = new RefSetCache();\n    this.nonBlendModesSet = new RefSet();\n    this.systemFontCache = new Map();\n  }\n  cloneDict() {\n    return this._catDict.clone();\n  }\n  get version() {\n    const version = this._catDict.get(\"Version\");\n    if (version instanceof Name) {\n      if (PDF_VERSION_REGEXP.test(version.name)) {\n        return shadow(this, \"version\", version.name);\n      }\n      warn(`Invalid PDF catalog version: ${version.name}`);\n    }\n    return shadow(this, \"version\", null);\n  }\n  get lang() {\n    const lang = this._catDict.get(\"Lang\");\n    return shadow(this, \"lang\", typeof lang === \"string\" ? stringToPDFString(lang) : null);\n  }\n  get needsRendering() {\n    const needsRendering = this._catDict.get(\"NeedsRendering\");\n    return shadow(this, \"needsRendering\", typeof needsRendering === \"boolean\" ? needsRendering : false);\n  }\n  get collection() {\n    let collection = null;\n    try {\n      const obj = this._catDict.get(\"Collection\");\n      if (obj instanceof Dict && obj.size > 0) {\n        collection = obj;\n      }\n    } catch (ex) {\n      if (ex instanceof MissingDataException) {\n        throw ex;\n      }\n      info(\"Cannot fetch Collection entry; assuming no collection is present.\");\n    }\n    return shadow(this, \"collection\", collection);\n  }\n  get acroForm() {\n    let acroForm = null;\n    try {\n      const obj = this._catDict.get(\"AcroForm\");\n      if (obj instanceof Dict && obj.size > 0) {\n        acroForm = obj;\n      }\n    } catch (ex) {\n      if (ex instanceof MissingDataException) {\n        throw ex;\n      }\n      info(\"Cannot fetch AcroForm entry; assuming no forms are present.\");\n    }\n    return shadow(this, \"acroForm\", acroForm);\n  }\n  get acroFormRef() {\n    const value = this._catDict.getRaw(\"AcroForm\");\n    return shadow(this, \"acroFormRef\", value instanceof Ref ? value : null);\n  }\n  get metadata() {\n    const streamRef = this._catDict.getRaw(\"Metadata\");\n    if (!(streamRef instanceof Ref)) {\n      return shadow(this, \"metadata\", null);\n    }\n    let metadata = null;\n    try {\n      const stream = this.xref.fetch(streamRef, !this.xref.encrypt?.encryptMetadata);\n      if (stream instanceof BaseStream && stream.dict instanceof Dict) {\n        const type = stream.dict.get(\"Type\");\n        const subtype = stream.dict.get(\"Subtype\");\n        if (isName(type, \"Metadata\") && isName(subtype, \"XML\")) {\n          const data = stringToUTF8String(stream.getString());\n          if (data) {\n            metadata = new MetadataParser(data).serializable;\n          }\n        }\n      }\n    } catch (ex) {\n      if (ex instanceof MissingDataException) {\n        throw ex;\n      }\n      info(`Skipping invalid Metadata: \"${ex}\".`);\n    }\n    return shadow(this, \"metadata\", metadata);\n  }\n  get markInfo() {\n    let markInfo = null;\n    try {\n      markInfo = this._readMarkInfo();\n    } catch (ex) {\n      if (ex instanceof MissingDataException) {\n        throw ex;\n      }\n      warn(\"Unable to read mark info.\");\n    }\n    return shadow(this, \"markInfo\", markInfo);\n  }\n  _readMarkInfo() {\n    const obj = this._catDict.get(\"MarkInfo\");\n    if (!(obj instanceof Dict)) {\n      return null;\n    }\n    const markInfo = {\n      Marked: false,\n      UserProperties: false,\n      Suspects: false\n    };\n    for (const key in markInfo) {\n      const value = obj.get(key);\n      if (typeof value === \"boolean\") {\n        markInfo[key] = value;\n      }\n    }\n    return markInfo;\n  }\n  get structTreeRoot() {\n    let structTree = null;\n    try {\n      structTree = this._readStructTreeRoot();\n    } catch (ex) {\n      if (ex instanceof MissingDataException) {\n        throw ex;\n      }\n      warn(\"Unable read to structTreeRoot info.\");\n    }\n    return shadow(this, \"structTreeRoot\", structTree);\n  }\n  _readStructTreeRoot() {\n    const rawObj = this._catDict.getRaw(\"StructTreeRoot\");\n    const obj = this.xref.fetchIfRef(rawObj);\n    if (!(obj instanceof Dict)) {\n      return null;\n    }\n    const root = new StructTreeRoot(obj, rawObj);\n    root.init();\n    return root;\n  }\n  get toplevelPagesDict() {\n    const pagesObj = this._catDict.get(\"Pages\");\n    if (!(pagesObj instanceof Dict)) {\n      throw new FormatError(\"Invalid top-level pages dictionary.\");\n    }\n    return shadow(this, \"toplevelPagesDict\", pagesObj);\n  }\n  get documentOutline() {\n    let obj = null;\n    try {\n      obj = this._readDocumentOutline();\n    } catch (ex) {\n      if (ex instanceof MissingDataException) {\n        throw ex;\n      }\n      warn(\"Unable to read document outline.\");\n    }\n    return shadow(this, \"documentOutline\", obj);\n  }\n  _readDocumentOutline() {\n    let obj = this._catDict.get(\"Outlines\");\n    if (!(obj instanceof Dict)) {\n      return null;\n    }\n    obj = obj.getRaw(\"First\");\n    if (!(obj instanceof Ref)) {\n      return null;\n    }\n    const root = {\n      items: []\n    };\n    const queue = [{\n      obj,\n      parent: root\n    }];\n    const processed = new RefSet();\n    processed.put(obj);\n    const xref = this.xref,\n      blackColor = new Uint8ClampedArray(3);\n    while (queue.length > 0) {\n      const i = queue.shift();\n      const outlineDict = xref.fetchIfRef(i.obj);\n      if (outlineDict === null) {\n        continue;\n      }\n      if (!outlineDict.has(\"Title\")) {\n        warn(\"Invalid outline item encountered.\");\n      }\n      const data = {\n        url: null,\n        dest: null,\n        action: null\n      };\n      Catalog.parseDestDictionary({\n        destDict: outlineDict,\n        resultObj: data,\n        docBaseUrl: this.baseUrl,\n        docAttachments: this.attachments\n      });\n      const title = outlineDict.get(\"Title\");\n      const flags = outlineDict.get(\"F\") || 0;\n      const color = outlineDict.getArray(\"C\");\n      const count = outlineDict.get(\"Count\");\n      let rgbColor = blackColor;\n      if (Array.isArray(color) && color.length === 3 && (color[0] !== 0 || color[1] !== 0 || color[2] !== 0)) {\n        rgbColor = ColorSpace.singletons.rgb.getRgb(color, 0);\n      }\n      const outlineItem = {\n        action: data.action,\n        attachment: data.attachment,\n        dest: data.dest,\n        url: data.url,\n        unsafeUrl: data.unsafeUrl,\n        newWindow: data.newWindow,\n        setOCGState: data.setOCGState,\n        title: typeof title === \"string\" ? stringToPDFString(title) : \"\",\n        color: rgbColor,\n        count: Number.isInteger(count) ? count : undefined,\n        bold: !!(flags & 2),\n        italic: !!(flags & 1),\n        items: []\n      };\n      i.parent.items.push(outlineItem);\n      obj = outlineDict.getRaw(\"First\");\n      if (obj instanceof Ref && !processed.has(obj)) {\n        queue.push({\n          obj,\n          parent: outlineItem\n        });\n        processed.put(obj);\n      }\n      obj = outlineDict.getRaw(\"Next\");\n      if (obj instanceof Ref && !processed.has(obj)) {\n        queue.push({\n          obj,\n          parent: i.parent\n        });\n        processed.put(obj);\n      }\n    }\n    return root.items.length > 0 ? root.items : null;\n  }\n  get permissions() {\n    let permissions = null;\n    try {\n      permissions = this._readPermissions();\n    } catch (ex) {\n      if (ex instanceof MissingDataException) {\n        throw ex;\n      }\n      warn(\"Unable to read permissions.\");\n    }\n    return shadow(this, \"permissions\", permissions);\n  }\n  _readPermissions() {\n    const encrypt = this.xref.trailer.get(\"Encrypt\");\n    if (!(encrypt instanceof Dict)) {\n      return null;\n    }\n    let flags = encrypt.get(\"P\");\n    if (typeof flags !== \"number\") {\n      return null;\n    }\n    flags += 2 ** 32;\n    const permissions = [];\n    for (const key in PermissionFlag) {\n      const value = PermissionFlag[key];\n      if (flags & value) {\n        permissions.push(value);\n      }\n    }\n    return permissions;\n  }\n  get optionalContentConfig() {\n    let config = null;\n    try {\n      const properties = this._catDict.get(\"OCProperties\");\n      if (!properties) {\n        return shadow(this, \"optionalContentConfig\", null);\n      }\n      const defaultConfig = properties.get(\"D\");\n      if (!defaultConfig) {\n        return shadow(this, \"optionalContentConfig\", null);\n      }\n      const groupsData = properties.get(\"OCGs\");\n      if (!Array.isArray(groupsData)) {\n        return shadow(this, \"optionalContentConfig\", null);\n      }\n      const groups = [];\n      const groupRefs = new RefSet();\n      for (const groupRef of groupsData) {\n        if (!(groupRef instanceof Ref) || groupRefs.has(groupRef)) {\n          continue;\n        }\n        groupRefs.put(groupRef);\n        groups.push(this.#readOptionalContentGroup(groupRef));\n      }\n      config = this.#readOptionalContentConfig(defaultConfig, groupRefs);\n      config.groups = groups;\n    } catch (ex) {\n      if (ex instanceof MissingDataException) {\n        throw ex;\n      }\n      warn(`Unable to read optional content config: ${ex}`);\n    }\n    return shadow(this, \"optionalContentConfig\", config);\n  }\n  #readOptionalContentGroup(groupRef) {\n    const group = this.xref.fetch(groupRef);\n    const obj = {\n      id: groupRef.toString(),\n      name: null,\n      intent: null,\n      usage: {\n        print: null,\n        view: null\n      }\n    };\n    const name = group.get(\"Name\");\n    if (typeof name === \"string\") {\n      obj.name = stringToPDFString(name);\n    }\n    let intent = group.getArray(\"Intent\");\n    if (!Array.isArray(intent)) {\n      intent = [intent];\n    }\n    if (intent.every(i => i instanceof Name)) {\n      obj.intent = intent.map(i => i.name);\n    }\n    const usage = group.get(\"Usage\");\n    if (!(usage instanceof Dict)) {\n      return obj;\n    }\n    const usageObj = obj.usage;\n    const print = usage.get(\"Print\");\n    if (print instanceof Dict) {\n      const printState = print.get(\"PrintState\");\n      if (printState instanceof Name) {\n        switch (printState.name) {\n          case \"ON\":\n          case \"OFF\":\n            usageObj.print = {\n              printState: printState.name\n            };\n        }\n      }\n    }\n    const view = usage.get(\"View\");\n    if (view instanceof Dict) {\n      const viewState = view.get(\"ViewState\");\n      if (viewState instanceof Name) {\n        switch (viewState.name) {\n          case \"ON\":\n          case \"OFF\":\n            usageObj.view = {\n              viewState: viewState.name\n            };\n        }\n      }\n    }\n    return obj;\n  }\n  #readOptionalContentConfig(config, contentGroupRefs) {\n    function parseOnOff(refs) {\n      const onParsed = [];\n      if (Array.isArray(refs)) {\n        for (const value of refs) {\n          if (!(value instanceof Ref)) {\n            continue;\n          }\n          if (contentGroupRefs.has(value)) {\n            onParsed.push(value.toString());\n          }\n        }\n      }\n      return onParsed;\n    }\n    function parseOrder(refs, nestedLevels = 0) {\n      if (!Array.isArray(refs)) {\n        return null;\n      }\n      const order = [];\n      for (const value of refs) {\n        if (value instanceof Ref && contentGroupRefs.has(value)) {\n          parsedOrderRefs.put(value);\n          order.push(value.toString());\n          continue;\n        }\n        const nestedOrder = parseNestedOrder(value, nestedLevels);\n        if (nestedOrder) {\n          order.push(nestedOrder);\n        }\n      }\n      if (nestedLevels > 0) {\n        return order;\n      }\n      const hiddenGroups = [];\n      for (const groupRef of contentGroupRefs) {\n        if (parsedOrderRefs.has(groupRef)) {\n          continue;\n        }\n        hiddenGroups.push(groupRef.toString());\n      }\n      if (hiddenGroups.length) {\n        order.push({\n          name: null,\n          order: hiddenGroups\n        });\n      }\n      return order;\n    }\n    function parseNestedOrder(ref, nestedLevels) {\n      if (++nestedLevels > MAX_NESTED_LEVELS) {\n        warn(\"parseNestedOrder - reached MAX_NESTED_LEVELS.\");\n        return null;\n      }\n      const value = xref.fetchIfRef(ref);\n      if (!Array.isArray(value)) {\n        return null;\n      }\n      const nestedName = xref.fetchIfRef(value[0]);\n      if (typeof nestedName !== \"string\") {\n        return null;\n      }\n      const nestedOrder = parseOrder(value.slice(1), nestedLevels);\n      if (!nestedOrder || !nestedOrder.length) {\n        return null;\n      }\n      return {\n        name: stringToPDFString(nestedName),\n        order: nestedOrder\n      };\n    }\n    const xref = this.xref,\n      parsedOrderRefs = new RefSet(),\n      MAX_NESTED_LEVELS = 10;\n    return {\n      name: typeof config.get(\"Name\") === \"string\" ? stringToPDFString(config.get(\"Name\")) : null,\n      creator: typeof config.get(\"Creator\") === \"string\" ? stringToPDFString(config.get(\"Creator\")) : null,\n      baseState: config.get(\"BaseState\") instanceof Name ? config.get(\"BaseState\").name : null,\n      on: parseOnOff(config.get(\"ON\")),\n      off: parseOnOff(config.get(\"OFF\")),\n      order: parseOrder(config.get(\"Order\")),\n      groups: null\n    };\n  }\n  setActualNumPages(num = null) {\n    this._actualNumPages = num;\n  }\n  get hasActualNumPages() {\n    return this._actualNumPages !== null;\n  }\n  get _pagesCount() {\n    const obj = this.toplevelPagesDict.get(\"Count\");\n    if (!Number.isInteger(obj)) {\n      throw new FormatError(\"Page count in top-level pages dictionary is not an integer.\");\n    }\n    return shadow(this, \"_pagesCount\", obj);\n  }\n  get numPages() {\n    return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;\n  }\n  get destinations() {\n    const obj = this._readDests(),\n      dests = Object.create(null);\n    if (obj instanceof NameTree) {\n      for (const [key, value] of obj.getAll()) {\n        const dest = fetchDest(value);\n        if (dest) {\n          dests[stringToPDFString(key)] = dest;\n        }\n      }\n    } else if (obj instanceof Dict) {\n      obj.forEach(function (key, value) {\n        const dest = fetchDest(value);\n        if (dest) {\n          dests[key] = dest;\n        }\n      });\n    }\n    return shadow(this, \"destinations\", dests);\n  }\n  getDestination(id) {\n    const obj = this._readDests();\n    if (obj instanceof NameTree) {\n      const dest = fetchDest(obj.get(id));\n      if (dest) {\n        return dest;\n      }\n      const allDest = this.destinations[id];\n      if (allDest) {\n        warn(`Found \"${id}\" at an incorrect position in the NameTree.`);\n        return allDest;\n      }\n    } else if (obj instanceof Dict) {\n      const dest = fetchDest(obj.get(id));\n      if (dest) {\n        return dest;\n      }\n    }\n    return null;\n  }\n  _readDests() {\n    const obj = this._catDict.get(\"Names\");\n    if (obj?.has(\"Dests\")) {\n      return new NameTree(obj.getRaw(\"Dests\"), this.xref);\n    } else if (this._catDict.has(\"Dests\")) {\n      return this._catDict.get(\"Dests\");\n    }\n    return undefined;\n  }\n  get pageLabels() {\n    let obj = null;\n    try {\n      obj = this._readPageLabels();\n    } catch (ex) {\n      if (ex instanceof MissingDataException) {\n        throw ex;\n      }\n      warn(\"Unable to read page labels.\");\n    }\n    return shadow(this, \"pageLabels\", obj);\n  }\n  _readPageLabels() {\n    const obj = this._catDict.getRaw(\"PageLabels\");\n    if (!obj) {\n      return null;\n    }\n    const pageLabels = new Array(this.numPages);\n    let style = null,\n      prefix = \"\";\n    const numberTree = new NumberTree(obj, this.xref);\n    const nums = numberTree.getAll();\n    let currentLabel = \"\",\n      currentIndex = 1;\n    for (let i = 0, ii = this.numPages; i < ii; i++) {\n      const labelDict = nums.get(i);\n      if (labelDict !== undefined) {\n        if (!(labelDict instanceof Dict)) {\n          throw new FormatError(\"PageLabel is not a dictionary.\");\n        }\n        if (labelDict.has(\"Type\") && !isName(labelDict.get(\"Type\"), \"PageLabel\")) {\n          throw new FormatError(\"Invalid type in PageLabel dictionary.\");\n        }\n        if (labelDict.has(\"S\")) {\n          const s = labelDict.get(\"S\");\n          if (!(s instanceof Name)) {\n            throw new FormatError(\"Invalid style in PageLabel dictionary.\");\n          }\n          style = s.name;\n        } else {\n          style = null;\n        }\n        if (labelDict.has(\"P\")) {\n          const p = labelDict.get(\"P\");\n          if (typeof p !== \"string\") {\n            throw new FormatError(\"Invalid prefix in PageLabel dictionary.\");\n          }\n          prefix = stringToPDFString(p);\n        } else {\n          prefix = \"\";\n        }\n        if (labelDict.has(\"St\")) {\n          const st = labelDict.get(\"St\");\n          if (!(Number.isInteger(st) && st >= 1)) {\n            throw new FormatError(\"Invalid start in PageLabel dictionary.\");\n          }\n          currentIndex = st;\n        } else {\n          currentIndex = 1;\n        }\n      }\n      switch (style) {\n        case \"D\":\n          currentLabel = currentIndex;\n          break;\n        case \"R\":\n        case \"r\":\n          currentLabel = toRomanNumerals(currentIndex, style === \"r\");\n          break;\n        case \"A\":\n        case \"a\":\n          const LIMIT = 26;\n          const A_UPPER_CASE = 0x41,\n            A_LOWER_CASE = 0x61;\n          const baseCharCode = style === \"a\" ? A_LOWER_CASE : A_UPPER_CASE;\n          const letterIndex = currentIndex - 1;\n          const character = String.fromCharCode(baseCharCode + letterIndex % LIMIT);\n          currentLabel = character.repeat(Math.floor(letterIndex / LIMIT) + 1);\n          break;\n        default:\n          if (style) {\n            throw new FormatError(`Invalid style \"${style}\" in PageLabel dictionary.`);\n          }\n          currentLabel = \"\";\n      }\n      pageLabels[i] = prefix + currentLabel;\n      currentIndex++;\n    }\n    return pageLabels;\n  }\n  get pageLayout() {\n    const obj = this._catDict.get(\"PageLayout\");\n    let pageLayout = \"\";\n    if (obj instanceof Name) {\n      switch (obj.name) {\n        case \"SinglePage\":\n        case \"OneColumn\":\n        case \"TwoColumnLeft\":\n        case \"TwoColumnRight\":\n        case \"TwoPageLeft\":\n        case \"TwoPageRight\":\n          pageLayout = obj.name;\n      }\n    }\n    return shadow(this, \"pageLayout\", pageLayout);\n  }\n  get pageMode() {\n    const obj = this._catDict.get(\"PageMode\");\n    let pageMode = \"UseNone\";\n    if (obj instanceof Name) {\n      switch (obj.name) {\n        case \"UseNone\":\n        case \"UseOutlines\":\n        case \"UseThumbs\":\n        case \"FullScreen\":\n        case \"UseOC\":\n        case \"UseAttachments\":\n          pageMode = obj.name;\n      }\n    }\n    return shadow(this, \"pageMode\", pageMode);\n  }\n  get viewerPreferences() {\n    const obj = this._catDict.get(\"ViewerPreferences\");\n    if (!(obj instanceof Dict)) {\n      return shadow(this, \"viewerPreferences\", null);\n    }\n    let prefs = null;\n    for (const key of obj.getKeys()) {\n      const value = obj.get(key);\n      let prefValue;\n      switch (key) {\n        case \"HideToolbar\":\n        case \"HideMenubar\":\n        case \"HideWindowUI\":\n        case \"FitWindow\":\n        case \"CenterWindow\":\n        case \"DisplayDocTitle\":\n        case \"PickTrayByPDFSize\":\n          if (typeof value === \"boolean\") {\n            prefValue = value;\n          }\n          break;\n        case \"NonFullScreenPageMode\":\n          if (value instanceof Name) {\n            switch (value.name) {\n              case \"UseNone\":\n              case \"UseOutlines\":\n              case \"UseThumbs\":\n              case \"UseOC\":\n                prefValue = value.name;\n                break;\n              default:\n                prefValue = \"UseNone\";\n            }\n          }\n          break;\n        case \"Direction\":\n          if (value instanceof Name) {\n            switch (value.name) {\n              case \"L2R\":\n              case \"R2L\":\n                prefValue = value.name;\n                break;\n              default:\n                prefValue = \"L2R\";\n            }\n          }\n          break;\n        case \"ViewArea\":\n        case \"ViewClip\":\n        case \"PrintArea\":\n        case \"PrintClip\":\n          if (value instanceof Name) {\n            switch (value.name) {\n              case \"MediaBox\":\n              case \"CropBox\":\n              case \"BleedBox\":\n              case \"TrimBox\":\n              case \"ArtBox\":\n                prefValue = value.name;\n                break;\n              default:\n                prefValue = \"CropBox\";\n            }\n          }\n          break;\n        case \"PrintScaling\":\n          if (value instanceof Name) {\n            switch (value.name) {\n              case \"None\":\n              case \"AppDefault\":\n                prefValue = value.name;\n                break;\n              default:\n                prefValue = \"AppDefault\";\n            }\n          }\n          break;\n        case \"Duplex\":\n          if (value instanceof Name) {\n            switch (value.name) {\n              case \"Simplex\":\n              case \"DuplexFlipShortEdge\":\n              case \"DuplexFlipLongEdge\":\n                prefValue = value.name;\n                break;\n              default:\n                prefValue = \"None\";\n            }\n          }\n          break;\n        case \"PrintPageRange\":\n          if (Array.isArray(value) && value.length % 2 === 0) {\n            const isValid = value.every((page, i, arr) => Number.isInteger(page) && page > 0 && (i === 0 || page >= arr[i - 1]) && page <= this.numPages);\n            if (isValid) {\n              prefValue = value;\n            }\n          }\n          break;\n        case \"NumCopies\":\n          if (Number.isInteger(value) && value > 0) {\n            prefValue = value;\n          }\n          break;\n        default:\n          warn(`Ignoring non-standard key in ViewerPreferences: ${key}.`);\n          continue;\n      }\n      if (prefValue === undefined) {\n        warn(`Bad value, for key \"${key}\", in ViewerPreferences: ${value}.`);\n        continue;\n      }\n      if (!prefs) {\n        prefs = Object.create(null);\n      }\n      prefs[key] = prefValue;\n    }\n    return shadow(this, \"viewerPreferences\", prefs);\n  }\n  get openAction() {\n    const obj = this._catDict.get(\"OpenAction\");\n    const openAction = Object.create(null);\n    if (obj instanceof Dict) {\n      const destDict = new Dict(this.xref);\n      destDict.set(\"A\", obj);\n      const resultObj = {\n        url: null,\n        dest: null,\n        action: null\n      };\n      Catalog.parseDestDictionary({\n        destDict,\n        resultObj\n      });\n      if (Array.isArray(resultObj.dest)) {\n        openAction.dest = resultObj.dest;\n      } else if (resultObj.action) {\n        openAction.action = resultObj.action;\n      }\n    } else if (Array.isArray(obj)) {\n      openAction.dest = obj;\n    }\n    return shadow(this, \"openAction\", objectSize(openAction) > 0 ? openAction : null);\n  }\n  get attachments() {\n    const obj = this._catDict.get(\"Names\");\n    let attachments = null;\n    if (obj instanceof Dict && obj.has(\"EmbeddedFiles\")) {\n      const nameTree = new NameTree(obj.getRaw(\"EmbeddedFiles\"), this.xref);\n      for (const [key, value] of nameTree.getAll()) {\n        const fs = new FileSpec(value, this.xref);\n        if (!attachments) {\n          attachments = Object.create(null);\n        }\n        attachments[stringToPDFString(key)] = fs.serializable;\n      }\n    }\n    return shadow(this, \"attachments\", attachments);\n  }\n  get xfaImages() {\n    const obj = this._catDict.get(\"Names\");\n    let xfaImages = null;\n    if (obj instanceof Dict && obj.has(\"XFAImages\")) {\n      const nameTree = new NameTree(obj.getRaw(\"XFAImages\"), this.xref);\n      for (const [key, value] of nameTree.getAll()) {\n        if (!xfaImages) {\n          xfaImages = new Dict(this.xref);\n        }\n        xfaImages.set(stringToPDFString(key), value);\n      }\n    }\n    return shadow(this, \"xfaImages\", xfaImages);\n  }\n  _collectJavaScript() {\n    const obj = this._catDict.get(\"Names\");\n    let javaScript = null;\n    function appendIfJavaScriptDict(name, jsDict) {\n      if (!(jsDict instanceof Dict)) {\n        return;\n      }\n      if (!isName(jsDict.get(\"S\"), \"JavaScript\")) {\n        return;\n      }\n      let js = jsDict.get(\"JS\");\n      if (js instanceof BaseStream) {\n        js = js.getString();\n      } else if (typeof js !== \"string\") {\n        return;\n      }\n      js = stringToPDFString(js).replaceAll(\"\\x00\", \"\");\n      if (js) {\n        (javaScript ||= new Map()).set(name, js);\n      }\n    }\n    if (obj instanceof Dict && obj.has(\"JavaScript\")) {\n      const nameTree = new NameTree(obj.getRaw(\"JavaScript\"), this.xref);\n      for (const [key, value] of nameTree.getAll()) {\n        appendIfJavaScriptDict(stringToPDFString(key), value);\n      }\n    }\n    const openAction = this._catDict.get(\"OpenAction\");\n    if (openAction) {\n      appendIfJavaScriptDict(\"OpenAction\", openAction);\n    }\n    return javaScript;\n  }\n  get jsActions() {\n    const javaScript = this._collectJavaScript();\n    let actions = collectActions(this.xref, this._catDict, DocumentActionEventType);\n    if (javaScript) {\n      actions ||= Object.create(null);\n      for (const [key, val] of javaScript) {\n        if (key in actions) {\n          actions[key].push(val);\n        } else {\n          actions[key] = [val];\n        }\n      }\n    }\n    return shadow(this, \"jsActions\", actions);\n  }\n  async fontFallback(id, handler) {\n    const translatedFonts = await Promise.all(this.fontCache);\n    for (const translatedFont of translatedFonts) {\n      if (translatedFont.loadedName === id) {\n        translatedFont.fallback(handler);\n        return;\n      }\n    }\n  }\n  async cleanup(manuallyTriggered = false) {\n    clearGlobalCaches();\n    this.globalImageCache.clear(manuallyTriggered);\n    this.pageKidsCountCache.clear();\n    this.pageIndexCache.clear();\n    this.nonBlendModesSet.clear();\n    const translatedFonts = await Promise.all(this.fontCache);\n    for (const {\n      dict\n    } of translatedFonts) {\n      delete dict.cacheKey;\n    }\n    this.fontCache.clear();\n    this.builtInCMapCache.clear();\n    this.standardFontDataCache.clear();\n    this.systemFontCache.clear();\n  }\n  async getPageDict(pageIndex) {\n    const nodesToVisit = [this.toplevelPagesDict];\n    const visitedNodes = new RefSet();\n    const pagesRef = this._catDict.getRaw(\"Pages\");\n    if (pagesRef instanceof Ref) {\n      visitedNodes.put(pagesRef);\n    }\n    const xref = this.xref,\n      pageKidsCountCache = this.pageKidsCountCache,\n      pageIndexCache = this.pageIndexCache;\n    let currentPageIndex = 0;\n    while (nodesToVisit.length) {\n      const currentNode = nodesToVisit.pop();\n      if (currentNode instanceof Ref) {\n        const count = pageKidsCountCache.get(currentNode);\n        if (count >= 0 && currentPageIndex + count <= pageIndex) {\n          currentPageIndex += count;\n          continue;\n        }\n        if (visitedNodes.has(currentNode)) {\n          throw new FormatError(\"Pages tree contains circular reference.\");\n        }\n        visitedNodes.put(currentNode);\n        const obj = await xref.fetchAsync(currentNode);\n        if (obj instanceof Dict) {\n          let type = obj.getRaw(\"Type\");\n          if (type instanceof Ref) {\n            type = await xref.fetchAsync(type);\n          }\n          if (isName(type, \"Page\") || !obj.has(\"Kids\")) {\n            if (!pageKidsCountCache.has(currentNode)) {\n              pageKidsCountCache.put(currentNode, 1);\n            }\n            if (!pageIndexCache.has(currentNode)) {\n              pageIndexCache.put(currentNode, currentPageIndex);\n            }\n            if (currentPageIndex === pageIndex) {\n              return [obj, currentNode];\n            }\n            currentPageIndex++;\n            continue;\n          }\n        }\n        nodesToVisit.push(obj);\n        continue;\n      }\n      if (!(currentNode instanceof Dict)) {\n        throw new FormatError(\"Page dictionary kid reference points to wrong type of object.\");\n      }\n      const {\n        objId\n      } = currentNode;\n      let count = currentNode.getRaw(\"Count\");\n      if (count instanceof Ref) {\n        count = await xref.fetchAsync(count);\n      }\n      if (Number.isInteger(count) && count >= 0) {\n        if (objId && !pageKidsCountCache.has(objId)) {\n          pageKidsCountCache.put(objId, count);\n        }\n        if (currentPageIndex + count <= pageIndex) {\n          currentPageIndex += count;\n          continue;\n        }\n      }\n      let kids = currentNode.getRaw(\"Kids\");\n      if (kids instanceof Ref) {\n        kids = await xref.fetchAsync(kids);\n      }\n      if (!Array.isArray(kids)) {\n        let type = currentNode.getRaw(\"Type\");\n        if (type instanceof Ref) {\n          type = await xref.fetchAsync(type);\n        }\n        if (isName(type, \"Page\") || !currentNode.has(\"Kids\")) {\n          if (currentPageIndex === pageIndex) {\n            return [currentNode, null];\n          }\n          currentPageIndex++;\n          continue;\n        }\n        throw new FormatError(\"Page dictionary kids object is not an array.\");\n      }\n      for (let last = kids.length - 1; last >= 0; last--) {\n        nodesToVisit.push(kids[last]);\n      }\n    }\n    throw new Error(`Page index ${pageIndex} not found.`);\n  }\n  async getAllPageDicts(recoveryMode = false) {\n    const {\n      ignoreErrors\n    } = this.pdfManager.evaluatorOptions;\n    const queue = [{\n      currentNode: this.toplevelPagesDict,\n      posInKids: 0\n    }];\n    const visitedNodes = new RefSet();\n    const pagesRef = this._catDict.getRaw(\"Pages\");\n    if (pagesRef instanceof Ref) {\n      visitedNodes.put(pagesRef);\n    }\n    const map = new Map(),\n      xref = this.xref,\n      pageIndexCache = this.pageIndexCache;\n    let pageIndex = 0;\n    function addPageDict(pageDict, pageRef) {\n      if (pageRef && !pageIndexCache.has(pageRef)) {\n        pageIndexCache.put(pageRef, pageIndex);\n      }\n      map.set(pageIndex++, [pageDict, pageRef]);\n    }\n    function addPageError(error) {\n      if (error instanceof XRefEntryException && !recoveryMode) {\n        throw error;\n      }\n      if (recoveryMode && ignoreErrors && pageIndex === 0) {\n        warn(`getAllPageDicts - Skipping invalid first page: \"${error}\".`);\n        error = Dict.empty;\n      }\n      map.set(pageIndex++, [error, null]);\n    }\n    while (queue.length > 0) {\n      const queueItem = queue.at(-1);\n      const {\n        currentNode,\n        posInKids\n      } = queueItem;\n      let kids = currentNode.getRaw(\"Kids\");\n      if (kids instanceof Ref) {\n        try {\n          kids = await xref.fetchAsync(kids);\n        } catch (ex) {\n          addPageError(ex);\n          break;\n        }\n      }\n      if (!Array.isArray(kids)) {\n        addPageError(new FormatError(\"Page dictionary kids object is not an array.\"));\n        break;\n      }\n      if (posInKids >= kids.length) {\n        queue.pop();\n        continue;\n      }\n      const kidObj = kids[posInKids];\n      let obj;\n      if (kidObj instanceof Ref) {\n        if (visitedNodes.has(kidObj)) {\n          addPageError(new FormatError(\"Pages tree contains circular reference.\"));\n          break;\n        }\n        visitedNodes.put(kidObj);\n        try {\n          obj = await xref.fetchAsync(kidObj);\n        } catch (ex) {\n          addPageError(ex);\n          break;\n        }\n      } else {\n        obj = kidObj;\n      }\n      if (!(obj instanceof Dict)) {\n        addPageError(new FormatError(\"Page dictionary kid reference points to wrong type of object.\"));\n        break;\n      }\n      let type = obj.getRaw(\"Type\");\n      if (type instanceof Ref) {\n        try {\n          type = await xref.fetchAsync(type);\n        } catch (ex) {\n          addPageError(ex);\n          break;\n        }\n      }\n      if (isName(type, \"Page\") || !obj.has(\"Kids\")) {\n        addPageDict(obj, kidObj instanceof Ref ? kidObj : null);\n      } else {\n        queue.push({\n          currentNode: obj,\n          posInKids: 0\n        });\n      }\n      queueItem.posInKids++;\n    }\n    return map;\n  }\n  getPageIndex(pageRef) {\n    const cachedPageIndex = this.pageIndexCache.get(pageRef);\n    if (cachedPageIndex !== undefined) {\n      return Promise.resolve(cachedPageIndex);\n    }\n    const xref = this.xref;\n    function pagesBeforeRef(kidRef) {\n      let total = 0,\n        parentRef;\n      return xref.fetchAsync(kidRef).then(function (node) {\n        if (isRefsEqual(kidRef, pageRef) && !isDict(node, \"Page\") && !(node instanceof Dict && !node.has(\"Type\") && node.has(\"Contents\"))) {\n          throw new FormatError(\"The reference does not point to a /Page dictionary.\");\n        }\n        if (!node) {\n          return null;\n        }\n        if (!(node instanceof Dict)) {\n          throw new FormatError(\"Node must be a dictionary.\");\n        }\n        parentRef = node.getRaw(\"Parent\");\n        return node.getAsync(\"Parent\");\n      }).then(function (parent) {\n        if (!parent) {\n          return null;\n        }\n        if (!(parent instanceof Dict)) {\n          throw new FormatError(\"Parent must be a dictionary.\");\n        }\n        return parent.getAsync(\"Kids\");\n      }).then(function (kids) {\n        if (!kids) {\n          return null;\n        }\n        const kidPromises = [];\n        let found = false;\n        for (const kid of kids) {\n          if (!(kid instanceof Ref)) {\n            throw new FormatError(\"Kid must be a reference.\");\n          }\n          if (isRefsEqual(kid, kidRef)) {\n            found = true;\n            break;\n          }\n          kidPromises.push(xref.fetchAsync(kid).then(function (obj) {\n            if (!(obj instanceof Dict)) {\n              throw new FormatError(\"Kid node must be a dictionary.\");\n            }\n            if (obj.has(\"Count\")) {\n              total += obj.get(\"Count\");\n            } else {\n              total++;\n            }\n          }));\n        }\n        if (!found) {\n          throw new FormatError(\"Kid reference not found in parent's kids.\");\n        }\n        return Promise.all(kidPromises).then(function () {\n          return [total, parentRef];\n        });\n      });\n    }\n    let total = 0;\n    const next = ref => pagesBeforeRef(ref).then(args => {\n      if (!args) {\n        this.pageIndexCache.put(pageRef, total);\n        return total;\n      }\n      const [count, parentRef] = args;\n      total += count;\n      return next(parentRef);\n    });\n    return next(pageRef);\n  }\n  get baseUrl() {\n    const uri = this._catDict.get(\"URI\");\n    if (uri instanceof Dict) {\n      const base = uri.get(\"Base\");\n      if (typeof base === \"string\") {\n        const absoluteUrl = createValidAbsoluteUrl(base, null, {\n          tryConvertEncoding: true\n        });\n        if (absoluteUrl) {\n          return shadow(this, \"baseUrl\", absoluteUrl.href);\n        }\n      }\n    }\n    return shadow(this, \"baseUrl\", this.pdfManager.docBaseUrl);\n  }\n  static parseDestDictionary({\n    destDict,\n    resultObj,\n    docBaseUrl = null,\n    docAttachments = null\n  }) {\n    if (!(destDict instanceof Dict)) {\n      warn(\"parseDestDictionary: `destDict` must be a dictionary.\");\n      return;\n    }\n    let action = destDict.get(\"A\"),\n      url,\n      dest;\n    if (!(action instanceof Dict)) {\n      if (destDict.has(\"Dest\")) {\n        action = destDict.get(\"Dest\");\n      } else {\n        action = destDict.get(\"AA\");\n        if (action instanceof Dict) {\n          if (action.has(\"D\")) {\n            action = action.get(\"D\");\n          } else if (action.has(\"U\")) {\n            action = action.get(\"U\");\n          }\n        }\n      }\n    }\n    if (action instanceof Dict) {\n      const actionType = action.get(\"S\");\n      if (!(actionType instanceof Name)) {\n        warn(\"parseDestDictionary: Invalid type in Action dictionary.\");\n        return;\n      }\n      const actionName = actionType.name;\n      switch (actionName) {\n        case \"ResetForm\":\n          const flags = action.get(\"Flags\");\n          const include = ((typeof flags === \"number\" ? flags : 0) & 1) === 0;\n          const fields = [];\n          const refs = [];\n          for (const obj of action.get(\"Fields\") || []) {\n            if (obj instanceof Ref) {\n              refs.push(obj.toString());\n            } else if (typeof obj === \"string\") {\n              fields.push(stringToPDFString(obj));\n            }\n          }\n          resultObj.resetForm = {\n            fields,\n            refs,\n            include\n          };\n          break;\n        case \"URI\":\n          url = action.get(\"URI\");\n          if (url instanceof Name) {\n            url = \"/\" + url.name;\n          }\n          break;\n        case \"GoTo\":\n          dest = action.get(\"D\");\n          break;\n        case \"Launch\":\n        case \"GoToR\":\n          const urlDict = action.get(\"F\");\n          if (urlDict instanceof Dict) {\n            const fs = new FileSpec(urlDict, null, true);\n            const {\n              filename\n            } = fs.serializable;\n            url = filename;\n          } else if (typeof urlDict === \"string\") {\n            url = urlDict;\n          }\n          const remoteDest = fetchRemoteDest(action);\n          if (remoteDest && typeof url === \"string\") {\n            url = url.split(\"#\", 1)[0] + \"#\" + remoteDest;\n          }\n          const newWindow = action.get(\"NewWindow\");\n          if (typeof newWindow === \"boolean\") {\n            resultObj.newWindow = newWindow;\n          }\n          break;\n        case \"GoToE\":\n          const target = action.get(\"T\");\n          let attachment;\n          if (docAttachments && target instanceof Dict) {\n            const relationship = target.get(\"R\");\n            const name = target.get(\"N\");\n            if (isName(relationship, \"C\") && typeof name === \"string\") {\n              attachment = docAttachments[stringToPDFString(name)];\n            }\n          }\n          if (attachment) {\n            resultObj.attachment = attachment;\n            const attachmentDest = fetchRemoteDest(action);\n            if (attachmentDest) {\n              resultObj.attachmentDest = attachmentDest;\n            }\n          } else {\n            warn(`parseDestDictionary - unimplemented \"GoToE\" action.`);\n          }\n          break;\n        case \"Named\":\n          const namedAction = action.get(\"N\");\n          if (namedAction instanceof Name) {\n            resultObj.action = namedAction.name;\n          }\n          break;\n        case \"SetOCGState\":\n          const state = action.get(\"State\");\n          const preserveRB = action.get(\"PreserveRB\");\n          if (!Array.isArray(state) || state.length === 0) {\n            break;\n          }\n          const stateArr = [];\n          for (const elem of state) {\n            if (elem instanceof Name) {\n              switch (elem.name) {\n                case \"ON\":\n                case \"OFF\":\n                case \"Toggle\":\n                  stateArr.push(elem.name);\n                  break;\n              }\n            } else if (elem instanceof Ref) {\n              stateArr.push(elem.toString());\n            }\n          }\n          if (stateArr.length !== state.length) {\n            break;\n          }\n          resultObj.setOCGState = {\n            state: stateArr,\n            preserveRB: typeof preserveRB === \"boolean\" ? preserveRB : true\n          };\n          break;\n        case \"JavaScript\":\n          const jsAction = action.get(\"JS\");\n          let js;\n          if (jsAction instanceof BaseStream) {\n            js = jsAction.getString();\n          } else if (typeof jsAction === \"string\") {\n            js = jsAction;\n          }\n          const jsURL = js && recoverJsURL(stringToPDFString(js));\n          if (jsURL) {\n            url = jsURL.url;\n            resultObj.newWindow = jsURL.newWindow;\n            break;\n          }\n        default:\n          if (actionName === \"JavaScript\" || actionName === \"SubmitForm\") {\n            break;\n          }\n          warn(`parseDestDictionary - unsupported action: \"${actionName}\".`);\n          break;\n      }\n    } else if (destDict.has(\"Dest\")) {\n      dest = destDict.get(\"Dest\");\n    }\n    if (typeof url === \"string\") {\n      const absoluteUrl = createValidAbsoluteUrl(url, docBaseUrl, {\n        addDefaultProtocol: true,\n        tryConvertEncoding: true\n      });\n      if (absoluteUrl) {\n        resultObj.url = absoluteUrl.href;\n      }\n      resultObj.unsafeUrl = url;\n    }\n    if (dest) {\n      if (dest instanceof Name) {\n        dest = dest.name;\n      }\n      if (typeof dest === \"string\") {\n        resultObj.dest = stringToPDFString(dest);\n      } else if (isValidExplicitDest(dest)) {\n        resultObj.dest = dest;\n      }\n    }\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/object_loader.js\n\n\n\n\nfunction mayHaveChildren(value) {\n  return value instanceof Ref || value instanceof Dict || value instanceof BaseStream || Array.isArray(value);\n}\nfunction addChildren(node, nodesToVisit) {\n  if (node instanceof Dict) {\n    node = node.getRawValues();\n  } else if (node instanceof BaseStream) {\n    node = node.dict.getRawValues();\n  } else if (!Array.isArray(node)) {\n    return;\n  }\n  for (const rawValue of node) {\n    if (mayHaveChildren(rawValue)) {\n      nodesToVisit.push(rawValue);\n    }\n  }\n}\nclass ObjectLoader {\n  constructor(dict, keys, xref) {\n    this.dict = dict;\n    this.keys = keys;\n    this.xref = xref;\n    this.refSet = null;\n  }\n  async load() {\n    if (this.xref.stream.isDataLoaded) {\n      return undefined;\n    }\n    const {\n      keys,\n      dict\n    } = this;\n    this.refSet = new RefSet();\n    const nodesToVisit = [];\n    for (const key of keys) {\n      const rawValue = dict.getRaw(key);\n      if (rawValue !== undefined) {\n        nodesToVisit.push(rawValue);\n      }\n    }\n    return this._walk(nodesToVisit);\n  }\n  async _walk(nodesToVisit) {\n    const nodesToRevisit = [];\n    const pendingRequests = [];\n    while (nodesToVisit.length) {\n      let currentNode = nodesToVisit.pop();\n      if (currentNode instanceof Ref) {\n        if (this.refSet.has(currentNode)) {\n          continue;\n        }\n        try {\n          this.refSet.put(currentNode);\n          currentNode = this.xref.fetch(currentNode);\n        } catch (ex) {\n          if (!(ex instanceof MissingDataException)) {\n            warn(`ObjectLoader._walk - requesting all data: \"${ex}\".`);\n            this.refSet = null;\n            const {\n              manager\n            } = this.xref.stream;\n            return manager.requestAllChunks();\n          }\n          nodesToRevisit.push(currentNode);\n          pendingRequests.push({\n            begin: ex.begin,\n            end: ex.end\n          });\n        }\n      }\n      if (currentNode instanceof BaseStream) {\n        const baseStreams = currentNode.getBaseStreams();\n        if (baseStreams) {\n          let foundMissingData = false;\n          for (const stream of baseStreams) {\n            if (stream.isDataLoaded) {\n              continue;\n            }\n            foundMissingData = true;\n            pendingRequests.push({\n              begin: stream.start,\n              end: stream.end\n            });\n          }\n          if (foundMissingData) {\n            nodesToRevisit.push(currentNode);\n          }\n        }\n      }\n      addChildren(currentNode, nodesToVisit);\n    }\n    if (pendingRequests.length) {\n      await this.xref.stream.manager.requestRanges(pendingRequests);\n      for (const node of nodesToRevisit) {\n        if (node instanceof Ref) {\n          this.refSet.remove(node);\n        }\n      }\n      return this._walk(nodesToRevisit);\n    }\n    this.refSet = null;\n    return undefined;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/symbol_utils.js\nconst $acceptWhitespace = Symbol();\nconst $addHTML = Symbol();\nconst $appendChild = Symbol();\nconst $childrenToHTML = Symbol();\nconst $clean = Symbol();\nconst $cleanPage = Symbol();\nconst $cleanup = Symbol();\nconst $clone = Symbol();\nconst $consumed = Symbol();\nconst $content = Symbol(\"content\");\nconst $data = Symbol(\"data\");\nconst $dump = Symbol();\nconst $extra = Symbol(\"extra\");\nconst $finalize = Symbol();\nconst $flushHTML = Symbol();\nconst $getAttributeIt = Symbol();\nconst $getAttributes = Symbol();\nconst $getAvailableSpace = Symbol();\nconst $getChildrenByClass = Symbol();\nconst $getChildrenByName = Symbol();\nconst $getChildrenByNameIt = Symbol();\nconst $getDataValue = Symbol();\nconst $getExtra = Symbol();\nconst $getRealChildrenByNameIt = Symbol();\nconst $getChildren = Symbol();\nconst $getContainedChildren = Symbol();\nconst $getNextPage = Symbol();\nconst $getSubformParent = Symbol();\nconst $getParent = Symbol();\nconst $getTemplateRoot = Symbol();\nconst $globalData = Symbol();\nconst $hasSettableValue = Symbol();\nconst $ids = Symbol();\nconst $indexOf = Symbol();\nconst $insertAt = Symbol();\nconst $isCDATAXml = Symbol();\nconst $isBindable = Symbol();\nconst $isDataValue = Symbol();\nconst $isDescendent = Symbol();\nconst $isNsAgnostic = Symbol();\nconst $isSplittable = Symbol();\nconst $isThereMoreWidth = Symbol();\nconst $isTransparent = Symbol();\nconst $isUsable = Symbol();\nconst $lastAttribute = Symbol();\nconst $namespaceId = Symbol(\"namespaceId\");\nconst $nodeName = Symbol(\"nodeName\");\nconst $nsAttributes = Symbol();\nconst $onChild = Symbol();\nconst $onChildCheck = Symbol();\nconst $onText = Symbol();\nconst $pushGlyphs = Symbol();\nconst $popPara = Symbol();\nconst $pushPara = Symbol();\nconst $removeChild = Symbol();\nconst $root = Symbol(\"root\");\nconst $resolvePrototypes = Symbol();\nconst $searchNode = Symbol();\nconst $setId = Symbol();\nconst $setSetAttributes = Symbol();\nconst $setValue = Symbol();\nconst $tabIndex = Symbol();\nconst $text = Symbol();\nconst $toPages = Symbol();\nconst $toHTML = Symbol();\nconst $toString = Symbol();\nconst $toStyle = Symbol();\nconst $uid = Symbol(\"uid\");\n\n;// CONCATENATED MODULE: ./src/core/xfa/namespaces.js\nconst $buildXFAObject = Symbol();\nconst NamespaceIds = {\n  config: {\n    id: 0,\n    check: ns => ns.startsWith(\"http://www.xfa.org/schema/xci/\")\n  },\n  connectionSet: {\n    id: 1,\n    check: ns => ns.startsWith(\"http://www.xfa.org/schema/xfa-connection-set/\")\n  },\n  datasets: {\n    id: 2,\n    check: ns => ns.startsWith(\"http://www.xfa.org/schema/xfa-data/\")\n  },\n  form: {\n    id: 3,\n    check: ns => ns.startsWith(\"http://www.xfa.org/schema/xfa-form/\")\n  },\n  localeSet: {\n    id: 4,\n    check: ns => ns.startsWith(\"http://www.xfa.org/schema/xfa-locale-set/\")\n  },\n  pdf: {\n    id: 5,\n    check: ns => ns === \"http://ns.adobe.com/xdp/pdf/\"\n  },\n  signature: {\n    id: 6,\n    check: ns => ns === \"http://www.w3.org/2000/09/xmldsig#\"\n  },\n  sourceSet: {\n    id: 7,\n    check: ns => ns.startsWith(\"http://www.xfa.org/schema/xfa-source-set/\")\n  },\n  stylesheet: {\n    id: 8,\n    check: ns => ns === \"http://www.w3.org/1999/XSL/Transform\"\n  },\n  template: {\n    id: 9,\n    check: ns => ns.startsWith(\"http://www.xfa.org/schema/xfa-template/\")\n  },\n  xdc: {\n    id: 10,\n    check: ns => ns.startsWith(\"http://www.xfa.org/schema/xdc/\")\n  },\n  xdp: {\n    id: 11,\n    check: ns => ns === \"http://ns.adobe.com/xdp/\"\n  },\n  xfdf: {\n    id: 12,\n    check: ns => ns === \"http://ns.adobe.com/xfdf/\"\n  },\n  xhtml: {\n    id: 13,\n    check: ns => ns === \"http://www.w3.org/1999/xhtml\"\n  },\n  xmpmeta: {\n    id: 14,\n    check: ns => ns === \"http://ns.adobe.com/xmpmeta/\"\n  }\n};\n\n;// CONCATENATED MODULE: ./src/core/xfa/utils.js\n\nconst dimConverters = {\n  pt: x => x,\n  cm: x => x / 2.54 * 72,\n  mm: x => x / (10 * 2.54) * 72,\n  in: x => x * 72,\n  px: x => x\n};\nconst measurementPattern = /([+-]?\\d+\\.?\\d*)(.*)/;\nfunction stripQuotes(str) {\n  if (str.startsWith(\"'\") || str.startsWith('\"')) {\n    return str.slice(1, -1);\n  }\n  return str;\n}\nfunction getInteger({\n  data,\n  defaultValue,\n  validate\n}) {\n  if (!data) {\n    return defaultValue;\n  }\n  data = data.trim();\n  const n = parseInt(data, 10);\n  if (!isNaN(n) && validate(n)) {\n    return n;\n  }\n  return defaultValue;\n}\nfunction getFloat({\n  data,\n  defaultValue,\n  validate\n}) {\n  if (!data) {\n    return defaultValue;\n  }\n  data = data.trim();\n  const n = parseFloat(data);\n  if (!isNaN(n) && validate(n)) {\n    return n;\n  }\n  return defaultValue;\n}\nfunction getKeyword({\n  data,\n  defaultValue,\n  validate\n}) {\n  if (!data) {\n    return defaultValue;\n  }\n  data = data.trim();\n  if (validate(data)) {\n    return data;\n  }\n  return defaultValue;\n}\nfunction getStringOption(data, options) {\n  return getKeyword({\n    data,\n    defaultValue: options[0],\n    validate: k => options.includes(k)\n  });\n}\nfunction getMeasurement(str, def = \"0\") {\n  def ||= \"0\";\n  if (!str) {\n    return getMeasurement(def);\n  }\n  const match = str.trim().match(measurementPattern);\n  if (!match) {\n    return getMeasurement(def);\n  }\n  const [, valueStr, unit] = match;\n  const value = parseFloat(valueStr);\n  if (isNaN(value)) {\n    return getMeasurement(def);\n  }\n  if (value === 0) {\n    return 0;\n  }\n  const conv = dimConverters[unit];\n  if (conv) {\n    return conv(value);\n  }\n  return value;\n}\nfunction getRatio(data) {\n  if (!data) {\n    return {\n      num: 1,\n      den: 1\n    };\n  }\n  const ratio = data.trim().split(/\\s*:\\s*/).map(x => parseFloat(x)).filter(x => !isNaN(x));\n  if (ratio.length === 1) {\n    ratio.push(1);\n  }\n  if (ratio.length === 0) {\n    return {\n      num: 1,\n      den: 1\n    };\n  }\n  const [num, den] = ratio;\n  return {\n    num,\n    den\n  };\n}\nfunction getRelevant(data) {\n  if (!data) {\n    return [];\n  }\n  return data.trim().split(/\\s+/).map(e => ({\n    excluded: e[0] === \"-\",\n    viewname: e.substring(1)\n  }));\n}\nfunction getColor(data, def = [0, 0, 0]) {\n  let [r, g, b] = def;\n  if (!data) {\n    return {\n      r,\n      g,\n      b\n    };\n  }\n  const color = data.trim().split(/\\s*,\\s*/).map(c => Math.min(Math.max(0, parseInt(c.trim(), 10)), 255)).map(c => isNaN(c) ? 0 : c);\n  if (color.length < 3) {\n    return {\n      r,\n      g,\n      b\n    };\n  }\n  [r, g, b] = color;\n  return {\n    r,\n    g,\n    b\n  };\n}\nfunction getBBox(data) {\n  const def = -1;\n  if (!data) {\n    return {\n      x: def,\n      y: def,\n      width: def,\n      height: def\n    };\n  }\n  const bbox = data.trim().split(/\\s*,\\s*/).map(m => getMeasurement(m, \"-1\"));\n  if (bbox.length < 4 || bbox[2] < 0 || bbox[3] < 0) {\n    return {\n      x: def,\n      y: def,\n      width: def,\n      height: def\n    };\n  }\n  const [x, y, width, height] = bbox;\n  return {\n    x,\n    y,\n    width,\n    height\n  };\n}\nclass HTMLResult {\n  static get FAILURE() {\n    return shadow(this, \"FAILURE\", new HTMLResult(false, null, null, null));\n  }\n  static get EMPTY() {\n    return shadow(this, \"EMPTY\", new HTMLResult(true, null, null, null));\n  }\n  constructor(success, html, bbox, breakNode) {\n    this.success = success;\n    this.html = html;\n    this.bbox = bbox;\n    this.breakNode = breakNode;\n  }\n  isBreak() {\n    return !!this.breakNode;\n  }\n  static breakNode(node) {\n    return new HTMLResult(false, null, null, node);\n  }\n  static success(html, bbox = null) {\n    return new HTMLResult(true, html, bbox, null);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/fonts.js\n\n\n\nclass FontFinder {\n  constructor(pdfFonts) {\n    this.fonts = new Map();\n    this.cache = new Map();\n    this.warned = new Set();\n    this.defaultFont = null;\n    this.add(pdfFonts);\n  }\n  add(pdfFonts, reallyMissingFonts = null) {\n    for (const pdfFont of pdfFonts) {\n      this.addPdfFont(pdfFont);\n    }\n    for (const pdfFont of this.fonts.values()) {\n      if (!pdfFont.regular) {\n        pdfFont.regular = pdfFont.italic || pdfFont.bold || pdfFont.bolditalic;\n      }\n    }\n    if (!reallyMissingFonts || reallyMissingFonts.size === 0) {\n      return;\n    }\n    const myriad = this.fonts.get(\"PdfJS-Fallback-PdfJS-XFA\");\n    for (const missing of reallyMissingFonts) {\n      this.fonts.set(missing, myriad);\n    }\n  }\n  addPdfFont(pdfFont) {\n    const cssFontInfo = pdfFont.cssFontInfo;\n    const name = cssFontInfo.fontFamily;\n    let font = this.fonts.get(name);\n    if (!font) {\n      font = Object.create(null);\n      this.fonts.set(name, font);\n      if (!this.defaultFont) {\n        this.defaultFont = font;\n      }\n    }\n    let property = \"\";\n    const fontWeight = parseFloat(cssFontInfo.fontWeight);\n    if (parseFloat(cssFontInfo.italicAngle) !== 0) {\n      property = fontWeight >= 700 ? \"bolditalic\" : \"italic\";\n    } else if (fontWeight >= 700) {\n      property = \"bold\";\n    }\n    if (!property) {\n      if (pdfFont.name.includes(\"Bold\") || pdfFont.psName?.includes(\"Bold\")) {\n        property = \"bold\";\n      }\n      if (pdfFont.name.includes(\"Italic\") || pdfFont.name.endsWith(\"It\") || pdfFont.psName?.includes(\"Italic\") || pdfFont.psName?.endsWith(\"It\")) {\n        property += \"italic\";\n      }\n    }\n    if (!property) {\n      property = \"regular\";\n    }\n    font[property] = pdfFont;\n  }\n  getDefault() {\n    return this.defaultFont;\n  }\n  find(fontName, mustWarn = true) {\n    let font = this.fonts.get(fontName) || this.cache.get(fontName);\n    if (font) {\n      return font;\n    }\n    const pattern = /,|-|_| |bolditalic|bold|italic|regular|it/gi;\n    let name = fontName.replaceAll(pattern, \"\");\n    font = this.fonts.get(name);\n    if (font) {\n      this.cache.set(fontName, font);\n      return font;\n    }\n    name = name.toLowerCase();\n    const maybe = [];\n    for (const [family, pdfFont] of this.fonts.entries()) {\n      if (family.replaceAll(pattern, \"\").toLowerCase().startsWith(name)) {\n        maybe.push(pdfFont);\n      }\n    }\n    if (maybe.length === 0) {\n      for (const [, pdfFont] of this.fonts.entries()) {\n        if (pdfFont.regular.name?.replaceAll(pattern, \"\").toLowerCase().startsWith(name)) {\n          maybe.push(pdfFont);\n        }\n      }\n    }\n    if (maybe.length === 0) {\n      name = name.replaceAll(/psmt|mt/gi, \"\");\n      for (const [family, pdfFont] of this.fonts.entries()) {\n        if (family.replaceAll(pattern, \"\").toLowerCase().startsWith(name)) {\n          maybe.push(pdfFont);\n        }\n      }\n    }\n    if (maybe.length === 0) {\n      for (const pdfFont of this.fonts.values()) {\n        if (pdfFont.regular.name?.replaceAll(pattern, \"\").toLowerCase().startsWith(name)) {\n          maybe.push(pdfFont);\n        }\n      }\n    }\n    if (maybe.length >= 1) {\n      if (maybe.length !== 1 && mustWarn) {\n        warn(`XFA - Too many choices to guess the correct font: ${fontName}`);\n      }\n      this.cache.set(fontName, maybe[0]);\n      return maybe[0];\n    }\n    if (mustWarn && !this.warned.has(fontName)) {\n      this.warned.add(fontName);\n      warn(`XFA - Cannot find the font: ${fontName}`);\n    }\n    return null;\n  }\n}\nfunction selectFont(xfaFont, typeface) {\n  if (xfaFont.posture === \"italic\") {\n    if (xfaFont.weight === \"bold\") {\n      return typeface.bolditalic;\n    }\n    return typeface.italic;\n  } else if (xfaFont.weight === \"bold\") {\n    return typeface.bold;\n  }\n  return typeface.regular;\n}\nfunction fonts_getMetrics(xfaFont, real = false) {\n  let pdfFont = null;\n  if (xfaFont) {\n    const name = stripQuotes(xfaFont.typeface);\n    const typeface = xfaFont[$globalData].fontFinder.find(name);\n    pdfFont = selectFont(xfaFont, typeface);\n  }\n  if (!pdfFont) {\n    return {\n      lineHeight: 12,\n      lineGap: 2,\n      lineNoGap: 10\n    };\n  }\n  const size = xfaFont.size || 10;\n  const lineHeight = pdfFont.lineHeight ? Math.max(real ? 0 : 1.2, pdfFont.lineHeight) : 1.2;\n  const lineGap = pdfFont.lineGap === undefined ? 0.2 : pdfFont.lineGap;\n  return {\n    lineHeight: lineHeight * size,\n    lineGap: lineGap * size,\n    lineNoGap: Math.max(1, lineHeight - lineGap) * size\n  };\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/text.js\n\nconst WIDTH_FACTOR = 1.02;\nclass FontInfo {\n  constructor(xfaFont, margin, lineHeight, fontFinder) {\n    this.lineHeight = lineHeight;\n    this.paraMargin = margin || {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0\n    };\n    if (!xfaFont) {\n      [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder);\n      return;\n    }\n    this.xfaFont = {\n      typeface: xfaFont.typeface,\n      posture: xfaFont.posture,\n      weight: xfaFont.weight,\n      size: xfaFont.size,\n      letterSpacing: xfaFont.letterSpacing\n    };\n    const typeface = fontFinder.find(xfaFont.typeface);\n    if (!typeface) {\n      [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder);\n      return;\n    }\n    this.pdfFont = selectFont(xfaFont, typeface);\n    if (!this.pdfFont) {\n      [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder);\n    }\n  }\n  defaultFont(fontFinder) {\n    const font = fontFinder.find(\"Helvetica\", false) || fontFinder.find(\"Myriad Pro\", false) || fontFinder.find(\"Arial\", false) || fontFinder.getDefault();\n    if (font?.regular) {\n      const pdfFont = font.regular;\n      const info = pdfFont.cssFontInfo;\n      const xfaFont = {\n        typeface: info.fontFamily,\n        posture: \"normal\",\n        weight: \"normal\",\n        size: 10,\n        letterSpacing: 0\n      };\n      return [pdfFont, xfaFont];\n    }\n    const xfaFont = {\n      typeface: \"Courier\",\n      posture: \"normal\",\n      weight: \"normal\",\n      size: 10,\n      letterSpacing: 0\n    };\n    return [null, xfaFont];\n  }\n}\nclass FontSelector {\n  constructor(defaultXfaFont, defaultParaMargin, defaultLineHeight, fontFinder) {\n    this.fontFinder = fontFinder;\n    this.stack = [new FontInfo(defaultXfaFont, defaultParaMargin, defaultLineHeight, fontFinder)];\n  }\n  pushData(xfaFont, margin, lineHeight) {\n    const lastFont = this.stack.at(-1);\n    for (const name of [\"typeface\", \"posture\", \"weight\", \"size\", \"letterSpacing\"]) {\n      if (!xfaFont[name]) {\n        xfaFont[name] = lastFont.xfaFont[name];\n      }\n    }\n    for (const name of [\"top\", \"bottom\", \"left\", \"right\"]) {\n      if (isNaN(margin[name])) {\n        margin[name] = lastFont.paraMargin[name];\n      }\n    }\n    const fontInfo = new FontInfo(xfaFont, margin, lineHeight || lastFont.lineHeight, this.fontFinder);\n    if (!fontInfo.pdfFont) {\n      fontInfo.pdfFont = lastFont.pdfFont;\n    }\n    this.stack.push(fontInfo);\n  }\n  popFont() {\n    this.stack.pop();\n  }\n  topFont() {\n    return this.stack.at(-1);\n  }\n}\nclass TextMeasure {\n  constructor(defaultXfaFont, defaultParaMargin, defaultLineHeight, fonts) {\n    this.glyphs = [];\n    this.fontSelector = new FontSelector(defaultXfaFont, defaultParaMargin, defaultLineHeight, fonts);\n    this.extraHeight = 0;\n  }\n  pushData(xfaFont, margin, lineHeight) {\n    this.fontSelector.pushData(xfaFont, margin, lineHeight);\n  }\n  popFont(xfaFont) {\n    return this.fontSelector.popFont();\n  }\n  addPara() {\n    const lastFont = this.fontSelector.topFont();\n    this.extraHeight += lastFont.paraMargin.top + lastFont.paraMargin.bottom;\n  }\n  addString(str) {\n    if (!str) {\n      return;\n    }\n    const lastFont = this.fontSelector.topFont();\n    const fontSize = lastFont.xfaFont.size;\n    if (lastFont.pdfFont) {\n      const letterSpacing = lastFont.xfaFont.letterSpacing;\n      const pdfFont = lastFont.pdfFont;\n      const fontLineHeight = pdfFont.lineHeight || 1.2;\n      const lineHeight = lastFont.lineHeight || Math.max(1.2, fontLineHeight) * fontSize;\n      const lineGap = pdfFont.lineGap === undefined ? 0.2 : pdfFont.lineGap;\n      const noGap = fontLineHeight - lineGap;\n      const firstLineHeight = Math.max(1, noGap) * fontSize;\n      const scale = fontSize / 1000;\n      const fallbackWidth = pdfFont.defaultWidth || pdfFont.charsToGlyphs(\" \")[0].width;\n      for (const line of str.split(/[\\u2029\\n]/)) {\n        const encodedLine = pdfFont.encodeString(line).join(\"\");\n        const glyphs = pdfFont.charsToGlyphs(encodedLine);\n        for (const glyph of glyphs) {\n          const width = glyph.width || fallbackWidth;\n          this.glyphs.push([width * scale + letterSpacing, lineHeight, firstLineHeight, glyph.unicode, false]);\n        }\n        this.glyphs.push([0, 0, 0, \"\\n\", true]);\n      }\n      this.glyphs.pop();\n      return;\n    }\n    for (const line of str.split(/[\\u2029\\n]/)) {\n      for (const char of line.split(\"\")) {\n        this.glyphs.push([fontSize, 1.2 * fontSize, fontSize, char, false]);\n      }\n      this.glyphs.push([0, 0, 0, \"\\n\", true]);\n    }\n    this.glyphs.pop();\n  }\n  compute(maxWidth) {\n    let lastSpacePos = -1,\n      lastSpaceWidth = 0,\n      width = 0,\n      height = 0,\n      currentLineWidth = 0,\n      currentLineHeight = 0;\n    let isBroken = false;\n    let isFirstLine = true;\n    for (let i = 0, ii = this.glyphs.length; i < ii; i++) {\n      const [glyphWidth, lineHeight, firstLineHeight, char, isEOL] = this.glyphs[i];\n      const isSpace = char === \" \";\n      const glyphHeight = isFirstLine ? firstLineHeight : lineHeight;\n      if (isEOL) {\n        width = Math.max(width, currentLineWidth);\n        currentLineWidth = 0;\n        height += currentLineHeight;\n        currentLineHeight = glyphHeight;\n        lastSpacePos = -1;\n        lastSpaceWidth = 0;\n        isFirstLine = false;\n        continue;\n      }\n      if (isSpace) {\n        if (currentLineWidth + glyphWidth > maxWidth) {\n          width = Math.max(width, currentLineWidth);\n          currentLineWidth = 0;\n          height += currentLineHeight;\n          currentLineHeight = glyphHeight;\n          lastSpacePos = -1;\n          lastSpaceWidth = 0;\n          isBroken = true;\n          isFirstLine = false;\n        } else {\n          currentLineHeight = Math.max(glyphHeight, currentLineHeight);\n          lastSpaceWidth = currentLineWidth;\n          currentLineWidth += glyphWidth;\n          lastSpacePos = i;\n        }\n        continue;\n      }\n      if (currentLineWidth + glyphWidth > maxWidth) {\n        height += currentLineHeight;\n        currentLineHeight = glyphHeight;\n        if (lastSpacePos !== -1) {\n          i = lastSpacePos;\n          width = Math.max(width, lastSpaceWidth);\n          currentLineWidth = 0;\n          lastSpacePos = -1;\n          lastSpaceWidth = 0;\n        } else {\n          width = Math.max(width, currentLineWidth);\n          currentLineWidth = glyphWidth;\n        }\n        isBroken = true;\n        isFirstLine = false;\n        continue;\n      }\n      currentLineWidth += glyphWidth;\n      currentLineHeight = Math.max(glyphHeight, currentLineHeight);\n    }\n    width = Math.max(width, currentLineWidth);\n    height += currentLineHeight + this.extraHeight;\n    return {\n      width: WIDTH_FACTOR * width,\n      height,\n      isBroken\n    };\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/som.js\n\n\nconst namePattern = /^[^.[]+/;\nconst indexPattern = /^[^\\]]+/;\nconst operators = {\n  dot: 0,\n  dotDot: 1,\n  dotHash: 2,\n  dotBracket: 3,\n  dotParen: 4\n};\nconst shortcuts = new Map([[\"$data\", (root, current) => root.datasets ? root.datasets.data : root], [\"$record\", (root, current) => (root.datasets ? root.datasets.data : root)[$getChildren]()[0]], [\"$template\", (root, current) => root.template], [\"$connectionSet\", (root, current) => root.connectionSet], [\"$form\", (root, current) => root.form], [\"$layout\", (root, current) => root.layout], [\"$host\", (root, current) => root.host], [\"$dataWindow\", (root, current) => root.dataWindow], [\"$event\", (root, current) => root.event], [\"!\", (root, current) => root.datasets], [\"$xfa\", (root, current) => root], [\"xfa\", (root, current) => root], [\"$\", (root, current) => current]]);\nconst somCache = new WeakMap();\nfunction parseIndex(index) {\n  index = index.trim();\n  if (index === \"*\") {\n    return Infinity;\n  }\n  return parseInt(index, 10) || 0;\n}\nfunction parseExpression(expr, dotDotAllowed, noExpr = true) {\n  let match = expr.match(namePattern);\n  if (!match) {\n    return null;\n  }\n  let [name] = match;\n  const parsed = [{\n    name,\n    cacheName: \".\" + name,\n    index: 0,\n    js: null,\n    formCalc: null,\n    operator: operators.dot\n  }];\n  let pos = name.length;\n  while (pos < expr.length) {\n    const spos = pos;\n    const char = expr.charAt(pos++);\n    if (char === \"[\") {\n      match = expr.slice(pos).match(indexPattern);\n      if (!match) {\n        warn(\"XFA - Invalid index in SOM expression\");\n        return null;\n      }\n      parsed.at(-1).index = parseIndex(match[0]);\n      pos += match[0].length + 1;\n      continue;\n    }\n    let operator;\n    switch (expr.charAt(pos)) {\n      case \".\":\n        if (!dotDotAllowed) {\n          return null;\n        }\n        pos++;\n        operator = operators.dotDot;\n        break;\n      case \"#\":\n        pos++;\n        operator = operators.dotHash;\n        break;\n      case \"[\":\n        if (noExpr) {\n          warn(\"XFA - SOM expression contains a FormCalc subexpression which is not supported for now.\");\n          return null;\n        }\n        operator = operators.dotBracket;\n        break;\n      case \"(\":\n        if (noExpr) {\n          warn(\"XFA - SOM expression contains a JavaScript subexpression which is not supported for now.\");\n          return null;\n        }\n        operator = operators.dotParen;\n        break;\n      default:\n        operator = operators.dot;\n        break;\n    }\n    match = expr.slice(pos).match(namePattern);\n    if (!match) {\n      break;\n    }\n    [name] = match;\n    pos += name.length;\n    parsed.push({\n      name,\n      cacheName: expr.slice(spos, pos),\n      operator,\n      index: 0,\n      js: null,\n      formCalc: null\n    });\n  }\n  return parsed;\n}\nfunction searchNode(root, container, expr, dotDotAllowed = true, useCache = true) {\n  const parsed = parseExpression(expr, dotDotAllowed);\n  if (!parsed) {\n    return null;\n  }\n  const fn = shortcuts.get(parsed[0].name);\n  let i = 0;\n  let isQualified;\n  if (fn) {\n    isQualified = true;\n    root = [fn(root, container)];\n    i = 1;\n  } else {\n    isQualified = container === null;\n    root = [container || root];\n  }\n  for (let ii = parsed.length; i < ii; i++) {\n    const {\n      name,\n      cacheName,\n      operator,\n      index\n    } = parsed[i];\n    const nodes = [];\n    for (const node of root) {\n      if (!node.isXFAObject) {\n        continue;\n      }\n      let children, cached;\n      if (useCache) {\n        cached = somCache.get(node);\n        if (!cached) {\n          cached = new Map();\n          somCache.set(node, cached);\n        }\n        children = cached.get(cacheName);\n      }\n      if (!children) {\n        switch (operator) {\n          case operators.dot:\n            children = node[$getChildrenByName](name, false);\n            break;\n          case operators.dotDot:\n            children = node[$getChildrenByName](name, true);\n            break;\n          case operators.dotHash:\n            children = node[$getChildrenByClass](name);\n            children = children.isXFAObjectArray ? children.children : [children];\n            break;\n          default:\n            break;\n        }\n        if (useCache) {\n          cached.set(cacheName, children);\n        }\n      }\n      if (children.length > 0) {\n        nodes.push(children);\n      }\n    }\n    if (nodes.length === 0 && !isQualified && i === 0) {\n      const parent = container[$getParent]();\n      container = parent;\n      if (!container) {\n        return null;\n      }\n      i = -1;\n      root = [container];\n      continue;\n    }\n    root = isFinite(index) ? nodes.filter(node => index < node.length).map(node => node[index]) : nodes.flat();\n  }\n  if (root.length === 0) {\n    return null;\n  }\n  return root;\n}\nfunction createDataNode(root, container, expr) {\n  const parsed = parseExpression(expr);\n  if (!parsed) {\n    return null;\n  }\n  if (parsed.some(x => x.operator === operators.dotDot)) {\n    return null;\n  }\n  const fn = shortcuts.get(parsed[0].name);\n  let i = 0;\n  if (fn) {\n    root = fn(root, container);\n    i = 1;\n  } else {\n    root = container || root;\n  }\n  for (let ii = parsed.length; i < ii; i++) {\n    const {\n      name,\n      operator,\n      index\n    } = parsed[i];\n    if (!isFinite(index)) {\n      parsed[i].index = 0;\n      return root.createNodes(parsed.slice(i));\n    }\n    let children;\n    switch (operator) {\n      case operators.dot:\n        children = root[$getChildrenByName](name, false);\n        break;\n      case operators.dotDot:\n        children = root[$getChildrenByName](name, true);\n        break;\n      case operators.dotHash:\n        children = root[$getChildrenByClass](name);\n        children = children.isXFAObjectArray ? children.children : [children];\n        break;\n      default:\n        break;\n    }\n    if (children.length === 0) {\n      return root.createNodes(parsed.slice(i));\n    }\n    if (index < children.length) {\n      const child = children[index];\n      if (!child.isXFAObject) {\n        warn(`XFA - Cannot create a node.`);\n        return null;\n      }\n      root = child;\n    } else {\n      parsed[i].index = index - children.length;\n      return root.createNodes(parsed.slice(i));\n    }\n  }\n  return null;\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/xfa_object.js\n\n\n\n\n\n\nconst _applyPrototype = Symbol();\nconst _attributes = Symbol();\nconst _attributeNames = Symbol();\nconst _children = Symbol(\"_children\");\nconst _cloneAttribute = Symbol();\nconst _dataValue = Symbol();\nconst _defaultValue = Symbol();\nconst _filteredChildrenGenerator = Symbol();\nconst _getPrototype = Symbol();\nconst _getUnsetAttributes = Symbol();\nconst _hasChildren = Symbol();\nconst _max = Symbol();\nconst _options = Symbol();\nconst _parent = Symbol(\"parent\");\nconst _resolvePrototypesHelper = Symbol();\nconst _setAttributes = Symbol();\nconst _validator = Symbol();\nlet uid = 0;\nconst NS_DATASETS = NamespaceIds.datasets.id;\nclass XFAObject {\n  constructor(nsId, name, hasChildren = false) {\n    this[$namespaceId] = nsId;\n    this[$nodeName] = name;\n    this[_hasChildren] = hasChildren;\n    this[_parent] = null;\n    this[_children] = [];\n    this[$uid] = `${name}${uid++}`;\n    this[$globalData] = null;\n  }\n  get isXFAObject() {\n    return true;\n  }\n  get isXFAObjectArray() {\n    return false;\n  }\n  createNodes(path) {\n    let root = this,\n      node = null;\n    for (const {\n      name,\n      index\n    } of path) {\n      for (let i = 0, ii = isFinite(index) ? index : 0; i <= ii; i++) {\n        const nsId = root[$namespaceId] === NS_DATASETS ? -1 : root[$namespaceId];\n        node = new XmlObject(nsId, name);\n        root[$appendChild](node);\n      }\n      root = node;\n    }\n    return node;\n  }\n  [$onChild](child) {\n    if (!this[_hasChildren] || !this[$onChildCheck](child)) {\n      return false;\n    }\n    const name = child[$nodeName];\n    const node = this[name];\n    if (node instanceof XFAObjectArray) {\n      if (node.push(child)) {\n        this[$appendChild](child);\n        return true;\n      }\n    } else {\n      if (node !== null) {\n        this[$removeChild](node);\n      }\n      this[name] = child;\n      this[$appendChild](child);\n      return true;\n    }\n    let id = \"\";\n    if (this.id) {\n      id = ` (id: ${this.id})`;\n    } else if (this.name) {\n      id = ` (name: ${this.name} ${this.h.value})`;\n    }\n    warn(`XFA - node \"${this[$nodeName]}\"${id} has already enough \"${name}\"!`);\n    return false;\n  }\n  [$onChildCheck](child) {\n    return this.hasOwnProperty(child[$nodeName]) && child[$namespaceId] === this[$namespaceId];\n  }\n  [$isNsAgnostic]() {\n    return false;\n  }\n  [$acceptWhitespace]() {\n    return false;\n  }\n  [$isCDATAXml]() {\n    return false;\n  }\n  [$isBindable]() {\n    return false;\n  }\n  [$popPara]() {\n    if (this.para) {\n      this[$getTemplateRoot]()[$extra].paraStack.pop();\n    }\n  }\n  [$pushPara]() {\n    this[$getTemplateRoot]()[$extra].paraStack.push(this.para);\n  }\n  [$setId](ids) {\n    if (this.id && this[$namespaceId] === NamespaceIds.template.id) {\n      ids.set(this.id, this);\n    }\n  }\n  [$getTemplateRoot]() {\n    return this[$globalData].template;\n  }\n  [$isSplittable]() {\n    return false;\n  }\n  [$isThereMoreWidth]() {\n    return false;\n  }\n  [$appendChild](child) {\n    child[_parent] = this;\n    this[_children].push(child);\n    if (!child[$globalData] && this[$globalData]) {\n      child[$globalData] = this[$globalData];\n    }\n  }\n  [$removeChild](child) {\n    const i = this[_children].indexOf(child);\n    this[_children].splice(i, 1);\n  }\n  [$hasSettableValue]() {\n    return this.hasOwnProperty(\"value\");\n  }\n  [$setValue](_) {}\n  [$onText](_) {}\n  [$finalize]() {}\n  [$clean](builder) {\n    delete this[_hasChildren];\n    if (this[$cleanup]) {\n      builder.clean(this[$cleanup]);\n      delete this[$cleanup];\n    }\n  }\n  [$indexOf](child) {\n    return this[_children].indexOf(child);\n  }\n  [$insertAt](i, child) {\n    child[_parent] = this;\n    this[_children].splice(i, 0, child);\n    if (!child[$globalData] && this[$globalData]) {\n      child[$globalData] = this[$globalData];\n    }\n  }\n  [$isTransparent]() {\n    return !this.name;\n  }\n  [$lastAttribute]() {\n    return \"\";\n  }\n  [$text]() {\n    if (this[_children].length === 0) {\n      return this[$content];\n    }\n    return this[_children].map(c => c[$text]()).join(\"\");\n  }\n  get [_attributeNames]() {\n    const proto = Object.getPrototypeOf(this);\n    if (!proto._attributes) {\n      const attributes = proto._attributes = new Set();\n      for (const name of Object.getOwnPropertyNames(this)) {\n        if (this[name] === null || this[name] instanceof XFAObject || this[name] instanceof XFAObjectArray) {\n          break;\n        }\n        attributes.add(name);\n      }\n    }\n    return shadow(this, _attributeNames, proto._attributes);\n  }\n  [$isDescendent](parent) {\n    let node = this;\n    while (node) {\n      if (node === parent) {\n        return true;\n      }\n      node = node[$getParent]();\n    }\n    return false;\n  }\n  [$getParent]() {\n    return this[_parent];\n  }\n  [$getSubformParent]() {\n    return this[$getParent]();\n  }\n  [$getChildren](name = null) {\n    if (!name) {\n      return this[_children];\n    }\n    return this[name];\n  }\n  [$dump]() {\n    const dumped = Object.create(null);\n    if (this[$content]) {\n      dumped.$content = this[$content];\n    }\n    for (const name of Object.getOwnPropertyNames(this)) {\n      const value = this[name];\n      if (value === null) {\n        continue;\n      }\n      if (value instanceof XFAObject) {\n        dumped[name] = value[$dump]();\n      } else if (value instanceof XFAObjectArray) {\n        if (!value.isEmpty()) {\n          dumped[name] = value.dump();\n        }\n      } else {\n        dumped[name] = value;\n      }\n    }\n    return dumped;\n  }\n  [$toStyle]() {\n    return null;\n  }\n  [$toHTML]() {\n    return HTMLResult.EMPTY;\n  }\n  *[$getContainedChildren]() {\n    for (const node of this[$getChildren]()) {\n      yield node;\n    }\n  }\n  *[_filteredChildrenGenerator](filter, include) {\n    for (const node of this[$getContainedChildren]()) {\n      if (!filter || include === filter.has(node[$nodeName])) {\n        const availableSpace = this[$getAvailableSpace]();\n        const res = node[$toHTML](availableSpace);\n        if (!res.success) {\n          this[$extra].failingNode = node;\n        }\n        yield res;\n      }\n    }\n  }\n  [$flushHTML]() {\n    return null;\n  }\n  [$addHTML](html, bbox) {\n    this[$extra].children.push(html);\n  }\n  [$getAvailableSpace]() {}\n  [$childrenToHTML]({\n    filter = null,\n    include = true\n  }) {\n    if (!this[$extra].generator) {\n      this[$extra].generator = this[_filteredChildrenGenerator](filter, include);\n    } else {\n      const availableSpace = this[$getAvailableSpace]();\n      const res = this[$extra].failingNode[$toHTML](availableSpace);\n      if (!res.success) {\n        return res;\n      }\n      if (res.html) {\n        this[$addHTML](res.html, res.bbox);\n      }\n      delete this[$extra].failingNode;\n    }\n    while (true) {\n      const gen = this[$extra].generator.next();\n      if (gen.done) {\n        break;\n      }\n      const res = gen.value;\n      if (!res.success) {\n        return res;\n      }\n      if (res.html) {\n        this[$addHTML](res.html, res.bbox);\n      }\n    }\n    this[$extra].generator = null;\n    return HTMLResult.EMPTY;\n  }\n  [$setSetAttributes](attributes) {\n    this[_setAttributes] = new Set(Object.keys(attributes));\n  }\n  [_getUnsetAttributes](protoAttributes) {\n    const allAttr = this[_attributeNames];\n    const setAttr = this[_setAttributes];\n    return [...protoAttributes].filter(x => allAttr.has(x) && !setAttr.has(x));\n  }\n  [$resolvePrototypes](ids, ancestors = new Set()) {\n    for (const child of this[_children]) {\n      child[_resolvePrototypesHelper](ids, ancestors);\n    }\n  }\n  [_resolvePrototypesHelper](ids, ancestors) {\n    const proto = this[_getPrototype](ids, ancestors);\n    if (proto) {\n      this[_applyPrototype](proto, ids, ancestors);\n    } else {\n      this[$resolvePrototypes](ids, ancestors);\n    }\n  }\n  [_getPrototype](ids, ancestors) {\n    const {\n      use,\n      usehref\n    } = this;\n    if (!use && !usehref) {\n      return null;\n    }\n    let proto = null;\n    let somExpression = null;\n    let id = null;\n    let ref = use;\n    if (usehref) {\n      ref = usehref;\n      if (usehref.startsWith(\"#som(\") && usehref.endsWith(\")\")) {\n        somExpression = usehref.slice(\"#som(\".length, -1);\n      } else if (usehref.startsWith(\".#som(\") && usehref.endsWith(\")\")) {\n        somExpression = usehref.slice(\".#som(\".length, -1);\n      } else if (usehref.startsWith(\"#\")) {\n        id = usehref.slice(1);\n      } else if (usehref.startsWith(\".#\")) {\n        id = usehref.slice(2);\n      }\n    } else if (use.startsWith(\"#\")) {\n      id = use.slice(1);\n    } else {\n      somExpression = use;\n    }\n    this.use = this.usehref = \"\";\n    if (id) {\n      proto = ids.get(id);\n    } else {\n      proto = searchNode(ids.get($root), this, somExpression, true, false);\n      if (proto) {\n        proto = proto[0];\n      }\n    }\n    if (!proto) {\n      warn(`XFA - Invalid prototype reference: ${ref}.`);\n      return null;\n    }\n    if (proto[$nodeName] !== this[$nodeName]) {\n      warn(`XFA - Incompatible prototype: ${proto[$nodeName]} !== ${this[$nodeName]}.`);\n      return null;\n    }\n    if (ancestors.has(proto)) {\n      warn(`XFA - Cycle detected in prototypes use.`);\n      return null;\n    }\n    ancestors.add(proto);\n    const protoProto = proto[_getPrototype](ids, ancestors);\n    if (protoProto) {\n      proto[_applyPrototype](protoProto, ids, ancestors);\n    }\n    proto[$resolvePrototypes](ids, ancestors);\n    ancestors.delete(proto);\n    return proto;\n  }\n  [_applyPrototype](proto, ids, ancestors) {\n    if (ancestors.has(proto)) {\n      warn(`XFA - Cycle detected in prototypes use.`);\n      return;\n    }\n    if (!this[$content] && proto[$content]) {\n      this[$content] = proto[$content];\n    }\n    const newAncestors = new Set(ancestors);\n    newAncestors.add(proto);\n    for (const unsetAttrName of this[_getUnsetAttributes](proto[_setAttributes])) {\n      this[unsetAttrName] = proto[unsetAttrName];\n      if (this[_setAttributes]) {\n        this[_setAttributes].add(unsetAttrName);\n      }\n    }\n    for (const name of Object.getOwnPropertyNames(this)) {\n      if (this[_attributeNames].has(name)) {\n        continue;\n      }\n      const value = this[name];\n      const protoValue = proto[name];\n      if (value instanceof XFAObjectArray) {\n        for (const child of value[_children]) {\n          child[_resolvePrototypesHelper](ids, ancestors);\n        }\n        for (let i = value[_children].length, ii = protoValue[_children].length; i < ii; i++) {\n          const child = proto[_children][i][$clone]();\n          if (value.push(child)) {\n            child[_parent] = this;\n            this[_children].push(child);\n            child[_resolvePrototypesHelper](ids, ancestors);\n          } else {\n            break;\n          }\n        }\n        continue;\n      }\n      if (value !== null) {\n        value[$resolvePrototypes](ids, ancestors);\n        if (protoValue) {\n          value[_applyPrototype](protoValue, ids, ancestors);\n        }\n        continue;\n      }\n      if (protoValue !== null) {\n        const child = protoValue[$clone]();\n        child[_parent] = this;\n        this[name] = child;\n        this[_children].push(child);\n        child[_resolvePrototypesHelper](ids, ancestors);\n      }\n    }\n  }\n  static [_cloneAttribute](obj) {\n    if (Array.isArray(obj)) {\n      return obj.map(x => XFAObject[_cloneAttribute](x));\n    }\n    if (typeof obj === \"object\" && obj !== null) {\n      return Object.assign({}, obj);\n    }\n    return obj;\n  }\n  [$clone]() {\n    const clone = Object.create(Object.getPrototypeOf(this));\n    for (const $symbol of Object.getOwnPropertySymbols(this)) {\n      try {\n        clone[$symbol] = this[$symbol];\n      } catch {\n        shadow(clone, $symbol, this[$symbol]);\n      }\n    }\n    clone[$uid] = `${clone[$nodeName]}${uid++}`;\n    clone[_children] = [];\n    for (const name of Object.getOwnPropertyNames(this)) {\n      if (this[_attributeNames].has(name)) {\n        clone[name] = XFAObject[_cloneAttribute](this[name]);\n        continue;\n      }\n      const value = this[name];\n      clone[name] = value instanceof XFAObjectArray ? new XFAObjectArray(value[_max]) : null;\n    }\n    for (const child of this[_children]) {\n      const name = child[$nodeName];\n      const clonedChild = child[$clone]();\n      clone[_children].push(clonedChild);\n      clonedChild[_parent] = clone;\n      if (clone[name] === null) {\n        clone[name] = clonedChild;\n      } else {\n        clone[name][_children].push(clonedChild);\n      }\n    }\n    return clone;\n  }\n  [$getChildren](name = null) {\n    if (!name) {\n      return this[_children];\n    }\n    return this[_children].filter(c => c[$nodeName] === name);\n  }\n  [$getChildrenByClass](name) {\n    return this[name];\n  }\n  [$getChildrenByName](name, allTransparent, first = true) {\n    return Array.from(this[$getChildrenByNameIt](name, allTransparent, first));\n  }\n  *[$getChildrenByNameIt](name, allTransparent, first = true) {\n    if (name === \"parent\") {\n      yield this[_parent];\n      return;\n    }\n    for (const child of this[_children]) {\n      if (child[$nodeName] === name) {\n        yield child;\n      }\n      if (child.name === name) {\n        yield child;\n      }\n      if (allTransparent || child[$isTransparent]()) {\n        yield* child[$getChildrenByNameIt](name, allTransparent, false);\n      }\n    }\n    if (first && this[_attributeNames].has(name)) {\n      yield new XFAAttribute(this, name, this[name]);\n    }\n  }\n}\nclass XFAObjectArray {\n  constructor(max = Infinity) {\n    this[_max] = max;\n    this[_children] = [];\n  }\n  get isXFAObject() {\n    return false;\n  }\n  get isXFAObjectArray() {\n    return true;\n  }\n  push(child) {\n    const len = this[_children].length;\n    if (len <= this[_max]) {\n      this[_children].push(child);\n      return true;\n    }\n    warn(`XFA - node \"${child[$nodeName]}\" accepts no more than ${this[_max]} children`);\n    return false;\n  }\n  isEmpty() {\n    return this[_children].length === 0;\n  }\n  dump() {\n    return this[_children].length === 1 ? this[_children][0][$dump]() : this[_children].map(x => x[$dump]());\n  }\n  [$clone]() {\n    const clone = new XFAObjectArray(this[_max]);\n    clone[_children] = this[_children].map(c => c[$clone]());\n    return clone;\n  }\n  get children() {\n    return this[_children];\n  }\n  clear() {\n    this[_children].length = 0;\n  }\n}\nclass XFAAttribute {\n  constructor(node, name, value) {\n    this[_parent] = node;\n    this[$nodeName] = name;\n    this[$content] = value;\n    this[$consumed] = false;\n    this[$uid] = `attribute${uid++}`;\n  }\n  [$getParent]() {\n    return this[_parent];\n  }\n  [$isDataValue]() {\n    return true;\n  }\n  [$getDataValue]() {\n    return this[$content].trim();\n  }\n  [$setValue](value) {\n    value = value.value || \"\";\n    this[$content] = value.toString();\n  }\n  [$text]() {\n    return this[$content];\n  }\n  [$isDescendent](parent) {\n    return this[_parent] === parent || this[_parent][$isDescendent](parent);\n  }\n}\nclass XmlObject extends XFAObject {\n  constructor(nsId, name, attributes = {}) {\n    super(nsId, name);\n    this[$content] = \"\";\n    this[_dataValue] = null;\n    if (name !== \"#text\") {\n      const map = new Map();\n      this[_attributes] = map;\n      for (const [attrName, value] of Object.entries(attributes)) {\n        map.set(attrName, new XFAAttribute(this, attrName, value));\n      }\n      if (attributes.hasOwnProperty($nsAttributes)) {\n        const dataNode = attributes[$nsAttributes].xfa.dataNode;\n        if (dataNode !== undefined) {\n          if (dataNode === \"dataGroup\") {\n            this[_dataValue] = false;\n          } else if (dataNode === \"dataValue\") {\n            this[_dataValue] = true;\n          }\n        }\n      }\n    }\n    this[$consumed] = false;\n  }\n  [$toString](buf) {\n    const tagName = this[$nodeName];\n    if (tagName === \"#text\") {\n      buf.push(encodeToXmlString(this[$content]));\n      return;\n    }\n    const utf8TagName = utf8StringToString(tagName);\n    const prefix = this[$namespaceId] === NS_DATASETS ? \"xfa:\" : \"\";\n    buf.push(`<${prefix}${utf8TagName}`);\n    for (const [name, value] of this[_attributes].entries()) {\n      const utf8Name = utf8StringToString(name);\n      buf.push(` ${utf8Name}=\"${encodeToXmlString(value[$content])}\"`);\n    }\n    if (this[_dataValue] !== null) {\n      if (this[_dataValue]) {\n        buf.push(` xfa:dataNode=\"dataValue\"`);\n      } else {\n        buf.push(` xfa:dataNode=\"dataGroup\"`);\n      }\n    }\n    if (!this[$content] && this[_children].length === 0) {\n      buf.push(\"/>\");\n      return;\n    }\n    buf.push(\">\");\n    if (this[$content]) {\n      if (typeof this[$content] === \"string\") {\n        buf.push(encodeToXmlString(this[$content]));\n      } else {\n        this[$content][$toString](buf);\n      }\n    } else {\n      for (const child of this[_children]) {\n        child[$toString](buf);\n      }\n    }\n    buf.push(`</${prefix}${utf8TagName}>`);\n  }\n  [$onChild](child) {\n    if (this[$content]) {\n      const node = new XmlObject(this[$namespaceId], \"#text\");\n      this[$appendChild](node);\n      node[$content] = this[$content];\n      this[$content] = \"\";\n    }\n    this[$appendChild](child);\n    return true;\n  }\n  [$onText](str) {\n    this[$content] += str;\n  }\n  [$finalize]() {\n    if (this[$content] && this[_children].length > 0) {\n      const node = new XmlObject(this[$namespaceId], \"#text\");\n      this[$appendChild](node);\n      node[$content] = this[$content];\n      delete this[$content];\n    }\n  }\n  [$toHTML]() {\n    if (this[$nodeName] === \"#text\") {\n      return HTMLResult.success({\n        name: \"#text\",\n        value: this[$content]\n      });\n    }\n    return HTMLResult.EMPTY;\n  }\n  [$getChildren](name = null) {\n    if (!name) {\n      return this[_children];\n    }\n    return this[_children].filter(c => c[$nodeName] === name);\n  }\n  [$getAttributes]() {\n    return this[_attributes];\n  }\n  [$getChildrenByClass](name) {\n    const value = this[_attributes].get(name);\n    if (value !== undefined) {\n      return value;\n    }\n    return this[$getChildren](name);\n  }\n  *[$getChildrenByNameIt](name, allTransparent) {\n    const value = this[_attributes].get(name);\n    if (value) {\n      yield value;\n    }\n    for (const child of this[_children]) {\n      if (child[$nodeName] === name) {\n        yield child;\n      }\n      if (allTransparent) {\n        yield* child[$getChildrenByNameIt](name, allTransparent);\n      }\n    }\n  }\n  *[$getAttributeIt](name, skipConsumed) {\n    const value = this[_attributes].get(name);\n    if (value && (!skipConsumed || !value[$consumed])) {\n      yield value;\n    }\n    for (const child of this[_children]) {\n      yield* child[$getAttributeIt](name, skipConsumed);\n    }\n  }\n  *[$getRealChildrenByNameIt](name, allTransparent, skipConsumed) {\n    for (const child of this[_children]) {\n      if (child[$nodeName] === name && (!skipConsumed || !child[$consumed])) {\n        yield child;\n      }\n      if (allTransparent) {\n        yield* child[$getRealChildrenByNameIt](name, allTransparent, skipConsumed);\n      }\n    }\n  }\n  [$isDataValue]() {\n    if (this[_dataValue] === null) {\n      return this[_children].length === 0 || this[_children][0][$namespaceId] === NamespaceIds.xhtml.id;\n    }\n    return this[_dataValue];\n  }\n  [$getDataValue]() {\n    if (this[_dataValue] === null) {\n      if (this[_children].length === 0) {\n        return this[$content].trim();\n      }\n      if (this[_children][0][$namespaceId] === NamespaceIds.xhtml.id) {\n        return this[_children][0][$text]().trim();\n      }\n      return null;\n    }\n    return this[$content].trim();\n  }\n  [$setValue](value) {\n    value = value.value || \"\";\n    this[$content] = value.toString();\n  }\n  [$dump](hasNS = false) {\n    const dumped = Object.create(null);\n    if (hasNS) {\n      dumped.$ns = this[$namespaceId];\n    }\n    if (this[$content]) {\n      dumped.$content = this[$content];\n    }\n    dumped.$name = this[$nodeName];\n    dumped.children = [];\n    for (const child of this[_children]) {\n      dumped.children.push(child[$dump](hasNS));\n    }\n    dumped.attributes = Object.create(null);\n    for (const [name, value] of this[_attributes]) {\n      dumped.attributes[name] = value[$content];\n    }\n    return dumped;\n  }\n}\nclass ContentObject extends XFAObject {\n  constructor(nsId, name) {\n    super(nsId, name);\n    this[$content] = \"\";\n  }\n  [$onText](text) {\n    this[$content] += text;\n  }\n  [$finalize]() {}\n}\nclass OptionObject extends ContentObject {\n  constructor(nsId, name, options) {\n    super(nsId, name);\n    this[_options] = options;\n  }\n  [$finalize]() {\n    this[$content] = getKeyword({\n      data: this[$content],\n      defaultValue: this[_options][0],\n      validate: k => this[_options].includes(k)\n    });\n  }\n  [$clean](builder) {\n    super[$clean](builder);\n    delete this[_options];\n  }\n}\nclass StringObject extends ContentObject {\n  [$finalize]() {\n    this[$content] = this[$content].trim();\n  }\n}\nclass IntegerObject extends ContentObject {\n  constructor(nsId, name, defaultValue, validator) {\n    super(nsId, name);\n    this[_defaultValue] = defaultValue;\n    this[_validator] = validator;\n  }\n  [$finalize]() {\n    this[$content] = getInteger({\n      data: this[$content],\n      defaultValue: this[_defaultValue],\n      validate: this[_validator]\n    });\n  }\n  [$clean](builder) {\n    super[$clean](builder);\n    delete this[_defaultValue];\n    delete this[_validator];\n  }\n}\nclass Option01 extends IntegerObject {\n  constructor(nsId, name) {\n    super(nsId, name, 0, n => n === 1);\n  }\n}\nclass Option10 extends IntegerObject {\n  constructor(nsId, name) {\n    super(nsId, name, 1, n => n === 0);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/html_utils.js\n\n\n\n\n\n\nfunction measureToString(m) {\n  if (typeof m === \"string\") {\n    return \"0px\";\n  }\n  return Number.isInteger(m) ? `${m}px` : `${m.toFixed(2)}px`;\n}\nconst converters = {\n  anchorType(node, style) {\n    const parent = node[$getSubformParent]();\n    if (!parent || parent.layout && parent.layout !== \"position\") {\n      return;\n    }\n    if (!(\"transform\" in style)) {\n      style.transform = \"\";\n    }\n    switch (node.anchorType) {\n      case \"bottomCenter\":\n        style.transform += \"translate(-50%, -100%)\";\n        break;\n      case \"bottomLeft\":\n        style.transform += \"translate(0,-100%)\";\n        break;\n      case \"bottomRight\":\n        style.transform += \"translate(-100%,-100%)\";\n        break;\n      case \"middleCenter\":\n        style.transform += \"translate(-50%,-50%)\";\n        break;\n      case \"middleLeft\":\n        style.transform += \"translate(0,-50%)\";\n        break;\n      case \"middleRight\":\n        style.transform += \"translate(-100%,-50%)\";\n        break;\n      case \"topCenter\":\n        style.transform += \"translate(-50%,0)\";\n        break;\n      case \"topRight\":\n        style.transform += \"translate(-100%,0)\";\n        break;\n    }\n  },\n  dimensions(node, style) {\n    const parent = node[$getSubformParent]();\n    let width = node.w;\n    const height = node.h;\n    if (parent.layout?.includes(\"row\")) {\n      const extra = parent[$extra];\n      const colSpan = node.colSpan;\n      let w;\n      if (colSpan === -1) {\n        w = extra.columnWidths.slice(extra.currentColumn).reduce((a, x) => a + x, 0);\n        extra.currentColumn = 0;\n      } else {\n        w = extra.columnWidths.slice(extra.currentColumn, extra.currentColumn + colSpan).reduce((a, x) => a + x, 0);\n        extra.currentColumn = (extra.currentColumn + node.colSpan) % extra.columnWidths.length;\n      }\n      if (!isNaN(w)) {\n        width = node.w = w;\n      }\n    }\n    style.width = width !== \"\" ? measureToString(width) : \"auto\";\n    style.height = height !== \"\" ? measureToString(height) : \"auto\";\n  },\n  position(node, style) {\n    const parent = node[$getSubformParent]();\n    if (parent?.layout && parent.layout !== \"position\") {\n      return;\n    }\n    style.position = \"absolute\";\n    style.left = measureToString(node.x);\n    style.top = measureToString(node.y);\n  },\n  rotate(node, style) {\n    if (node.rotate) {\n      if (!(\"transform\" in style)) {\n        style.transform = \"\";\n      }\n      style.transform += `rotate(-${node.rotate}deg)`;\n      style.transformOrigin = \"top left\";\n    }\n  },\n  presence(node, style) {\n    switch (node.presence) {\n      case \"invisible\":\n        style.visibility = \"hidden\";\n        break;\n      case \"hidden\":\n      case \"inactive\":\n        style.display = \"none\";\n        break;\n    }\n  },\n  hAlign(node, style) {\n    if (node[$nodeName] === \"para\") {\n      switch (node.hAlign) {\n        case \"justifyAll\":\n          style.textAlign = \"justify-all\";\n          break;\n        case \"radix\":\n          style.textAlign = \"left\";\n          break;\n        default:\n          style.textAlign = node.hAlign;\n      }\n    } else {\n      switch (node.hAlign) {\n        case \"left\":\n          style.alignSelf = \"start\";\n          break;\n        case \"center\":\n          style.alignSelf = \"center\";\n          break;\n        case \"right\":\n          style.alignSelf = \"end\";\n          break;\n      }\n    }\n  },\n  margin(node, style) {\n    if (node.margin) {\n      style.margin = node.margin[$toStyle]().margin;\n    }\n  }\n};\nfunction setMinMaxDimensions(node, style) {\n  const parent = node[$getSubformParent]();\n  if (parent.layout === \"position\") {\n    if (node.minW > 0) {\n      style.minWidth = measureToString(node.minW);\n    }\n    if (node.maxW > 0) {\n      style.maxWidth = measureToString(node.maxW);\n    }\n    if (node.minH > 0) {\n      style.minHeight = measureToString(node.minH);\n    }\n    if (node.maxH > 0) {\n      style.maxHeight = measureToString(node.maxH);\n    }\n  }\n}\nfunction layoutText(text, xfaFont, margin, lineHeight, fontFinder, width) {\n  const measure = new TextMeasure(xfaFont, margin, lineHeight, fontFinder);\n  if (typeof text === \"string\") {\n    measure.addString(text);\n  } else {\n    text[$pushGlyphs](measure);\n  }\n  return measure.compute(width);\n}\nfunction layoutNode(node, availableSpace) {\n  let height = null;\n  let width = null;\n  let isBroken = false;\n  if ((!node.w || !node.h) && node.value) {\n    let marginH = 0;\n    let marginV = 0;\n    if (node.margin) {\n      marginH = node.margin.leftInset + node.margin.rightInset;\n      marginV = node.margin.topInset + node.margin.bottomInset;\n    }\n    let lineHeight = null;\n    let margin = null;\n    if (node.para) {\n      margin = Object.create(null);\n      lineHeight = node.para.lineHeight === \"\" ? null : node.para.lineHeight;\n      margin.top = node.para.spaceAbove === \"\" ? 0 : node.para.spaceAbove;\n      margin.bottom = node.para.spaceBelow === \"\" ? 0 : node.para.spaceBelow;\n      margin.left = node.para.marginLeft === \"\" ? 0 : node.para.marginLeft;\n      margin.right = node.para.marginRight === \"\" ? 0 : node.para.marginRight;\n    }\n    let font = node.font;\n    if (!font) {\n      const root = node[$getTemplateRoot]();\n      let parent = node[$getParent]();\n      while (parent && parent !== root) {\n        if (parent.font) {\n          font = parent.font;\n          break;\n        }\n        parent = parent[$getParent]();\n      }\n    }\n    const maxWidth = (node.w || availableSpace.width) - marginH;\n    const fontFinder = node[$globalData].fontFinder;\n    if (node.value.exData && node.value.exData[$content] && node.value.exData.contentType === \"text/html\") {\n      const res = layoutText(node.value.exData[$content], font, margin, lineHeight, fontFinder, maxWidth);\n      width = res.width;\n      height = res.height;\n      isBroken = res.isBroken;\n    } else {\n      const text = node.value[$text]();\n      if (text) {\n        const res = layoutText(text, font, margin, lineHeight, fontFinder, maxWidth);\n        width = res.width;\n        height = res.height;\n        isBroken = res.isBroken;\n      }\n    }\n    if (width !== null && !node.w) {\n      width += marginH;\n    }\n    if (height !== null && !node.h) {\n      height += marginV;\n    }\n  }\n  return {\n    w: width,\n    h: height,\n    isBroken\n  };\n}\nfunction computeBbox(node, html, availableSpace) {\n  let bbox;\n  if (node.w !== \"\" && node.h !== \"\") {\n    bbox = [node.x, node.y, node.w, node.h];\n  } else {\n    if (!availableSpace) {\n      return null;\n    }\n    let width = node.w;\n    if (width === \"\") {\n      if (node.maxW === 0) {\n        const parent = node[$getSubformParent]();\n        width = parent.layout === \"position\" && parent.w !== \"\" ? 0 : node.minW;\n      } else {\n        width = Math.min(node.maxW, availableSpace.width);\n      }\n      html.attributes.style.width = measureToString(width);\n    }\n    let height = node.h;\n    if (height === \"\") {\n      if (node.maxH === 0) {\n        const parent = node[$getSubformParent]();\n        height = parent.layout === \"position\" && parent.h !== \"\" ? 0 : node.minH;\n      } else {\n        height = Math.min(node.maxH, availableSpace.height);\n      }\n      html.attributes.style.height = measureToString(height);\n    }\n    bbox = [node.x, node.y, width, height];\n  }\n  return bbox;\n}\nfunction fixDimensions(node) {\n  const parent = node[$getSubformParent]();\n  if (parent.layout?.includes(\"row\")) {\n    const extra = parent[$extra];\n    const colSpan = node.colSpan;\n    let width;\n    if (colSpan === -1) {\n      width = extra.columnWidths.slice(extra.currentColumn).reduce((a, w) => a + w, 0);\n    } else {\n      width = extra.columnWidths.slice(extra.currentColumn, extra.currentColumn + colSpan).reduce((a, w) => a + w, 0);\n    }\n    if (!isNaN(width)) {\n      node.w = width;\n    }\n  }\n  if (parent.layout && parent.layout !== \"position\") {\n    node.x = node.y = 0;\n  }\n  if (node.layout === \"table\") {\n    if (node.w === \"\" && Array.isArray(node.columnWidths)) {\n      node.w = node.columnWidths.reduce((a, x) => a + x, 0);\n    }\n  }\n}\nfunction layoutClass(node) {\n  switch (node.layout) {\n    case \"position\":\n      return \"xfaPosition\";\n    case \"lr-tb\":\n      return \"xfaLrTb\";\n    case \"rl-row\":\n      return \"xfaRlRow\";\n    case \"rl-tb\":\n      return \"xfaRlTb\";\n    case \"row\":\n      return \"xfaRow\";\n    case \"table\":\n      return \"xfaTable\";\n    case \"tb\":\n      return \"xfaTb\";\n    default:\n      return \"xfaPosition\";\n  }\n}\nfunction toStyle(node, ...names) {\n  const style = Object.create(null);\n  for (const name of names) {\n    const value = node[name];\n    if (value === null) {\n      continue;\n    }\n    if (converters.hasOwnProperty(name)) {\n      converters[name](node, style);\n      continue;\n    }\n    if (value instanceof XFAObject) {\n      const newStyle = value[$toStyle]();\n      if (newStyle) {\n        Object.assign(style, newStyle);\n      } else {\n        warn(`(DEBUG) - XFA - style for ${name} not implemented yet`);\n      }\n    }\n  }\n  return style;\n}\nfunction createWrapper(node, html) {\n  const {\n    attributes\n  } = html;\n  const {\n    style\n  } = attributes;\n  const wrapper = {\n    name: \"div\",\n    attributes: {\n      class: [\"xfaWrapper\"],\n      style: Object.create(null)\n    },\n    children: []\n  };\n  attributes.class.push(\"xfaWrapped\");\n  if (node.border) {\n    const {\n      widths,\n      insets\n    } = node.border[$extra];\n    let width, height;\n    let top = insets[0];\n    let left = insets[3];\n    const insetsH = insets[0] + insets[2];\n    const insetsW = insets[1] + insets[3];\n    switch (node.border.hand) {\n      case \"even\":\n        top -= widths[0] / 2;\n        left -= widths[3] / 2;\n        width = `calc(100% + ${(widths[1] + widths[3]) / 2 - insetsW}px)`;\n        height = `calc(100% + ${(widths[0] + widths[2]) / 2 - insetsH}px)`;\n        break;\n      case \"left\":\n        top -= widths[0];\n        left -= widths[3];\n        width = `calc(100% + ${widths[1] + widths[3] - insetsW}px)`;\n        height = `calc(100% + ${widths[0] + widths[2] - insetsH}px)`;\n        break;\n      case \"right\":\n        width = insetsW ? `calc(100% - ${insetsW}px)` : \"100%\";\n        height = insetsH ? `calc(100% - ${insetsH}px)` : \"100%\";\n        break;\n    }\n    const classNames = [\"xfaBorder\"];\n    if (isPrintOnly(node.border)) {\n      classNames.push(\"xfaPrintOnly\");\n    }\n    const border = {\n      name: \"div\",\n      attributes: {\n        class: classNames,\n        style: {\n          top: `${top}px`,\n          left: `${left}px`,\n          width,\n          height\n        }\n      },\n      children: []\n    };\n    for (const key of [\"border\", \"borderWidth\", \"borderColor\", \"borderRadius\", \"borderStyle\"]) {\n      if (style[key] !== undefined) {\n        border.attributes.style[key] = style[key];\n        delete style[key];\n      }\n    }\n    wrapper.children.push(border, html);\n  } else {\n    wrapper.children.push(html);\n  }\n  for (const key of [\"background\", \"backgroundClip\", \"top\", \"left\", \"width\", \"height\", \"minWidth\", \"minHeight\", \"maxWidth\", \"maxHeight\", \"transform\", \"transformOrigin\", \"visibility\"]) {\n    if (style[key] !== undefined) {\n      wrapper.attributes.style[key] = style[key];\n      delete style[key];\n    }\n  }\n  wrapper.attributes.style.position = style.position === \"absolute\" ? \"absolute\" : \"relative\";\n  delete style.position;\n  if (style.alignSelf) {\n    wrapper.attributes.style.alignSelf = style.alignSelf;\n    delete style.alignSelf;\n  }\n  return wrapper;\n}\nfunction fixTextIndent(styles) {\n  const indent = getMeasurement(styles.textIndent, \"0px\");\n  if (indent >= 0) {\n    return;\n  }\n  const align = styles.textAlign === \"right\" ? \"right\" : \"left\";\n  const name = \"padding\" + (align === \"left\" ? \"Left\" : \"Right\");\n  const padding = getMeasurement(styles[name], \"0px\");\n  styles[name] = `${padding - indent}px`;\n}\nfunction setAccess(node, classNames) {\n  switch (node.access) {\n    case \"nonInteractive\":\n      classNames.push(\"xfaNonInteractive\");\n      break;\n    case \"readOnly\":\n      classNames.push(\"xfaReadOnly\");\n      break;\n    case \"protected\":\n      classNames.push(\"xfaDisabled\");\n      break;\n  }\n}\nfunction isPrintOnly(node) {\n  return node.relevant.length > 0 && !node.relevant[0].excluded && node.relevant[0].viewname === \"print\";\n}\nfunction getCurrentPara(node) {\n  const stack = node[$getTemplateRoot]()[$extra].paraStack;\n  return stack.length ? stack.at(-1) : null;\n}\nfunction setPara(node, nodeStyle, value) {\n  if (value.attributes.class?.includes(\"xfaRich\")) {\n    if (nodeStyle) {\n      if (node.h === \"\") {\n        nodeStyle.height = \"auto\";\n      }\n      if (node.w === \"\") {\n        nodeStyle.width = \"auto\";\n      }\n    }\n    const para = getCurrentPara(node);\n    if (para) {\n      const valueStyle = value.attributes.style;\n      valueStyle.display = \"flex\";\n      valueStyle.flexDirection = \"column\";\n      switch (para.vAlign) {\n        case \"top\":\n          valueStyle.justifyContent = \"start\";\n          break;\n        case \"bottom\":\n          valueStyle.justifyContent = \"end\";\n          break;\n        case \"middle\":\n          valueStyle.justifyContent = \"center\";\n          break;\n      }\n      const paraStyle = para[$toStyle]();\n      for (const [key, val] of Object.entries(paraStyle)) {\n        if (!(key in valueStyle)) {\n          valueStyle[key] = val;\n        }\n      }\n    }\n  }\n}\nfunction setFontFamily(xfaFont, node, fontFinder, style) {\n  if (!fontFinder) {\n    delete style.fontFamily;\n    return;\n  }\n  const name = stripQuotes(xfaFont.typeface);\n  style.fontFamily = `\"${name}\"`;\n  const typeface = fontFinder.find(name);\n  if (typeface) {\n    const {\n      fontFamily\n    } = typeface.regular.cssFontInfo;\n    if (fontFamily !== name) {\n      style.fontFamily = `\"${fontFamily}\"`;\n    }\n    const para = getCurrentPara(node);\n    if (para && para.lineHeight !== \"\") {\n      return;\n    }\n    if (style.lineHeight) {\n      return;\n    }\n    const pdfFont = selectFont(xfaFont, typeface);\n    if (pdfFont) {\n      style.lineHeight = Math.max(1.2, pdfFont.lineHeight);\n    }\n  }\n}\nfunction fixURL(str) {\n  const absoluteUrl = createValidAbsoluteUrl(str, null, {\n    addDefaultProtocol: true,\n    tryConvertEncoding: true\n  });\n  return absoluteUrl ? absoluteUrl.href : null;\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/layout.js\n\n\nfunction createLine(node, children) {\n  return {\n    name: \"div\",\n    attributes: {\n      class: [node.layout === \"lr-tb\" ? \"xfaLr\" : \"xfaRl\"]\n    },\n    children\n  };\n}\nfunction flushHTML(node) {\n  if (!node[$extra]) {\n    return null;\n  }\n  const attributes = node[$extra].attributes;\n  const html = {\n    name: \"div\",\n    attributes,\n    children: node[$extra].children\n  };\n  if (node[$extra].failingNode) {\n    const htmlFromFailing = node[$extra].failingNode[$flushHTML]();\n    if (htmlFromFailing) {\n      if (node.layout.endsWith(\"-tb\")) {\n        html.children.push(createLine(node, [htmlFromFailing]));\n      } else {\n        html.children.push(htmlFromFailing);\n      }\n    }\n  }\n  if (html.children.length === 0) {\n    return null;\n  }\n  return html;\n}\nfunction addHTML(node, html, bbox) {\n  const extra = node[$extra];\n  const availableSpace = extra.availableSpace;\n  const [x, y, w, h] = bbox;\n  switch (node.layout) {\n    case \"position\":\n      {\n        extra.width = Math.max(extra.width, x + w);\n        extra.height = Math.max(extra.height, y + h);\n        extra.children.push(html);\n        break;\n      }\n    case \"lr-tb\":\n    case \"rl-tb\":\n      if (!extra.line || extra.attempt === 1) {\n        extra.line = createLine(node, []);\n        extra.children.push(extra.line);\n        extra.numberInLine = 0;\n      }\n      extra.numberInLine += 1;\n      extra.line.children.push(html);\n      if (extra.attempt === 0) {\n        extra.currentWidth += w;\n        extra.height = Math.max(extra.height, extra.prevHeight + h);\n      } else {\n        extra.currentWidth = w;\n        extra.prevHeight = extra.height;\n        extra.height += h;\n        extra.attempt = 0;\n      }\n      extra.width = Math.max(extra.width, extra.currentWidth);\n      break;\n    case \"rl-row\":\n    case \"row\":\n      {\n        extra.children.push(html);\n        extra.width += w;\n        extra.height = Math.max(extra.height, h);\n        const height = measureToString(extra.height);\n        for (const child of extra.children) {\n          child.attributes.style.height = height;\n        }\n        break;\n      }\n    case \"table\":\n      {\n        extra.width = Math.min(availableSpace.width, Math.max(extra.width, w));\n        extra.height += h;\n        extra.children.push(html);\n        break;\n      }\n    case \"tb\":\n      {\n        extra.width = Math.min(availableSpace.width, Math.max(extra.width, w));\n        extra.height += h;\n        extra.children.push(html);\n        break;\n      }\n  }\n}\nfunction getAvailableSpace(node) {\n  const availableSpace = node[$extra].availableSpace;\n  const marginV = node.margin ? node.margin.topInset + node.margin.bottomInset : 0;\n  const marginH = node.margin ? node.margin.leftInset + node.margin.rightInset : 0;\n  switch (node.layout) {\n    case \"lr-tb\":\n    case \"rl-tb\":\n      if (node[$extra].attempt === 0) {\n        return {\n          width: availableSpace.width - marginH - node[$extra].currentWidth,\n          height: availableSpace.height - marginV - node[$extra].prevHeight\n        };\n      }\n      return {\n        width: availableSpace.width - marginH,\n        height: availableSpace.height - marginV - node[$extra].height\n      };\n    case \"rl-row\":\n    case \"row\":\n      const width = node[$extra].columnWidths.slice(node[$extra].currentColumn).reduce((a, x) => a + x);\n      return {\n        width,\n        height: availableSpace.height - marginH\n      };\n    case \"table\":\n    case \"tb\":\n      return {\n        width: availableSpace.width - marginH,\n        height: availableSpace.height - marginV - node[$extra].height\n      };\n    case \"position\":\n    default:\n      return availableSpace;\n  }\n}\nfunction getTransformedBBox(node) {\n  let w = node.w === \"\" ? NaN : node.w;\n  let h = node.h === \"\" ? NaN : node.h;\n  let [centerX, centerY] = [0, 0];\n  switch (node.anchorType || \"\") {\n    case \"bottomCenter\":\n      [centerX, centerY] = [w / 2, h];\n      break;\n    case \"bottomLeft\":\n      [centerX, centerY] = [0, h];\n      break;\n    case \"bottomRight\":\n      [centerX, centerY] = [w, h];\n      break;\n    case \"middleCenter\":\n      [centerX, centerY] = [w / 2, h / 2];\n      break;\n    case \"middleLeft\":\n      [centerX, centerY] = [0, h / 2];\n      break;\n    case \"middleRight\":\n      [centerX, centerY] = [w, h / 2];\n      break;\n    case \"topCenter\":\n      [centerX, centerY] = [w / 2, 0];\n      break;\n    case \"topRight\":\n      [centerX, centerY] = [w, 0];\n      break;\n  }\n  let x, y;\n  switch (node.rotate || 0) {\n    case 0:\n      [x, y] = [-centerX, -centerY];\n      break;\n    case 90:\n      [x, y] = [-centerY, centerX];\n      [w, h] = [h, -w];\n      break;\n    case 180:\n      [x, y] = [centerX, centerY];\n      [w, h] = [-w, -h];\n      break;\n    case 270:\n      [x, y] = [centerY, -centerX];\n      [w, h] = [-h, w];\n      break;\n  }\n  return [node.x + x + Math.min(0, w), node.y + y + Math.min(0, h), Math.abs(w), Math.abs(h)];\n}\nfunction checkDimensions(node, space) {\n  if (node[$getTemplateRoot]()[$extra].firstUnsplittable === null) {\n    return true;\n  }\n  if (node.w === 0 || node.h === 0) {\n    return true;\n  }\n  const ERROR = 2;\n  const parent = node[$getSubformParent]();\n  const attempt = parent[$extra]?.attempt || 0;\n  const [, y, w, h] = getTransformedBBox(node);\n  switch (parent.layout) {\n    case \"lr-tb\":\n    case \"rl-tb\":\n      if (attempt === 0) {\n        if (!node[$getTemplateRoot]()[$extra].noLayoutFailure) {\n          if (node.h !== \"\" && Math.round(h - space.height) > ERROR) {\n            return false;\n          }\n          if (node.w !== \"\") {\n            if (Math.round(w - space.width) <= ERROR) {\n              return true;\n            }\n            if (parent[$extra].numberInLine === 0) {\n              return space.height > ERROR;\n            }\n            return false;\n          }\n          return space.width > ERROR;\n        }\n        if (node.w !== \"\") {\n          return Math.round(w - space.width) <= ERROR;\n        }\n        return space.width > ERROR;\n      }\n      if (node[$getTemplateRoot]()[$extra].noLayoutFailure) {\n        return true;\n      }\n      if (node.h !== \"\" && Math.round(h - space.height) > ERROR) {\n        return false;\n      }\n      if (node.w === \"\" || Math.round(w - space.width) <= ERROR) {\n        return space.height > ERROR;\n      }\n      if (parent[$isThereMoreWidth]()) {\n        return false;\n      }\n      return space.height > ERROR;\n    case \"table\":\n    case \"tb\":\n      if (node[$getTemplateRoot]()[$extra].noLayoutFailure) {\n        return true;\n      }\n      if (node.h !== \"\" && !node[$isSplittable]()) {\n        return Math.round(h - space.height) <= ERROR;\n      }\n      if (node.w === \"\" || Math.round(w - space.width) <= ERROR) {\n        return space.height > ERROR;\n      }\n      if (parent[$isThereMoreWidth]()) {\n        return false;\n      }\n      return space.height > ERROR;\n    case \"position\":\n      if (node[$getTemplateRoot]()[$extra].noLayoutFailure) {\n        return true;\n      }\n      if (node.h === \"\" || Math.round(h + y - space.height) <= ERROR) {\n        return true;\n      }\n      const area = node[$getTemplateRoot]()[$extra].currentContentArea;\n      return h + y > area.h;\n    case \"rl-row\":\n    case \"row\":\n      if (node[$getTemplateRoot]()[$extra].noLayoutFailure) {\n        return true;\n      }\n      if (node.h !== \"\") {\n        return Math.round(h - space.height) <= ERROR;\n      }\n      return true;\n    default:\n      return true;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/template.js\n\n\n\n\n\n\n\n\n\n\nconst TEMPLATE_NS_ID = NamespaceIds.template.id;\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\nconst MAX_ATTEMPTS_FOR_LRTB_LAYOUT = 2;\nconst MAX_EMPTY_PAGES = 3;\nconst DEFAULT_TAB_INDEX = 5000;\nconst HEADING_PATTERN = /^H(\\d+)$/;\nconst MIMES = new Set([\"image/gif\", \"image/jpeg\", \"image/jpg\", \"image/pjpeg\", \"image/png\", \"image/apng\", \"image/x-png\", \"image/bmp\", \"image/x-ms-bmp\", \"image/tiff\", \"image/tif\", \"application/octet-stream\"]);\nconst IMAGES_HEADERS = [[[0x42, 0x4d], \"image/bmp\"], [[0xff, 0xd8, 0xff], \"image/jpeg\"], [[0x49, 0x49, 0x2a, 0x00], \"image/tiff\"], [[0x4d, 0x4d, 0x00, 0x2a], \"image/tiff\"], [[0x47, 0x49, 0x46, 0x38, 0x39, 0x61], \"image/gif\"], [[0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a], \"image/png\"]];\nfunction getBorderDims(node) {\n  if (!node || !node.border) {\n    return {\n      w: 0,\n      h: 0\n    };\n  }\n  const borderExtra = node.border[$getExtra]();\n  if (!borderExtra) {\n    return {\n      w: 0,\n      h: 0\n    };\n  }\n  return {\n    w: borderExtra.widths[0] + borderExtra.widths[2] + borderExtra.insets[0] + borderExtra.insets[2],\n    h: borderExtra.widths[1] + borderExtra.widths[3] + borderExtra.insets[1] + borderExtra.insets[3]\n  };\n}\nfunction hasMargin(node) {\n  return node.margin && (node.margin.topInset || node.margin.rightInset || node.margin.bottomInset || node.margin.leftInset);\n}\nfunction _setValue(templateNode, value) {\n  if (!templateNode.value) {\n    const nodeValue = new Value({});\n    templateNode[$appendChild](nodeValue);\n    templateNode.value = nodeValue;\n  }\n  templateNode.value[$setValue](value);\n}\nfunction* getContainedChildren(node) {\n  for (const child of node[$getChildren]()) {\n    if (child instanceof SubformSet) {\n      yield* child[$getContainedChildren]();\n      continue;\n    }\n    yield child;\n  }\n}\nfunction isRequired(node) {\n  return node.validate?.nullTest === \"error\";\n}\nfunction setTabIndex(node) {\n  while (node) {\n    if (!node.traversal) {\n      node[$tabIndex] = node[$getParent]()[$tabIndex];\n      return;\n    }\n    if (node[$tabIndex]) {\n      return;\n    }\n    let next = null;\n    for (const child of node.traversal[$getChildren]()) {\n      if (child.operation === \"next\") {\n        next = child;\n        break;\n      }\n    }\n    if (!next || !next.ref) {\n      node[$tabIndex] = node[$getParent]()[$tabIndex];\n      return;\n    }\n    const root = node[$getTemplateRoot]();\n    node[$tabIndex] = ++root[$tabIndex];\n    const ref = root[$searchNode](next.ref, node);\n    if (!ref) {\n      return;\n    }\n    node = ref[0];\n  }\n}\nfunction applyAssist(obj, attributes) {\n  const assist = obj.assist;\n  if (assist) {\n    const assistTitle = assist[$toHTML]();\n    if (assistTitle) {\n      attributes.title = assistTitle;\n    }\n    const role = assist.role;\n    const match = role.match(HEADING_PATTERN);\n    if (match) {\n      const ariaRole = \"heading\";\n      const ariaLevel = match[1];\n      attributes.role = ariaRole;\n      attributes[\"aria-level\"] = ariaLevel;\n    }\n  }\n  if (obj.layout === \"table\") {\n    attributes.role = \"table\";\n  } else if (obj.layout === \"row\") {\n    attributes.role = \"row\";\n  } else {\n    const parent = obj[$getParent]();\n    if (parent.layout === \"row\") {\n      attributes.role = parent.assist?.role === \"TH\" ? \"columnheader\" : \"cell\";\n    }\n  }\n}\nfunction ariaLabel(obj) {\n  if (!obj.assist) {\n    return null;\n  }\n  const assist = obj.assist;\n  if (assist.speak && assist.speak[$content] !== \"\") {\n    return assist.speak[$content];\n  }\n  if (assist.toolTip) {\n    return assist.toolTip[$content];\n  }\n  return null;\n}\nfunction valueToHtml(value) {\n  return HTMLResult.success({\n    name: \"div\",\n    attributes: {\n      class: [\"xfaRich\"],\n      style: Object.create(null)\n    },\n    children: [{\n      name: \"span\",\n      attributes: {\n        style: Object.create(null)\n      },\n      value\n    }]\n  });\n}\nfunction setFirstUnsplittable(node) {\n  const root = node[$getTemplateRoot]();\n  if (root[$extra].firstUnsplittable === null) {\n    root[$extra].firstUnsplittable = node;\n    root[$extra].noLayoutFailure = true;\n  }\n}\nfunction unsetFirstUnsplittable(node) {\n  const root = node[$getTemplateRoot]();\n  if (root[$extra].firstUnsplittable === node) {\n    root[$extra].noLayoutFailure = false;\n  }\n}\nfunction handleBreak(node) {\n  if (node[$extra]) {\n    return false;\n  }\n  node[$extra] = Object.create(null);\n  if (node.targetType === \"auto\") {\n    return false;\n  }\n  const root = node[$getTemplateRoot]();\n  let target = null;\n  if (node.target) {\n    target = root[$searchNode](node.target, node[$getParent]());\n    if (!target) {\n      return false;\n    }\n    target = target[0];\n  }\n  const {\n    currentPageArea,\n    currentContentArea\n  } = root[$extra];\n  if (node.targetType === \"pageArea\") {\n    if (!(target instanceof PageArea)) {\n      target = null;\n    }\n    if (node.startNew) {\n      node[$extra].target = target || currentPageArea;\n      return true;\n    } else if (target && target !== currentPageArea) {\n      node[$extra].target = target;\n      return true;\n    }\n    return false;\n  }\n  if (!(target instanceof ContentArea)) {\n    target = null;\n  }\n  const pageArea = target && target[$getParent]();\n  let index;\n  let nextPageArea = pageArea;\n  if (node.startNew) {\n    if (target) {\n      const contentAreas = pageArea.contentArea.children;\n      const indexForCurrent = contentAreas.indexOf(currentContentArea);\n      const indexForTarget = contentAreas.indexOf(target);\n      if (indexForCurrent !== -1 && indexForCurrent < indexForTarget) {\n        nextPageArea = null;\n      }\n      index = indexForTarget - 1;\n    } else {\n      index = currentPageArea.contentArea.children.indexOf(currentContentArea);\n    }\n  } else if (target && target !== currentContentArea) {\n    const contentAreas = pageArea.contentArea.children;\n    index = contentAreas.indexOf(target) - 1;\n    nextPageArea = pageArea === currentPageArea ? null : pageArea;\n  } else {\n    return false;\n  }\n  node[$extra].target = nextPageArea;\n  node[$extra].index = index;\n  return true;\n}\nfunction handleOverflow(node, extraNode, space) {\n  const root = node[$getTemplateRoot]();\n  const saved = root[$extra].noLayoutFailure;\n  const savedMethod = extraNode[$getSubformParent];\n  extraNode[$getSubformParent] = () => node;\n  root[$extra].noLayoutFailure = true;\n  const res = extraNode[$toHTML](space);\n  node[$addHTML](res.html, res.bbox);\n  root[$extra].noLayoutFailure = saved;\n  extraNode[$getSubformParent] = savedMethod;\n}\nclass AppearanceFilter extends StringObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"appearanceFilter\");\n    this.id = attributes.id || \"\";\n    this.type = getStringOption(attributes.type, [\"optional\", \"required\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass Arc extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"arc\", true);\n    this.circular = getInteger({\n      data: attributes.circular,\n      defaultValue: 0,\n      validate: x => x === 1\n    });\n    this.hand = getStringOption(attributes.hand, [\"even\", \"left\", \"right\"]);\n    this.id = attributes.id || \"\";\n    this.startAngle = getFloat({\n      data: attributes.startAngle,\n      defaultValue: 0,\n      validate: x => true\n    });\n    this.sweepAngle = getFloat({\n      data: attributes.sweepAngle,\n      defaultValue: 360,\n      validate: x => true\n    });\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.edge = null;\n    this.fill = null;\n  }\n  [$toHTML]() {\n    const edge = this.edge || new Edge({});\n    const edgeStyle = edge[$toStyle]();\n    const style = Object.create(null);\n    if (this.fill?.presence === \"visible\") {\n      Object.assign(style, this.fill[$toStyle]());\n    } else {\n      style.fill = \"transparent\";\n    }\n    style.strokeWidth = measureToString(edge.presence === \"visible\" ? edge.thickness : 0);\n    style.stroke = edgeStyle.color;\n    let arc;\n    const attributes = {\n      xmlns: SVG_NS,\n      style: {\n        width: \"100%\",\n        height: \"100%\",\n        overflow: \"visible\"\n      }\n    };\n    if (this.sweepAngle === 360) {\n      arc = {\n        name: \"ellipse\",\n        attributes: {\n          xmlns: SVG_NS,\n          cx: \"50%\",\n          cy: \"50%\",\n          rx: \"50%\",\n          ry: \"50%\",\n          style\n        }\n      };\n    } else {\n      const startAngle = this.startAngle * Math.PI / 180;\n      const sweepAngle = this.sweepAngle * Math.PI / 180;\n      const largeArc = this.sweepAngle > 180 ? 1 : 0;\n      const [x1, y1, x2, y2] = [50 * (1 + Math.cos(startAngle)), 50 * (1 - Math.sin(startAngle)), 50 * (1 + Math.cos(startAngle + sweepAngle)), 50 * (1 - Math.sin(startAngle + sweepAngle))];\n      arc = {\n        name: \"path\",\n        attributes: {\n          xmlns: SVG_NS,\n          d: `M ${x1} ${y1} A 50 50 0 ${largeArc} 0 ${x2} ${y2}`,\n          vectorEffect: \"non-scaling-stroke\",\n          style\n        }\n      };\n      Object.assign(attributes, {\n        viewBox: \"0 0 100 100\",\n        preserveAspectRatio: \"none\"\n      });\n    }\n    const svg = {\n      name: \"svg\",\n      children: [arc],\n      attributes\n    };\n    const parent = this[$getParent]()[$getParent]();\n    if (hasMargin(parent)) {\n      return HTMLResult.success({\n        name: \"div\",\n        attributes: {\n          style: {\n            display: \"inline\",\n            width: \"100%\",\n            height: \"100%\"\n          }\n        },\n        children: [svg]\n      });\n    }\n    svg.attributes.style.position = \"absolute\";\n    return HTMLResult.success(svg);\n  }\n}\nclass Area extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"area\", true);\n    this.colSpan = getInteger({\n      data: attributes.colSpan,\n      defaultValue: 1,\n      validate: n => n >= 1 || n === -1\n    });\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.relevant = getRelevant(attributes.relevant);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.x = getMeasurement(attributes.x, \"0pt\");\n    this.y = getMeasurement(attributes.y, \"0pt\");\n    this.desc = null;\n    this.extras = null;\n    this.area = new XFAObjectArray();\n    this.draw = new XFAObjectArray();\n    this.exObject = new XFAObjectArray();\n    this.exclGroup = new XFAObjectArray();\n    this.field = new XFAObjectArray();\n    this.subform = new XFAObjectArray();\n    this.subformSet = new XFAObjectArray();\n  }\n  *[$getContainedChildren]() {\n    yield* getContainedChildren(this);\n  }\n  [$isTransparent]() {\n    return true;\n  }\n  [$isBindable]() {\n    return true;\n  }\n  [$addHTML](html, bbox) {\n    const [x, y, w, h] = bbox;\n    this[$extra].width = Math.max(this[$extra].width, x + w);\n    this[$extra].height = Math.max(this[$extra].height, y + h);\n    this[$extra].children.push(html);\n  }\n  [$getAvailableSpace]() {\n    return this[$extra].availableSpace;\n  }\n  [$toHTML](availableSpace) {\n    const style = toStyle(this, \"position\");\n    const attributes = {\n      style,\n      id: this[$uid],\n      class: [\"xfaArea\"]\n    };\n    if (isPrintOnly(this)) {\n      attributes.class.push(\"xfaPrintOnly\");\n    }\n    if (this.name) {\n      attributes.xfaName = this.name;\n    }\n    const children = [];\n    this[$extra] = {\n      children,\n      width: 0,\n      height: 0,\n      availableSpace\n    };\n    const result = this[$childrenToHTML]({\n      filter: new Set([\"area\", \"draw\", \"field\", \"exclGroup\", \"subform\", \"subformSet\"]),\n      include: true\n    });\n    if (!result.success) {\n      if (result.isBreak()) {\n        return result;\n      }\n      delete this[$extra];\n      return HTMLResult.FAILURE;\n    }\n    style.width = measureToString(this[$extra].width);\n    style.height = measureToString(this[$extra].height);\n    const html = {\n      name: \"div\",\n      attributes,\n      children\n    };\n    const bbox = [this.x, this.y, this[$extra].width, this[$extra].height];\n    delete this[$extra];\n    return HTMLResult.success(html, bbox);\n  }\n}\nclass Assist extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"assist\", true);\n    this.id = attributes.id || \"\";\n    this.role = attributes.role || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.speak = null;\n    this.toolTip = null;\n  }\n  [$toHTML]() {\n    return this.toolTip?.[$content] || null;\n  }\n}\nclass Barcode extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"barcode\", true);\n    this.charEncoding = getKeyword({\n      data: attributes.charEncoding ? attributes.charEncoding.toLowerCase() : \"\",\n      defaultValue: \"\",\n      validate: k => [\"utf-8\", \"big-five\", \"fontspecific\", \"gbk\", \"gb-18030\", \"gb-2312\", \"ksc-5601\", \"none\", \"shift-jis\", \"ucs-2\", \"utf-16\"].includes(k) || k.match(/iso-8859-\\d{2}/)\n    });\n    this.checksum = getStringOption(attributes.checksum, [\"none\", \"1mod10\", \"1mod10_1mod11\", \"2mod10\", \"auto\"]);\n    this.dataColumnCount = getInteger({\n      data: attributes.dataColumnCount,\n      defaultValue: -1,\n      validate: x => x >= 0\n    });\n    this.dataLength = getInteger({\n      data: attributes.dataLength,\n      defaultValue: -1,\n      validate: x => x >= 0\n    });\n    this.dataPrep = getStringOption(attributes.dataPrep, [\"none\", \"flateCompress\"]);\n    this.dataRowCount = getInteger({\n      data: attributes.dataRowCount,\n      defaultValue: -1,\n      validate: x => x >= 0\n    });\n    this.endChar = attributes.endChar || \"\";\n    this.errorCorrectionLevel = getInteger({\n      data: attributes.errorCorrectionLevel,\n      defaultValue: -1,\n      validate: x => x >= 0 && x <= 8\n    });\n    this.id = attributes.id || \"\";\n    this.moduleHeight = getMeasurement(attributes.moduleHeight, \"5mm\");\n    this.moduleWidth = getMeasurement(attributes.moduleWidth, \"0.25mm\");\n    this.printCheckDigit = getInteger({\n      data: attributes.printCheckDigit,\n      defaultValue: 0,\n      validate: x => x === 1\n    });\n    this.rowColumnRatio = getRatio(attributes.rowColumnRatio);\n    this.startChar = attributes.startChar || \"\";\n    this.textLocation = getStringOption(attributes.textLocation, [\"below\", \"above\", \"aboveEmbedded\", \"belowEmbedded\", \"none\"]);\n    this.truncate = getInteger({\n      data: attributes.truncate,\n      defaultValue: 0,\n      validate: x => x === 1\n    });\n    this.type = getStringOption(attributes.type ? attributes.type.toLowerCase() : \"\", [\"aztec\", \"codabar\", \"code2of5industrial\", \"code2of5interleaved\", \"code2of5matrix\", \"code2of5standard\", \"code3of9\", \"code3of9extended\", \"code11\", \"code49\", \"code93\", \"code128\", \"code128a\", \"code128b\", \"code128c\", \"code128sscc\", \"datamatrix\", \"ean8\", \"ean8add2\", \"ean8add5\", \"ean13\", \"ean13add2\", \"ean13add5\", \"ean13pwcd\", \"fim\", \"logmars\", \"maxicode\", \"msi\", \"pdf417\", \"pdf417macro\", \"plessey\", \"postauscust2\", \"postauscust3\", \"postausreplypaid\", \"postausstandard\", \"postukrm4scc\", \"postusdpbc\", \"postusimb\", \"postusstandard\", \"postus5zip\", \"qrcode\", \"rfid\", \"rss14\", \"rss14expanded\", \"rss14limited\", \"rss14stacked\", \"rss14stackedomni\", \"rss14truncated\", \"telepen\", \"ucc128\", \"ucc128random\", \"ucc128sscc\", \"upca\", \"upcaadd2\", \"upcaadd5\", \"upcapwcd\", \"upce\", \"upceadd2\", \"upceadd5\", \"upcean2\", \"upcean5\", \"upsmaxicode\"]);\n    this.upsMode = getStringOption(attributes.upsMode, [\"usCarrier\", \"internationalCarrier\", \"secureSymbol\", \"standardSymbol\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.wideNarrowRatio = getRatio(attributes.wideNarrowRatio);\n    this.encrypt = null;\n    this.extras = null;\n  }\n}\nclass Bind extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"bind\", true);\n    this.match = getStringOption(attributes.match, [\"once\", \"dataRef\", \"global\", \"none\"]);\n    this.ref = attributes.ref || \"\";\n    this.picture = null;\n  }\n}\nclass BindItems extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"bindItems\");\n    this.connection = attributes.connection || \"\";\n    this.labelRef = attributes.labelRef || \"\";\n    this.ref = attributes.ref || \"\";\n    this.valueRef = attributes.valueRef || \"\";\n  }\n}\nclass Bookend extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"bookend\");\n    this.id = attributes.id || \"\";\n    this.leader = attributes.leader || \"\";\n    this.trailer = attributes.trailer || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass BooleanElement extends Option01 {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"boolean\");\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n  [$toHTML](availableSpace) {\n    return valueToHtml(this[$content] === 1 ? \"1\" : \"0\");\n  }\n}\nclass Border extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"border\", true);\n    this.break = getStringOption(attributes.break, [\"close\", \"open\"]);\n    this.hand = getStringOption(attributes.hand, [\"even\", \"left\", \"right\"]);\n    this.id = attributes.id || \"\";\n    this.presence = getStringOption(attributes.presence, [\"visible\", \"hidden\", \"inactive\", \"invisible\"]);\n    this.relevant = getRelevant(attributes.relevant);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.corner = new XFAObjectArray(4);\n    this.edge = new XFAObjectArray(4);\n    this.extras = null;\n    this.fill = null;\n    this.margin = null;\n  }\n  [$getExtra]() {\n    if (!this[$extra]) {\n      const edges = this.edge.children.slice();\n      if (edges.length < 4) {\n        const defaultEdge = edges.at(-1) || new Edge({});\n        for (let i = edges.length; i < 4; i++) {\n          edges.push(defaultEdge);\n        }\n      }\n      const widths = edges.map(edge => edge.thickness);\n      const insets = [0, 0, 0, 0];\n      if (this.margin) {\n        insets[0] = this.margin.topInset;\n        insets[1] = this.margin.rightInset;\n        insets[2] = this.margin.bottomInset;\n        insets[3] = this.margin.leftInset;\n      }\n      this[$extra] = {\n        widths,\n        insets,\n        edges\n      };\n    }\n    return this[$extra];\n  }\n  [$toStyle]() {\n    const {\n      edges\n    } = this[$getExtra]();\n    const edgeStyles = edges.map(node => {\n      const style = node[$toStyle]();\n      style.color ||= \"#000000\";\n      return style;\n    });\n    const style = Object.create(null);\n    if (this.margin) {\n      Object.assign(style, this.margin[$toStyle]());\n    }\n    if (this.fill?.presence === \"visible\") {\n      Object.assign(style, this.fill[$toStyle]());\n    }\n    if (this.corner.children.some(node => node.radius !== 0)) {\n      const cornerStyles = this.corner.children.map(node => node[$toStyle]());\n      if (cornerStyles.length === 2 || cornerStyles.length === 3) {\n        const last = cornerStyles.at(-1);\n        for (let i = cornerStyles.length; i < 4; i++) {\n          cornerStyles.push(last);\n        }\n      }\n      style.borderRadius = cornerStyles.map(s => s.radius).join(\" \");\n    }\n    switch (this.presence) {\n      case \"invisible\":\n      case \"hidden\":\n        style.borderStyle = \"\";\n        break;\n      case \"inactive\":\n        style.borderStyle = \"none\";\n        break;\n      default:\n        style.borderStyle = edgeStyles.map(s => s.style).join(\" \");\n        break;\n    }\n    style.borderWidth = edgeStyles.map(s => s.width).join(\" \");\n    style.borderColor = edgeStyles.map(s => s.color).join(\" \");\n    return style;\n  }\n}\nclass Break extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"break\", true);\n    this.after = getStringOption(attributes.after, [\"auto\", \"contentArea\", \"pageArea\", \"pageEven\", \"pageOdd\"]);\n    this.afterTarget = attributes.afterTarget || \"\";\n    this.before = getStringOption(attributes.before, [\"auto\", \"contentArea\", \"pageArea\", \"pageEven\", \"pageOdd\"]);\n    this.beforeTarget = attributes.beforeTarget || \"\";\n    this.bookendLeader = attributes.bookendLeader || \"\";\n    this.bookendTrailer = attributes.bookendTrailer || \"\";\n    this.id = attributes.id || \"\";\n    this.overflowLeader = attributes.overflowLeader || \"\";\n    this.overflowTarget = attributes.overflowTarget || \"\";\n    this.overflowTrailer = attributes.overflowTrailer || \"\";\n    this.startNew = getInteger({\n      data: attributes.startNew,\n      defaultValue: 0,\n      validate: x => x === 1\n    });\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.extras = null;\n  }\n}\nclass BreakAfter extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"breakAfter\", true);\n    this.id = attributes.id || \"\";\n    this.leader = attributes.leader || \"\";\n    this.startNew = getInteger({\n      data: attributes.startNew,\n      defaultValue: 0,\n      validate: x => x === 1\n    });\n    this.target = attributes.target || \"\";\n    this.targetType = getStringOption(attributes.targetType, [\"auto\", \"contentArea\", \"pageArea\"]);\n    this.trailer = attributes.trailer || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.script = null;\n  }\n}\nclass BreakBefore extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"breakBefore\", true);\n    this.id = attributes.id || \"\";\n    this.leader = attributes.leader || \"\";\n    this.startNew = getInteger({\n      data: attributes.startNew,\n      defaultValue: 0,\n      validate: x => x === 1\n    });\n    this.target = attributes.target || \"\";\n    this.targetType = getStringOption(attributes.targetType, [\"auto\", \"contentArea\", \"pageArea\"]);\n    this.trailer = attributes.trailer || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.script = null;\n  }\n  [$toHTML](availableSpace) {\n    this[$extra] = {};\n    return HTMLResult.FAILURE;\n  }\n}\nclass Button extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"button\", true);\n    this.highlight = getStringOption(attributes.highlight, [\"inverted\", \"none\", \"outline\", \"push\"]);\n    this.id = attributes.id || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.extras = null;\n  }\n  [$toHTML](availableSpace) {\n    const parent = this[$getParent]();\n    const grandpa = parent[$getParent]();\n    const htmlButton = {\n      name: \"button\",\n      attributes: {\n        id: this[$uid],\n        class: [\"xfaButton\"],\n        style: {}\n      },\n      children: []\n    };\n    for (const event of grandpa.event.children) {\n      if (event.activity !== \"click\" || !event.script) {\n        continue;\n      }\n      const jsURL = recoverJsURL(event.script[$content]);\n      if (!jsURL) {\n        continue;\n      }\n      const href = fixURL(jsURL.url);\n      if (!href) {\n        continue;\n      }\n      htmlButton.children.push({\n        name: \"a\",\n        attributes: {\n          id: \"link\" + this[$uid],\n          href,\n          newWindow: jsURL.newWindow,\n          class: [\"xfaLink\"],\n          style: {}\n        },\n        children: []\n      });\n    }\n    return HTMLResult.success(htmlButton);\n  }\n}\nclass Calculate extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"calculate\", true);\n    this.id = attributes.id || \"\";\n    this.override = getStringOption(attributes.override, [\"disabled\", \"error\", \"ignore\", \"warning\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.extras = null;\n    this.message = null;\n    this.script = null;\n  }\n}\nclass Caption extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"caption\", true);\n    this.id = attributes.id || \"\";\n    this.placement = getStringOption(attributes.placement, [\"left\", \"bottom\", \"inline\", \"right\", \"top\"]);\n    this.presence = getStringOption(attributes.presence, [\"visible\", \"hidden\", \"inactive\", \"invisible\"]);\n    this.reserve = Math.ceil(getMeasurement(attributes.reserve));\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.extras = null;\n    this.font = null;\n    this.margin = null;\n    this.para = null;\n    this.value = null;\n  }\n  [$setValue](value) {\n    _setValue(this, value);\n  }\n  [$getExtra](availableSpace) {\n    if (!this[$extra]) {\n      let {\n        width,\n        height\n      } = availableSpace;\n      switch (this.placement) {\n        case \"left\":\n        case \"right\":\n        case \"inline\":\n          width = this.reserve <= 0 ? width : this.reserve;\n          break;\n        case \"top\":\n        case \"bottom\":\n          height = this.reserve <= 0 ? height : this.reserve;\n          break;\n      }\n      this[$extra] = layoutNode(this, {\n        width,\n        height\n      });\n    }\n    return this[$extra];\n  }\n  [$toHTML](availableSpace) {\n    if (!this.value) {\n      return HTMLResult.EMPTY;\n    }\n    this[$pushPara]();\n    const value = this.value[$toHTML](availableSpace).html;\n    if (!value) {\n      this[$popPara]();\n      return HTMLResult.EMPTY;\n    }\n    const savedReserve = this.reserve;\n    if (this.reserve <= 0) {\n      const {\n        w,\n        h\n      } = this[$getExtra](availableSpace);\n      switch (this.placement) {\n        case \"left\":\n        case \"right\":\n        case \"inline\":\n          this.reserve = w;\n          break;\n        case \"top\":\n        case \"bottom\":\n          this.reserve = h;\n          break;\n      }\n    }\n    const children = [];\n    if (typeof value === \"string\") {\n      children.push({\n        name: \"#text\",\n        value\n      });\n    } else {\n      children.push(value);\n    }\n    const style = toStyle(this, \"font\", \"margin\", \"visibility\");\n    switch (this.placement) {\n      case \"left\":\n      case \"right\":\n        if (this.reserve > 0) {\n          style.width = measureToString(this.reserve);\n        }\n        break;\n      case \"top\":\n      case \"bottom\":\n        if (this.reserve > 0) {\n          style.height = measureToString(this.reserve);\n        }\n        break;\n    }\n    setPara(this, null, value);\n    this[$popPara]();\n    this.reserve = savedReserve;\n    return HTMLResult.success({\n      name: \"div\",\n      attributes: {\n        style,\n        class: [\"xfaCaption\"]\n      },\n      children\n    });\n  }\n}\nclass Certificate extends StringObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"certificate\");\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass Certificates extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"certificates\", true);\n    this.credentialServerPolicy = getStringOption(attributes.credentialServerPolicy, [\"optional\", \"required\"]);\n    this.id = attributes.id || \"\";\n    this.url = attributes.url || \"\";\n    this.urlPolicy = attributes.urlPolicy || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.encryption = null;\n    this.issuers = null;\n    this.keyUsage = null;\n    this.oids = null;\n    this.signing = null;\n    this.subjectDNs = null;\n  }\n}\nclass CheckButton extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"checkButton\", true);\n    this.id = attributes.id || \"\";\n    this.mark = getStringOption(attributes.mark, [\"default\", \"check\", \"circle\", \"cross\", \"diamond\", \"square\", \"star\"]);\n    this.shape = getStringOption(attributes.shape, [\"square\", \"round\"]);\n    this.size = getMeasurement(attributes.size, \"10pt\");\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.border = null;\n    this.extras = null;\n    this.margin = null;\n  }\n  [$toHTML](availableSpace) {\n    const style = toStyle(\"margin\");\n    const size = measureToString(this.size);\n    style.width = style.height = size;\n    let type;\n    let className;\n    let groupId;\n    const field = this[$getParent]()[$getParent]();\n    const items = field.items.children.length && field.items.children[0][$toHTML]().html || [];\n    const exportedValue = {\n      on: (items[0] !== undefined ? items[0] : \"on\").toString(),\n      off: (items[1] !== undefined ? items[1] : \"off\").toString()\n    };\n    const value = field.value?.[$text]() || \"off\";\n    const checked = value === exportedValue.on || undefined;\n    const container = field[$getSubformParent]();\n    const fieldId = field[$uid];\n    let dataId;\n    if (container instanceof ExclGroup) {\n      groupId = container[$uid];\n      type = \"radio\";\n      className = \"xfaRadio\";\n      dataId = container[$data]?.[$uid] || container[$uid];\n    } else {\n      type = \"checkbox\";\n      className = \"xfaCheckbox\";\n      dataId = field[$data]?.[$uid] || field[$uid];\n    }\n    const input = {\n      name: \"input\",\n      attributes: {\n        class: [className],\n        style,\n        fieldId,\n        dataId,\n        type,\n        checked,\n        xfaOn: exportedValue.on,\n        xfaOff: exportedValue.off,\n        \"aria-label\": ariaLabel(field),\n        \"aria-required\": false\n      }\n    };\n    if (groupId) {\n      input.attributes.name = groupId;\n    }\n    if (isRequired(field)) {\n      input.attributes[\"aria-required\"] = true;\n      input.attributes.required = true;\n    }\n    return HTMLResult.success({\n      name: \"label\",\n      attributes: {\n        class: [\"xfaLabel\"]\n      },\n      children: [input]\n    });\n  }\n}\nclass ChoiceList extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"choiceList\", true);\n    this.commitOn = getStringOption(attributes.commitOn, [\"select\", \"exit\"]);\n    this.id = attributes.id || \"\";\n    this.open = getStringOption(attributes.open, [\"userControl\", \"always\", \"multiSelect\", \"onEntry\"]);\n    this.textEntry = getInteger({\n      data: attributes.textEntry,\n      defaultValue: 0,\n      validate: x => x === 1\n    });\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.border = null;\n    this.extras = null;\n    this.margin = null;\n  }\n  [$toHTML](availableSpace) {\n    const style = toStyle(this, \"border\", \"margin\");\n    const ui = this[$getParent]();\n    const field = ui[$getParent]();\n    const fontSize = field.font?.size || 10;\n    const optionStyle = {\n      fontSize: `calc(${fontSize}px * var(--scale-factor))`\n    };\n    const children = [];\n    if (field.items.children.length > 0) {\n      const items = field.items;\n      let displayedIndex = 0;\n      let saveIndex = 0;\n      if (items.children.length === 2) {\n        displayedIndex = items.children[0].save;\n        saveIndex = 1 - displayedIndex;\n      }\n      const displayed = items.children[displayedIndex][$toHTML]().html;\n      const values = items.children[saveIndex][$toHTML]().html;\n      let selected = false;\n      const value = field.value?.[$text]() || \"\";\n      for (let i = 0, ii = displayed.length; i < ii; i++) {\n        const option = {\n          name: \"option\",\n          attributes: {\n            value: values[i] || displayed[i],\n            style: optionStyle\n          },\n          value: displayed[i]\n        };\n        if (values[i] === value) {\n          option.attributes.selected = selected = true;\n        }\n        children.push(option);\n      }\n      if (!selected) {\n        children.splice(0, 0, {\n          name: \"option\",\n          attributes: {\n            hidden: true,\n            selected: true\n          },\n          value: \" \"\n        });\n      }\n    }\n    const selectAttributes = {\n      class: [\"xfaSelect\"],\n      fieldId: field[$uid],\n      dataId: field[$data]?.[$uid] || field[$uid],\n      style,\n      \"aria-label\": ariaLabel(field),\n      \"aria-required\": false\n    };\n    if (isRequired(field)) {\n      selectAttributes[\"aria-required\"] = true;\n      selectAttributes.required = true;\n    }\n    if (this.open === \"multiSelect\") {\n      selectAttributes.multiple = true;\n    }\n    return HTMLResult.success({\n      name: \"label\",\n      attributes: {\n        class: [\"xfaLabel\"]\n      },\n      children: [{\n        name: \"select\",\n        children,\n        attributes: selectAttributes\n      }]\n    });\n  }\n}\nclass Color extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"color\", true);\n    this.cSpace = getStringOption(attributes.cSpace, [\"SRGB\"]);\n    this.id = attributes.id || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.value = attributes.value ? getColor(attributes.value) : \"\";\n    this.extras = null;\n  }\n  [$hasSettableValue]() {\n    return false;\n  }\n  [$toStyle]() {\n    return this.value ? Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;\n  }\n}\nclass Comb extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"comb\");\n    this.id = attributes.id || \"\";\n    this.numberOfCells = getInteger({\n      data: attributes.numberOfCells,\n      defaultValue: 0,\n      validate: x => x >= 0\n    });\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass Connect extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"connect\", true);\n    this.connection = attributes.connection || \"\";\n    this.id = attributes.id || \"\";\n    this.ref = attributes.ref || \"\";\n    this.usage = getStringOption(attributes.usage, [\"exportAndImport\", \"exportOnly\", \"importOnly\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.picture = null;\n  }\n}\nclass ContentArea extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"contentArea\", true);\n    this.h = getMeasurement(attributes.h);\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.relevant = getRelevant(attributes.relevant);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.w = getMeasurement(attributes.w);\n    this.x = getMeasurement(attributes.x, \"0pt\");\n    this.y = getMeasurement(attributes.y, \"0pt\");\n    this.desc = null;\n    this.extras = null;\n  }\n  [$toHTML](availableSpace) {\n    const left = measureToString(this.x);\n    const top = measureToString(this.y);\n    const style = {\n      left,\n      top,\n      width: measureToString(this.w),\n      height: measureToString(this.h)\n    };\n    const classNames = [\"xfaContentarea\"];\n    if (isPrintOnly(this)) {\n      classNames.push(\"xfaPrintOnly\");\n    }\n    return HTMLResult.success({\n      name: \"div\",\n      children: [],\n      attributes: {\n        style,\n        class: classNames,\n        id: this[$uid]\n      }\n    });\n  }\n}\nclass Corner extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"corner\", true);\n    this.id = attributes.id || \"\";\n    this.inverted = getInteger({\n      data: attributes.inverted,\n      defaultValue: 0,\n      validate: x => x === 1\n    });\n    this.join = getStringOption(attributes.join, [\"square\", \"round\"]);\n    this.presence = getStringOption(attributes.presence, [\"visible\", \"hidden\", \"inactive\", \"invisible\"]);\n    this.radius = getMeasurement(attributes.radius);\n    this.stroke = getStringOption(attributes.stroke, [\"solid\", \"dashDot\", \"dashDotDot\", \"dashed\", \"dotted\", \"embossed\", \"etched\", \"lowered\", \"raised\"]);\n    this.thickness = getMeasurement(attributes.thickness, \"0.5pt\");\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.color = null;\n    this.extras = null;\n  }\n  [$toStyle]() {\n    const style = toStyle(this, \"visibility\");\n    style.radius = measureToString(this.join === \"square\" ? 0 : this.radius);\n    return style;\n  }\n}\nclass DateElement extends ContentObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"date\");\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n  [$finalize]() {\n    const date = this[$content].trim();\n    this[$content] = date ? new Date(date) : null;\n  }\n  [$toHTML](availableSpace) {\n    return valueToHtml(this[$content] ? this[$content].toString() : \"\");\n  }\n}\nclass DateTime extends ContentObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"dateTime\");\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n  [$finalize]() {\n    const date = this[$content].trim();\n    this[$content] = date ? new Date(date) : null;\n  }\n  [$toHTML](availableSpace) {\n    return valueToHtml(this[$content] ? this[$content].toString() : \"\");\n  }\n}\nclass DateTimeEdit extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"dateTimeEdit\", true);\n    this.hScrollPolicy = getStringOption(attributes.hScrollPolicy, [\"auto\", \"off\", \"on\"]);\n    this.id = attributes.id || \"\";\n    this.picker = getStringOption(attributes.picker, [\"host\", \"none\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.border = null;\n    this.comb = null;\n    this.extras = null;\n    this.margin = null;\n  }\n  [$toHTML](availableSpace) {\n    const style = toStyle(this, \"border\", \"font\", \"margin\");\n    const field = this[$getParent]()[$getParent]();\n    const html = {\n      name: \"input\",\n      attributes: {\n        type: \"text\",\n        fieldId: field[$uid],\n        dataId: field[$data]?.[$uid] || field[$uid],\n        class: [\"xfaTextfield\"],\n        style,\n        \"aria-label\": ariaLabel(field),\n        \"aria-required\": false\n      }\n    };\n    if (isRequired(field)) {\n      html.attributes[\"aria-required\"] = true;\n      html.attributes.required = true;\n    }\n    return HTMLResult.success({\n      name: \"label\",\n      attributes: {\n        class: [\"xfaLabel\"]\n      },\n      children: [html]\n    });\n  }\n}\nclass Decimal extends ContentObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"decimal\");\n    this.fracDigits = getInteger({\n      data: attributes.fracDigits,\n      defaultValue: 2,\n      validate: x => true\n    });\n    this.id = attributes.id || \"\";\n    this.leadDigits = getInteger({\n      data: attributes.leadDigits,\n      defaultValue: -1,\n      validate: x => true\n    });\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n  [$finalize]() {\n    const number = parseFloat(this[$content].trim());\n    this[$content] = isNaN(number) ? null : number;\n  }\n  [$toHTML](availableSpace) {\n    return valueToHtml(this[$content] !== null ? this[$content].toString() : \"\");\n  }\n}\nclass DefaultUi extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"defaultUi\", true);\n    this.id = attributes.id || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.extras = null;\n  }\n}\nclass Desc extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"desc\", true);\n    this.id = attributes.id || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.boolean = new XFAObjectArray();\n    this.date = new XFAObjectArray();\n    this.dateTime = new XFAObjectArray();\n    this.decimal = new XFAObjectArray();\n    this.exData = new XFAObjectArray();\n    this.float = new XFAObjectArray();\n    this.image = new XFAObjectArray();\n    this.integer = new XFAObjectArray();\n    this.text = new XFAObjectArray();\n    this.time = new XFAObjectArray();\n  }\n}\nclass DigestMethod extends OptionObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"digestMethod\", [\"\", \"SHA1\", \"SHA256\", \"SHA512\", \"RIPEMD160\"]);\n    this.id = attributes.id || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass DigestMethods extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"digestMethods\", true);\n    this.id = attributes.id || \"\";\n    this.type = getStringOption(attributes.type, [\"optional\", \"required\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.digestMethod = new XFAObjectArray();\n  }\n}\nclass Draw extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"draw\", true);\n    this.anchorType = getStringOption(attributes.anchorType, [\"topLeft\", \"bottomCenter\", \"bottomLeft\", \"bottomRight\", \"middleCenter\", \"middleLeft\", \"middleRight\", \"topCenter\", \"topRight\"]);\n    this.colSpan = getInteger({\n      data: attributes.colSpan,\n      defaultValue: 1,\n      validate: n => n >= 1 || n === -1\n    });\n    this.h = attributes.h ? getMeasurement(attributes.h) : \"\";\n    this.hAlign = getStringOption(attributes.hAlign, [\"left\", \"center\", \"justify\", \"justifyAll\", \"radix\", \"right\"]);\n    this.id = attributes.id || \"\";\n    this.locale = attributes.locale || \"\";\n    this.maxH = getMeasurement(attributes.maxH, \"0pt\");\n    this.maxW = getMeasurement(attributes.maxW, \"0pt\");\n    this.minH = getMeasurement(attributes.minH, \"0pt\");\n    this.minW = getMeasurement(attributes.minW, \"0pt\");\n    this.name = attributes.name || \"\";\n    this.presence = getStringOption(attributes.presence, [\"visible\", \"hidden\", \"inactive\", \"invisible\"]);\n    this.relevant = getRelevant(attributes.relevant);\n    this.rotate = getInteger({\n      data: attributes.rotate,\n      defaultValue: 0,\n      validate: x => x % 90 === 0\n    });\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.w = attributes.w ? getMeasurement(attributes.w) : \"\";\n    this.x = getMeasurement(attributes.x, \"0pt\");\n    this.y = getMeasurement(attributes.y, \"0pt\");\n    this.assist = null;\n    this.border = null;\n    this.caption = null;\n    this.desc = null;\n    this.extras = null;\n    this.font = null;\n    this.keep = null;\n    this.margin = null;\n    this.para = null;\n    this.traversal = null;\n    this.ui = null;\n    this.value = null;\n    this.setProperty = new XFAObjectArray();\n  }\n  [$setValue](value) {\n    _setValue(this, value);\n  }\n  [$toHTML](availableSpace) {\n    setTabIndex(this);\n    if (this.presence === \"hidden\" || this.presence === \"inactive\") {\n      return HTMLResult.EMPTY;\n    }\n    fixDimensions(this);\n    this[$pushPara]();\n    const savedW = this.w;\n    const savedH = this.h;\n    const {\n      w,\n      h,\n      isBroken\n    } = layoutNode(this, availableSpace);\n    if (w && this.w === \"\") {\n      if (isBroken && this[$getSubformParent]()[$isThereMoreWidth]()) {\n        this[$popPara]();\n        return HTMLResult.FAILURE;\n      }\n      this.w = w;\n    }\n    if (h && this.h === \"\") {\n      this.h = h;\n    }\n    setFirstUnsplittable(this);\n    if (!checkDimensions(this, availableSpace)) {\n      this.w = savedW;\n      this.h = savedH;\n      this[$popPara]();\n      return HTMLResult.FAILURE;\n    }\n    unsetFirstUnsplittable(this);\n    const style = toStyle(this, \"font\", \"hAlign\", \"dimensions\", \"position\", \"presence\", \"rotate\", \"anchorType\", \"border\", \"margin\");\n    setMinMaxDimensions(this, style);\n    if (style.margin) {\n      style.padding = style.margin;\n      delete style.margin;\n    }\n    const classNames = [\"xfaDraw\"];\n    if (this.font) {\n      classNames.push(\"xfaFont\");\n    }\n    if (isPrintOnly(this)) {\n      classNames.push(\"xfaPrintOnly\");\n    }\n    const attributes = {\n      style,\n      id: this[$uid],\n      class: classNames\n    };\n    if (this.name) {\n      attributes.xfaName = this.name;\n    }\n    const html = {\n      name: \"div\",\n      attributes,\n      children: []\n    };\n    applyAssist(this, attributes);\n    const bbox = computeBbox(this, html, availableSpace);\n    const value = this.value ? this.value[$toHTML](availableSpace).html : null;\n    if (value === null) {\n      this.w = savedW;\n      this.h = savedH;\n      this[$popPara]();\n      return HTMLResult.success(createWrapper(this, html), bbox);\n    }\n    html.children.push(value);\n    setPara(this, style, value);\n    this.w = savedW;\n    this.h = savedH;\n    this[$popPara]();\n    return HTMLResult.success(createWrapper(this, html), bbox);\n  }\n}\nclass Edge extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"edge\", true);\n    this.cap = getStringOption(attributes.cap, [\"square\", \"butt\", \"round\"]);\n    this.id = attributes.id || \"\";\n    this.presence = getStringOption(attributes.presence, [\"visible\", \"hidden\", \"inactive\", \"invisible\"]);\n    this.stroke = getStringOption(attributes.stroke, [\"solid\", \"dashDot\", \"dashDotDot\", \"dashed\", \"dotted\", \"embossed\", \"etched\", \"lowered\", \"raised\"]);\n    this.thickness = getMeasurement(attributes.thickness, \"0.5pt\");\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.color = null;\n    this.extras = null;\n  }\n  [$toStyle]() {\n    const style = toStyle(this, \"visibility\");\n    Object.assign(style, {\n      linecap: this.cap,\n      width: measureToString(this.thickness),\n      color: this.color ? this.color[$toStyle]() : \"#000000\",\n      style: \"\"\n    });\n    if (this.presence !== \"visible\") {\n      style.style = \"none\";\n    } else {\n      switch (this.stroke) {\n        case \"solid\":\n          style.style = \"solid\";\n          break;\n        case \"dashDot\":\n          style.style = \"dashed\";\n          break;\n        case \"dashDotDot\":\n          style.style = \"dashed\";\n          break;\n        case \"dashed\":\n          style.style = \"dashed\";\n          break;\n        case \"dotted\":\n          style.style = \"dotted\";\n          break;\n        case \"embossed\":\n          style.style = \"ridge\";\n          break;\n        case \"etched\":\n          style.style = \"groove\";\n          break;\n        case \"lowered\":\n          style.style = \"inset\";\n          break;\n        case \"raised\":\n          style.style = \"outset\";\n          break;\n      }\n    }\n    return style;\n  }\n}\nclass Encoding extends OptionObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"encoding\", [\"adbe.x509.rsa_sha1\", \"adbe.pkcs7.detached\", \"adbe.pkcs7.sha1\"]);\n    this.id = attributes.id || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass Encodings extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"encodings\", true);\n    this.id = attributes.id || \"\";\n    this.type = getStringOption(attributes.type, [\"optional\", \"required\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.encoding = new XFAObjectArray();\n  }\n}\nclass Encrypt extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"encrypt\", true);\n    this.id = attributes.id || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.certificate = null;\n  }\n}\nclass EncryptData extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"encryptData\", true);\n    this.id = attributes.id || \"\";\n    this.operation = getStringOption(attributes.operation, [\"encrypt\", \"decrypt\"]);\n    this.target = attributes.target || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.filter = null;\n    this.manifest = null;\n  }\n}\nclass Encryption extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"encryption\", true);\n    this.id = attributes.id || \"\";\n    this.type = getStringOption(attributes.type, [\"optional\", \"required\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.certificate = new XFAObjectArray();\n  }\n}\nclass EncryptionMethod extends OptionObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"encryptionMethod\", [\"\", \"AES256-CBC\", \"TRIPLEDES-CBC\", \"AES128-CBC\", \"AES192-CBC\"]);\n    this.id = attributes.id || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass EncryptionMethods extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"encryptionMethods\", true);\n    this.id = attributes.id || \"\";\n    this.type = getStringOption(attributes.type, [\"optional\", \"required\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.encryptionMethod = new XFAObjectArray();\n  }\n}\nclass Event extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"event\", true);\n    this.activity = getStringOption(attributes.activity, [\"click\", \"change\", \"docClose\", \"docReady\", \"enter\", \"exit\", \"full\", \"indexChange\", \"initialize\", \"mouseDown\", \"mouseEnter\", \"mouseExit\", \"mouseUp\", \"postExecute\", \"postOpen\", \"postPrint\", \"postSave\", \"postSign\", \"postSubmit\", \"preExecute\", \"preOpen\", \"prePrint\", \"preSave\", \"preSign\", \"preSubmit\", \"ready\", \"validationState\"]);\n    this.id = attributes.id || \"\";\n    this.listen = getStringOption(attributes.listen, [\"refOnly\", \"refAndDescendents\"]);\n    this.name = attributes.name || \"\";\n    this.ref = attributes.ref || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.extras = null;\n    this.encryptData = null;\n    this.execute = null;\n    this.script = null;\n    this.signData = null;\n    this.submit = null;\n  }\n}\nclass ExData extends ContentObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"exData\");\n    this.contentType = attributes.contentType || \"\";\n    this.href = attributes.href || \"\";\n    this.id = attributes.id || \"\";\n    this.maxLength = getInteger({\n      data: attributes.maxLength,\n      defaultValue: -1,\n      validate: x => x >= -1\n    });\n    this.name = attributes.name || \"\";\n    this.rid = attributes.rid || \"\";\n    this.transferEncoding = getStringOption(attributes.transferEncoding, [\"none\", \"base64\", \"package\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n  [$isCDATAXml]() {\n    return this.contentType === \"text/html\";\n  }\n  [$onChild](child) {\n    if (this.contentType === \"text/html\" && child[$namespaceId] === NamespaceIds.xhtml.id) {\n      this[$content] = child;\n      return true;\n    }\n    if (this.contentType === \"text/xml\") {\n      this[$content] = child;\n      return true;\n    }\n    return false;\n  }\n  [$toHTML](availableSpace) {\n    if (this.contentType !== \"text/html\" || !this[$content]) {\n      return HTMLResult.EMPTY;\n    }\n    return this[$content][$toHTML](availableSpace);\n  }\n}\nclass ExObject extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"exObject\", true);\n    this.archive = attributes.archive || \"\";\n    this.classId = attributes.classId || \"\";\n    this.codeBase = attributes.codeBase || \"\";\n    this.codeType = attributes.codeType || \"\";\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.extras = null;\n    this.boolean = new XFAObjectArray();\n    this.date = new XFAObjectArray();\n    this.dateTime = new XFAObjectArray();\n    this.decimal = new XFAObjectArray();\n    this.exData = new XFAObjectArray();\n    this.exObject = new XFAObjectArray();\n    this.float = new XFAObjectArray();\n    this.image = new XFAObjectArray();\n    this.integer = new XFAObjectArray();\n    this.text = new XFAObjectArray();\n    this.time = new XFAObjectArray();\n  }\n}\nclass ExclGroup extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"exclGroup\", true);\n    this.access = getStringOption(attributes.access, [\"open\", \"nonInteractive\", \"protected\", \"readOnly\"]);\n    this.accessKey = attributes.accessKey || \"\";\n    this.anchorType = getStringOption(attributes.anchorType, [\"topLeft\", \"bottomCenter\", \"bottomLeft\", \"bottomRight\", \"middleCenter\", \"middleLeft\", \"middleRight\", \"topCenter\", \"topRight\"]);\n    this.colSpan = getInteger({\n      data: attributes.colSpan,\n      defaultValue: 1,\n      validate: n => n >= 1 || n === -1\n    });\n    this.h = attributes.h ? getMeasurement(attributes.h) : \"\";\n    this.hAlign = getStringOption(attributes.hAlign, [\"left\", \"center\", \"justify\", \"justifyAll\", \"radix\", \"right\"]);\n    this.id = attributes.id || \"\";\n    this.layout = getStringOption(attributes.layout, [\"position\", \"lr-tb\", \"rl-row\", \"rl-tb\", \"row\", \"table\", \"tb\"]);\n    this.maxH = getMeasurement(attributes.maxH, \"0pt\");\n    this.maxW = getMeasurement(attributes.maxW, \"0pt\");\n    this.minH = getMeasurement(attributes.minH, \"0pt\");\n    this.minW = getMeasurement(attributes.minW, \"0pt\");\n    this.name = attributes.name || \"\";\n    this.presence = getStringOption(attributes.presence, [\"visible\", \"hidden\", \"inactive\", \"invisible\"]);\n    this.relevant = getRelevant(attributes.relevant);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.w = attributes.w ? getMeasurement(attributes.w) : \"\";\n    this.x = getMeasurement(attributes.x, \"0pt\");\n    this.y = getMeasurement(attributes.y, \"0pt\");\n    this.assist = null;\n    this.bind = null;\n    this.border = null;\n    this.calculate = null;\n    this.caption = null;\n    this.desc = null;\n    this.extras = null;\n    this.margin = null;\n    this.para = null;\n    this.traversal = null;\n    this.validate = null;\n    this.connect = new XFAObjectArray();\n    this.event = new XFAObjectArray();\n    this.field = new XFAObjectArray();\n    this.setProperty = new XFAObjectArray();\n  }\n  [$isBindable]() {\n    return true;\n  }\n  [$hasSettableValue]() {\n    return true;\n  }\n  [$setValue](value) {\n    for (const field of this.field.children) {\n      if (!field.value) {\n        const nodeValue = new Value({});\n        field[$appendChild](nodeValue);\n        field.value = nodeValue;\n      }\n      field.value[$setValue](value);\n    }\n  }\n  [$isThereMoreWidth]() {\n    return this.layout.endsWith(\"-tb\") && this[$extra].attempt === 0 && this[$extra].numberInLine > 0 || this[$getParent]()[$isThereMoreWidth]();\n  }\n  [$isSplittable]() {\n    const parent = this[$getSubformParent]();\n    if (!parent[$isSplittable]()) {\n      return false;\n    }\n    if (this[$extra]._isSplittable !== undefined) {\n      return this[$extra]._isSplittable;\n    }\n    if (this.layout === \"position\" || this.layout.includes(\"row\")) {\n      this[$extra]._isSplittable = false;\n      return false;\n    }\n    if (parent.layout?.endsWith(\"-tb\") && parent[$extra].numberInLine !== 0) {\n      return false;\n    }\n    this[$extra]._isSplittable = true;\n    return true;\n  }\n  [$flushHTML]() {\n    return flushHTML(this);\n  }\n  [$addHTML](html, bbox) {\n    addHTML(this, html, bbox);\n  }\n  [$getAvailableSpace]() {\n    return getAvailableSpace(this);\n  }\n  [$toHTML](availableSpace) {\n    setTabIndex(this);\n    if (this.presence === \"hidden\" || this.presence === \"inactive\" || this.h === 0 || this.w === 0) {\n      return HTMLResult.EMPTY;\n    }\n    fixDimensions(this);\n    const children = [];\n    const attributes = {\n      id: this[$uid],\n      class: []\n    };\n    setAccess(this, attributes.class);\n    if (!this[$extra]) {\n      this[$extra] = Object.create(null);\n    }\n    Object.assign(this[$extra], {\n      children,\n      attributes,\n      attempt: 0,\n      line: null,\n      numberInLine: 0,\n      availableSpace: {\n        width: Math.min(this.w || Infinity, availableSpace.width),\n        height: Math.min(this.h || Infinity, availableSpace.height)\n      },\n      width: 0,\n      height: 0,\n      prevHeight: 0,\n      currentWidth: 0\n    });\n    const isSplittable = this[$isSplittable]();\n    if (!isSplittable) {\n      setFirstUnsplittable(this);\n    }\n    if (!checkDimensions(this, availableSpace)) {\n      return HTMLResult.FAILURE;\n    }\n    const filter = new Set([\"field\"]);\n    if (this.layout.includes(\"row\")) {\n      const columnWidths = this[$getSubformParent]().columnWidths;\n      if (Array.isArray(columnWidths) && columnWidths.length > 0) {\n        this[$extra].columnWidths = columnWidths;\n        this[$extra].currentColumn = 0;\n      }\n    }\n    const style = toStyle(this, \"anchorType\", \"dimensions\", \"position\", \"presence\", \"border\", \"margin\", \"hAlign\");\n    const classNames = [\"xfaExclgroup\"];\n    const cl = layoutClass(this);\n    if (cl) {\n      classNames.push(cl);\n    }\n    if (isPrintOnly(this)) {\n      classNames.push(\"xfaPrintOnly\");\n    }\n    attributes.style = style;\n    attributes.class = classNames;\n    if (this.name) {\n      attributes.xfaName = this.name;\n    }\n    this[$pushPara]();\n    const isLrTb = this.layout === \"lr-tb\" || this.layout === \"rl-tb\";\n    const maxRun = isLrTb ? MAX_ATTEMPTS_FOR_LRTB_LAYOUT : 1;\n    for (; this[$extra].attempt < maxRun; this[$extra].attempt++) {\n      if (isLrTb && this[$extra].attempt === MAX_ATTEMPTS_FOR_LRTB_LAYOUT - 1) {\n        this[$extra].numberInLine = 0;\n      }\n      const result = this[$childrenToHTML]({\n        filter,\n        include: true\n      });\n      if (result.success) {\n        break;\n      }\n      if (result.isBreak()) {\n        this[$popPara]();\n        return result;\n      }\n      if (isLrTb && this[$extra].attempt === 0 && this[$extra].numberInLine === 0 && !this[$getTemplateRoot]()[$extra].noLayoutFailure) {\n        this[$extra].attempt = maxRun;\n        break;\n      }\n    }\n    this[$popPara]();\n    if (!isSplittable) {\n      unsetFirstUnsplittable(this);\n    }\n    if (this[$extra].attempt === maxRun) {\n      if (!isSplittable) {\n        delete this[$extra];\n      }\n      return HTMLResult.FAILURE;\n    }\n    let marginH = 0;\n    let marginV = 0;\n    if (this.margin) {\n      marginH = this.margin.leftInset + this.margin.rightInset;\n      marginV = this.margin.topInset + this.margin.bottomInset;\n    }\n    const width = Math.max(this[$extra].width + marginH, this.w || 0);\n    const height = Math.max(this[$extra].height + marginV, this.h || 0);\n    const bbox = [this.x, this.y, width, height];\n    if (this.w === \"\") {\n      style.width = measureToString(width);\n    }\n    if (this.h === \"\") {\n      style.height = measureToString(height);\n    }\n    const html = {\n      name: \"div\",\n      attributes,\n      children\n    };\n    applyAssist(this, attributes);\n    delete this[$extra];\n    return HTMLResult.success(createWrapper(this, html), bbox);\n  }\n}\nclass Execute extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"execute\");\n    this.connection = attributes.connection || \"\";\n    this.executeType = getStringOption(attributes.executeType, [\"import\", \"remerge\"]);\n    this.id = attributes.id || \"\";\n    this.runAt = getStringOption(attributes.runAt, [\"client\", \"both\", \"server\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass Extras extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"extras\", true);\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.boolean = new XFAObjectArray();\n    this.date = new XFAObjectArray();\n    this.dateTime = new XFAObjectArray();\n    this.decimal = new XFAObjectArray();\n    this.exData = new XFAObjectArray();\n    this.extras = new XFAObjectArray();\n    this.float = new XFAObjectArray();\n    this.image = new XFAObjectArray();\n    this.integer = new XFAObjectArray();\n    this.text = new XFAObjectArray();\n    this.time = new XFAObjectArray();\n  }\n}\nclass Field extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"field\", true);\n    this.access = getStringOption(attributes.access, [\"open\", \"nonInteractive\", \"protected\", \"readOnly\"]);\n    this.accessKey = attributes.accessKey || \"\";\n    this.anchorType = getStringOption(attributes.anchorType, [\"topLeft\", \"bottomCenter\", \"bottomLeft\", \"bottomRight\", \"middleCenter\", \"middleLeft\", \"middleRight\", \"topCenter\", \"topRight\"]);\n    this.colSpan = getInteger({\n      data: attributes.colSpan,\n      defaultValue: 1,\n      validate: n => n >= 1 || n === -1\n    });\n    this.h = attributes.h ? getMeasurement(attributes.h) : \"\";\n    this.hAlign = getStringOption(attributes.hAlign, [\"left\", \"center\", \"justify\", \"justifyAll\", \"radix\", \"right\"]);\n    this.id = attributes.id || \"\";\n    this.locale = attributes.locale || \"\";\n    this.maxH = getMeasurement(attributes.maxH, \"0pt\");\n    this.maxW = getMeasurement(attributes.maxW, \"0pt\");\n    this.minH = getMeasurement(attributes.minH, \"0pt\");\n    this.minW = getMeasurement(attributes.minW, \"0pt\");\n    this.name = attributes.name || \"\";\n    this.presence = getStringOption(attributes.presence, [\"visible\", \"hidden\", \"inactive\", \"invisible\"]);\n    this.relevant = getRelevant(attributes.relevant);\n    this.rotate = getInteger({\n      data: attributes.rotate,\n      defaultValue: 0,\n      validate: x => x % 90 === 0\n    });\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.w = attributes.w ? getMeasurement(attributes.w) : \"\";\n    this.x = getMeasurement(attributes.x, \"0pt\");\n    this.y = getMeasurement(attributes.y, \"0pt\");\n    this.assist = null;\n    this.bind = null;\n    this.border = null;\n    this.calculate = null;\n    this.caption = null;\n    this.desc = null;\n    this.extras = null;\n    this.font = null;\n    this.format = null;\n    this.items = new XFAObjectArray(2);\n    this.keep = null;\n    this.margin = null;\n    this.para = null;\n    this.traversal = null;\n    this.ui = null;\n    this.validate = null;\n    this.value = null;\n    this.bindItems = new XFAObjectArray();\n    this.connect = new XFAObjectArray();\n    this.event = new XFAObjectArray();\n    this.setProperty = new XFAObjectArray();\n  }\n  [$isBindable]() {\n    return true;\n  }\n  [$setValue](value) {\n    _setValue(this, value);\n  }\n  [$toHTML](availableSpace) {\n    setTabIndex(this);\n    if (!this.ui) {\n      this.ui = new Ui({});\n      this.ui[$globalData] = this[$globalData];\n      this[$appendChild](this.ui);\n      let node;\n      switch (this.items.children.length) {\n        case 0:\n          node = new TextEdit({});\n          this.ui.textEdit = node;\n          break;\n        case 1:\n          node = new CheckButton({});\n          this.ui.checkButton = node;\n          break;\n        case 2:\n          node = new ChoiceList({});\n          this.ui.choiceList = node;\n          break;\n      }\n      this.ui[$appendChild](node);\n    }\n    if (!this.ui || this.presence === \"hidden\" || this.presence === \"inactive\" || this.h === 0 || this.w === 0) {\n      return HTMLResult.EMPTY;\n    }\n    if (this.caption) {\n      delete this.caption[$extra];\n    }\n    this[$pushPara]();\n    const caption = this.caption ? this.caption[$toHTML](availableSpace).html : null;\n    const savedW = this.w;\n    const savedH = this.h;\n    let marginH = 0;\n    let marginV = 0;\n    if (this.margin) {\n      marginH = this.margin.leftInset + this.margin.rightInset;\n      marginV = this.margin.topInset + this.margin.bottomInset;\n    }\n    let borderDims = null;\n    if (this.w === \"\" || this.h === \"\") {\n      let width = null;\n      let height = null;\n      let uiW = 0;\n      let uiH = 0;\n      if (this.ui.checkButton) {\n        uiW = uiH = this.ui.checkButton.size;\n      } else {\n        const {\n          w,\n          h\n        } = layoutNode(this, availableSpace);\n        if (w !== null) {\n          uiW = w;\n          uiH = h;\n        } else {\n          uiH = fonts_getMetrics(this.font, true).lineNoGap;\n        }\n      }\n      borderDims = getBorderDims(this.ui[$getExtra]());\n      uiW += borderDims.w;\n      uiH += borderDims.h;\n      if (this.caption) {\n        const {\n          w,\n          h,\n          isBroken\n        } = this.caption[$getExtra](availableSpace);\n        if (isBroken && this[$getSubformParent]()[$isThereMoreWidth]()) {\n          this[$popPara]();\n          return HTMLResult.FAILURE;\n        }\n        width = w;\n        height = h;\n        switch (this.caption.placement) {\n          case \"left\":\n          case \"right\":\n          case \"inline\":\n            width += uiW;\n            break;\n          case \"top\":\n          case \"bottom\":\n            height += uiH;\n            break;\n        }\n      } else {\n        width = uiW;\n        height = uiH;\n      }\n      if (width && this.w === \"\") {\n        width += marginH;\n        this.w = Math.min(this.maxW <= 0 ? Infinity : this.maxW, this.minW + 1 < width ? width : this.minW);\n      }\n      if (height && this.h === \"\") {\n        height += marginV;\n        this.h = Math.min(this.maxH <= 0 ? Infinity : this.maxH, this.minH + 1 < height ? height : this.minH);\n      }\n    }\n    this[$popPara]();\n    fixDimensions(this);\n    setFirstUnsplittable(this);\n    if (!checkDimensions(this, availableSpace)) {\n      this.w = savedW;\n      this.h = savedH;\n      this[$popPara]();\n      return HTMLResult.FAILURE;\n    }\n    unsetFirstUnsplittable(this);\n    const style = toStyle(this, \"font\", \"dimensions\", \"position\", \"rotate\", \"anchorType\", \"presence\", \"margin\", \"hAlign\");\n    setMinMaxDimensions(this, style);\n    const classNames = [\"xfaField\"];\n    if (this.font) {\n      classNames.push(\"xfaFont\");\n    }\n    if (isPrintOnly(this)) {\n      classNames.push(\"xfaPrintOnly\");\n    }\n    const attributes = {\n      style,\n      id: this[$uid],\n      class: classNames\n    };\n    if (style.margin) {\n      style.padding = style.margin;\n      delete style.margin;\n    }\n    setAccess(this, classNames);\n    if (this.name) {\n      attributes.xfaName = this.name;\n    }\n    const children = [];\n    const html = {\n      name: \"div\",\n      attributes,\n      children\n    };\n    applyAssist(this, attributes);\n    const borderStyle = this.border ? this.border[$toStyle]() : null;\n    const bbox = computeBbox(this, html, availableSpace);\n    const ui = this.ui[$toHTML]().html;\n    if (!ui) {\n      Object.assign(style, borderStyle);\n      return HTMLResult.success(createWrapper(this, html), bbox);\n    }\n    if (this[$tabIndex]) {\n      if (ui.children?.[0]) {\n        ui.children[0].attributes.tabindex = this[$tabIndex];\n      } else {\n        ui.attributes.tabindex = this[$tabIndex];\n      }\n    }\n    if (!ui.attributes.style) {\n      ui.attributes.style = Object.create(null);\n    }\n    let aElement = null;\n    if (this.ui.button) {\n      if (ui.children.length === 1) {\n        [aElement] = ui.children.splice(0, 1);\n      }\n      Object.assign(ui.attributes.style, borderStyle);\n    } else {\n      Object.assign(style, borderStyle);\n    }\n    children.push(ui);\n    if (this.value) {\n      if (this.ui.imageEdit) {\n        ui.children.push(this.value[$toHTML]().html);\n      } else if (!this.ui.button) {\n        let value = \"\";\n        if (this.value.exData) {\n          value = this.value.exData[$text]();\n        } else if (this.value.text) {\n          value = this.value.text[$getExtra]();\n        } else {\n          const htmlValue = this.value[$toHTML]().html;\n          if (htmlValue !== null) {\n            value = htmlValue.children[0].value;\n          }\n        }\n        if (this.ui.textEdit && this.value.text?.maxChars) {\n          ui.children[0].attributes.maxLength = this.value.text.maxChars;\n        }\n        if (value) {\n          if (this.ui.numericEdit) {\n            value = parseFloat(value);\n            value = isNaN(value) ? \"\" : value.toString();\n          }\n          if (ui.children[0].name === \"textarea\") {\n            ui.children[0].attributes.textContent = value;\n          } else {\n            ui.children[0].attributes.value = value;\n          }\n        }\n      }\n    }\n    if (!this.ui.imageEdit && ui.children?.[0] && this.h) {\n      borderDims = borderDims || getBorderDims(this.ui[$getExtra]());\n      let captionHeight = 0;\n      if (this.caption && [\"top\", \"bottom\"].includes(this.caption.placement)) {\n        captionHeight = this.caption.reserve;\n        if (captionHeight <= 0) {\n          captionHeight = this.caption[$getExtra](availableSpace).h;\n        }\n        const inputHeight = this.h - captionHeight - marginV - borderDims.h;\n        ui.children[0].attributes.style.height = measureToString(inputHeight);\n      } else {\n        ui.children[0].attributes.style.height = \"100%\";\n      }\n    }\n    if (aElement) {\n      ui.children.push(aElement);\n    }\n    if (!caption) {\n      if (ui.attributes.class) {\n        ui.attributes.class.push(\"xfaLeft\");\n      }\n      this.w = savedW;\n      this.h = savedH;\n      return HTMLResult.success(createWrapper(this, html), bbox);\n    }\n    if (this.ui.button) {\n      if (style.padding) {\n        delete style.padding;\n      }\n      if (caption.name === \"div\") {\n        caption.name = \"span\";\n      }\n      ui.children.push(caption);\n      return HTMLResult.success(html, bbox);\n    } else if (this.ui.checkButton) {\n      caption.attributes.class[0] = \"xfaCaptionForCheckButton\";\n    }\n    if (!ui.attributes.class) {\n      ui.attributes.class = [];\n    }\n    ui.children.splice(0, 0, caption);\n    switch (this.caption.placement) {\n      case \"left\":\n        ui.attributes.class.push(\"xfaLeft\");\n        break;\n      case \"right\":\n        ui.attributes.class.push(\"xfaRight\");\n        break;\n      case \"top\":\n        ui.attributes.class.push(\"xfaTop\");\n        break;\n      case \"bottom\":\n        ui.attributes.class.push(\"xfaBottom\");\n        break;\n      case \"inline\":\n        ui.attributes.class.push(\"xfaLeft\");\n        break;\n    }\n    this.w = savedW;\n    this.h = savedH;\n    return HTMLResult.success(createWrapper(this, html), bbox);\n  }\n}\nclass Fill extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"fill\", true);\n    this.id = attributes.id || \"\";\n    this.presence = getStringOption(attributes.presence, [\"visible\", \"hidden\", \"inactive\", \"invisible\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.color = null;\n    this.extras = null;\n    this.linear = null;\n    this.pattern = null;\n    this.radial = null;\n    this.solid = null;\n    this.stipple = null;\n  }\n  [$toStyle]() {\n    const parent = this[$getParent]();\n    const grandpa = parent[$getParent]();\n    const ggrandpa = grandpa[$getParent]();\n    const style = Object.create(null);\n    let propName = \"color\";\n    let altPropName = propName;\n    if (parent instanceof Border) {\n      propName = \"background-color\";\n      altPropName = \"background\";\n      if (ggrandpa instanceof Ui) {\n        style.backgroundColor = \"white\";\n      }\n    }\n    if (parent instanceof Rectangle || parent instanceof Arc) {\n      propName = altPropName = \"fill\";\n      style.fill = \"white\";\n    }\n    for (const name of Object.getOwnPropertyNames(this)) {\n      if (name === \"extras\" || name === \"color\") {\n        continue;\n      }\n      const obj = this[name];\n      if (!(obj instanceof XFAObject)) {\n        continue;\n      }\n      const color = obj[$toStyle](this.color);\n      if (color) {\n        style[color.startsWith(\"#\") ? propName : altPropName] = color;\n      }\n      return style;\n    }\n    if (this.color?.value) {\n      const color = this.color[$toStyle]();\n      style[color.startsWith(\"#\") ? propName : altPropName] = color;\n    }\n    return style;\n  }\n}\nclass Filter extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"filter\", true);\n    this.addRevocationInfo = getStringOption(attributes.addRevocationInfo, [\"\", \"required\", \"optional\", \"none\"]);\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.version = getInteger({\n      data: this.version,\n      defaultValue: 5,\n      validate: x => x >= 1 && x <= 5\n    });\n    this.appearanceFilter = null;\n    this.certificates = null;\n    this.digestMethods = null;\n    this.encodings = null;\n    this.encryptionMethods = null;\n    this.handler = null;\n    this.lockDocument = null;\n    this.mdp = null;\n    this.reasons = null;\n    this.timeStamp = null;\n  }\n}\nclass Float extends ContentObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"float\");\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n  [$finalize]() {\n    const number = parseFloat(this[$content].trim());\n    this[$content] = isNaN(number) ? null : number;\n  }\n  [$toHTML](availableSpace) {\n    return valueToHtml(this[$content] !== null ? this[$content].toString() : \"\");\n  }\n}\nclass template_Font extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"font\", true);\n    this.baselineShift = getMeasurement(attributes.baselineShift);\n    this.fontHorizontalScale = getFloat({\n      data: attributes.fontHorizontalScale,\n      defaultValue: 100,\n      validate: x => x >= 0\n    });\n    this.fontVerticalScale = getFloat({\n      data: attributes.fontVerticalScale,\n      defaultValue: 100,\n      validate: x => x >= 0\n    });\n    this.id = attributes.id || \"\";\n    this.kerningMode = getStringOption(attributes.kerningMode, [\"none\", \"pair\"]);\n    this.letterSpacing = getMeasurement(attributes.letterSpacing, \"0\");\n    this.lineThrough = getInteger({\n      data: attributes.lineThrough,\n      defaultValue: 0,\n      validate: x => x === 1 || x === 2\n    });\n    this.lineThroughPeriod = getStringOption(attributes.lineThroughPeriod, [\"all\", \"word\"]);\n    this.overline = getInteger({\n      data: attributes.overline,\n      defaultValue: 0,\n      validate: x => x === 1 || x === 2\n    });\n    this.overlinePeriod = getStringOption(attributes.overlinePeriod, [\"all\", \"word\"]);\n    this.posture = getStringOption(attributes.posture, [\"normal\", \"italic\"]);\n    this.size = getMeasurement(attributes.size, \"10pt\");\n    this.typeface = attributes.typeface || \"Courier\";\n    this.underline = getInteger({\n      data: attributes.underline,\n      defaultValue: 0,\n      validate: x => x === 1 || x === 2\n    });\n    this.underlinePeriod = getStringOption(attributes.underlinePeriod, [\"all\", \"word\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.weight = getStringOption(attributes.weight, [\"normal\", \"bold\"]);\n    this.extras = null;\n    this.fill = null;\n  }\n  [$clean](builder) {\n    super[$clean](builder);\n    this[$globalData].usedTypefaces.add(this.typeface);\n  }\n  [$toStyle]() {\n    const style = toStyle(this, \"fill\");\n    const color = style.color;\n    if (color) {\n      if (color === \"#000000\") {\n        delete style.color;\n      } else if (!color.startsWith(\"#\")) {\n        style.background = color;\n        style.backgroundClip = \"text\";\n        style.color = \"transparent\";\n      }\n    }\n    if (this.baselineShift) {\n      style.verticalAlign = measureToString(this.baselineShift);\n    }\n    style.fontKerning = this.kerningMode === \"none\" ? \"none\" : \"normal\";\n    style.letterSpacing = measureToString(this.letterSpacing);\n    if (this.lineThrough !== 0) {\n      style.textDecoration = \"line-through\";\n      if (this.lineThrough === 2) {\n        style.textDecorationStyle = \"double\";\n      }\n    }\n    if (this.overline !== 0) {\n      style.textDecoration = \"overline\";\n      if (this.overline === 2) {\n        style.textDecorationStyle = \"double\";\n      }\n    }\n    style.fontStyle = this.posture;\n    style.fontSize = measureToString(0.99 * this.size);\n    setFontFamily(this, this, this[$globalData].fontFinder, style);\n    if (this.underline !== 0) {\n      style.textDecoration = \"underline\";\n      if (this.underline === 2) {\n        style.textDecorationStyle = \"double\";\n      }\n    }\n    style.fontWeight = this.weight;\n    return style;\n  }\n}\nclass Format extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"format\", true);\n    this.id = attributes.id || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.extras = null;\n    this.picture = null;\n  }\n}\nclass Handler extends StringObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"handler\");\n    this.id = attributes.id || \"\";\n    this.type = getStringOption(attributes.type, [\"optional\", \"required\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass Hyphenation extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"hyphenation\");\n    this.excludeAllCaps = getInteger({\n      data: attributes.excludeAllCaps,\n      defaultValue: 0,\n      validate: x => x === 1\n    });\n    this.excludeInitialCap = getInteger({\n      data: attributes.excludeInitialCap,\n      defaultValue: 0,\n      validate: x => x === 1\n    });\n    this.hyphenate = getInteger({\n      data: attributes.hyphenate,\n      defaultValue: 0,\n      validate: x => x === 1\n    });\n    this.id = attributes.id || \"\";\n    this.pushCharacterCount = getInteger({\n      data: attributes.pushCharacterCount,\n      defaultValue: 3,\n      validate: x => x >= 0\n    });\n    this.remainCharacterCount = getInteger({\n      data: attributes.remainCharacterCount,\n      defaultValue: 3,\n      validate: x => x >= 0\n    });\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.wordCharacterCount = getInteger({\n      data: attributes.wordCharacterCount,\n      defaultValue: 7,\n      validate: x => x >= 0\n    });\n  }\n}\nclass Image extends StringObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"image\");\n    this.aspect = getStringOption(attributes.aspect, [\"fit\", \"actual\", \"height\", \"none\", \"width\"]);\n    this.contentType = attributes.contentType || \"\";\n    this.href = attributes.href || \"\";\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.transferEncoding = getStringOption(attributes.transferEncoding, [\"base64\", \"none\", \"package\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n  [$toHTML]() {\n    if (this.contentType && !MIMES.has(this.contentType.toLowerCase())) {\n      return HTMLResult.EMPTY;\n    }\n    let buffer = this[$globalData].images && this[$globalData].images.get(this.href);\n    if (!buffer && (this.href || !this[$content])) {\n      return HTMLResult.EMPTY;\n    }\n    if (!buffer && this.transferEncoding === \"base64\") {\n      buffer = stringToBytes(atob(this[$content]));\n    }\n    if (!buffer) {\n      return HTMLResult.EMPTY;\n    }\n    if (!this.contentType) {\n      for (const [header, type] of IMAGES_HEADERS) {\n        if (buffer.length > header.length && header.every((x, i) => x === buffer[i])) {\n          this.contentType = type;\n          break;\n        }\n      }\n      if (!this.contentType) {\n        return HTMLResult.EMPTY;\n      }\n    }\n    const blob = new Blob([buffer], {\n      type: this.contentType\n    });\n    let style;\n    switch (this.aspect) {\n      case \"fit\":\n      case \"actual\":\n        break;\n      case \"height\":\n        style = {\n          height: \"100%\",\n          objectFit: \"fill\"\n        };\n        break;\n      case \"none\":\n        style = {\n          width: \"100%\",\n          height: \"100%\",\n          objectFit: \"fill\"\n        };\n        break;\n      case \"width\":\n        style = {\n          width: \"100%\",\n          objectFit: \"fill\"\n        };\n        break;\n    }\n    const parent = this[$getParent]();\n    return HTMLResult.success({\n      name: \"img\",\n      attributes: {\n        class: [\"xfaImage\"],\n        style,\n        src: URL.createObjectURL(blob),\n        alt: parent ? ariaLabel(parent[$getParent]()) : null\n      }\n    });\n  }\n}\nclass ImageEdit extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"imageEdit\", true);\n    this.data = getStringOption(attributes.data, [\"link\", \"embed\"]);\n    this.id = attributes.id || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.border = null;\n    this.extras = null;\n    this.margin = null;\n  }\n  [$toHTML](availableSpace) {\n    if (this.data === \"embed\") {\n      return HTMLResult.success({\n        name: \"div\",\n        children: [],\n        attributes: {}\n      });\n    }\n    return HTMLResult.EMPTY;\n  }\n}\nclass Integer extends ContentObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"integer\");\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n  [$finalize]() {\n    const number = parseInt(this[$content].trim(), 10);\n    this[$content] = isNaN(number) ? null : number;\n  }\n  [$toHTML](availableSpace) {\n    return valueToHtml(this[$content] !== null ? this[$content].toString() : \"\");\n  }\n}\nclass Issuers extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"issuers\", true);\n    this.id = attributes.id || \"\";\n    this.type = getStringOption(attributes.type, [\"optional\", \"required\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.certificate = new XFAObjectArray();\n  }\n}\nclass Items extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"items\", true);\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.presence = getStringOption(attributes.presence, [\"visible\", \"hidden\", \"inactive\", \"invisible\"]);\n    this.ref = attributes.ref || \"\";\n    this.save = getInteger({\n      data: attributes.save,\n      defaultValue: 0,\n      validate: x => x === 1\n    });\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.boolean = new XFAObjectArray();\n    this.date = new XFAObjectArray();\n    this.dateTime = new XFAObjectArray();\n    this.decimal = new XFAObjectArray();\n    this.exData = new XFAObjectArray();\n    this.float = new XFAObjectArray();\n    this.image = new XFAObjectArray();\n    this.integer = new XFAObjectArray();\n    this.text = new XFAObjectArray();\n    this.time = new XFAObjectArray();\n  }\n  [$toHTML]() {\n    const output = [];\n    for (const child of this[$getChildren]()) {\n      output.push(child[$text]());\n    }\n    return HTMLResult.success(output);\n  }\n}\nclass Keep extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"keep\", true);\n    this.id = attributes.id || \"\";\n    const options = [\"none\", \"contentArea\", \"pageArea\"];\n    this.intact = getStringOption(attributes.intact, options);\n    this.next = getStringOption(attributes.next, options);\n    this.previous = getStringOption(attributes.previous, options);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.extras = null;\n  }\n}\nclass KeyUsage extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"keyUsage\");\n    const options = [\"\", \"yes\", \"no\"];\n    this.crlSign = getStringOption(attributes.crlSign, options);\n    this.dataEncipherment = getStringOption(attributes.dataEncipherment, options);\n    this.decipherOnly = getStringOption(attributes.decipherOnly, options);\n    this.digitalSignature = getStringOption(attributes.digitalSignature, options);\n    this.encipherOnly = getStringOption(attributes.encipherOnly, options);\n    this.id = attributes.id || \"\";\n    this.keyAgreement = getStringOption(attributes.keyAgreement, options);\n    this.keyCertSign = getStringOption(attributes.keyCertSign, options);\n    this.keyEncipherment = getStringOption(attributes.keyEncipherment, options);\n    this.nonRepudiation = getStringOption(attributes.nonRepudiation, options);\n    this.type = getStringOption(attributes.type, [\"optional\", \"required\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass Line extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"line\", true);\n    this.hand = getStringOption(attributes.hand, [\"even\", \"left\", \"right\"]);\n    this.id = attributes.id || \"\";\n    this.slope = getStringOption(attributes.slope, [\"\\\\\", \"/\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.edge = null;\n  }\n  [$toHTML]() {\n    const parent = this[$getParent]()[$getParent]();\n    const edge = this.edge || new Edge({});\n    const edgeStyle = edge[$toStyle]();\n    const style = Object.create(null);\n    const thickness = edge.presence === \"visible\" ? edge.thickness : 0;\n    style.strokeWidth = measureToString(thickness);\n    style.stroke = edgeStyle.color;\n    let x1, y1, x2, y2;\n    let width = \"100%\";\n    let height = \"100%\";\n    if (parent.w <= thickness) {\n      [x1, y1, x2, y2] = [\"50%\", 0, \"50%\", \"100%\"];\n      width = style.strokeWidth;\n    } else if (parent.h <= thickness) {\n      [x1, y1, x2, y2] = [0, \"50%\", \"100%\", \"50%\"];\n      height = style.strokeWidth;\n    } else if (this.slope === \"\\\\\") {\n      [x1, y1, x2, y2] = [0, 0, \"100%\", \"100%\"];\n    } else {\n      [x1, y1, x2, y2] = [0, \"100%\", \"100%\", 0];\n    }\n    const line = {\n      name: \"line\",\n      attributes: {\n        xmlns: SVG_NS,\n        x1,\n        y1,\n        x2,\n        y2,\n        style\n      }\n    };\n    const svg = {\n      name: \"svg\",\n      children: [line],\n      attributes: {\n        xmlns: SVG_NS,\n        width,\n        height,\n        style: {\n          overflow: \"visible\"\n        }\n      }\n    };\n    if (hasMargin(parent)) {\n      return HTMLResult.success({\n        name: \"div\",\n        attributes: {\n          style: {\n            display: \"inline\",\n            width: \"100%\",\n            height: \"100%\"\n          }\n        },\n        children: [svg]\n      });\n    }\n    svg.attributes.style.position = \"absolute\";\n    return HTMLResult.success(svg);\n  }\n}\nclass Linear extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"linear\", true);\n    this.id = attributes.id || \"\";\n    this.type = getStringOption(attributes.type, [\"toRight\", \"toBottom\", \"toLeft\", \"toTop\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.color = null;\n    this.extras = null;\n  }\n  [$toStyle](startColor) {\n    startColor = startColor ? startColor[$toStyle]() : \"#FFFFFF\";\n    const transf = this.type.replace(/([RBLT])/, \" $1\").toLowerCase();\n    const endColor = this.color ? this.color[$toStyle]() : \"#000000\";\n    return `linear-gradient(${transf}, ${startColor}, ${endColor})`;\n  }\n}\nclass LockDocument extends ContentObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"lockDocument\");\n    this.id = attributes.id || \"\";\n    this.type = getStringOption(attributes.type, [\"optional\", \"required\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n  [$finalize]() {\n    this[$content] = getStringOption(this[$content], [\"auto\", \"0\", \"1\"]);\n  }\n}\nclass Manifest extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"manifest\", true);\n    this.action = getStringOption(attributes.action, [\"include\", \"all\", \"exclude\"]);\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.extras = null;\n    this.ref = new XFAObjectArray();\n  }\n}\nclass Margin extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"margin\", true);\n    this.bottomInset = getMeasurement(attributes.bottomInset, \"0\");\n    this.id = attributes.id || \"\";\n    this.leftInset = getMeasurement(attributes.leftInset, \"0\");\n    this.rightInset = getMeasurement(attributes.rightInset, \"0\");\n    this.topInset = getMeasurement(attributes.topInset, \"0\");\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.extras = null;\n  }\n  [$toStyle]() {\n    return {\n      margin: measureToString(this.topInset) + \" \" + measureToString(this.rightInset) + \" \" + measureToString(this.bottomInset) + \" \" + measureToString(this.leftInset)\n    };\n  }\n}\nclass Mdp extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"mdp\");\n    this.id = attributes.id || \"\";\n    this.permissions = getInteger({\n      data: attributes.permissions,\n      defaultValue: 2,\n      validate: x => x === 1 || x === 3\n    });\n    this.signatureType = getStringOption(attributes.signatureType, [\"filler\", \"author\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass Medium extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"medium\");\n    this.id = attributes.id || \"\";\n    this.imagingBBox = getBBox(attributes.imagingBBox);\n    this.long = getMeasurement(attributes.long);\n    this.orientation = getStringOption(attributes.orientation, [\"portrait\", \"landscape\"]);\n    this.short = getMeasurement(attributes.short);\n    this.stock = attributes.stock || \"\";\n    this.trayIn = getStringOption(attributes.trayIn, [\"auto\", \"delegate\", \"pageFront\"]);\n    this.trayOut = getStringOption(attributes.trayOut, [\"auto\", \"delegate\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass Message extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"message\", true);\n    this.id = attributes.id || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.text = new XFAObjectArray();\n  }\n}\nclass NumericEdit extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"numericEdit\", true);\n    this.hScrollPolicy = getStringOption(attributes.hScrollPolicy, [\"auto\", \"off\", \"on\"]);\n    this.id = attributes.id || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.border = null;\n    this.comb = null;\n    this.extras = null;\n    this.margin = null;\n  }\n  [$toHTML](availableSpace) {\n    const style = toStyle(this, \"border\", \"font\", \"margin\");\n    const field = this[$getParent]()[$getParent]();\n    const html = {\n      name: \"input\",\n      attributes: {\n        type: \"text\",\n        fieldId: field[$uid],\n        dataId: field[$data]?.[$uid] || field[$uid],\n        class: [\"xfaTextfield\"],\n        style,\n        \"aria-label\": ariaLabel(field),\n        \"aria-required\": false\n      }\n    };\n    if (isRequired(field)) {\n      html.attributes[\"aria-required\"] = true;\n      html.attributes.required = true;\n    }\n    return HTMLResult.success({\n      name: \"label\",\n      attributes: {\n        class: [\"xfaLabel\"]\n      },\n      children: [html]\n    });\n  }\n}\nclass Occur extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"occur\", true);\n    this.id = attributes.id || \"\";\n    this.initial = attributes.initial !== \"\" ? getInteger({\n      data: attributes.initial,\n      defaultValue: \"\",\n      validate: x => true\n    }) : \"\";\n    this.max = attributes.max !== \"\" ? getInteger({\n      data: attributes.max,\n      defaultValue: 1,\n      validate: x => true\n    }) : \"\";\n    this.min = attributes.min !== \"\" ? getInteger({\n      data: attributes.min,\n      defaultValue: 1,\n      validate: x => true\n    }) : \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.extras = null;\n  }\n  [$clean]() {\n    const parent = this[$getParent]();\n    const originalMin = this.min;\n    if (this.min === \"\") {\n      this.min = parent instanceof PageArea || parent instanceof PageSet ? 0 : 1;\n    }\n    if (this.max === \"\") {\n      if (originalMin === \"\") {\n        this.max = parent instanceof PageArea || parent instanceof PageSet ? -1 : 1;\n      } else {\n        this.max = this.min;\n      }\n    }\n    if (this.max !== -1 && this.max < this.min) {\n      this.max = this.min;\n    }\n    if (this.initial === \"\") {\n      this.initial = parent instanceof Template ? 1 : this.min;\n    }\n  }\n}\nclass Oid extends StringObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"oid\");\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass Oids extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"oids\", true);\n    this.id = attributes.id || \"\";\n    this.type = getStringOption(attributes.type, [\"optional\", \"required\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.oid = new XFAObjectArray();\n  }\n}\nclass Overflow extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"overflow\");\n    this.id = attributes.id || \"\";\n    this.leader = attributes.leader || \"\";\n    this.target = attributes.target || \"\";\n    this.trailer = attributes.trailer || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n  [$getExtra]() {\n    if (!this[$extra]) {\n      const parent = this[$getParent]();\n      const root = this[$getTemplateRoot]();\n      const target = root[$searchNode](this.target, parent);\n      const leader = root[$searchNode](this.leader, parent);\n      const trailer = root[$searchNode](this.trailer, parent);\n      this[$extra] = {\n        target: target?.[0] || null,\n        leader: leader?.[0] || null,\n        trailer: trailer?.[0] || null,\n        addLeader: false,\n        addTrailer: false\n      };\n    }\n    return this[$extra];\n  }\n}\nclass PageArea extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"pageArea\", true);\n    this.blankOrNotBlank = getStringOption(attributes.blankOrNotBlank, [\"any\", \"blank\", \"notBlank\"]);\n    this.id = attributes.id || \"\";\n    this.initialNumber = getInteger({\n      data: attributes.initialNumber,\n      defaultValue: 1,\n      validate: x => true\n    });\n    this.name = attributes.name || \"\";\n    this.numbered = getInteger({\n      data: attributes.numbered,\n      defaultValue: 1,\n      validate: x => true\n    });\n    this.oddOrEven = getStringOption(attributes.oddOrEven, [\"any\", \"even\", \"odd\"]);\n    this.pagePosition = getStringOption(attributes.pagePosition, [\"any\", \"first\", \"last\", \"only\", \"rest\"]);\n    this.relevant = getRelevant(attributes.relevant);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.desc = null;\n    this.extras = null;\n    this.medium = null;\n    this.occur = null;\n    this.area = new XFAObjectArray();\n    this.contentArea = new XFAObjectArray();\n    this.draw = new XFAObjectArray();\n    this.exclGroup = new XFAObjectArray();\n    this.field = new XFAObjectArray();\n    this.subform = new XFAObjectArray();\n  }\n  [$isUsable]() {\n    if (!this[$extra]) {\n      this[$extra] = {\n        numberOfUse: 0\n      };\n      return true;\n    }\n    return !this.occur || this.occur.max === -1 || this[$extra].numberOfUse < this.occur.max;\n  }\n  [$cleanPage]() {\n    delete this[$extra];\n  }\n  [$getNextPage]() {\n    if (!this[$extra]) {\n      this[$extra] = {\n        numberOfUse: 0\n      };\n    }\n    const parent = this[$getParent]();\n    if (parent.relation === \"orderedOccurrence\") {\n      if (this[$isUsable]()) {\n        this[$extra].numberOfUse += 1;\n        return this;\n      }\n    }\n    return parent[$getNextPage]();\n  }\n  [$getAvailableSpace]() {\n    return this[$extra].space || {\n      width: 0,\n      height: 0\n    };\n  }\n  [$toHTML]() {\n    if (!this[$extra]) {\n      this[$extra] = {\n        numberOfUse: 1\n      };\n    }\n    const children = [];\n    this[$extra].children = children;\n    const style = Object.create(null);\n    if (this.medium && this.medium.short && this.medium.long) {\n      style.width = measureToString(this.medium.short);\n      style.height = measureToString(this.medium.long);\n      this[$extra].space = {\n        width: this.medium.short,\n        height: this.medium.long\n      };\n      if (this.medium.orientation === \"landscape\") {\n        const x = style.width;\n        style.width = style.height;\n        style.height = x;\n        this[$extra].space = {\n          width: this.medium.long,\n          height: this.medium.short\n        };\n      }\n    } else {\n      warn(\"XFA - No medium specified in pageArea: please file a bug.\");\n    }\n    this[$childrenToHTML]({\n      filter: new Set([\"area\", \"draw\", \"field\", \"subform\"]),\n      include: true\n    });\n    this[$childrenToHTML]({\n      filter: new Set([\"contentArea\"]),\n      include: true\n    });\n    return HTMLResult.success({\n      name: \"div\",\n      children,\n      attributes: {\n        class: [\"xfaPage\"],\n        id: this[$uid],\n        style,\n        xfaName: this.name\n      }\n    });\n  }\n}\nclass PageSet extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"pageSet\", true);\n    this.duplexImposition = getStringOption(attributes.duplexImposition, [\"longEdge\", \"shortEdge\"]);\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.relation = getStringOption(attributes.relation, [\"orderedOccurrence\", \"duplexPaginated\", \"simplexPaginated\"]);\n    this.relevant = getRelevant(attributes.relevant);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.extras = null;\n    this.occur = null;\n    this.pageArea = new XFAObjectArray();\n    this.pageSet = new XFAObjectArray();\n  }\n  [$cleanPage]() {\n    for (const page of this.pageArea.children) {\n      page[$cleanPage]();\n    }\n    for (const page of this.pageSet.children) {\n      page[$cleanPage]();\n    }\n  }\n  [$isUsable]() {\n    return !this.occur || this.occur.max === -1 || this[$extra].numberOfUse < this.occur.max;\n  }\n  [$getNextPage]() {\n    if (!this[$extra]) {\n      this[$extra] = {\n        numberOfUse: 1,\n        pageIndex: -1,\n        pageSetIndex: -1\n      };\n    }\n    if (this.relation === \"orderedOccurrence\") {\n      if (this[$extra].pageIndex + 1 < this.pageArea.children.length) {\n        this[$extra].pageIndex += 1;\n        const pageArea = this.pageArea.children[this[$extra].pageIndex];\n        return pageArea[$getNextPage]();\n      }\n      if (this[$extra].pageSetIndex + 1 < this.pageSet.children.length) {\n        this[$extra].pageSetIndex += 1;\n        return this.pageSet.children[this[$extra].pageSetIndex][$getNextPage]();\n      }\n      if (this[$isUsable]()) {\n        this[$extra].numberOfUse += 1;\n        this[$extra].pageIndex = -1;\n        this[$extra].pageSetIndex = -1;\n        return this[$getNextPage]();\n      }\n      const parent = this[$getParent]();\n      if (parent instanceof PageSet) {\n        return parent[$getNextPage]();\n      }\n      this[$cleanPage]();\n      return this[$getNextPage]();\n    }\n    const pageNumber = this[$getTemplateRoot]()[$extra].pageNumber;\n    const parity = pageNumber % 2 === 0 ? \"even\" : \"odd\";\n    const position = pageNumber === 0 ? \"first\" : \"rest\";\n    let page = this.pageArea.children.find(p => p.oddOrEven === parity && p.pagePosition === position);\n    if (page) {\n      return page;\n    }\n    page = this.pageArea.children.find(p => p.oddOrEven === \"any\" && p.pagePosition === position);\n    if (page) {\n      return page;\n    }\n    page = this.pageArea.children.find(p => p.oddOrEven === \"any\" && p.pagePosition === \"any\");\n    if (page) {\n      return page;\n    }\n    return this.pageArea.children[0];\n  }\n}\nclass Para extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"para\", true);\n    this.hAlign = getStringOption(attributes.hAlign, [\"left\", \"center\", \"justify\", \"justifyAll\", \"radix\", \"right\"]);\n    this.id = attributes.id || \"\";\n    this.lineHeight = attributes.lineHeight ? getMeasurement(attributes.lineHeight, \"0pt\") : \"\";\n    this.marginLeft = attributes.marginLeft ? getMeasurement(attributes.marginLeft, \"0pt\") : \"\";\n    this.marginRight = attributes.marginRight ? getMeasurement(attributes.marginRight, \"0pt\") : \"\";\n    this.orphans = getInteger({\n      data: attributes.orphans,\n      defaultValue: 0,\n      validate: x => x >= 0\n    });\n    this.preserve = attributes.preserve || \"\";\n    this.radixOffset = attributes.radixOffset ? getMeasurement(attributes.radixOffset, \"0pt\") : \"\";\n    this.spaceAbove = attributes.spaceAbove ? getMeasurement(attributes.spaceAbove, \"0pt\") : \"\";\n    this.spaceBelow = attributes.spaceBelow ? getMeasurement(attributes.spaceBelow, \"0pt\") : \"\";\n    this.tabDefault = attributes.tabDefault ? getMeasurement(this.tabDefault) : \"\";\n    this.tabStops = (attributes.tabStops || \"\").trim().split(/\\s+/).map((x, i) => i % 2 === 1 ? getMeasurement(x) : x);\n    this.textIndent = attributes.textIndent ? getMeasurement(attributes.textIndent, \"0pt\") : \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.vAlign = getStringOption(attributes.vAlign, [\"top\", \"bottom\", \"middle\"]);\n    this.widows = getInteger({\n      data: attributes.widows,\n      defaultValue: 0,\n      validate: x => x >= 0\n    });\n    this.hyphenation = null;\n  }\n  [$toStyle]() {\n    const style = toStyle(this, \"hAlign\");\n    if (this.marginLeft !== \"\") {\n      style.paddingLeft = measureToString(this.marginLeft);\n    }\n    if (this.marginRight !== \"\") {\n      style.paddingight = measureToString(this.marginRight);\n    }\n    if (this.spaceAbove !== \"\") {\n      style.paddingTop = measureToString(this.spaceAbove);\n    }\n    if (this.spaceBelow !== \"\") {\n      style.paddingBottom = measureToString(this.spaceBelow);\n    }\n    if (this.textIndent !== \"\") {\n      style.textIndent = measureToString(this.textIndent);\n      fixTextIndent(style);\n    }\n    if (this.lineHeight > 0) {\n      style.lineHeight = measureToString(this.lineHeight);\n    }\n    if (this.tabDefault !== \"\") {\n      style.tabSize = measureToString(this.tabDefault);\n    }\n    if (this.tabStops.length > 0) {}\n    if (this.hyphenatation) {\n      Object.assign(style, this.hyphenatation[$toStyle]());\n    }\n    return style;\n  }\n}\nclass PasswordEdit extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"passwordEdit\", true);\n    this.hScrollPolicy = getStringOption(attributes.hScrollPolicy, [\"auto\", \"off\", \"on\"]);\n    this.id = attributes.id || \"\";\n    this.passwordChar = attributes.passwordChar || \"*\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.border = null;\n    this.extras = null;\n    this.margin = null;\n  }\n}\nclass template_Pattern extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"pattern\", true);\n    this.id = attributes.id || \"\";\n    this.type = getStringOption(attributes.type, [\"crossHatch\", \"crossDiagonal\", \"diagonalLeft\", \"diagonalRight\", \"horizontal\", \"vertical\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.color = null;\n    this.extras = null;\n  }\n  [$toStyle](startColor) {\n    startColor = startColor ? startColor[$toStyle]() : \"#FFFFFF\";\n    const endColor = this.color ? this.color[$toStyle]() : \"#000000\";\n    const width = 5;\n    const cmd = \"repeating-linear-gradient\";\n    const colors = `${startColor},${startColor} ${width}px,${endColor} ${width}px,${endColor} ${2 * width}px`;\n    switch (this.type) {\n      case \"crossHatch\":\n        return `${cmd}(to top,${colors}) ${cmd}(to right,${colors})`;\n      case \"crossDiagonal\":\n        return `${cmd}(45deg,${colors}) ${cmd}(-45deg,${colors})`;\n      case \"diagonalLeft\":\n        return `${cmd}(45deg,${colors})`;\n      case \"diagonalRight\":\n        return `${cmd}(-45deg,${colors})`;\n      case \"horizontal\":\n        return `${cmd}(to top,${colors})`;\n      case \"vertical\":\n        return `${cmd}(to right,${colors})`;\n    }\n    return \"\";\n  }\n}\nclass Picture extends StringObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"picture\");\n    this.id = attributes.id || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass Proto extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"proto\", true);\n    this.appearanceFilter = new XFAObjectArray();\n    this.arc = new XFAObjectArray();\n    this.area = new XFAObjectArray();\n    this.assist = new XFAObjectArray();\n    this.barcode = new XFAObjectArray();\n    this.bindItems = new XFAObjectArray();\n    this.bookend = new XFAObjectArray();\n    this.boolean = new XFAObjectArray();\n    this.border = new XFAObjectArray();\n    this.break = new XFAObjectArray();\n    this.breakAfter = new XFAObjectArray();\n    this.breakBefore = new XFAObjectArray();\n    this.button = new XFAObjectArray();\n    this.calculate = new XFAObjectArray();\n    this.caption = new XFAObjectArray();\n    this.certificate = new XFAObjectArray();\n    this.certificates = new XFAObjectArray();\n    this.checkButton = new XFAObjectArray();\n    this.choiceList = new XFAObjectArray();\n    this.color = new XFAObjectArray();\n    this.comb = new XFAObjectArray();\n    this.connect = new XFAObjectArray();\n    this.contentArea = new XFAObjectArray();\n    this.corner = new XFAObjectArray();\n    this.date = new XFAObjectArray();\n    this.dateTime = new XFAObjectArray();\n    this.dateTimeEdit = new XFAObjectArray();\n    this.decimal = new XFAObjectArray();\n    this.defaultUi = new XFAObjectArray();\n    this.desc = new XFAObjectArray();\n    this.digestMethod = new XFAObjectArray();\n    this.digestMethods = new XFAObjectArray();\n    this.draw = new XFAObjectArray();\n    this.edge = new XFAObjectArray();\n    this.encoding = new XFAObjectArray();\n    this.encodings = new XFAObjectArray();\n    this.encrypt = new XFAObjectArray();\n    this.encryptData = new XFAObjectArray();\n    this.encryption = new XFAObjectArray();\n    this.encryptionMethod = new XFAObjectArray();\n    this.encryptionMethods = new XFAObjectArray();\n    this.event = new XFAObjectArray();\n    this.exData = new XFAObjectArray();\n    this.exObject = new XFAObjectArray();\n    this.exclGroup = new XFAObjectArray();\n    this.execute = new XFAObjectArray();\n    this.extras = new XFAObjectArray();\n    this.field = new XFAObjectArray();\n    this.fill = new XFAObjectArray();\n    this.filter = new XFAObjectArray();\n    this.float = new XFAObjectArray();\n    this.font = new XFAObjectArray();\n    this.format = new XFAObjectArray();\n    this.handler = new XFAObjectArray();\n    this.hyphenation = new XFAObjectArray();\n    this.image = new XFAObjectArray();\n    this.imageEdit = new XFAObjectArray();\n    this.integer = new XFAObjectArray();\n    this.issuers = new XFAObjectArray();\n    this.items = new XFAObjectArray();\n    this.keep = new XFAObjectArray();\n    this.keyUsage = new XFAObjectArray();\n    this.line = new XFAObjectArray();\n    this.linear = new XFAObjectArray();\n    this.lockDocument = new XFAObjectArray();\n    this.manifest = new XFAObjectArray();\n    this.margin = new XFAObjectArray();\n    this.mdp = new XFAObjectArray();\n    this.medium = new XFAObjectArray();\n    this.message = new XFAObjectArray();\n    this.numericEdit = new XFAObjectArray();\n    this.occur = new XFAObjectArray();\n    this.oid = new XFAObjectArray();\n    this.oids = new XFAObjectArray();\n    this.overflow = new XFAObjectArray();\n    this.pageArea = new XFAObjectArray();\n    this.pageSet = new XFAObjectArray();\n    this.para = new XFAObjectArray();\n    this.passwordEdit = new XFAObjectArray();\n    this.pattern = new XFAObjectArray();\n    this.picture = new XFAObjectArray();\n    this.radial = new XFAObjectArray();\n    this.reason = new XFAObjectArray();\n    this.reasons = new XFAObjectArray();\n    this.rectangle = new XFAObjectArray();\n    this.ref = new XFAObjectArray();\n    this.script = new XFAObjectArray();\n    this.setProperty = new XFAObjectArray();\n    this.signData = new XFAObjectArray();\n    this.signature = new XFAObjectArray();\n    this.signing = new XFAObjectArray();\n    this.solid = new XFAObjectArray();\n    this.speak = new XFAObjectArray();\n    this.stipple = new XFAObjectArray();\n    this.subform = new XFAObjectArray();\n    this.subformSet = new XFAObjectArray();\n    this.subjectDN = new XFAObjectArray();\n    this.subjectDNs = new XFAObjectArray();\n    this.submit = new XFAObjectArray();\n    this.text = new XFAObjectArray();\n    this.textEdit = new XFAObjectArray();\n    this.time = new XFAObjectArray();\n    this.timeStamp = new XFAObjectArray();\n    this.toolTip = new XFAObjectArray();\n    this.traversal = new XFAObjectArray();\n    this.traverse = new XFAObjectArray();\n    this.ui = new XFAObjectArray();\n    this.validate = new XFAObjectArray();\n    this.value = new XFAObjectArray();\n    this.variables = new XFAObjectArray();\n  }\n}\nclass Radial extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"radial\", true);\n    this.id = attributes.id || \"\";\n    this.type = getStringOption(attributes.type, [\"toEdge\", \"toCenter\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.color = null;\n    this.extras = null;\n  }\n  [$toStyle](startColor) {\n    startColor = startColor ? startColor[$toStyle]() : \"#FFFFFF\";\n    const endColor = this.color ? this.color[$toStyle]() : \"#000000\";\n    const colors = this.type === \"toEdge\" ? `${startColor},${endColor}` : `${endColor},${startColor}`;\n    return `radial-gradient(circle at center, ${colors})`;\n  }\n}\nclass Reason extends StringObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"reason\");\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass Reasons extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"reasons\", true);\n    this.id = attributes.id || \"\";\n    this.type = getStringOption(attributes.type, [\"optional\", \"required\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.reason = new XFAObjectArray();\n  }\n}\nclass Rectangle extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"rectangle\", true);\n    this.hand = getStringOption(attributes.hand, [\"even\", \"left\", \"right\"]);\n    this.id = attributes.id || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.corner = new XFAObjectArray(4);\n    this.edge = new XFAObjectArray(4);\n    this.fill = null;\n  }\n  [$toHTML]() {\n    const edge = this.edge.children.length ? this.edge.children[0] : new Edge({});\n    const edgeStyle = edge[$toStyle]();\n    const style = Object.create(null);\n    if (this.fill?.presence === \"visible\") {\n      Object.assign(style, this.fill[$toStyle]());\n    } else {\n      style.fill = \"transparent\";\n    }\n    style.strokeWidth = measureToString(edge.presence === \"visible\" ? edge.thickness : 0);\n    style.stroke = edgeStyle.color;\n    const corner = this.corner.children.length ? this.corner.children[0] : new Corner({});\n    const cornerStyle = corner[$toStyle]();\n    const rect = {\n      name: \"rect\",\n      attributes: {\n        xmlns: SVG_NS,\n        width: \"100%\",\n        height: \"100%\",\n        x: 0,\n        y: 0,\n        rx: cornerStyle.radius,\n        ry: cornerStyle.radius,\n        style\n      }\n    };\n    const svg = {\n      name: \"svg\",\n      children: [rect],\n      attributes: {\n        xmlns: SVG_NS,\n        style: {\n          overflow: \"visible\"\n        },\n        width: \"100%\",\n        height: \"100%\"\n      }\n    };\n    const parent = this[$getParent]()[$getParent]();\n    if (hasMargin(parent)) {\n      return HTMLResult.success({\n        name: \"div\",\n        attributes: {\n          style: {\n            display: \"inline\",\n            width: \"100%\",\n            height: \"100%\"\n          }\n        },\n        children: [svg]\n      });\n    }\n    svg.attributes.style.position = \"absolute\";\n    return HTMLResult.success(svg);\n  }\n}\nclass RefElement extends StringObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"ref\");\n    this.id = attributes.id || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass Script extends StringObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"script\");\n    this.binding = attributes.binding || \"\";\n    this.contentType = attributes.contentType || \"\";\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.runAt = getStringOption(attributes.runAt, [\"client\", \"both\", \"server\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass SetProperty extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"setProperty\");\n    this.connection = attributes.connection || \"\";\n    this.ref = attributes.ref || \"\";\n    this.target = attributes.target || \"\";\n  }\n}\nclass SignData extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"signData\", true);\n    this.id = attributes.id || \"\";\n    this.operation = getStringOption(attributes.operation, [\"sign\", \"clear\", \"verify\"]);\n    this.ref = attributes.ref || \"\";\n    this.target = attributes.target || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.filter = null;\n    this.manifest = null;\n  }\n}\nclass Signature extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"signature\", true);\n    this.id = attributes.id || \"\";\n    this.type = getStringOption(attributes.type, [\"PDF1.3\", \"PDF1.6\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.border = null;\n    this.extras = null;\n    this.filter = null;\n    this.manifest = null;\n    this.margin = null;\n  }\n}\nclass Signing extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"signing\", true);\n    this.id = attributes.id || \"\";\n    this.type = getStringOption(attributes.type, [\"optional\", \"required\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.certificate = new XFAObjectArray();\n  }\n}\nclass Solid extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"solid\", true);\n    this.id = attributes.id || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.extras = null;\n  }\n  [$toStyle](startColor) {\n    return startColor ? startColor[$toStyle]() : \"#FFFFFF\";\n  }\n}\nclass Speak extends StringObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"speak\");\n    this.disable = getInteger({\n      data: attributes.disable,\n      defaultValue: 0,\n      validate: x => x === 1\n    });\n    this.id = attributes.id || \"\";\n    this.priority = getStringOption(attributes.priority, [\"custom\", \"caption\", \"name\", \"toolTip\"]);\n    this.rid = attributes.rid || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass Stipple extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"stipple\", true);\n    this.id = attributes.id || \"\";\n    this.rate = getInteger({\n      data: attributes.rate,\n      defaultValue: 50,\n      validate: x => x >= 0 && x <= 100\n    });\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.color = null;\n    this.extras = null;\n  }\n  [$toStyle](bgColor) {\n    const alpha = this.rate / 100;\n    return Util.makeHexColor(Math.round(bgColor.value.r * (1 - alpha) + this.value.r * alpha), Math.round(bgColor.value.g * (1 - alpha) + this.value.g * alpha), Math.round(bgColor.value.b * (1 - alpha) + this.value.b * alpha));\n  }\n}\nclass Subform extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"subform\", true);\n    this.access = getStringOption(attributes.access, [\"open\", \"nonInteractive\", \"protected\", \"readOnly\"]);\n    this.allowMacro = getInteger({\n      data: attributes.allowMacro,\n      defaultValue: 0,\n      validate: x => x === 1\n    });\n    this.anchorType = getStringOption(attributes.anchorType, [\"topLeft\", \"bottomCenter\", \"bottomLeft\", \"bottomRight\", \"middleCenter\", \"middleLeft\", \"middleRight\", \"topCenter\", \"topRight\"]);\n    this.colSpan = getInteger({\n      data: attributes.colSpan,\n      defaultValue: 1,\n      validate: n => n >= 1 || n === -1\n    });\n    this.columnWidths = (attributes.columnWidths || \"\").trim().split(/\\s+/).map(x => x === \"-1\" ? -1 : getMeasurement(x));\n    this.h = attributes.h ? getMeasurement(attributes.h) : \"\";\n    this.hAlign = getStringOption(attributes.hAlign, [\"left\", \"center\", \"justify\", \"justifyAll\", \"radix\", \"right\"]);\n    this.id = attributes.id || \"\";\n    this.layout = getStringOption(attributes.layout, [\"position\", \"lr-tb\", \"rl-row\", \"rl-tb\", \"row\", \"table\", \"tb\"]);\n    this.locale = attributes.locale || \"\";\n    this.maxH = getMeasurement(attributes.maxH, \"0pt\");\n    this.maxW = getMeasurement(attributes.maxW, \"0pt\");\n    this.mergeMode = getStringOption(attributes.mergeMode, [\"consumeData\", \"matchTemplate\"]);\n    this.minH = getMeasurement(attributes.minH, \"0pt\");\n    this.minW = getMeasurement(attributes.minW, \"0pt\");\n    this.name = attributes.name || \"\";\n    this.presence = getStringOption(attributes.presence, [\"visible\", \"hidden\", \"inactive\", \"invisible\"]);\n    this.relevant = getRelevant(attributes.relevant);\n    this.restoreState = getStringOption(attributes.restoreState, [\"manual\", \"auto\"]);\n    this.scope = getStringOption(attributes.scope, [\"name\", \"none\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.w = attributes.w ? getMeasurement(attributes.w) : \"\";\n    this.x = getMeasurement(attributes.x, \"0pt\");\n    this.y = getMeasurement(attributes.y, \"0pt\");\n    this.assist = null;\n    this.bind = null;\n    this.bookend = null;\n    this.border = null;\n    this.break = null;\n    this.calculate = null;\n    this.desc = null;\n    this.extras = null;\n    this.keep = null;\n    this.margin = null;\n    this.occur = null;\n    this.overflow = null;\n    this.pageSet = null;\n    this.para = null;\n    this.traversal = null;\n    this.validate = null;\n    this.variables = null;\n    this.area = new XFAObjectArray();\n    this.breakAfter = new XFAObjectArray();\n    this.breakBefore = new XFAObjectArray();\n    this.connect = new XFAObjectArray();\n    this.draw = new XFAObjectArray();\n    this.event = new XFAObjectArray();\n    this.exObject = new XFAObjectArray();\n    this.exclGroup = new XFAObjectArray();\n    this.field = new XFAObjectArray();\n    this.proto = new XFAObjectArray();\n    this.setProperty = new XFAObjectArray();\n    this.subform = new XFAObjectArray();\n    this.subformSet = new XFAObjectArray();\n  }\n  [$getSubformParent]() {\n    const parent = this[$getParent]();\n    if (parent instanceof SubformSet) {\n      return parent[$getSubformParent]();\n    }\n    return parent;\n  }\n  [$isBindable]() {\n    return true;\n  }\n  [$isThereMoreWidth]() {\n    return this.layout.endsWith(\"-tb\") && this[$extra].attempt === 0 && this[$extra].numberInLine > 0 || this[$getParent]()[$isThereMoreWidth]();\n  }\n  *[$getContainedChildren]() {\n    yield* getContainedChildren(this);\n  }\n  [$flushHTML]() {\n    return flushHTML(this);\n  }\n  [$addHTML](html, bbox) {\n    addHTML(this, html, bbox);\n  }\n  [$getAvailableSpace]() {\n    return getAvailableSpace(this);\n  }\n  [$isSplittable]() {\n    const parent = this[$getSubformParent]();\n    if (!parent[$isSplittable]()) {\n      return false;\n    }\n    if (this[$extra]._isSplittable !== undefined) {\n      return this[$extra]._isSplittable;\n    }\n    if (this.layout === \"position\" || this.layout.includes(\"row\")) {\n      this[$extra]._isSplittable = false;\n      return false;\n    }\n    if (this.keep && this.keep.intact !== \"none\") {\n      this[$extra]._isSplittable = false;\n      return false;\n    }\n    if (parent.layout?.endsWith(\"-tb\") && parent[$extra].numberInLine !== 0) {\n      return false;\n    }\n    this[$extra]._isSplittable = true;\n    return true;\n  }\n  [$toHTML](availableSpace) {\n    setTabIndex(this);\n    if (this.break) {\n      if (this.break.after !== \"auto\" || this.break.afterTarget !== \"\") {\n        const node = new BreakAfter({\n          targetType: this.break.after,\n          target: this.break.afterTarget,\n          startNew: this.break.startNew.toString()\n        });\n        node[$globalData] = this[$globalData];\n        this[$appendChild](node);\n        this.breakAfter.push(node);\n      }\n      if (this.break.before !== \"auto\" || this.break.beforeTarget !== \"\") {\n        const node = new BreakBefore({\n          targetType: this.break.before,\n          target: this.break.beforeTarget,\n          startNew: this.break.startNew.toString()\n        });\n        node[$globalData] = this[$globalData];\n        this[$appendChild](node);\n        this.breakBefore.push(node);\n      }\n      if (this.break.overflowTarget !== \"\") {\n        const node = new Overflow({\n          target: this.break.overflowTarget,\n          leader: this.break.overflowLeader,\n          trailer: this.break.overflowTrailer\n        });\n        node[$globalData] = this[$globalData];\n        this[$appendChild](node);\n        this.overflow.push(node);\n      }\n      this[$removeChild](this.break);\n      this.break = null;\n    }\n    if (this.presence === \"hidden\" || this.presence === \"inactive\") {\n      return HTMLResult.EMPTY;\n    }\n    if (this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) {\n      warn(\"XFA - Several breakBefore or breakAfter in subforms: please file a bug.\");\n    }\n    if (this.breakBefore.children.length >= 1) {\n      const breakBefore = this.breakBefore.children[0];\n      if (handleBreak(breakBefore)) {\n        return HTMLResult.breakNode(breakBefore);\n      }\n    }\n    if (this[$extra]?.afterBreakAfter) {\n      return HTMLResult.EMPTY;\n    }\n    fixDimensions(this);\n    const children = [];\n    const attributes = {\n      id: this[$uid],\n      class: []\n    };\n    setAccess(this, attributes.class);\n    if (!this[$extra]) {\n      this[$extra] = Object.create(null);\n    }\n    Object.assign(this[$extra], {\n      children,\n      line: null,\n      attributes,\n      attempt: 0,\n      numberInLine: 0,\n      availableSpace: {\n        width: Math.min(this.w || Infinity, availableSpace.width),\n        height: Math.min(this.h || Infinity, availableSpace.height)\n      },\n      width: 0,\n      height: 0,\n      prevHeight: 0,\n      currentWidth: 0\n    });\n    const root = this[$getTemplateRoot]();\n    const savedNoLayoutFailure = root[$extra].noLayoutFailure;\n    const isSplittable = this[$isSplittable]();\n    if (!isSplittable) {\n      setFirstUnsplittable(this);\n    }\n    if (!checkDimensions(this, availableSpace)) {\n      return HTMLResult.FAILURE;\n    }\n    const filter = new Set([\"area\", \"draw\", \"exclGroup\", \"field\", \"subform\", \"subformSet\"]);\n    if (this.layout.includes(\"row\")) {\n      const columnWidths = this[$getSubformParent]().columnWidths;\n      if (Array.isArray(columnWidths) && columnWidths.length > 0) {\n        this[$extra].columnWidths = columnWidths;\n        this[$extra].currentColumn = 0;\n      }\n    }\n    const style = toStyle(this, \"anchorType\", \"dimensions\", \"position\", \"presence\", \"border\", \"margin\", \"hAlign\");\n    const classNames = [\"xfaSubform\"];\n    const cl = layoutClass(this);\n    if (cl) {\n      classNames.push(cl);\n    }\n    attributes.style = style;\n    attributes.class = classNames;\n    if (this.name) {\n      attributes.xfaName = this.name;\n    }\n    if (this.overflow) {\n      const overflowExtra = this.overflow[$getExtra]();\n      if (overflowExtra.addLeader) {\n        overflowExtra.addLeader = false;\n        handleOverflow(this, overflowExtra.leader, availableSpace);\n      }\n    }\n    this[$pushPara]();\n    const isLrTb = this.layout === \"lr-tb\" || this.layout === \"rl-tb\";\n    const maxRun = isLrTb ? MAX_ATTEMPTS_FOR_LRTB_LAYOUT : 1;\n    for (; this[$extra].attempt < maxRun; this[$extra].attempt++) {\n      if (isLrTb && this[$extra].attempt === MAX_ATTEMPTS_FOR_LRTB_LAYOUT - 1) {\n        this[$extra].numberInLine = 0;\n      }\n      const result = this[$childrenToHTML]({\n        filter,\n        include: true\n      });\n      if (result.success) {\n        break;\n      }\n      if (result.isBreak()) {\n        this[$popPara]();\n        return result;\n      }\n      if (isLrTb && this[$extra].attempt === 0 && this[$extra].numberInLine === 0 && !root[$extra].noLayoutFailure) {\n        this[$extra].attempt = maxRun;\n        break;\n      }\n    }\n    this[$popPara]();\n    if (!isSplittable) {\n      unsetFirstUnsplittable(this);\n    }\n    root[$extra].noLayoutFailure = savedNoLayoutFailure;\n    if (this[$extra].attempt === maxRun) {\n      if (this.overflow) {\n        this[$getTemplateRoot]()[$extra].overflowNode = this.overflow;\n      }\n      if (!isSplittable) {\n        delete this[$extra];\n      }\n      return HTMLResult.FAILURE;\n    }\n    if (this.overflow) {\n      const overflowExtra = this.overflow[$getExtra]();\n      if (overflowExtra.addTrailer) {\n        overflowExtra.addTrailer = false;\n        handleOverflow(this, overflowExtra.trailer, availableSpace);\n      }\n    }\n    let marginH = 0;\n    let marginV = 0;\n    if (this.margin) {\n      marginH = this.margin.leftInset + this.margin.rightInset;\n      marginV = this.margin.topInset + this.margin.bottomInset;\n    }\n    const width = Math.max(this[$extra].width + marginH, this.w || 0);\n    const height = Math.max(this[$extra].height + marginV, this.h || 0);\n    const bbox = [this.x, this.y, width, height];\n    if (this.w === \"\") {\n      style.width = measureToString(width);\n    }\n    if (this.h === \"\") {\n      style.height = measureToString(height);\n    }\n    if ((style.width === \"0px\" || style.height === \"0px\") && children.length === 0) {\n      return HTMLResult.EMPTY;\n    }\n    const html = {\n      name: \"div\",\n      attributes,\n      children\n    };\n    applyAssist(this, attributes);\n    const result = HTMLResult.success(createWrapper(this, html), bbox);\n    if (this.breakAfter.children.length >= 1) {\n      const breakAfter = this.breakAfter.children[0];\n      if (handleBreak(breakAfter)) {\n        this[$extra].afterBreakAfter = result;\n        return HTMLResult.breakNode(breakAfter);\n      }\n    }\n    delete this[$extra];\n    return result;\n  }\n}\nclass SubformSet extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"subformSet\", true);\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.relation = getStringOption(attributes.relation, [\"ordered\", \"choice\", \"unordered\"]);\n    this.relevant = getRelevant(attributes.relevant);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.bookend = null;\n    this.break = null;\n    this.desc = null;\n    this.extras = null;\n    this.occur = null;\n    this.overflow = null;\n    this.breakAfter = new XFAObjectArray();\n    this.breakBefore = new XFAObjectArray();\n    this.subform = new XFAObjectArray();\n    this.subformSet = new XFAObjectArray();\n  }\n  *[$getContainedChildren]() {\n    yield* getContainedChildren(this);\n  }\n  [$getSubformParent]() {\n    let parent = this[$getParent]();\n    while (!(parent instanceof Subform)) {\n      parent = parent[$getParent]();\n    }\n    return parent;\n  }\n  [$isBindable]() {\n    return true;\n  }\n}\nclass SubjectDN extends ContentObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"subjectDN\");\n    this.delimiter = attributes.delimiter || \",\";\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n  [$finalize]() {\n    this[$content] = new Map(this[$content].split(this.delimiter).map(kv => {\n      kv = kv.split(\"=\", 2);\n      kv[0] = kv[0].trim();\n      return kv;\n    }));\n  }\n}\nclass SubjectDNs extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"subjectDNs\", true);\n    this.id = attributes.id || \"\";\n    this.type = getStringOption(attributes.type, [\"optional\", \"required\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.subjectDN = new XFAObjectArray();\n  }\n}\nclass Submit extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"submit\", true);\n    this.embedPDF = getInteger({\n      data: attributes.embedPDF,\n      defaultValue: 0,\n      validate: x => x === 1\n    });\n    this.format = getStringOption(attributes.format, [\"xdp\", \"formdata\", \"pdf\", \"urlencoded\", \"xfd\", \"xml\"]);\n    this.id = attributes.id || \"\";\n    this.target = attributes.target || \"\";\n    this.textEncoding = getKeyword({\n      data: attributes.textEncoding ? attributes.textEncoding.toLowerCase() : \"\",\n      defaultValue: \"\",\n      validate: k => [\"utf-8\", \"big-five\", \"fontspecific\", \"gbk\", \"gb-18030\", \"gb-2312\", \"ksc-5601\", \"none\", \"shift-jis\", \"ucs-2\", \"utf-16\"].includes(k) || k.match(/iso-8859-\\d{2}/)\n    });\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.xdpContent = attributes.xdpContent || \"\";\n    this.encrypt = null;\n    this.encryptData = new XFAObjectArray();\n    this.signData = new XFAObjectArray();\n  }\n}\nclass Template extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"template\", true);\n    this.baseProfile = getStringOption(attributes.baseProfile, [\"full\", \"interactiveForms\"]);\n    this.extras = null;\n    this.subform = new XFAObjectArray();\n  }\n  [$finalize]() {\n    if (this.subform.children.length === 0) {\n      warn(\"XFA - No subforms in template node.\");\n    }\n    if (this.subform.children.length >= 2) {\n      warn(\"XFA - Several subforms in template node: please file a bug.\");\n    }\n    this[$tabIndex] = DEFAULT_TAB_INDEX;\n  }\n  [$isSplittable]() {\n    return true;\n  }\n  [$searchNode](expr, container) {\n    if (expr.startsWith(\"#\")) {\n      return [this[$ids].get(expr.slice(1))];\n    }\n    return searchNode(this, container, expr, true, true);\n  }\n  *[$toPages]() {\n    if (!this.subform.children.length) {\n      return HTMLResult.success({\n        name: \"div\",\n        children: []\n      });\n    }\n    this[$extra] = {\n      overflowNode: null,\n      firstUnsplittable: null,\n      currentContentArea: null,\n      currentPageArea: null,\n      noLayoutFailure: false,\n      pageNumber: 1,\n      pagePosition: \"first\",\n      oddOrEven: \"odd\",\n      blankOrNotBlank: \"nonBlank\",\n      paraStack: []\n    };\n    const root = this.subform.children[0];\n    root.pageSet[$cleanPage]();\n    const pageAreas = root.pageSet.pageArea.children;\n    const mainHtml = {\n      name: \"div\",\n      children: []\n    };\n    let pageArea = null;\n    let breakBefore = null;\n    let breakBeforeTarget = null;\n    if (root.breakBefore.children.length >= 1) {\n      breakBefore = root.breakBefore.children[0];\n      breakBeforeTarget = breakBefore.target;\n    } else if (root.subform.children.length >= 1 && root.subform.children[0].breakBefore.children.length >= 1) {\n      breakBefore = root.subform.children[0].breakBefore.children[0];\n      breakBeforeTarget = breakBefore.target;\n    } else if (root.break?.beforeTarget) {\n      breakBefore = root.break;\n      breakBeforeTarget = breakBefore.beforeTarget;\n    } else if (root.subform.children.length >= 1 && root.subform.children[0].break?.beforeTarget) {\n      breakBefore = root.subform.children[0].break;\n      breakBeforeTarget = breakBefore.beforeTarget;\n    }\n    if (breakBefore) {\n      const target = this[$searchNode](breakBeforeTarget, breakBefore[$getParent]());\n      if (target instanceof PageArea) {\n        pageArea = target;\n        breakBefore[$extra] = {};\n      }\n    }\n    if (!pageArea) {\n      pageArea = pageAreas[0];\n    }\n    pageArea[$extra] = {\n      numberOfUse: 1\n    };\n    const pageAreaParent = pageArea[$getParent]();\n    pageAreaParent[$extra] = {\n      numberOfUse: 1,\n      pageIndex: pageAreaParent.pageArea.children.indexOf(pageArea),\n      pageSetIndex: 0\n    };\n    let targetPageArea;\n    let leader = null;\n    let trailer = null;\n    let hasSomething = true;\n    let hasSomethingCounter = 0;\n    let startIndex = 0;\n    while (true) {\n      if (!hasSomething) {\n        mainHtml.children.pop();\n        if (++hasSomethingCounter === MAX_EMPTY_PAGES) {\n          warn(\"XFA - Something goes wrong: please file a bug.\");\n          return mainHtml;\n        }\n      } else {\n        hasSomethingCounter = 0;\n      }\n      targetPageArea = null;\n      this[$extra].currentPageArea = pageArea;\n      const page = pageArea[$toHTML]().html;\n      mainHtml.children.push(page);\n      if (leader) {\n        this[$extra].noLayoutFailure = true;\n        page.children.push(leader[$toHTML](pageArea[$extra].space).html);\n        leader = null;\n      }\n      if (trailer) {\n        this[$extra].noLayoutFailure = true;\n        page.children.push(trailer[$toHTML](pageArea[$extra].space).html);\n        trailer = null;\n      }\n      const contentAreas = pageArea.contentArea.children;\n      const htmlContentAreas = page.children.filter(node => node.attributes.class.includes(\"xfaContentarea\"));\n      hasSomething = false;\n      this[$extra].firstUnsplittable = null;\n      this[$extra].noLayoutFailure = false;\n      const flush = index => {\n        const html = root[$flushHTML]();\n        if (html) {\n          hasSomething ||= html.children?.length > 0;\n          htmlContentAreas[index].children.push(html);\n        }\n      };\n      for (let i = startIndex, ii = contentAreas.length; i < ii; i++) {\n        const contentArea = this[$extra].currentContentArea = contentAreas[i];\n        const space = {\n          width: contentArea.w,\n          height: contentArea.h\n        };\n        startIndex = 0;\n        if (leader) {\n          htmlContentAreas[i].children.push(leader[$toHTML](space).html);\n          leader = null;\n        }\n        if (trailer) {\n          htmlContentAreas[i].children.push(trailer[$toHTML](space).html);\n          trailer = null;\n        }\n        const html = root[$toHTML](space);\n        if (html.success) {\n          if (html.html) {\n            hasSomething ||= html.html.children?.length > 0;\n            htmlContentAreas[i].children.push(html.html);\n          } else if (!hasSomething && mainHtml.children.length > 1) {\n            mainHtml.children.pop();\n          }\n          return mainHtml;\n        }\n        if (html.isBreak()) {\n          const node = html.breakNode;\n          flush(i);\n          if (node.targetType === \"auto\") {\n            continue;\n          }\n          if (node.leader) {\n            leader = this[$searchNode](node.leader, node[$getParent]());\n            leader = leader ? leader[0] : null;\n          }\n          if (node.trailer) {\n            trailer = this[$searchNode](node.trailer, node[$getParent]());\n            trailer = trailer ? trailer[0] : null;\n          }\n          if (node.targetType === \"pageArea\") {\n            targetPageArea = node[$extra].target;\n            i = Infinity;\n          } else if (!node[$extra].target) {\n            i = node[$extra].index;\n          } else {\n            targetPageArea = node[$extra].target;\n            startIndex = node[$extra].index + 1;\n            i = Infinity;\n          }\n          continue;\n        }\n        if (this[$extra].overflowNode) {\n          const node = this[$extra].overflowNode;\n          this[$extra].overflowNode = null;\n          const overflowExtra = node[$getExtra]();\n          const target = overflowExtra.target;\n          overflowExtra.addLeader = overflowExtra.leader !== null;\n          overflowExtra.addTrailer = overflowExtra.trailer !== null;\n          flush(i);\n          const currentIndex = i;\n          i = Infinity;\n          if (target instanceof PageArea) {\n            targetPageArea = target;\n          } else if (target instanceof ContentArea) {\n            const index = contentAreas.indexOf(target);\n            if (index !== -1) {\n              if (index > currentIndex) {\n                i = index - 1;\n              } else {\n                startIndex = index;\n              }\n            } else {\n              targetPageArea = target[$getParent]();\n              startIndex = targetPageArea.contentArea.children.indexOf(target);\n            }\n          }\n          continue;\n        }\n        flush(i);\n      }\n      this[$extra].pageNumber += 1;\n      if (targetPageArea) {\n        if (targetPageArea[$isUsable]()) {\n          targetPageArea[$extra].numberOfUse += 1;\n        } else {\n          targetPageArea = null;\n        }\n      }\n      pageArea = targetPageArea || pageArea[$getNextPage]();\n      yield null;\n    }\n  }\n}\nclass Text extends ContentObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"text\");\n    this.id = attributes.id || \"\";\n    this.maxChars = getInteger({\n      data: attributes.maxChars,\n      defaultValue: 0,\n      validate: x => x >= 0\n    });\n    this.name = attributes.name || \"\";\n    this.rid = attributes.rid || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n  [$acceptWhitespace]() {\n    return true;\n  }\n  [$onChild](child) {\n    if (child[$namespaceId] === NamespaceIds.xhtml.id) {\n      this[$content] = child;\n      return true;\n    }\n    warn(`XFA - Invalid content in Text: ${child[$nodeName]}.`);\n    return false;\n  }\n  [$onText](str) {\n    if (this[$content] instanceof XFAObject) {\n      return;\n    }\n    super[$onText](str);\n  }\n  [$finalize]() {\n    if (typeof this[$content] === \"string\") {\n      this[$content] = this[$content].replaceAll(\"\\r\\n\", \"\\n\");\n    }\n  }\n  [$getExtra]() {\n    if (typeof this[$content] === \"string\") {\n      return this[$content].split(/[\\u2029\\u2028\\n]/).reduce((acc, line) => {\n        if (line) {\n          acc.push(line);\n        }\n        return acc;\n      }, []).join(\"\\n\");\n    }\n    return this[$content][$text]();\n  }\n  [$toHTML](availableSpace) {\n    if (typeof this[$content] === \"string\") {\n      const html = valueToHtml(this[$content]).html;\n      if (this[$content].includes(\"\\u2029\")) {\n        html.name = \"div\";\n        html.children = [];\n        this[$content].split(\"\\u2029\").map(para => para.split(/[\\u2028\\n]/).reduce((acc, line) => {\n          acc.push({\n            name: \"span\",\n            value: line\n          }, {\n            name: \"br\"\n          });\n          return acc;\n        }, [])).forEach(lines => {\n          html.children.push({\n            name: \"p\",\n            children: lines\n          });\n        });\n      } else if (/[\\u2028\\n]/.test(this[$content])) {\n        html.name = \"div\";\n        html.children = [];\n        this[$content].split(/[\\u2028\\n]/).forEach(line => {\n          html.children.push({\n            name: \"span\",\n            value: line\n          }, {\n            name: \"br\"\n          });\n        });\n      }\n      return HTMLResult.success(html);\n    }\n    return this[$content][$toHTML](availableSpace);\n  }\n}\nclass TextEdit extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"textEdit\", true);\n    this.allowRichText = getInteger({\n      data: attributes.allowRichText,\n      defaultValue: 0,\n      validate: x => x === 1\n    });\n    this.hScrollPolicy = getStringOption(attributes.hScrollPolicy, [\"auto\", \"off\", \"on\"]);\n    this.id = attributes.id || \"\";\n    this.multiLine = getInteger({\n      data: attributes.multiLine,\n      defaultValue: \"\",\n      validate: x => x === 0 || x === 1\n    });\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.vScrollPolicy = getStringOption(attributes.vScrollPolicy, [\"auto\", \"off\", \"on\"]);\n    this.border = null;\n    this.comb = null;\n    this.extras = null;\n    this.margin = null;\n  }\n  [$toHTML](availableSpace) {\n    const style = toStyle(this, \"border\", \"font\", \"margin\");\n    let html;\n    const field = this[$getParent]()[$getParent]();\n    if (this.multiLine === \"\") {\n      this.multiLine = field instanceof Draw ? 1 : 0;\n    }\n    if (this.multiLine === 1) {\n      html = {\n        name: \"textarea\",\n        attributes: {\n          dataId: field[$data]?.[$uid] || field[$uid],\n          fieldId: field[$uid],\n          class: [\"xfaTextfield\"],\n          style,\n          \"aria-label\": ariaLabel(field),\n          \"aria-required\": false\n        }\n      };\n    } else {\n      html = {\n        name: \"input\",\n        attributes: {\n          type: \"text\",\n          dataId: field[$data]?.[$uid] || field[$uid],\n          fieldId: field[$uid],\n          class: [\"xfaTextfield\"],\n          style,\n          \"aria-label\": ariaLabel(field),\n          \"aria-required\": false\n        }\n      };\n    }\n    if (isRequired(field)) {\n      html.attributes[\"aria-required\"] = true;\n      html.attributes.required = true;\n    }\n    return HTMLResult.success({\n      name: \"label\",\n      attributes: {\n        class: [\"xfaLabel\"]\n      },\n      children: [html]\n    });\n  }\n}\nclass Time extends StringObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"time\");\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n  [$finalize]() {\n    const date = this[$content].trim();\n    this[$content] = date ? new Date(date) : null;\n  }\n  [$toHTML](availableSpace) {\n    return valueToHtml(this[$content] ? this[$content].toString() : \"\");\n  }\n}\nclass TimeStamp extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"timeStamp\");\n    this.id = attributes.id || \"\";\n    this.server = attributes.server || \"\";\n    this.type = getStringOption(attributes.type, [\"optional\", \"required\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass ToolTip extends StringObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"toolTip\");\n    this.id = attributes.id || \"\";\n    this.rid = attributes.rid || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass Traversal extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"traversal\", true);\n    this.id = attributes.id || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.extras = null;\n    this.traverse = new XFAObjectArray();\n  }\n}\nclass Traverse extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"traverse\", true);\n    this.id = attributes.id || \"\";\n    this.operation = getStringOption(attributes.operation, [\"next\", \"back\", \"down\", \"first\", \"left\", \"right\", \"up\"]);\n    this.ref = attributes.ref || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.extras = null;\n    this.script = null;\n  }\n  get name() {\n    return this.operation;\n  }\n  [$isTransparent]() {\n    return false;\n  }\n}\nclass Ui extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"ui\", true);\n    this.id = attributes.id || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.extras = null;\n    this.picture = null;\n    this.barcode = null;\n    this.button = null;\n    this.checkButton = null;\n    this.choiceList = null;\n    this.dateTimeEdit = null;\n    this.defaultUi = null;\n    this.imageEdit = null;\n    this.numericEdit = null;\n    this.passwordEdit = null;\n    this.signature = null;\n    this.textEdit = null;\n  }\n  [$getExtra]() {\n    if (this[$extra] === undefined) {\n      for (const name of Object.getOwnPropertyNames(this)) {\n        if (name === \"extras\" || name === \"picture\") {\n          continue;\n        }\n        const obj = this[name];\n        if (!(obj instanceof XFAObject)) {\n          continue;\n        }\n        this[$extra] = obj;\n        return obj;\n      }\n      this[$extra] = null;\n    }\n    return this[$extra];\n  }\n  [$toHTML](availableSpace) {\n    const obj = this[$getExtra]();\n    if (obj) {\n      return obj[$toHTML](availableSpace);\n    }\n    return HTMLResult.EMPTY;\n  }\n}\nclass Validate extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"validate\", true);\n    this.formatTest = getStringOption(attributes.formatTest, [\"warning\", \"disabled\", \"error\"]);\n    this.id = attributes.id || \"\";\n    this.nullTest = getStringOption(attributes.nullTest, [\"disabled\", \"error\", \"warning\"]);\n    this.scriptTest = getStringOption(attributes.scriptTest, [\"error\", \"disabled\", \"warning\"]);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.extras = null;\n    this.message = null;\n    this.picture = null;\n    this.script = null;\n  }\n}\nclass Value extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"value\", true);\n    this.id = attributes.id || \"\";\n    this.override = getInteger({\n      data: attributes.override,\n      defaultValue: 0,\n      validate: x => x === 1\n    });\n    this.relevant = getRelevant(attributes.relevant);\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.arc = null;\n    this.boolean = null;\n    this.date = null;\n    this.dateTime = null;\n    this.decimal = null;\n    this.exData = null;\n    this.float = null;\n    this.image = null;\n    this.integer = null;\n    this.line = null;\n    this.rectangle = null;\n    this.text = null;\n    this.time = null;\n  }\n  [$setValue](value) {\n    const parent = this[$getParent]();\n    if (parent instanceof Field) {\n      if (parent.ui?.imageEdit) {\n        if (!this.image) {\n          this.image = new Image({});\n          this[$appendChild](this.image);\n        }\n        this.image[$content] = value[$content];\n        return;\n      }\n    }\n    const valueName = value[$nodeName];\n    if (this[valueName] !== null) {\n      this[valueName][$content] = value[$content];\n      return;\n    }\n    for (const name of Object.getOwnPropertyNames(this)) {\n      const obj = this[name];\n      if (obj instanceof XFAObject) {\n        this[name] = null;\n        this[$removeChild](obj);\n      }\n    }\n    this[value[$nodeName]] = value;\n    this[$appendChild](value);\n  }\n  [$text]() {\n    if (this.exData) {\n      if (typeof this.exData[$content] === \"string\") {\n        return this.exData[$content].trim();\n      }\n      return this.exData[$content][$text]().trim();\n    }\n    for (const name of Object.getOwnPropertyNames(this)) {\n      if (name === \"image\") {\n        continue;\n      }\n      const obj = this[name];\n      if (obj instanceof XFAObject) {\n        return (obj[$content] || \"\").toString().trim();\n      }\n    }\n    return null;\n  }\n  [$toHTML](availableSpace) {\n    for (const name of Object.getOwnPropertyNames(this)) {\n      const obj = this[name];\n      if (!(obj instanceof XFAObject)) {\n        continue;\n      }\n      return obj[$toHTML](availableSpace);\n    }\n    return HTMLResult.EMPTY;\n  }\n}\nclass Variables extends XFAObject {\n  constructor(attributes) {\n    super(TEMPLATE_NS_ID, \"variables\", true);\n    this.id = attributes.id || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n    this.boolean = new XFAObjectArray();\n    this.date = new XFAObjectArray();\n    this.dateTime = new XFAObjectArray();\n    this.decimal = new XFAObjectArray();\n    this.exData = new XFAObjectArray();\n    this.float = new XFAObjectArray();\n    this.image = new XFAObjectArray();\n    this.integer = new XFAObjectArray();\n    this.manifest = new XFAObjectArray();\n    this.script = new XFAObjectArray();\n    this.text = new XFAObjectArray();\n    this.time = new XFAObjectArray();\n  }\n  [$isTransparent]() {\n    return true;\n  }\n}\nclass TemplateNamespace {\n  static [$buildXFAObject](name, attributes) {\n    if (TemplateNamespace.hasOwnProperty(name)) {\n      const node = TemplateNamespace[name](attributes);\n      node[$setSetAttributes](attributes);\n      return node;\n    }\n    return undefined;\n  }\n  static appearanceFilter(attrs) {\n    return new AppearanceFilter(attrs);\n  }\n  static arc(attrs) {\n    return new Arc(attrs);\n  }\n  static area(attrs) {\n    return new Area(attrs);\n  }\n  static assist(attrs) {\n    return new Assist(attrs);\n  }\n  static barcode(attrs) {\n    return new Barcode(attrs);\n  }\n  static bind(attrs) {\n    return new Bind(attrs);\n  }\n  static bindItems(attrs) {\n    return new BindItems(attrs);\n  }\n  static bookend(attrs) {\n    return new Bookend(attrs);\n  }\n  static boolean(attrs) {\n    return new BooleanElement(attrs);\n  }\n  static border(attrs) {\n    return new Border(attrs);\n  }\n  static break(attrs) {\n    return new Break(attrs);\n  }\n  static breakAfter(attrs) {\n    return new BreakAfter(attrs);\n  }\n  static breakBefore(attrs) {\n    return new BreakBefore(attrs);\n  }\n  static button(attrs) {\n    return new Button(attrs);\n  }\n  static calculate(attrs) {\n    return new Calculate(attrs);\n  }\n  static caption(attrs) {\n    return new Caption(attrs);\n  }\n  static certificate(attrs) {\n    return new Certificate(attrs);\n  }\n  static certificates(attrs) {\n    return new Certificates(attrs);\n  }\n  static checkButton(attrs) {\n    return new CheckButton(attrs);\n  }\n  static choiceList(attrs) {\n    return new ChoiceList(attrs);\n  }\n  static color(attrs) {\n    return new Color(attrs);\n  }\n  static comb(attrs) {\n    return new Comb(attrs);\n  }\n  static connect(attrs) {\n    return new Connect(attrs);\n  }\n  static contentArea(attrs) {\n    return new ContentArea(attrs);\n  }\n  static corner(attrs) {\n    return new Corner(attrs);\n  }\n  static date(attrs) {\n    return new DateElement(attrs);\n  }\n  static dateTime(attrs) {\n    return new DateTime(attrs);\n  }\n  static dateTimeEdit(attrs) {\n    return new DateTimeEdit(attrs);\n  }\n  static decimal(attrs) {\n    return new Decimal(attrs);\n  }\n  static defaultUi(attrs) {\n    return new DefaultUi(attrs);\n  }\n  static desc(attrs) {\n    return new Desc(attrs);\n  }\n  static digestMethod(attrs) {\n    return new DigestMethod(attrs);\n  }\n  static digestMethods(attrs) {\n    return new DigestMethods(attrs);\n  }\n  static draw(attrs) {\n    return new Draw(attrs);\n  }\n  static edge(attrs) {\n    return new Edge(attrs);\n  }\n  static encoding(attrs) {\n    return new Encoding(attrs);\n  }\n  static encodings(attrs) {\n    return new Encodings(attrs);\n  }\n  static encrypt(attrs) {\n    return new Encrypt(attrs);\n  }\n  static encryptData(attrs) {\n    return new EncryptData(attrs);\n  }\n  static encryption(attrs) {\n    return new Encryption(attrs);\n  }\n  static encryptionMethod(attrs) {\n    return new EncryptionMethod(attrs);\n  }\n  static encryptionMethods(attrs) {\n    return new EncryptionMethods(attrs);\n  }\n  static event(attrs) {\n    return new Event(attrs);\n  }\n  static exData(attrs) {\n    return new ExData(attrs);\n  }\n  static exObject(attrs) {\n    return new ExObject(attrs);\n  }\n  static exclGroup(attrs) {\n    return new ExclGroup(attrs);\n  }\n  static execute(attrs) {\n    return new Execute(attrs);\n  }\n  static extras(attrs) {\n    return new Extras(attrs);\n  }\n  static field(attrs) {\n    return new Field(attrs);\n  }\n  static fill(attrs) {\n    return new Fill(attrs);\n  }\n  static filter(attrs) {\n    return new Filter(attrs);\n  }\n  static float(attrs) {\n    return new Float(attrs);\n  }\n  static font(attrs) {\n    return new template_Font(attrs);\n  }\n  static format(attrs) {\n    return new Format(attrs);\n  }\n  static handler(attrs) {\n    return new Handler(attrs);\n  }\n  static hyphenation(attrs) {\n    return new Hyphenation(attrs);\n  }\n  static image(attrs) {\n    return new Image(attrs);\n  }\n  static imageEdit(attrs) {\n    return new ImageEdit(attrs);\n  }\n  static integer(attrs) {\n    return new Integer(attrs);\n  }\n  static issuers(attrs) {\n    return new Issuers(attrs);\n  }\n  static items(attrs) {\n    return new Items(attrs);\n  }\n  static keep(attrs) {\n    return new Keep(attrs);\n  }\n  static keyUsage(attrs) {\n    return new KeyUsage(attrs);\n  }\n  static line(attrs) {\n    return new Line(attrs);\n  }\n  static linear(attrs) {\n    return new Linear(attrs);\n  }\n  static lockDocument(attrs) {\n    return new LockDocument(attrs);\n  }\n  static manifest(attrs) {\n    return new Manifest(attrs);\n  }\n  static margin(attrs) {\n    return new Margin(attrs);\n  }\n  static mdp(attrs) {\n    return new Mdp(attrs);\n  }\n  static medium(attrs) {\n    return new Medium(attrs);\n  }\n  static message(attrs) {\n    return new Message(attrs);\n  }\n  static numericEdit(attrs) {\n    return new NumericEdit(attrs);\n  }\n  static occur(attrs) {\n    return new Occur(attrs);\n  }\n  static oid(attrs) {\n    return new Oid(attrs);\n  }\n  static oids(attrs) {\n    return new Oids(attrs);\n  }\n  static overflow(attrs) {\n    return new Overflow(attrs);\n  }\n  static pageArea(attrs) {\n    return new PageArea(attrs);\n  }\n  static pageSet(attrs) {\n    return new PageSet(attrs);\n  }\n  static para(attrs) {\n    return new Para(attrs);\n  }\n  static passwordEdit(attrs) {\n    return new PasswordEdit(attrs);\n  }\n  static pattern(attrs) {\n    return new template_Pattern(attrs);\n  }\n  static picture(attrs) {\n    return new Picture(attrs);\n  }\n  static proto(attrs) {\n    return new Proto(attrs);\n  }\n  static radial(attrs) {\n    return new Radial(attrs);\n  }\n  static reason(attrs) {\n    return new Reason(attrs);\n  }\n  static reasons(attrs) {\n    return new Reasons(attrs);\n  }\n  static rectangle(attrs) {\n    return new Rectangle(attrs);\n  }\n  static ref(attrs) {\n    return new RefElement(attrs);\n  }\n  static script(attrs) {\n    return new Script(attrs);\n  }\n  static setProperty(attrs) {\n    return new SetProperty(attrs);\n  }\n  static signData(attrs) {\n    return new SignData(attrs);\n  }\n  static signature(attrs) {\n    return new Signature(attrs);\n  }\n  static signing(attrs) {\n    return new Signing(attrs);\n  }\n  static solid(attrs) {\n    return new Solid(attrs);\n  }\n  static speak(attrs) {\n    return new Speak(attrs);\n  }\n  static stipple(attrs) {\n    return new Stipple(attrs);\n  }\n  static subform(attrs) {\n    return new Subform(attrs);\n  }\n  static subformSet(attrs) {\n    return new SubformSet(attrs);\n  }\n  static subjectDN(attrs) {\n    return new SubjectDN(attrs);\n  }\n  static subjectDNs(attrs) {\n    return new SubjectDNs(attrs);\n  }\n  static submit(attrs) {\n    return new Submit(attrs);\n  }\n  static template(attrs) {\n    return new Template(attrs);\n  }\n  static text(attrs) {\n    return new Text(attrs);\n  }\n  static textEdit(attrs) {\n    return new TextEdit(attrs);\n  }\n  static time(attrs) {\n    return new Time(attrs);\n  }\n  static timeStamp(attrs) {\n    return new TimeStamp(attrs);\n  }\n  static toolTip(attrs) {\n    return new ToolTip(attrs);\n  }\n  static traversal(attrs) {\n    return new Traversal(attrs);\n  }\n  static traverse(attrs) {\n    return new Traverse(attrs);\n  }\n  static ui(attrs) {\n    return new Ui(attrs);\n  }\n  static validate(attrs) {\n    return new Validate(attrs);\n  }\n  static value(attrs) {\n    return new Value(attrs);\n  }\n  static variables(attrs) {\n    return new Variables(attrs);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/bind.js\n\n\n\n\n\n\nconst bind_NS_DATASETS = NamespaceIds.datasets.id;\nfunction createText(content) {\n  const node = new Text({});\n  node[$content] = content;\n  return node;\n}\nclass Binder {\n  constructor(root) {\n    this.root = root;\n    this.datasets = root.datasets;\n    this.data = root.datasets?.data || new XmlObject(NamespaceIds.datasets.id, \"data\");\n    this.emptyMerge = this.data[$getChildren]().length === 0;\n    this.root.form = this.form = root.template[$clone]();\n  }\n  _isConsumeData() {\n    return !this.emptyMerge && this._mergeMode;\n  }\n  _isMatchTemplate() {\n    return !this._isConsumeData();\n  }\n  bind() {\n    this._bindElement(this.form, this.data);\n    return this.form;\n  }\n  getData() {\n    return this.data;\n  }\n  _bindValue(formNode, data, picture) {\n    formNode[$data] = data;\n    if (formNode[$hasSettableValue]()) {\n      if (data[$isDataValue]()) {\n        const value = data[$getDataValue]();\n        formNode[$setValue](createText(value));\n      } else if (formNode instanceof Field && formNode.ui?.choiceList?.open === \"multiSelect\") {\n        const value = data[$getChildren]().map(child => child[$content].trim()).join(\"\\n\");\n        formNode[$setValue](createText(value));\n      } else if (this._isConsumeData()) {\n        warn(`XFA - Nodes haven't the same type.`);\n      }\n    } else if (!data[$isDataValue]() || this._isMatchTemplate()) {\n      this._bindElement(formNode, data);\n    } else {\n      warn(`XFA - Nodes haven't the same type.`);\n    }\n  }\n  _findDataByNameToConsume(name, isValue, dataNode, global) {\n    if (!name) {\n      return null;\n    }\n    let generator, match;\n    for (let i = 0; i < 3; i++) {\n      generator = dataNode[$getRealChildrenByNameIt](name, false, true);\n      while (true) {\n        match = generator.next().value;\n        if (!match) {\n          break;\n        }\n        if (isValue === match[$isDataValue]()) {\n          return match;\n        }\n      }\n      if (dataNode[$namespaceId] === NamespaceIds.datasets.id && dataNode[$nodeName] === \"data\") {\n        break;\n      }\n      dataNode = dataNode[$getParent]();\n    }\n    if (!global) {\n      return null;\n    }\n    generator = this.data[$getRealChildrenByNameIt](name, true, false);\n    match = generator.next().value;\n    if (match) {\n      return match;\n    }\n    generator = this.data[$getAttributeIt](name, true);\n    match = generator.next().value;\n    if (match?.[$isDataValue]()) {\n      return match;\n    }\n    return null;\n  }\n  _setProperties(formNode, dataNode) {\n    if (!formNode.hasOwnProperty(\"setProperty\")) {\n      return;\n    }\n    for (const {\n      ref,\n      target,\n      connection\n    } of formNode.setProperty.children) {\n      if (connection) {\n        continue;\n      }\n      if (!ref) {\n        continue;\n      }\n      const nodes = searchNode(this.root, dataNode, ref, false, false);\n      if (!nodes) {\n        warn(`XFA - Invalid reference: ${ref}.`);\n        continue;\n      }\n      const [node] = nodes;\n      if (!node[$isDescendent](this.data)) {\n        warn(`XFA - Invalid node: must be a data node.`);\n        continue;\n      }\n      const targetNodes = searchNode(this.root, formNode, target, false, false);\n      if (!targetNodes) {\n        warn(`XFA - Invalid target: ${target}.`);\n        continue;\n      }\n      const [targetNode] = targetNodes;\n      if (!targetNode[$isDescendent](formNode)) {\n        warn(`XFA - Invalid target: must be a property or subproperty.`);\n        continue;\n      }\n      const targetParent = targetNode[$getParent]();\n      if (targetNode instanceof SetProperty || targetParent instanceof SetProperty) {\n        warn(`XFA - Invalid target: cannot be a setProperty or one of its properties.`);\n        continue;\n      }\n      if (targetNode instanceof BindItems || targetParent instanceof BindItems) {\n        warn(`XFA - Invalid target: cannot be a bindItems or one of its properties.`);\n        continue;\n      }\n      const content = node[$text]();\n      const name = targetNode[$nodeName];\n      if (targetNode instanceof XFAAttribute) {\n        const attrs = Object.create(null);\n        attrs[name] = content;\n        const obj = Reflect.construct(Object.getPrototypeOf(targetParent).constructor, [attrs]);\n        targetParent[name] = obj[name];\n        continue;\n      }\n      if (!targetNode.hasOwnProperty($content)) {\n        warn(`XFA - Invalid node to use in setProperty`);\n        continue;\n      }\n      targetNode[$data] = node;\n      targetNode[$content] = content;\n      targetNode[$finalize]();\n    }\n  }\n  _bindItems(formNode, dataNode) {\n    if (!formNode.hasOwnProperty(\"items\") || !formNode.hasOwnProperty(\"bindItems\") || formNode.bindItems.isEmpty()) {\n      return;\n    }\n    for (const item of formNode.items.children) {\n      formNode[$removeChild](item);\n    }\n    formNode.items.clear();\n    const labels = new Items({});\n    const values = new Items({});\n    formNode[$appendChild](labels);\n    formNode.items.push(labels);\n    formNode[$appendChild](values);\n    formNode.items.push(values);\n    for (const {\n      ref,\n      labelRef,\n      valueRef,\n      connection\n    } of formNode.bindItems.children) {\n      if (connection) {\n        continue;\n      }\n      if (!ref) {\n        continue;\n      }\n      const nodes = searchNode(this.root, dataNode, ref, false, false);\n      if (!nodes) {\n        warn(`XFA - Invalid reference: ${ref}.`);\n        continue;\n      }\n      for (const node of nodes) {\n        if (!node[$isDescendent](this.datasets)) {\n          warn(`XFA - Invalid ref (${ref}): must be a datasets child.`);\n          continue;\n        }\n        const labelNodes = searchNode(this.root, node, labelRef, true, false);\n        if (!labelNodes) {\n          warn(`XFA - Invalid label: ${labelRef}.`);\n          continue;\n        }\n        const [labelNode] = labelNodes;\n        if (!labelNode[$isDescendent](this.datasets)) {\n          warn(`XFA - Invalid label: must be a datasets child.`);\n          continue;\n        }\n        const valueNodes = searchNode(this.root, node, valueRef, true, false);\n        if (!valueNodes) {\n          warn(`XFA - Invalid value: ${valueRef}.`);\n          continue;\n        }\n        const [valueNode] = valueNodes;\n        if (!valueNode[$isDescendent](this.datasets)) {\n          warn(`XFA - Invalid value: must be a datasets child.`);\n          continue;\n        }\n        const label = createText(labelNode[$text]());\n        const value = createText(valueNode[$text]());\n        labels[$appendChild](label);\n        labels.text.push(label);\n        values[$appendChild](value);\n        values.text.push(value);\n      }\n    }\n  }\n  _bindOccurrences(formNode, matches, picture) {\n    let baseClone;\n    if (matches.length > 1) {\n      baseClone = formNode[$clone]();\n      baseClone[$removeChild](baseClone.occur);\n      baseClone.occur = null;\n    }\n    this._bindValue(formNode, matches[0], picture);\n    this._setProperties(formNode, matches[0]);\n    this._bindItems(formNode, matches[0]);\n    if (matches.length === 1) {\n      return;\n    }\n    const parent = formNode[$getParent]();\n    const name = formNode[$nodeName];\n    const pos = parent[$indexOf](formNode);\n    for (let i = 1, ii = matches.length; i < ii; i++) {\n      const match = matches[i];\n      const clone = baseClone[$clone]();\n      parent[name].push(clone);\n      parent[$insertAt](pos + i, clone);\n      this._bindValue(clone, match, picture);\n      this._setProperties(clone, match);\n      this._bindItems(clone, match);\n    }\n  }\n  _createOccurrences(formNode) {\n    if (!this.emptyMerge) {\n      return;\n    }\n    const {\n      occur\n    } = formNode;\n    if (!occur || occur.initial <= 1) {\n      return;\n    }\n    const parent = formNode[$getParent]();\n    const name = formNode[$nodeName];\n    if (!(parent[name] instanceof XFAObjectArray)) {\n      return;\n    }\n    let currentNumber;\n    if (formNode.name) {\n      currentNumber = parent[name].children.filter(e => e.name === formNode.name).length;\n    } else {\n      currentNumber = parent[name].children.length;\n    }\n    const pos = parent[$indexOf](formNode) + 1;\n    const ii = occur.initial - currentNumber;\n    if (ii) {\n      const nodeClone = formNode[$clone]();\n      nodeClone[$removeChild](nodeClone.occur);\n      nodeClone.occur = null;\n      parent[name].push(nodeClone);\n      parent[$insertAt](pos, nodeClone);\n      for (let i = 1; i < ii; i++) {\n        const clone = nodeClone[$clone]();\n        parent[name].push(clone);\n        parent[$insertAt](pos + i, clone);\n      }\n    }\n  }\n  _getOccurInfo(formNode) {\n    const {\n      name,\n      occur\n    } = formNode;\n    if (!occur || !name) {\n      return [1, 1];\n    }\n    const max = occur.max === -1 ? Infinity : occur.max;\n    return [occur.min, max];\n  }\n  _setAndBind(formNode, dataNode) {\n    this._setProperties(formNode, dataNode);\n    this._bindItems(formNode, dataNode);\n    this._bindElement(formNode, dataNode);\n  }\n  _bindElement(formNode, dataNode) {\n    const uselessNodes = [];\n    this._createOccurrences(formNode);\n    for (const child of formNode[$getChildren]()) {\n      if (child[$data]) {\n        continue;\n      }\n      if (this._mergeMode === undefined && child[$nodeName] === \"subform\") {\n        this._mergeMode = child.mergeMode === \"consumeData\";\n        const dataChildren = dataNode[$getChildren]();\n        if (dataChildren.length > 0) {\n          this._bindOccurrences(child, [dataChildren[0]], null);\n        } else if (this.emptyMerge) {\n          const nsId = dataNode[$namespaceId] === bind_NS_DATASETS ? -1 : dataNode[$namespaceId];\n          const dataChild = child[$data] = new XmlObject(nsId, child.name || \"root\");\n          dataNode[$appendChild](dataChild);\n          this._bindElement(child, dataChild);\n        }\n        continue;\n      }\n      if (!child[$isBindable]()) {\n        continue;\n      }\n      let global = false;\n      let picture = null;\n      let ref = null;\n      let match = null;\n      if (child.bind) {\n        switch (child.bind.match) {\n          case \"none\":\n            this._setAndBind(child, dataNode);\n            continue;\n          case \"global\":\n            global = true;\n            break;\n          case \"dataRef\":\n            if (!child.bind.ref) {\n              warn(`XFA - ref is empty in node ${child[$nodeName]}.`);\n              this._setAndBind(child, dataNode);\n              continue;\n            }\n            ref = child.bind.ref;\n            break;\n          default:\n            break;\n        }\n        if (child.bind.picture) {\n          picture = child.bind.picture[$content];\n        }\n      }\n      const [min, max] = this._getOccurInfo(child);\n      if (ref) {\n        match = searchNode(this.root, dataNode, ref, true, false);\n        if (match === null) {\n          match = createDataNode(this.data, dataNode, ref);\n          if (!match) {\n            continue;\n          }\n          if (this._isConsumeData()) {\n            match[$consumed] = true;\n          }\n          this._setAndBind(child, match);\n          continue;\n        } else {\n          if (this._isConsumeData()) {\n            match = match.filter(node => !node[$consumed]);\n          }\n          if (match.length > max) {\n            match = match.slice(0, max);\n          } else if (match.length === 0) {\n            match = null;\n          }\n          if (match && this._isConsumeData()) {\n            match.forEach(node => {\n              node[$consumed] = true;\n            });\n          }\n        }\n      } else {\n        if (!child.name) {\n          this._setAndBind(child, dataNode);\n          continue;\n        }\n        if (this._isConsumeData()) {\n          const matches = [];\n          while (matches.length < max) {\n            const found = this._findDataByNameToConsume(child.name, child[$hasSettableValue](), dataNode, global);\n            if (!found) {\n              break;\n            }\n            found[$consumed] = true;\n            matches.push(found);\n          }\n          match = matches.length > 0 ? matches : null;\n        } else {\n          match = dataNode[$getRealChildrenByNameIt](child.name, false, this.emptyMerge).next().value;\n          if (!match) {\n            if (min === 0) {\n              uselessNodes.push(child);\n              continue;\n            }\n            const nsId = dataNode[$namespaceId] === bind_NS_DATASETS ? -1 : dataNode[$namespaceId];\n            match = child[$data] = new XmlObject(nsId, child.name);\n            if (this.emptyMerge) {\n              match[$consumed] = true;\n            }\n            dataNode[$appendChild](match);\n            this._setAndBind(child, match);\n            continue;\n          }\n          if (this.emptyMerge) {\n            match[$consumed] = true;\n          }\n          match = [match];\n        }\n      }\n      if (match) {\n        this._bindOccurrences(child, match, picture);\n      } else if (min > 0) {\n        this._setAndBind(child, dataNode);\n      } else {\n        uselessNodes.push(child);\n      }\n    }\n    uselessNodes.forEach(node => node[$getParent]()[$removeChild](node));\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/data.js\n\nclass DataHandler {\n  constructor(root, data) {\n    this.data = data;\n    this.dataset = root.datasets || null;\n  }\n  serialize(storage) {\n    const stack = [[-1, this.data[$getChildren]()]];\n    while (stack.length > 0) {\n      const last = stack.at(-1);\n      const [i, children] = last;\n      if (i + 1 === children.length) {\n        stack.pop();\n        continue;\n      }\n      const child = children[++last[0]];\n      const storageEntry = storage.get(child[$uid]);\n      if (storageEntry) {\n        child[$setValue](storageEntry);\n      } else {\n        const attributes = child[$getAttributes]();\n        for (const value of attributes.values()) {\n          const entry = storage.get(value[$uid]);\n          if (entry) {\n            value[$setValue](entry);\n            break;\n          }\n        }\n      }\n      const nodes = child[$getChildren]();\n      if (nodes.length > 0) {\n        stack.push([-1, nodes]);\n      }\n    }\n    const buf = [`<xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">`];\n    if (this.dataset) {\n      for (const child of this.dataset[$getChildren]()) {\n        if (child[$nodeName] !== \"data\") {\n          child[$toString](buf);\n        }\n      }\n    }\n    this.data[$toString](buf);\n    buf.push(\"</xfa:datasets>\");\n    return buf.join(\"\");\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/config.js\n\n\n\n\n\nconst CONFIG_NS_ID = NamespaceIds.config.id;\nclass Acrobat extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"acrobat\", true);\n    this.acrobat7 = null;\n    this.autoSave = null;\n    this.common = null;\n    this.validate = null;\n    this.validateApprovalSignatures = null;\n    this.submitUrl = new XFAObjectArray();\n  }\n}\nclass Acrobat7 extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"acrobat7\", true);\n    this.dynamicRender = null;\n  }\n}\nclass ADBE_JSConsole extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"ADBE_JSConsole\", [\"delegate\", \"Enable\", \"Disable\"]);\n  }\n}\nclass ADBE_JSDebugger extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"ADBE_JSDebugger\", [\"delegate\", \"Enable\", \"Disable\"]);\n  }\n}\nclass AddSilentPrint extends Option01 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"addSilentPrint\");\n  }\n}\nclass AddViewerPreferences extends Option01 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"addViewerPreferences\");\n  }\n}\nclass AdjustData extends Option10 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"adjustData\");\n  }\n}\nclass AdobeExtensionLevel extends IntegerObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"adobeExtensionLevel\", 0, n => n >= 1 && n <= 8);\n  }\n}\nclass Agent extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"agent\", true);\n    this.name = attributes.name ? attributes.name.trim() : \"\";\n    this.common = new XFAObjectArray();\n  }\n}\nclass AlwaysEmbed extends ContentObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"alwaysEmbed\");\n  }\n}\nclass Amd extends StringObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"amd\");\n  }\n}\nclass config_Area extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"area\");\n    this.level = getInteger({\n      data: attributes.level,\n      defaultValue: 0,\n      validate: n => n >= 1 && n <= 3\n    });\n    this.name = getStringOption(attributes.name, [\"\", \"barcode\", \"coreinit\", \"deviceDriver\", \"font\", \"general\", \"layout\", \"merge\", \"script\", \"signature\", \"sourceSet\", \"templateCache\"]);\n  }\n}\nclass Attributes extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"attributes\", [\"preserve\", \"delegate\", \"ignore\"]);\n  }\n}\nclass AutoSave extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"autoSave\", [\"disabled\", \"enabled\"]);\n  }\n}\nclass Base extends StringObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"base\");\n  }\n}\nclass BatchOutput extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"batchOutput\");\n    this.format = getStringOption(attributes.format, [\"none\", \"concat\", \"zip\", \"zipCompress\"]);\n  }\n}\nclass BehaviorOverride extends ContentObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"behaviorOverride\");\n  }\n  [$finalize]() {\n    this[$content] = new Map(this[$content].trim().split(/\\s+/).filter(x => x.includes(\":\")).map(x => x.split(\":\", 2)));\n  }\n}\nclass Cache extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"cache\", true);\n    this.templateCache = null;\n  }\n}\nclass Change extends Option01 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"change\");\n  }\n}\nclass Common extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"common\", true);\n    this.data = null;\n    this.locale = null;\n    this.localeSet = null;\n    this.messaging = null;\n    this.suppressBanner = null;\n    this.template = null;\n    this.validationMessaging = null;\n    this.versionControl = null;\n    this.log = new XFAObjectArray();\n  }\n}\nclass Compress extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"compress\");\n    this.scope = getStringOption(attributes.scope, [\"imageOnly\", \"document\"]);\n  }\n}\nclass CompressLogicalStructure extends Option01 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"compressLogicalStructure\");\n  }\n}\nclass CompressObjectStream extends Option10 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"compressObjectStream\");\n  }\n}\nclass Compression extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"compression\", true);\n    this.compressLogicalStructure = null;\n    this.compressObjectStream = null;\n    this.level = null;\n    this.type = null;\n  }\n}\nclass Config extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"config\", true);\n    this.acrobat = null;\n    this.present = null;\n    this.trace = null;\n    this.agent = new XFAObjectArray();\n  }\n}\nclass Conformance extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"conformance\", [\"A\", \"B\"]);\n  }\n}\nclass ContentCopy extends Option01 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"contentCopy\");\n  }\n}\nclass Copies extends IntegerObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"copies\", 1, n => n >= 1);\n  }\n}\nclass Creator extends StringObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"creator\");\n  }\n}\nclass CurrentPage extends IntegerObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"currentPage\", 0, n => n >= 0);\n  }\n}\nclass Data extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"data\", true);\n    this.adjustData = null;\n    this.attributes = null;\n    this.incrementalLoad = null;\n    this.outputXSL = null;\n    this.range = null;\n    this.record = null;\n    this.startNode = null;\n    this.uri = null;\n    this.window = null;\n    this.xsl = null;\n    this.excludeNS = new XFAObjectArray();\n    this.transform = new XFAObjectArray();\n  }\n}\nclass Debug extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"debug\", true);\n    this.uri = null;\n  }\n}\nclass DefaultTypeface extends ContentObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"defaultTypeface\");\n    this.writingScript = getStringOption(attributes.writingScript, [\"*\", \"Arabic\", \"Cyrillic\", \"EastEuropeanRoman\", \"Greek\", \"Hebrew\", \"Japanese\", \"Korean\", \"Roman\", \"SimplifiedChinese\", \"Thai\", \"TraditionalChinese\", \"Vietnamese\"]);\n  }\n}\nclass Destination extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"destination\", [\"pdf\", \"pcl\", \"ps\", \"webClient\", \"zpl\"]);\n  }\n}\nclass DocumentAssembly extends Option01 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"documentAssembly\");\n  }\n}\nclass Driver extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"driver\", true);\n    this.name = attributes.name ? attributes.name.trim() : \"\";\n    this.fontInfo = null;\n    this.xdc = null;\n  }\n}\nclass DuplexOption extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"duplexOption\", [\"simplex\", \"duplexFlipLongEdge\", \"duplexFlipShortEdge\"]);\n  }\n}\nclass DynamicRender extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"dynamicRender\", [\"forbidden\", \"required\"]);\n  }\n}\nclass Embed extends Option01 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"embed\");\n  }\n}\nclass config_Encrypt extends Option01 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"encrypt\");\n  }\n}\nclass config_Encryption extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"encryption\", true);\n    this.encrypt = null;\n    this.encryptionLevel = null;\n    this.permissions = null;\n  }\n}\nclass EncryptionLevel extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"encryptionLevel\", [\"40bit\", \"128bit\"]);\n  }\n}\nclass Enforce extends StringObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"enforce\");\n  }\n}\nclass Equate extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"equate\");\n    this.force = getInteger({\n      data: attributes.force,\n      defaultValue: 1,\n      validate: n => n === 0\n    });\n    this.from = attributes.from || \"\";\n    this.to = attributes.to || \"\";\n  }\n}\nclass EquateRange extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"equateRange\");\n    this.from = attributes.from || \"\";\n    this.to = attributes.to || \"\";\n    this._unicodeRange = attributes.unicodeRange || \"\";\n  }\n  get unicodeRange() {\n    const ranges = [];\n    const unicodeRegex = /U\\+([0-9a-fA-F]+)/;\n    const unicodeRange = this._unicodeRange;\n    for (let range of unicodeRange.split(\",\").map(x => x.trim()).filter(x => !!x)) {\n      range = range.split(\"-\", 2).map(x => {\n        const found = x.match(unicodeRegex);\n        if (!found) {\n          return 0;\n        }\n        return parseInt(found[1], 16);\n      });\n      if (range.length === 1) {\n        range.push(range[0]);\n      }\n      ranges.push(range);\n    }\n    return shadow(this, \"unicodeRange\", ranges);\n  }\n}\nclass Exclude extends ContentObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"exclude\");\n  }\n  [$finalize]() {\n    this[$content] = this[$content].trim().split(/\\s+/).filter(x => x && [\"calculate\", \"close\", \"enter\", \"exit\", \"initialize\", \"ready\", \"validate\"].includes(x));\n  }\n}\nclass ExcludeNS extends StringObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"excludeNS\");\n  }\n}\nclass FlipLabel extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"flipLabel\", [\"usePrinterSetting\", \"on\", \"off\"]);\n  }\n}\nclass config_FontInfo extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"fontInfo\", true);\n    this.embed = null;\n    this.map = null;\n    this.subsetBelow = null;\n    this.alwaysEmbed = new XFAObjectArray();\n    this.defaultTypeface = new XFAObjectArray();\n    this.neverEmbed = new XFAObjectArray();\n  }\n}\nclass FormFieldFilling extends Option01 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"formFieldFilling\");\n  }\n}\nclass GroupParent extends StringObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"groupParent\");\n  }\n}\nclass IfEmpty extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"ifEmpty\", [\"dataValue\", \"dataGroup\", \"ignore\", \"remove\"]);\n  }\n}\nclass IncludeXDPContent extends StringObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"includeXDPContent\");\n  }\n}\nclass IncrementalLoad extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"incrementalLoad\", [\"none\", \"forwardOnly\"]);\n  }\n}\nclass IncrementalMerge extends Option01 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"incrementalMerge\");\n  }\n}\nclass Interactive extends Option01 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"interactive\");\n  }\n}\nclass Jog extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"jog\", [\"usePrinterSetting\", \"none\", \"pageSet\"]);\n  }\n}\nclass LabelPrinter extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"labelPrinter\", true);\n    this.name = getStringOption(attributes.name, [\"zpl\", \"dpl\", \"ipl\", \"tcpl\"]);\n    this.batchOutput = null;\n    this.flipLabel = null;\n    this.fontInfo = null;\n    this.xdc = null;\n  }\n}\nclass Layout extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"layout\", [\"paginate\", \"panel\"]);\n  }\n}\nclass Level extends IntegerObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"level\", 0, n => n > 0);\n  }\n}\nclass Linearized extends Option01 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"linearized\");\n  }\n}\nclass Locale extends StringObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"locale\");\n  }\n}\nclass LocaleSet extends StringObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"localeSet\");\n  }\n}\nclass Log extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"log\", true);\n    this.mode = null;\n    this.threshold = null;\n    this.to = null;\n    this.uri = null;\n  }\n}\nclass MapElement extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"map\", true);\n    this.equate = new XFAObjectArray();\n    this.equateRange = new XFAObjectArray();\n  }\n}\nclass MediumInfo extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"mediumInfo\", true);\n    this.map = null;\n  }\n}\nclass config_Message extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"message\", true);\n    this.msgId = null;\n    this.severity = null;\n  }\n}\nclass Messaging extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"messaging\", true);\n    this.message = new XFAObjectArray();\n  }\n}\nclass Mode extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"mode\", [\"append\", \"overwrite\"]);\n  }\n}\nclass ModifyAnnots extends Option01 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"modifyAnnots\");\n  }\n}\nclass MsgId extends IntegerObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"msgId\", 1, n => n >= 1);\n  }\n}\nclass NameAttr extends StringObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"nameAttr\");\n  }\n}\nclass NeverEmbed extends ContentObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"neverEmbed\");\n  }\n}\nclass NumberOfCopies extends IntegerObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"numberOfCopies\", null, n => n >= 2 && n <= 5);\n  }\n}\nclass OpenAction extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"openAction\", true);\n    this.destination = null;\n  }\n}\nclass Output extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"output\", true);\n    this.to = null;\n    this.type = null;\n    this.uri = null;\n  }\n}\nclass OutputBin extends StringObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"outputBin\");\n  }\n}\nclass OutputXSL extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"outputXSL\", true);\n    this.uri = null;\n  }\n}\nclass Overprint extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"overprint\", [\"none\", \"both\", \"draw\", \"field\"]);\n  }\n}\nclass Packets extends StringObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"packets\");\n  }\n  [$finalize]() {\n    if (this[$content] === \"*\") {\n      return;\n    }\n    this[$content] = this[$content].trim().split(/\\s+/).filter(x => [\"config\", \"datasets\", \"template\", \"xfdf\", \"xslt\"].includes(x));\n  }\n}\nclass PageOffset extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"pageOffset\");\n    this.x = getInteger({\n      data: attributes.x,\n      defaultValue: \"useXDCSetting\",\n      validate: n => true\n    });\n    this.y = getInteger({\n      data: attributes.y,\n      defaultValue: \"useXDCSetting\",\n      validate: n => true\n    });\n  }\n}\nclass PageRange extends StringObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"pageRange\");\n  }\n  [$finalize]() {\n    const numbers = this[$content].trim().split(/\\s+/).map(x => parseInt(x, 10));\n    const ranges = [];\n    for (let i = 0, ii = numbers.length; i < ii; i += 2) {\n      ranges.push(numbers.slice(i, i + 2));\n    }\n    this[$content] = ranges;\n  }\n}\nclass Pagination extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"pagination\", [\"simplex\", \"duplexShortEdge\", \"duplexLongEdge\"]);\n  }\n}\nclass PaginationOverride extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"paginationOverride\", [\"none\", \"forceDuplex\", \"forceDuplexLongEdge\", \"forceDuplexShortEdge\", \"forceSimplex\"]);\n  }\n}\nclass Part extends IntegerObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"part\", 1, n => false);\n  }\n}\nclass Pcl extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"pcl\", true);\n    this.name = attributes.name || \"\";\n    this.batchOutput = null;\n    this.fontInfo = null;\n    this.jog = null;\n    this.mediumInfo = null;\n    this.outputBin = null;\n    this.pageOffset = null;\n    this.staple = null;\n    this.xdc = null;\n  }\n}\nclass Pdf extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"pdf\", true);\n    this.name = attributes.name || \"\";\n    this.adobeExtensionLevel = null;\n    this.batchOutput = null;\n    this.compression = null;\n    this.creator = null;\n    this.encryption = null;\n    this.fontInfo = null;\n    this.interactive = null;\n    this.linearized = null;\n    this.openAction = null;\n    this.pdfa = null;\n    this.producer = null;\n    this.renderPolicy = null;\n    this.scriptModel = null;\n    this.silentPrint = null;\n    this.submitFormat = null;\n    this.tagged = null;\n    this.version = null;\n    this.viewerPreferences = null;\n    this.xdc = null;\n  }\n}\nclass Pdfa extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"pdfa\", true);\n    this.amd = null;\n    this.conformance = null;\n    this.includeXDPContent = null;\n    this.part = null;\n  }\n}\nclass Permissions extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"permissions\", true);\n    this.accessibleContent = null;\n    this.change = null;\n    this.contentCopy = null;\n    this.documentAssembly = null;\n    this.formFieldFilling = null;\n    this.modifyAnnots = null;\n    this.plaintextMetadata = null;\n    this.print = null;\n    this.printHighQuality = null;\n  }\n}\nclass PickTrayByPDFSize extends Option01 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"pickTrayByPDFSize\");\n  }\n}\nclass config_Picture extends StringObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"picture\");\n  }\n}\nclass PlaintextMetadata extends Option01 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"plaintextMetadata\");\n  }\n}\nclass Presence extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"presence\", [\"preserve\", \"dissolve\", \"dissolveStructure\", \"ignore\", \"remove\"]);\n  }\n}\nclass Present extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"present\", true);\n    this.behaviorOverride = null;\n    this.cache = null;\n    this.common = null;\n    this.copies = null;\n    this.destination = null;\n    this.incrementalMerge = null;\n    this.layout = null;\n    this.output = null;\n    this.overprint = null;\n    this.pagination = null;\n    this.paginationOverride = null;\n    this.script = null;\n    this.validate = null;\n    this.xdp = null;\n    this.driver = new XFAObjectArray();\n    this.labelPrinter = new XFAObjectArray();\n    this.pcl = new XFAObjectArray();\n    this.pdf = new XFAObjectArray();\n    this.ps = new XFAObjectArray();\n    this.submitUrl = new XFAObjectArray();\n    this.webClient = new XFAObjectArray();\n    this.zpl = new XFAObjectArray();\n  }\n}\nclass Print extends Option01 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"print\");\n  }\n}\nclass PrintHighQuality extends Option01 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"printHighQuality\");\n  }\n}\nclass PrintScaling extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"printScaling\", [\"appdefault\", \"noScaling\"]);\n  }\n}\nclass PrinterName extends StringObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"printerName\");\n  }\n}\nclass Producer extends StringObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"producer\");\n  }\n}\nclass Ps extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"ps\", true);\n    this.name = attributes.name || \"\";\n    this.batchOutput = null;\n    this.fontInfo = null;\n    this.jog = null;\n    this.mediumInfo = null;\n    this.outputBin = null;\n    this.staple = null;\n    this.xdc = null;\n  }\n}\nclass Range extends ContentObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"range\");\n  }\n  [$finalize]() {\n    this[$content] = this[$content].trim().split(/\\s*,\\s*/, 2).map(range => range.split(\"-\").map(x => parseInt(x.trim(), 10))).filter(range => range.every(x => !isNaN(x))).map(range => {\n      if (range.length === 1) {\n        range.push(range[0]);\n      }\n      return range;\n    });\n  }\n}\nclass Record extends ContentObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"record\");\n  }\n  [$finalize]() {\n    this[$content] = this[$content].trim();\n    const n = parseInt(this[$content], 10);\n    if (!isNaN(n) && n >= 0) {\n      this[$content] = n;\n    }\n  }\n}\nclass Relevant extends ContentObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"relevant\");\n  }\n  [$finalize]() {\n    this[$content] = this[$content].trim().split(/\\s+/);\n  }\n}\nclass Rename extends ContentObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"rename\");\n  }\n  [$finalize]() {\n    this[$content] = this[$content].trim();\n    if (this[$content].toLowerCase().startsWith(\"xml\") || new RegExp(\"[\\\\p{L}_][\\\\p{L}\\\\d._\\\\p{M}-]*\", \"u\").test(this[$content])) {\n      warn(\"XFA - Rename: invalid XFA name\");\n    }\n  }\n}\nclass RenderPolicy extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"renderPolicy\", [\"server\", \"client\"]);\n  }\n}\nclass RunScripts extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"runScripts\", [\"both\", \"client\", \"none\", \"server\"]);\n  }\n}\nclass config_Script extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"script\", true);\n    this.currentPage = null;\n    this.exclude = null;\n    this.runScripts = null;\n  }\n}\nclass ScriptModel extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"scriptModel\", [\"XFA\", \"none\"]);\n  }\n}\nclass Severity extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"severity\", [\"ignore\", \"error\", \"information\", \"trace\", \"warning\"]);\n  }\n}\nclass SilentPrint extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"silentPrint\", true);\n    this.addSilentPrint = null;\n    this.printerName = null;\n  }\n}\nclass Staple extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"staple\");\n    this.mode = getStringOption(attributes.mode, [\"usePrinterSetting\", \"on\", \"off\"]);\n  }\n}\nclass StartNode extends StringObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"startNode\");\n  }\n}\nclass StartPage extends IntegerObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"startPage\", 0, n => true);\n  }\n}\nclass SubmitFormat extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"submitFormat\", [\"html\", \"delegate\", \"fdf\", \"xml\", \"pdf\"]);\n  }\n}\nclass SubmitUrl extends StringObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"submitUrl\");\n  }\n}\nclass SubsetBelow extends IntegerObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"subsetBelow\", 100, n => n >= 0 && n <= 100);\n  }\n}\nclass SuppressBanner extends Option01 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"suppressBanner\");\n  }\n}\nclass Tagged extends Option01 {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"tagged\");\n  }\n}\nclass config_Template extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"template\", true);\n    this.base = null;\n    this.relevant = null;\n    this.startPage = null;\n    this.uri = null;\n    this.xsl = null;\n  }\n}\nclass Threshold extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"threshold\", [\"trace\", \"error\", \"information\", \"warning\"]);\n  }\n}\nclass To extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"to\", [\"null\", \"memory\", \"stderr\", \"stdout\", \"system\", \"uri\"]);\n  }\n}\nclass TemplateCache extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"templateCache\");\n    this.maxEntries = getInteger({\n      data: attributes.maxEntries,\n      defaultValue: 5,\n      validate: n => n >= 0\n    });\n  }\n}\nclass Trace extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"trace\", true);\n    this.area = new XFAObjectArray();\n  }\n}\nclass Transform extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"transform\", true);\n    this.groupParent = null;\n    this.ifEmpty = null;\n    this.nameAttr = null;\n    this.picture = null;\n    this.presence = null;\n    this.rename = null;\n    this.whitespace = null;\n  }\n}\nclass Type extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"type\", [\"none\", \"ascii85\", \"asciiHex\", \"ccittfax\", \"flate\", \"lzw\", \"runLength\", \"native\", \"xdp\", \"mergedXDP\"]);\n  }\n}\nclass Uri extends StringObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"uri\");\n  }\n}\nclass config_Validate extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"validate\", [\"preSubmit\", \"prePrint\", \"preExecute\", \"preSave\"]);\n  }\n}\nclass ValidateApprovalSignatures extends ContentObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"validateApprovalSignatures\");\n  }\n  [$finalize]() {\n    this[$content] = this[$content].trim().split(/\\s+/).filter(x => [\"docReady\", \"postSign\"].includes(x));\n  }\n}\nclass ValidationMessaging extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"validationMessaging\", [\"allMessagesIndividually\", \"allMessagesTogether\", \"firstMessageOnly\", \"noMessages\"]);\n  }\n}\nclass Version extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"version\", [\"1.7\", \"1.6\", \"1.5\", \"1.4\", \"1.3\", \"1.2\"]);\n  }\n}\nclass VersionControl extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"VersionControl\");\n    this.outputBelow = getStringOption(attributes.outputBelow, [\"warn\", \"error\", \"update\"]);\n    this.sourceAbove = getStringOption(attributes.sourceAbove, [\"warn\", \"error\"]);\n    this.sourceBelow = getStringOption(attributes.sourceBelow, [\"update\", \"maintain\"]);\n  }\n}\nclass ViewerPreferences extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"viewerPreferences\", true);\n    this.ADBE_JSConsole = null;\n    this.ADBE_JSDebugger = null;\n    this.addViewerPreferences = null;\n    this.duplexOption = null;\n    this.enforce = null;\n    this.numberOfCopies = null;\n    this.pageRange = null;\n    this.pickTrayByPDFSize = null;\n    this.printScaling = null;\n  }\n}\nclass WebClient extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"webClient\", true);\n    this.name = attributes.name ? attributes.name.trim() : \"\";\n    this.fontInfo = null;\n    this.xdc = null;\n  }\n}\nclass Whitespace extends OptionObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"whitespace\", [\"preserve\", \"ltrim\", \"normalize\", \"rtrim\", \"trim\"]);\n  }\n}\nclass Window extends ContentObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"window\");\n  }\n  [$finalize]() {\n    const pair = this[$content].trim().split(/\\s*,\\s*/, 2).map(x => parseInt(x, 10));\n    if (pair.some(x => isNaN(x))) {\n      this[$content] = [0, 0];\n      return;\n    }\n    if (pair.length === 1) {\n      pair.push(pair[0]);\n    }\n    this[$content] = pair;\n  }\n}\nclass Xdc extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"xdc\", true);\n    this.uri = new XFAObjectArray();\n    this.xsl = new XFAObjectArray();\n  }\n}\nclass Xdp extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"xdp\", true);\n    this.packets = null;\n  }\n}\nclass Xsl extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"xsl\", true);\n    this.debug = null;\n    this.uri = null;\n  }\n}\nclass Zpl extends XFAObject {\n  constructor(attributes) {\n    super(CONFIG_NS_ID, \"zpl\", true);\n    this.name = attributes.name ? attributes.name.trim() : \"\";\n    this.batchOutput = null;\n    this.flipLabel = null;\n    this.fontInfo = null;\n    this.xdc = null;\n  }\n}\nclass ConfigNamespace {\n  static [$buildXFAObject](name, attributes) {\n    if (ConfigNamespace.hasOwnProperty(name)) {\n      return ConfigNamespace[name](attributes);\n    }\n    return undefined;\n  }\n  static acrobat(attrs) {\n    return new Acrobat(attrs);\n  }\n  static acrobat7(attrs) {\n    return new Acrobat7(attrs);\n  }\n  static ADBE_JSConsole(attrs) {\n    return new ADBE_JSConsole(attrs);\n  }\n  static ADBE_JSDebugger(attrs) {\n    return new ADBE_JSDebugger(attrs);\n  }\n  static addSilentPrint(attrs) {\n    return new AddSilentPrint(attrs);\n  }\n  static addViewerPreferences(attrs) {\n    return new AddViewerPreferences(attrs);\n  }\n  static adjustData(attrs) {\n    return new AdjustData(attrs);\n  }\n  static adobeExtensionLevel(attrs) {\n    return new AdobeExtensionLevel(attrs);\n  }\n  static agent(attrs) {\n    return new Agent(attrs);\n  }\n  static alwaysEmbed(attrs) {\n    return new AlwaysEmbed(attrs);\n  }\n  static amd(attrs) {\n    return new Amd(attrs);\n  }\n  static area(attrs) {\n    return new config_Area(attrs);\n  }\n  static attributes(attrs) {\n    return new Attributes(attrs);\n  }\n  static autoSave(attrs) {\n    return new AutoSave(attrs);\n  }\n  static base(attrs) {\n    return new Base(attrs);\n  }\n  static batchOutput(attrs) {\n    return new BatchOutput(attrs);\n  }\n  static behaviorOverride(attrs) {\n    return new BehaviorOverride(attrs);\n  }\n  static cache(attrs) {\n    return new Cache(attrs);\n  }\n  static change(attrs) {\n    return new Change(attrs);\n  }\n  static common(attrs) {\n    return new Common(attrs);\n  }\n  static compress(attrs) {\n    return new Compress(attrs);\n  }\n  static compressLogicalStructure(attrs) {\n    return new CompressLogicalStructure(attrs);\n  }\n  static compressObjectStream(attrs) {\n    return new CompressObjectStream(attrs);\n  }\n  static compression(attrs) {\n    return new Compression(attrs);\n  }\n  static config(attrs) {\n    return new Config(attrs);\n  }\n  static conformance(attrs) {\n    return new Conformance(attrs);\n  }\n  static contentCopy(attrs) {\n    return new ContentCopy(attrs);\n  }\n  static copies(attrs) {\n    return new Copies(attrs);\n  }\n  static creator(attrs) {\n    return new Creator(attrs);\n  }\n  static currentPage(attrs) {\n    return new CurrentPage(attrs);\n  }\n  static data(attrs) {\n    return new Data(attrs);\n  }\n  static debug(attrs) {\n    return new Debug(attrs);\n  }\n  static defaultTypeface(attrs) {\n    return new DefaultTypeface(attrs);\n  }\n  static destination(attrs) {\n    return new Destination(attrs);\n  }\n  static documentAssembly(attrs) {\n    return new DocumentAssembly(attrs);\n  }\n  static driver(attrs) {\n    return new Driver(attrs);\n  }\n  static duplexOption(attrs) {\n    return new DuplexOption(attrs);\n  }\n  static dynamicRender(attrs) {\n    return new DynamicRender(attrs);\n  }\n  static embed(attrs) {\n    return new Embed(attrs);\n  }\n  static encrypt(attrs) {\n    return new config_Encrypt(attrs);\n  }\n  static encryption(attrs) {\n    return new config_Encryption(attrs);\n  }\n  static encryptionLevel(attrs) {\n    return new EncryptionLevel(attrs);\n  }\n  static enforce(attrs) {\n    return new Enforce(attrs);\n  }\n  static equate(attrs) {\n    return new Equate(attrs);\n  }\n  static equateRange(attrs) {\n    return new EquateRange(attrs);\n  }\n  static exclude(attrs) {\n    return new Exclude(attrs);\n  }\n  static excludeNS(attrs) {\n    return new ExcludeNS(attrs);\n  }\n  static flipLabel(attrs) {\n    return new FlipLabel(attrs);\n  }\n  static fontInfo(attrs) {\n    return new config_FontInfo(attrs);\n  }\n  static formFieldFilling(attrs) {\n    return new FormFieldFilling(attrs);\n  }\n  static groupParent(attrs) {\n    return new GroupParent(attrs);\n  }\n  static ifEmpty(attrs) {\n    return new IfEmpty(attrs);\n  }\n  static includeXDPContent(attrs) {\n    return new IncludeXDPContent(attrs);\n  }\n  static incrementalLoad(attrs) {\n    return new IncrementalLoad(attrs);\n  }\n  static incrementalMerge(attrs) {\n    return new IncrementalMerge(attrs);\n  }\n  static interactive(attrs) {\n    return new Interactive(attrs);\n  }\n  static jog(attrs) {\n    return new Jog(attrs);\n  }\n  static labelPrinter(attrs) {\n    return new LabelPrinter(attrs);\n  }\n  static layout(attrs) {\n    return new Layout(attrs);\n  }\n  static level(attrs) {\n    return new Level(attrs);\n  }\n  static linearized(attrs) {\n    return new Linearized(attrs);\n  }\n  static locale(attrs) {\n    return new Locale(attrs);\n  }\n  static localeSet(attrs) {\n    return new LocaleSet(attrs);\n  }\n  static log(attrs) {\n    return new Log(attrs);\n  }\n  static map(attrs) {\n    return new MapElement(attrs);\n  }\n  static mediumInfo(attrs) {\n    return new MediumInfo(attrs);\n  }\n  static message(attrs) {\n    return new config_Message(attrs);\n  }\n  static messaging(attrs) {\n    return new Messaging(attrs);\n  }\n  static mode(attrs) {\n    return new Mode(attrs);\n  }\n  static modifyAnnots(attrs) {\n    return new ModifyAnnots(attrs);\n  }\n  static msgId(attrs) {\n    return new MsgId(attrs);\n  }\n  static nameAttr(attrs) {\n    return new NameAttr(attrs);\n  }\n  static neverEmbed(attrs) {\n    return new NeverEmbed(attrs);\n  }\n  static numberOfCopies(attrs) {\n    return new NumberOfCopies(attrs);\n  }\n  static openAction(attrs) {\n    return new OpenAction(attrs);\n  }\n  static output(attrs) {\n    return new Output(attrs);\n  }\n  static outputBin(attrs) {\n    return new OutputBin(attrs);\n  }\n  static outputXSL(attrs) {\n    return new OutputXSL(attrs);\n  }\n  static overprint(attrs) {\n    return new Overprint(attrs);\n  }\n  static packets(attrs) {\n    return new Packets(attrs);\n  }\n  static pageOffset(attrs) {\n    return new PageOffset(attrs);\n  }\n  static pageRange(attrs) {\n    return new PageRange(attrs);\n  }\n  static pagination(attrs) {\n    return new Pagination(attrs);\n  }\n  static paginationOverride(attrs) {\n    return new PaginationOverride(attrs);\n  }\n  static part(attrs) {\n    return new Part(attrs);\n  }\n  static pcl(attrs) {\n    return new Pcl(attrs);\n  }\n  static pdf(attrs) {\n    return new Pdf(attrs);\n  }\n  static pdfa(attrs) {\n    return new Pdfa(attrs);\n  }\n  static permissions(attrs) {\n    return new Permissions(attrs);\n  }\n  static pickTrayByPDFSize(attrs) {\n    return new PickTrayByPDFSize(attrs);\n  }\n  static picture(attrs) {\n    return new config_Picture(attrs);\n  }\n  static plaintextMetadata(attrs) {\n    return new PlaintextMetadata(attrs);\n  }\n  static presence(attrs) {\n    return new Presence(attrs);\n  }\n  static present(attrs) {\n    return new Present(attrs);\n  }\n  static print(attrs) {\n    return new Print(attrs);\n  }\n  static printHighQuality(attrs) {\n    return new PrintHighQuality(attrs);\n  }\n  static printScaling(attrs) {\n    return new PrintScaling(attrs);\n  }\n  static printerName(attrs) {\n    return new PrinterName(attrs);\n  }\n  static producer(attrs) {\n    return new Producer(attrs);\n  }\n  static ps(attrs) {\n    return new Ps(attrs);\n  }\n  static range(attrs) {\n    return new Range(attrs);\n  }\n  static record(attrs) {\n    return new Record(attrs);\n  }\n  static relevant(attrs) {\n    return new Relevant(attrs);\n  }\n  static rename(attrs) {\n    return new Rename(attrs);\n  }\n  static renderPolicy(attrs) {\n    return new RenderPolicy(attrs);\n  }\n  static runScripts(attrs) {\n    return new RunScripts(attrs);\n  }\n  static script(attrs) {\n    return new config_Script(attrs);\n  }\n  static scriptModel(attrs) {\n    return new ScriptModel(attrs);\n  }\n  static severity(attrs) {\n    return new Severity(attrs);\n  }\n  static silentPrint(attrs) {\n    return new SilentPrint(attrs);\n  }\n  static staple(attrs) {\n    return new Staple(attrs);\n  }\n  static startNode(attrs) {\n    return new StartNode(attrs);\n  }\n  static startPage(attrs) {\n    return new StartPage(attrs);\n  }\n  static submitFormat(attrs) {\n    return new SubmitFormat(attrs);\n  }\n  static submitUrl(attrs) {\n    return new SubmitUrl(attrs);\n  }\n  static subsetBelow(attrs) {\n    return new SubsetBelow(attrs);\n  }\n  static suppressBanner(attrs) {\n    return new SuppressBanner(attrs);\n  }\n  static tagged(attrs) {\n    return new Tagged(attrs);\n  }\n  static template(attrs) {\n    return new config_Template(attrs);\n  }\n  static templateCache(attrs) {\n    return new TemplateCache(attrs);\n  }\n  static threshold(attrs) {\n    return new Threshold(attrs);\n  }\n  static to(attrs) {\n    return new To(attrs);\n  }\n  static trace(attrs) {\n    return new Trace(attrs);\n  }\n  static transform(attrs) {\n    return new Transform(attrs);\n  }\n  static type(attrs) {\n    return new Type(attrs);\n  }\n  static uri(attrs) {\n    return new Uri(attrs);\n  }\n  static validate(attrs) {\n    return new config_Validate(attrs);\n  }\n  static validateApprovalSignatures(attrs) {\n    return new ValidateApprovalSignatures(attrs);\n  }\n  static validationMessaging(attrs) {\n    return new ValidationMessaging(attrs);\n  }\n  static version(attrs) {\n    return new Version(attrs);\n  }\n  static versionControl(attrs) {\n    return new VersionControl(attrs);\n  }\n  static viewerPreferences(attrs) {\n    return new ViewerPreferences(attrs);\n  }\n  static webClient(attrs) {\n    return new WebClient(attrs);\n  }\n  static whitespace(attrs) {\n    return new Whitespace(attrs);\n  }\n  static window(attrs) {\n    return new Window(attrs);\n  }\n  static xdc(attrs) {\n    return new Xdc(attrs);\n  }\n  static xdp(attrs) {\n    return new Xdp(attrs);\n  }\n  static xsl(attrs) {\n    return new Xsl(attrs);\n  }\n  static zpl(attrs) {\n    return new Zpl(attrs);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/connection_set.js\n\n\nconst CONNECTION_SET_NS_ID = NamespaceIds.connectionSet.id;\nclass ConnectionSet extends XFAObject {\n  constructor(attributes) {\n    super(CONNECTION_SET_NS_ID, \"connectionSet\", true);\n    this.wsdlConnection = new XFAObjectArray();\n    this.xmlConnection = new XFAObjectArray();\n    this.xsdConnection = new XFAObjectArray();\n  }\n}\nclass EffectiveInputPolicy extends XFAObject {\n  constructor(attributes) {\n    super(CONNECTION_SET_NS_ID, \"effectiveInputPolicy\");\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass EffectiveOutputPolicy extends XFAObject {\n  constructor(attributes) {\n    super(CONNECTION_SET_NS_ID, \"effectiveOutputPolicy\");\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass Operation extends StringObject {\n  constructor(attributes) {\n    super(CONNECTION_SET_NS_ID, \"operation\");\n    this.id = attributes.id || \"\";\n    this.input = attributes.input || \"\";\n    this.name = attributes.name || \"\";\n    this.output = attributes.output || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass RootElement extends StringObject {\n  constructor(attributes) {\n    super(CONNECTION_SET_NS_ID, \"rootElement\");\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass SoapAction extends StringObject {\n  constructor(attributes) {\n    super(CONNECTION_SET_NS_ID, \"soapAction\");\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass SoapAddress extends StringObject {\n  constructor(attributes) {\n    super(CONNECTION_SET_NS_ID, \"soapAddress\");\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass connection_set_Uri extends StringObject {\n  constructor(attributes) {\n    super(CONNECTION_SET_NS_ID, \"uri\");\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass WsdlAddress extends StringObject {\n  constructor(attributes) {\n    super(CONNECTION_SET_NS_ID, \"wsdlAddress\");\n    this.id = attributes.id || \"\";\n    this.name = attributes.name || \"\";\n    this.use = attributes.use || \"\";\n    this.usehref = attributes.usehref || \"\";\n  }\n}\nclass WsdlConnection extends XFAObject {\n  constructor(attributes) {\n    super(CONNECTION_SET_NS_ID, \"wsdlConnection\", true);\n    this.dataDescription = attributes.dataDescription || \"\";\n    this.name = attributes.name || \"\";\n    this.effectiveInputPolicy = null;\n    this.effectiveOutputPolicy = null;\n    this.operation = null;\n    this.soapAction = null;\n    this.soapAddress = null;\n    this.wsdlAddress = null;\n  }\n}\nclass XmlConnection extends XFAObject {\n  constructor(attributes) {\n    super(CONNECTION_SET_NS_ID, \"xmlConnection\", true);\n    this.dataDescription = attributes.dataDescription || \"\";\n    this.name = attributes.name || \"\";\n    this.uri = null;\n  }\n}\nclass XsdConnection extends XFAObject {\n  constructor(attributes) {\n    super(CONNECTION_SET_NS_ID, \"xsdConnection\", true);\n    this.dataDescription = attributes.dataDescription || \"\";\n    this.name = attributes.name || \"\";\n    this.rootElement = null;\n    this.uri = null;\n  }\n}\nclass ConnectionSetNamespace {\n  static [$buildXFAObject](name, attributes) {\n    if (ConnectionSetNamespace.hasOwnProperty(name)) {\n      return ConnectionSetNamespace[name](attributes);\n    }\n    return undefined;\n  }\n  static connectionSet(attrs) {\n    return new ConnectionSet(attrs);\n  }\n  static effectiveInputPolicy(attrs) {\n    return new EffectiveInputPolicy(attrs);\n  }\n  static effectiveOutputPolicy(attrs) {\n    return new EffectiveOutputPolicy(attrs);\n  }\n  static operation(attrs) {\n    return new Operation(attrs);\n  }\n  static rootElement(attrs) {\n    return new RootElement(attrs);\n  }\n  static soapAction(attrs) {\n    return new SoapAction(attrs);\n  }\n  static soapAddress(attrs) {\n    return new SoapAddress(attrs);\n  }\n  static uri(attrs) {\n    return new connection_set_Uri(attrs);\n  }\n  static wsdlAddress(attrs) {\n    return new WsdlAddress(attrs);\n  }\n  static wsdlConnection(attrs) {\n    return new WsdlConnection(attrs);\n  }\n  static xmlConnection(attrs) {\n    return new XmlConnection(attrs);\n  }\n  static xsdConnection(attrs) {\n    return new XsdConnection(attrs);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/datasets.js\n\n\n\nconst DATASETS_NS_ID = NamespaceIds.datasets.id;\nclass datasets_Data extends XmlObject {\n  constructor(attributes) {\n    super(DATASETS_NS_ID, \"data\", attributes);\n  }\n  [$isNsAgnostic]() {\n    return true;\n  }\n}\nclass Datasets extends XFAObject {\n  constructor(attributes) {\n    super(DATASETS_NS_ID, \"datasets\", true);\n    this.data = null;\n    this.Signature = null;\n  }\n  [$onChild](child) {\n    const name = child[$nodeName];\n    if (name === \"data\" && child[$namespaceId] === DATASETS_NS_ID || name === \"Signature\" && child[$namespaceId] === NamespaceIds.signature.id) {\n      this[name] = child;\n    }\n    this[$appendChild](child);\n  }\n}\nclass DatasetsNamespace {\n  static [$buildXFAObject](name, attributes) {\n    if (DatasetsNamespace.hasOwnProperty(name)) {\n      return DatasetsNamespace[name](attributes);\n    }\n    return undefined;\n  }\n  static datasets(attributes) {\n    return new Datasets(attributes);\n  }\n  static data(attributes) {\n    return new datasets_Data(attributes);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/locale_set.js\n\n\n\nconst LOCALE_SET_NS_ID = NamespaceIds.localeSet.id;\nclass CalendarSymbols extends XFAObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"calendarSymbols\", true);\n    this.name = \"gregorian\";\n    this.dayNames = new XFAObjectArray(2);\n    this.eraNames = null;\n    this.meridiemNames = null;\n    this.monthNames = new XFAObjectArray(2);\n  }\n}\nclass CurrencySymbol extends StringObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"currencySymbol\");\n    this.name = getStringOption(attributes.name, [\"symbol\", \"isoname\", \"decimal\"]);\n  }\n}\nclass CurrencySymbols extends XFAObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"currencySymbols\", true);\n    this.currencySymbol = new XFAObjectArray(3);\n  }\n}\nclass DatePattern extends StringObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"datePattern\");\n    this.name = getStringOption(attributes.name, [\"full\", \"long\", \"med\", \"short\"]);\n  }\n}\nclass DatePatterns extends XFAObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"datePatterns\", true);\n    this.datePattern = new XFAObjectArray(4);\n  }\n}\nclass DateTimeSymbols extends ContentObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"dateTimeSymbols\");\n  }\n}\nclass Day extends StringObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"day\");\n  }\n}\nclass DayNames extends XFAObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"dayNames\", true);\n    this.abbr = getInteger({\n      data: attributes.abbr,\n      defaultValue: 0,\n      validate: x => x === 1\n    });\n    this.day = new XFAObjectArray(7);\n  }\n}\nclass Era extends StringObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"era\");\n  }\n}\nclass EraNames extends XFAObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"eraNames\", true);\n    this.era = new XFAObjectArray(2);\n  }\n}\nclass locale_set_Locale extends XFAObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"locale\", true);\n    this.desc = attributes.desc || \"\";\n    this.name = \"isoname\";\n    this.calendarSymbols = null;\n    this.currencySymbols = null;\n    this.datePatterns = null;\n    this.dateTimeSymbols = null;\n    this.numberPatterns = null;\n    this.numberSymbols = null;\n    this.timePatterns = null;\n    this.typeFaces = null;\n  }\n}\nclass locale_set_LocaleSet extends XFAObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"localeSet\", true);\n    this.locale = new XFAObjectArray();\n  }\n}\nclass Meridiem extends StringObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"meridiem\");\n  }\n}\nclass MeridiemNames extends XFAObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"meridiemNames\", true);\n    this.meridiem = new XFAObjectArray(2);\n  }\n}\nclass Month extends StringObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"month\");\n  }\n}\nclass MonthNames extends XFAObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"monthNames\", true);\n    this.abbr = getInteger({\n      data: attributes.abbr,\n      defaultValue: 0,\n      validate: x => x === 1\n    });\n    this.month = new XFAObjectArray(12);\n  }\n}\nclass NumberPattern extends StringObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"numberPattern\");\n    this.name = getStringOption(attributes.name, [\"full\", \"long\", \"med\", \"short\"]);\n  }\n}\nclass NumberPatterns extends XFAObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"numberPatterns\", true);\n    this.numberPattern = new XFAObjectArray(4);\n  }\n}\nclass NumberSymbol extends StringObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"numberSymbol\");\n    this.name = getStringOption(attributes.name, [\"decimal\", \"grouping\", \"percent\", \"minus\", \"zero\"]);\n  }\n}\nclass NumberSymbols extends XFAObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"numberSymbols\", true);\n    this.numberSymbol = new XFAObjectArray(5);\n  }\n}\nclass TimePattern extends StringObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"timePattern\");\n    this.name = getStringOption(attributes.name, [\"full\", \"long\", \"med\", \"short\"]);\n  }\n}\nclass TimePatterns extends XFAObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"timePatterns\", true);\n    this.timePattern = new XFAObjectArray(4);\n  }\n}\nclass TypeFace extends XFAObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"typeFace\", true);\n    this.name = attributes.name | \"\";\n  }\n}\nclass TypeFaces extends XFAObject {\n  constructor(attributes) {\n    super(LOCALE_SET_NS_ID, \"typeFaces\", true);\n    this.typeFace = new XFAObjectArray();\n  }\n}\nclass LocaleSetNamespace {\n  static [$buildXFAObject](name, attributes) {\n    if (LocaleSetNamespace.hasOwnProperty(name)) {\n      return LocaleSetNamespace[name](attributes);\n    }\n    return undefined;\n  }\n  static calendarSymbols(attrs) {\n    return new CalendarSymbols(attrs);\n  }\n  static currencySymbol(attrs) {\n    return new CurrencySymbol(attrs);\n  }\n  static currencySymbols(attrs) {\n    return new CurrencySymbols(attrs);\n  }\n  static datePattern(attrs) {\n    return new DatePattern(attrs);\n  }\n  static datePatterns(attrs) {\n    return new DatePatterns(attrs);\n  }\n  static dateTimeSymbols(attrs) {\n    return new DateTimeSymbols(attrs);\n  }\n  static day(attrs) {\n    return new Day(attrs);\n  }\n  static dayNames(attrs) {\n    return new DayNames(attrs);\n  }\n  static era(attrs) {\n    return new Era(attrs);\n  }\n  static eraNames(attrs) {\n    return new EraNames(attrs);\n  }\n  static locale(attrs) {\n    return new locale_set_Locale(attrs);\n  }\n  static localeSet(attrs) {\n    return new locale_set_LocaleSet(attrs);\n  }\n  static meridiem(attrs) {\n    return new Meridiem(attrs);\n  }\n  static meridiemNames(attrs) {\n    return new MeridiemNames(attrs);\n  }\n  static month(attrs) {\n    return new Month(attrs);\n  }\n  static monthNames(attrs) {\n    return new MonthNames(attrs);\n  }\n  static numberPattern(attrs) {\n    return new NumberPattern(attrs);\n  }\n  static numberPatterns(attrs) {\n    return new NumberPatterns(attrs);\n  }\n  static numberSymbol(attrs) {\n    return new NumberSymbol(attrs);\n  }\n  static numberSymbols(attrs) {\n    return new NumberSymbols(attrs);\n  }\n  static timePattern(attrs) {\n    return new TimePattern(attrs);\n  }\n  static timePatterns(attrs) {\n    return new TimePatterns(attrs);\n  }\n  static typeFace(attrs) {\n    return new TypeFace(attrs);\n  }\n  static typeFaces(attrs) {\n    return new TypeFaces(attrs);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/signature.js\n\n\nconst SIGNATURE_NS_ID = NamespaceIds.signature.id;\nclass signature_Signature extends XFAObject {\n  constructor(attributes) {\n    super(SIGNATURE_NS_ID, \"signature\", true);\n  }\n}\nclass SignatureNamespace {\n  static [$buildXFAObject](name, attributes) {\n    if (SignatureNamespace.hasOwnProperty(name)) {\n      return SignatureNamespace[name](attributes);\n    }\n    return undefined;\n  }\n  static signature(attributes) {\n    return new signature_Signature(attributes);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/stylesheet.js\n\n\nconst STYLESHEET_NS_ID = NamespaceIds.stylesheet.id;\nclass Stylesheet extends XFAObject {\n  constructor(attributes) {\n    super(STYLESHEET_NS_ID, \"stylesheet\", true);\n  }\n}\nclass StylesheetNamespace {\n  static [$buildXFAObject](name, attributes) {\n    if (StylesheetNamespace.hasOwnProperty(name)) {\n      return StylesheetNamespace[name](attributes);\n    }\n    return undefined;\n  }\n  static stylesheet(attributes) {\n    return new Stylesheet(attributes);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/xdp.js\n\n\n\nconst XDP_NS_ID = NamespaceIds.xdp.id;\nclass xdp_Xdp extends XFAObject {\n  constructor(attributes) {\n    super(XDP_NS_ID, \"xdp\", true);\n    this.uuid = attributes.uuid || \"\";\n    this.timeStamp = attributes.timeStamp || \"\";\n    this.config = null;\n    this.connectionSet = null;\n    this.datasets = null;\n    this.localeSet = null;\n    this.stylesheet = new XFAObjectArray();\n    this.template = null;\n  }\n  [$onChildCheck](child) {\n    const ns = NamespaceIds[child[$nodeName]];\n    return ns && child[$namespaceId] === ns.id;\n  }\n}\nclass XdpNamespace {\n  static [$buildXFAObject](name, attributes) {\n    if (XdpNamespace.hasOwnProperty(name)) {\n      return XdpNamespace[name](attributes);\n    }\n    return undefined;\n  }\n  static xdp(attributes) {\n    return new xdp_Xdp(attributes);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/xhtml.js\n\n\n\n\n\nconst XHTML_NS_ID = NamespaceIds.xhtml.id;\nconst $richText = Symbol();\nconst VALID_STYLES = new Set([\"color\", \"font\", \"font-family\", \"font-size\", \"font-stretch\", \"font-style\", \"font-weight\", \"margin\", \"margin-bottom\", \"margin-left\", \"margin-right\", \"margin-top\", \"letter-spacing\", \"line-height\", \"orphans\", \"page-break-after\", \"page-break-before\", \"page-break-inside\", \"tab-interval\", \"tab-stop\", \"text-align\", \"text-decoration\", \"text-indent\", \"vertical-align\", \"widows\", \"kerning-mode\", \"xfa-font-horizontal-scale\", \"xfa-font-vertical-scale\", \"xfa-spacerun\", \"xfa-tab-stops\"]);\nconst StyleMapping = new Map([[\"page-break-after\", \"breakAfter\"], [\"page-break-before\", \"breakBefore\"], [\"page-break-inside\", \"breakInside\"], [\"kerning-mode\", value => value === \"none\" ? \"none\" : \"normal\"], [\"xfa-font-horizontal-scale\", value => `scaleX(${Math.max(0, Math.min(parseInt(value) / 100)).toFixed(2)})`], [\"xfa-font-vertical-scale\", value => `scaleY(${Math.max(0, Math.min(parseInt(value) / 100)).toFixed(2)})`], [\"xfa-spacerun\", \"\"], [\"xfa-tab-stops\", \"\"], [\"font-size\", (value, original) => {\n  value = original.fontSize = getMeasurement(value);\n  return measureToString(0.99 * value);\n}], [\"letter-spacing\", value => measureToString(getMeasurement(value))], [\"line-height\", value => measureToString(getMeasurement(value))], [\"margin\", value => measureToString(getMeasurement(value))], [\"margin-bottom\", value => measureToString(getMeasurement(value))], [\"margin-left\", value => measureToString(getMeasurement(value))], [\"margin-right\", value => measureToString(getMeasurement(value))], [\"margin-top\", value => measureToString(getMeasurement(value))], [\"text-indent\", value => measureToString(getMeasurement(value))], [\"font-family\", value => value], [\"vertical-align\", value => measureToString(getMeasurement(value))]]);\nconst spacesRegExp = /\\s+/g;\nconst crlfRegExp = /[\\r\\n]+/g;\nconst crlfForRichTextRegExp = /\\r\\n?/g;\nfunction mapStyle(styleStr, node, richText) {\n  const style = Object.create(null);\n  if (!styleStr) {\n    return style;\n  }\n  const original = Object.create(null);\n  for (const [key, value] of styleStr.split(\";\").map(s => s.split(\":\", 2))) {\n    const mapping = StyleMapping.get(key);\n    if (mapping === \"\") {\n      continue;\n    }\n    let newValue = value;\n    if (mapping) {\n      newValue = typeof mapping === \"string\" ? mapping : mapping(value, original);\n    }\n    if (key.endsWith(\"scale\")) {\n      style.transform = style.transform ? `${style[key]} ${newValue}` : newValue;\n    } else {\n      style[key.replaceAll(/-([a-zA-Z])/g, (_, x) => x.toUpperCase())] = newValue;\n    }\n  }\n  if (style.fontFamily) {\n    setFontFamily({\n      typeface: style.fontFamily,\n      weight: style.fontWeight || \"normal\",\n      posture: style.fontStyle || \"normal\",\n      size: original.fontSize || 0\n    }, node, node[$globalData].fontFinder, style);\n  }\n  if (richText && style.verticalAlign && style.verticalAlign !== \"0px\" && style.fontSize) {\n    const SUB_SUPER_SCRIPT_FACTOR = 0.583;\n    const VERTICAL_FACTOR = 0.333;\n    const fontSize = getMeasurement(style.fontSize);\n    style.fontSize = measureToString(fontSize * SUB_SUPER_SCRIPT_FACTOR);\n    style.verticalAlign = measureToString(Math.sign(getMeasurement(style.verticalAlign)) * fontSize * VERTICAL_FACTOR);\n  }\n  if (richText && style.fontSize) {\n    style.fontSize = `calc(${style.fontSize} * var(--scale-factor))`;\n  }\n  fixTextIndent(style);\n  return style;\n}\nfunction checkStyle(node) {\n  if (!node.style) {\n    return \"\";\n  }\n  return node.style.trim().split(/\\s*;\\s*/).filter(s => !!s).map(s => s.split(/\\s*:\\s*/, 2)).filter(([key, value]) => {\n    if (key === \"font-family\") {\n      node[$globalData].usedTypefaces.add(value);\n    }\n    return VALID_STYLES.has(key);\n  }).map(kv => kv.join(\":\")).join(\";\");\n}\nconst NoWhites = new Set([\"body\", \"html\"]);\nclass XhtmlObject extends XmlObject {\n  constructor(attributes, name) {\n    super(XHTML_NS_ID, name);\n    this[$richText] = false;\n    this.style = attributes.style || \"\";\n  }\n  [$clean](builder) {\n    super[$clean](builder);\n    this.style = checkStyle(this);\n  }\n  [$acceptWhitespace]() {\n    return !NoWhites.has(this[$nodeName]);\n  }\n  [$onText](str, richText = false) {\n    if (!richText) {\n      str = str.replaceAll(crlfRegExp, \"\");\n      if (!this.style.includes(\"xfa-spacerun:yes\")) {\n        str = str.replaceAll(spacesRegExp, \" \");\n      }\n    } else {\n      this[$richText] = true;\n    }\n    if (str) {\n      this[$content] += str;\n    }\n  }\n  [$pushGlyphs](measure, mustPop = true) {\n    const xfaFont = Object.create(null);\n    const margin = {\n      top: NaN,\n      bottom: NaN,\n      left: NaN,\n      right: NaN\n    };\n    let lineHeight = null;\n    for (const [key, value] of this.style.split(\";\").map(s => s.split(\":\", 2))) {\n      switch (key) {\n        case \"font-family\":\n          xfaFont.typeface = stripQuotes(value);\n          break;\n        case \"font-size\":\n          xfaFont.size = getMeasurement(value);\n          break;\n        case \"font-weight\":\n          xfaFont.weight = value;\n          break;\n        case \"font-style\":\n          xfaFont.posture = value;\n          break;\n        case \"letter-spacing\":\n          xfaFont.letterSpacing = getMeasurement(value);\n          break;\n        case \"margin\":\n          const values = value.split(/ \\t/).map(x => getMeasurement(x));\n          switch (values.length) {\n            case 1:\n              margin.top = margin.bottom = margin.left = margin.right = values[0];\n              break;\n            case 2:\n              margin.top = margin.bottom = values[0];\n              margin.left = margin.right = values[1];\n              break;\n            case 3:\n              margin.top = values[0];\n              margin.bottom = values[2];\n              margin.left = margin.right = values[1];\n              break;\n            case 4:\n              margin.top = values[0];\n              margin.left = values[1];\n              margin.bottom = values[2];\n              margin.right = values[3];\n              break;\n          }\n          break;\n        case \"margin-top\":\n          margin.top = getMeasurement(value);\n          break;\n        case \"margin-bottom\":\n          margin.bottom = getMeasurement(value);\n          break;\n        case \"margin-left\":\n          margin.left = getMeasurement(value);\n          break;\n        case \"margin-right\":\n          margin.right = getMeasurement(value);\n          break;\n        case \"line-height\":\n          lineHeight = getMeasurement(value);\n          break;\n      }\n    }\n    measure.pushData(xfaFont, margin, lineHeight);\n    if (this[$content]) {\n      measure.addString(this[$content]);\n    } else {\n      for (const child of this[$getChildren]()) {\n        if (child[$nodeName] === \"#text\") {\n          measure.addString(child[$content]);\n          continue;\n        }\n        child[$pushGlyphs](measure);\n      }\n    }\n    if (mustPop) {\n      measure.popFont();\n    }\n  }\n  [$toHTML](availableSpace) {\n    const children = [];\n    this[$extra] = {\n      children\n    };\n    this[$childrenToHTML]({});\n    if (children.length === 0 && !this[$content]) {\n      return HTMLResult.EMPTY;\n    }\n    let value;\n    if (this[$richText]) {\n      value = this[$content] ? this[$content].replaceAll(crlfForRichTextRegExp, \"\\n\") : undefined;\n    } else {\n      value = this[$content] || undefined;\n    }\n    return HTMLResult.success({\n      name: this[$nodeName],\n      attributes: {\n        href: this.href,\n        style: mapStyle(this.style, this, this[$richText])\n      },\n      children,\n      value\n    });\n  }\n}\nclass A extends XhtmlObject {\n  constructor(attributes) {\n    super(attributes, \"a\");\n    this.href = fixURL(attributes.href) || \"\";\n  }\n}\nclass B extends XhtmlObject {\n  constructor(attributes) {\n    super(attributes, \"b\");\n  }\n  [$pushGlyphs](measure) {\n    measure.pushFont({\n      weight: \"bold\"\n    });\n    super[$pushGlyphs](measure);\n    measure.popFont();\n  }\n}\nclass Body extends XhtmlObject {\n  constructor(attributes) {\n    super(attributes, \"body\");\n  }\n  [$toHTML](availableSpace) {\n    const res = super[$toHTML](availableSpace);\n    const {\n      html\n    } = res;\n    if (!html) {\n      return HTMLResult.EMPTY;\n    }\n    html.name = \"div\";\n    html.attributes.class = [\"xfaRich\"];\n    return res;\n  }\n}\nclass Br extends XhtmlObject {\n  constructor(attributes) {\n    super(attributes, \"br\");\n  }\n  [$text]() {\n    return \"\\n\";\n  }\n  [$pushGlyphs](measure) {\n    measure.addString(\"\\n\");\n  }\n  [$toHTML](availableSpace) {\n    return HTMLResult.success({\n      name: \"br\"\n    });\n  }\n}\nclass Html extends XhtmlObject {\n  constructor(attributes) {\n    super(attributes, \"html\");\n  }\n  [$toHTML](availableSpace) {\n    const children = [];\n    this[$extra] = {\n      children\n    };\n    this[$childrenToHTML]({});\n    if (children.length === 0) {\n      return HTMLResult.success({\n        name: \"div\",\n        attributes: {\n          class: [\"xfaRich\"],\n          style: {}\n        },\n        value: this[$content] || \"\"\n      });\n    }\n    if (children.length === 1) {\n      const child = children[0];\n      if (child.attributes?.class.includes(\"xfaRich\")) {\n        return HTMLResult.success(child);\n      }\n    }\n    return HTMLResult.success({\n      name: \"div\",\n      attributes: {\n        class: [\"xfaRich\"],\n        style: {}\n      },\n      children\n    });\n  }\n}\nclass I extends XhtmlObject {\n  constructor(attributes) {\n    super(attributes, \"i\");\n  }\n  [$pushGlyphs](measure) {\n    measure.pushFont({\n      posture: \"italic\"\n    });\n    super[$pushGlyphs](measure);\n    measure.popFont();\n  }\n}\nclass Li extends XhtmlObject {\n  constructor(attributes) {\n    super(attributes, \"li\");\n  }\n}\nclass Ol extends XhtmlObject {\n  constructor(attributes) {\n    super(attributes, \"ol\");\n  }\n}\nclass P extends XhtmlObject {\n  constructor(attributes) {\n    super(attributes, \"p\");\n  }\n  [$pushGlyphs](measure) {\n    super[$pushGlyphs](measure, false);\n    measure.addString(\"\\n\");\n    measure.addPara();\n    measure.popFont();\n  }\n  [$text]() {\n    const siblings = this[$getParent]()[$getChildren]();\n    if (siblings.at(-1) === this) {\n      return super[$text]();\n    }\n    return super[$text]() + \"\\n\";\n  }\n}\nclass Span extends XhtmlObject {\n  constructor(attributes) {\n    super(attributes, \"span\");\n  }\n}\nclass Sub extends XhtmlObject {\n  constructor(attributes) {\n    super(attributes, \"sub\");\n  }\n}\nclass Sup extends XhtmlObject {\n  constructor(attributes) {\n    super(attributes, \"sup\");\n  }\n}\nclass Ul extends XhtmlObject {\n  constructor(attributes) {\n    super(attributes, \"ul\");\n  }\n}\nclass XhtmlNamespace {\n  static [$buildXFAObject](name, attributes) {\n    if (XhtmlNamespace.hasOwnProperty(name)) {\n      return XhtmlNamespace[name](attributes);\n    }\n    return undefined;\n  }\n  static a(attributes) {\n    return new A(attributes);\n  }\n  static b(attributes) {\n    return new B(attributes);\n  }\n  static body(attributes) {\n    return new Body(attributes);\n  }\n  static br(attributes) {\n    return new Br(attributes);\n  }\n  static html(attributes) {\n    return new Html(attributes);\n  }\n  static i(attributes) {\n    return new I(attributes);\n  }\n  static li(attributes) {\n    return new Li(attributes);\n  }\n  static ol(attributes) {\n    return new Ol(attributes);\n  }\n  static p(attributes) {\n    return new P(attributes);\n  }\n  static span(attributes) {\n    return new Span(attributes);\n  }\n  static sub(attributes) {\n    return new Sub(attributes);\n  }\n  static sup(attributes) {\n    return new Sup(attributes);\n  }\n  static ul(attributes) {\n    return new Ul(attributes);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/setup.js\n\n\n\n\n\n\n\n\n\nconst NamespaceSetUp = {\n  config: ConfigNamespace,\n  connection: ConnectionSetNamespace,\n  datasets: DatasetsNamespace,\n  localeSet: LocaleSetNamespace,\n  signature: SignatureNamespace,\n  stylesheet: StylesheetNamespace,\n  template: TemplateNamespace,\n  xdp: XdpNamespace,\n  xhtml: XhtmlNamespace\n};\n\n;// CONCATENATED MODULE: ./src/core/xfa/unknown.js\n\n\nclass UnknownNamespace {\n  constructor(nsId) {\n    this.namespaceId = nsId;\n  }\n  [$buildXFAObject](name, attributes) {\n    return new XmlObject(this.namespaceId, name, attributes);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/builder.js\n\n\n\n\n\n\n\nclass Root extends XFAObject {\n  constructor(ids) {\n    super(-1, \"root\", Object.create(null));\n    this.element = null;\n    this[$ids] = ids;\n  }\n  [$onChild](child) {\n    this.element = child;\n    return true;\n  }\n  [$finalize]() {\n    super[$finalize]();\n    if (this.element.template instanceof Template) {\n      this[$ids].set($root, this.element);\n      this.element.template[$resolvePrototypes](this[$ids]);\n      this.element.template[$ids] = this[$ids];\n    }\n  }\n}\nclass Empty extends XFAObject {\n  constructor() {\n    super(-1, \"\", Object.create(null));\n  }\n  [$onChild](_) {\n    return false;\n  }\n}\nclass Builder {\n  constructor(rootNameSpace = null) {\n    this._namespaceStack = [];\n    this._nsAgnosticLevel = 0;\n    this._namespacePrefixes = new Map();\n    this._namespaces = new Map();\n    this._nextNsId = Math.max(...Object.values(NamespaceIds).map(({\n      id\n    }) => id));\n    this._currentNamespace = rootNameSpace || new UnknownNamespace(++this._nextNsId);\n  }\n  buildRoot(ids) {\n    return new Root(ids);\n  }\n  build({\n    nsPrefix,\n    name,\n    attributes,\n    namespace,\n    prefixes\n  }) {\n    const hasNamespaceDef = namespace !== null;\n    if (hasNamespaceDef) {\n      this._namespaceStack.push(this._currentNamespace);\n      this._currentNamespace = this._searchNamespace(namespace);\n    }\n    if (prefixes) {\n      this._addNamespacePrefix(prefixes);\n    }\n    if (attributes.hasOwnProperty($nsAttributes)) {\n      const dataTemplate = NamespaceSetUp.datasets;\n      const nsAttrs = attributes[$nsAttributes];\n      let xfaAttrs = null;\n      for (const [ns, attrs] of Object.entries(nsAttrs)) {\n        const nsToUse = this._getNamespaceToUse(ns);\n        if (nsToUse === dataTemplate) {\n          xfaAttrs = {\n            xfa: attrs\n          };\n          break;\n        }\n      }\n      if (xfaAttrs) {\n        attributes[$nsAttributes] = xfaAttrs;\n      } else {\n        delete attributes[$nsAttributes];\n      }\n    }\n    const namespaceToUse = this._getNamespaceToUse(nsPrefix);\n    const node = namespaceToUse?.[$buildXFAObject](name, attributes) || new Empty();\n    if (node[$isNsAgnostic]()) {\n      this._nsAgnosticLevel++;\n    }\n    if (hasNamespaceDef || prefixes || node[$isNsAgnostic]()) {\n      node[$cleanup] = {\n        hasNamespace: hasNamespaceDef,\n        prefixes,\n        nsAgnostic: node[$isNsAgnostic]()\n      };\n    }\n    return node;\n  }\n  isNsAgnostic() {\n    return this._nsAgnosticLevel > 0;\n  }\n  _searchNamespace(nsName) {\n    let ns = this._namespaces.get(nsName);\n    if (ns) {\n      return ns;\n    }\n    for (const [name, {\n      check\n    }] of Object.entries(NamespaceIds)) {\n      if (check(nsName)) {\n        ns = NamespaceSetUp[name];\n        if (ns) {\n          this._namespaces.set(nsName, ns);\n          return ns;\n        }\n        break;\n      }\n    }\n    ns = new UnknownNamespace(++this._nextNsId);\n    this._namespaces.set(nsName, ns);\n    return ns;\n  }\n  _addNamespacePrefix(prefixes) {\n    for (const {\n      prefix,\n      value\n    } of prefixes) {\n      const namespace = this._searchNamespace(value);\n      let prefixStack = this._namespacePrefixes.get(prefix);\n      if (!prefixStack) {\n        prefixStack = [];\n        this._namespacePrefixes.set(prefix, prefixStack);\n      }\n      prefixStack.push(namespace);\n    }\n  }\n  _getNamespaceToUse(prefix) {\n    if (!prefix) {\n      return this._currentNamespace;\n    }\n    const prefixStack = this._namespacePrefixes.get(prefix);\n    if (prefixStack?.length > 0) {\n      return prefixStack.at(-1);\n    }\n    warn(`Unknown namespace prefix: ${prefix}.`);\n    return null;\n  }\n  clean(data) {\n    const {\n      hasNamespace,\n      prefixes,\n      nsAgnostic\n    } = data;\n    if (hasNamespace) {\n      this._currentNamespace = this._namespaceStack.pop();\n    }\n    if (prefixes) {\n      prefixes.forEach(({\n        prefix\n      }) => {\n        this._namespacePrefixes.get(prefix).pop();\n      });\n    }\n    if (nsAgnostic) {\n      this._nsAgnosticLevel--;\n    }\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/parser.js\n\n\n\n\nclass XFAParser extends XMLParserBase {\n  constructor(rootNameSpace = null, richText = false) {\n    super();\n    this._builder = new Builder(rootNameSpace);\n    this._stack = [];\n    this._globalData = {\n      usedTypefaces: new Set()\n    };\n    this._ids = new Map();\n    this._current = this._builder.buildRoot(this._ids);\n    this._errorCode = XMLParserErrorCode.NoError;\n    this._whiteRegex = /^\\s+$/;\n    this._nbsps = /\\xa0+/g;\n    this._richText = richText;\n  }\n  parse(data) {\n    this.parseXml(data);\n    if (this._errorCode !== XMLParserErrorCode.NoError) {\n      return undefined;\n    }\n    this._current[$finalize]();\n    return this._current.element;\n  }\n  onText(text) {\n    text = text.replace(this._nbsps, match => match.slice(1) + \" \");\n    if (this._richText || this._current[$acceptWhitespace]()) {\n      this._current[$onText](text, this._richText);\n      return;\n    }\n    if (this._whiteRegex.test(text)) {\n      return;\n    }\n    this._current[$onText](text.trim());\n  }\n  onCdata(text) {\n    this._current[$onText](text);\n  }\n  _mkAttributes(attributes, tagName) {\n    let namespace = null;\n    let prefixes = null;\n    const attributeObj = Object.create({});\n    for (const {\n      name,\n      value\n    } of attributes) {\n      if (name === \"xmlns\") {\n        if (!namespace) {\n          namespace = value;\n        } else {\n          warn(`XFA - multiple namespace definition in <${tagName}>`);\n        }\n      } else if (name.startsWith(\"xmlns:\")) {\n        const prefix = name.substring(\"xmlns:\".length);\n        if (!prefixes) {\n          prefixes = [];\n        }\n        prefixes.push({\n          prefix,\n          value\n        });\n      } else {\n        const i = name.indexOf(\":\");\n        if (i === -1) {\n          attributeObj[name] = value;\n        } else {\n          let nsAttrs = attributeObj[$nsAttributes];\n          if (!nsAttrs) {\n            nsAttrs = attributeObj[$nsAttributes] = Object.create(null);\n          }\n          const [ns, attrName] = [name.slice(0, i), name.slice(i + 1)];\n          const attrs = nsAttrs[ns] ||= Object.create(null);\n          attrs[attrName] = value;\n        }\n      }\n    }\n    return [namespace, prefixes, attributeObj];\n  }\n  _getNameAndPrefix(name, nsAgnostic) {\n    const i = name.indexOf(\":\");\n    if (i === -1) {\n      return [name, null];\n    }\n    return [name.substring(i + 1), nsAgnostic ? \"\" : name.substring(0, i)];\n  }\n  onBeginElement(tagName, attributes, isEmpty) {\n    const [namespace, prefixes, attributesObj] = this._mkAttributes(attributes, tagName);\n    const [name, nsPrefix] = this._getNameAndPrefix(tagName, this._builder.isNsAgnostic());\n    const node = this._builder.build({\n      nsPrefix,\n      name,\n      attributes: attributesObj,\n      namespace,\n      prefixes\n    });\n    node[$globalData] = this._globalData;\n    if (isEmpty) {\n      node[$finalize]();\n      if (this._current[$onChild](node)) {\n        node[$setId](this._ids);\n      }\n      node[$clean](this._builder);\n      return;\n    }\n    this._stack.push(this._current);\n    this._current = node;\n  }\n  onEndElement(name) {\n    const node = this._current;\n    if (node[$isCDATAXml]() && typeof node[$content] === \"string\") {\n      const parser = new XFAParser();\n      parser._globalData = this._globalData;\n      const root = parser.parse(node[$content]);\n      node[$content] = null;\n      node[$onChild](root);\n    }\n    node[$finalize]();\n    this._current = this._stack.pop();\n    if (this._current[$onChild](node)) {\n      node[$setId](this._ids);\n    }\n    node[$clean](this._builder);\n  }\n  onError(code) {\n    this._errorCode = code;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xfa/factory.js\n\n\n\n\n\n\n\n\nclass XFAFactory {\n  constructor(data) {\n    try {\n      this.root = new XFAParser().parse(XFAFactory._createDocument(data));\n      const binder = new Binder(this.root);\n      this.form = binder.bind();\n      this.dataHandler = new DataHandler(this.root, binder.getData());\n      this.form[$globalData].template = this.form;\n    } catch (e) {\n      warn(`XFA - an error occurred during parsing and binding: ${e}`);\n    }\n  }\n  isValid() {\n    return this.root && this.form;\n  }\n  _createPagesHelper() {\n    const iterator = this.form[$toPages]();\n    return new Promise((resolve, reject) => {\n      const nextIteration = () => {\n        try {\n          const value = iterator.next();\n          if (value.done) {\n            resolve(value.value);\n          } else {\n            setTimeout(nextIteration, 0);\n          }\n        } catch (e) {\n          reject(e);\n        }\n      };\n      setTimeout(nextIteration, 0);\n    });\n  }\n  async _createPages() {\n    try {\n      this.pages = await this._createPagesHelper();\n      this.dims = this.pages.children.map(c => {\n        const {\n          width,\n          height\n        } = c.attributes.style;\n        return [0, 0, parseInt(width), parseInt(height)];\n      });\n    } catch (e) {\n      warn(`XFA - an error occurred during layout: ${e}`);\n    }\n  }\n  getBoundingBox(pageIndex) {\n    return this.dims[pageIndex];\n  }\n  async getNumPages() {\n    if (!this.pages) {\n      await this._createPages();\n    }\n    return this.dims.length;\n  }\n  setImages(images) {\n    this.form[$globalData].images = images;\n  }\n  setFonts(fonts) {\n    this.form[$globalData].fontFinder = new FontFinder(fonts);\n    const missingFonts = [];\n    for (let typeface of this.form[$globalData].usedTypefaces) {\n      typeface = stripQuotes(typeface);\n      const font = this.form[$globalData].fontFinder.find(typeface);\n      if (!font) {\n        missingFonts.push(typeface);\n      }\n    }\n    if (missingFonts.length > 0) {\n      return missingFonts;\n    }\n    return null;\n  }\n  appendFonts(fonts, reallyMissingFonts) {\n    this.form[$globalData].fontFinder.add(fonts, reallyMissingFonts);\n  }\n  async getPages() {\n    if (!this.pages) {\n      await this._createPages();\n    }\n    const pages = this.pages;\n    this.pages = null;\n    return pages;\n  }\n  serializeData(storage) {\n    return this.dataHandler.serialize(storage);\n  }\n  static _createDocument(data) {\n    if (!data[\"/xdp:xdp\"]) {\n      return data[\"xdp:xdp\"];\n    }\n    return Object.values(data).join(\"\");\n  }\n  static getRichTextAsHtml(rc) {\n    if (!rc || typeof rc !== \"string\") {\n      return null;\n    }\n    try {\n      let root = new XFAParser(XhtmlNamespace, true).parse(rc);\n      if (![\"body\", \"xhtml\"].includes(root[$nodeName])) {\n        const newRoot = XhtmlNamespace.body({});\n        newRoot[$appendChild](root);\n        root = newRoot;\n      }\n      const result = root[$toHTML]();\n      if (!result.success) {\n        return null;\n      }\n      const {\n        html\n      } = result;\n      const {\n        attributes\n      } = html;\n      if (attributes) {\n        if (attributes.class) {\n          attributes.class = attributes.class.filter(attr => !attr.startsWith(\"xfa\"));\n        }\n        attributes.dir = \"auto\";\n      }\n      return {\n        html,\n        str: root[$text]()\n      };\n    } catch (e) {\n      warn(`XFA - an error occurred during parsing of rich text: ${e}`);\n    }\n    return null;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/annotation.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass AnnotationFactory {\n  static createGlobals(pdfManager) {\n    return Promise.all([pdfManager.ensureCatalog(\"acroForm\"), pdfManager.ensureDoc(\"xfaDatasets\"), pdfManager.ensureCatalog(\"structTreeRoot\"), pdfManager.ensureCatalog(\"baseUrl\"), pdfManager.ensureCatalog(\"attachments\")]).then(([acroForm, xfaDatasets, structTreeRoot, baseUrl, attachments]) => {\n      return {\n        pdfManager,\n        acroForm: acroForm instanceof Dict ? acroForm : Dict.empty,\n        xfaDatasets,\n        structTreeRoot,\n        baseUrl,\n        attachments\n      };\n    }, reason => {\n      warn(`createGlobals: \"${reason}\".`);\n      return null;\n    });\n  }\n  static async create(xref, ref, annotationGlobals, idFactory, collectFields, pageRef) {\n    const pageIndex = collectFields ? await this._getPageIndex(xref, ref, annotationGlobals.pdfManager) : null;\n    return annotationGlobals.pdfManager.ensure(this, \"_create\", [xref, ref, annotationGlobals, idFactory, collectFields, pageIndex, pageRef]);\n  }\n  static _create(xref, ref, annotationGlobals, idFactory, collectFields = false, pageIndex = null, pageRef = null) {\n    const dict = xref.fetchIfRef(ref);\n    if (!(dict instanceof Dict)) {\n      return undefined;\n    }\n    const {\n      acroForm,\n      pdfManager\n    } = annotationGlobals;\n    const id = ref instanceof Ref ? ref.toString() : `annot_${idFactory.createObjId()}`;\n    let subtype = dict.get(\"Subtype\");\n    subtype = subtype instanceof Name ? subtype.name : null;\n    const parameters = {\n      xref,\n      ref,\n      dict,\n      subtype,\n      id,\n      annotationGlobals,\n      collectFields,\n      needAppearances: !collectFields && acroForm.get(\"NeedAppearances\") === true,\n      pageIndex,\n      evaluatorOptions: pdfManager.evaluatorOptions,\n      pageRef\n    };\n    switch (subtype) {\n      case \"Link\":\n        return new LinkAnnotation(parameters);\n      case \"Text\":\n        return new TextAnnotation(parameters);\n      case \"Widget\":\n        let fieldType = getInheritableProperty({\n          dict,\n          key: \"FT\"\n        });\n        fieldType = fieldType instanceof Name ? fieldType.name : null;\n        switch (fieldType) {\n          case \"Tx\":\n            return new TextWidgetAnnotation(parameters);\n          case \"Btn\":\n            return new ButtonWidgetAnnotation(parameters);\n          case \"Ch\":\n            return new ChoiceWidgetAnnotation(parameters);\n          case \"Sig\":\n            return new SignatureWidgetAnnotation(parameters);\n        }\n        warn(`Unimplemented widget field type \"${fieldType}\", ` + \"falling back to base field type.\");\n        return new WidgetAnnotation(parameters);\n      case \"Popup\":\n        return new PopupAnnotation(parameters);\n      case \"FreeText\":\n        return new FreeTextAnnotation(parameters);\n      case \"Line\":\n        return new LineAnnotation(parameters);\n      case \"Square\":\n        return new SquareAnnotation(parameters);\n      case \"Circle\":\n        return new CircleAnnotation(parameters);\n      case \"PolyLine\":\n        return new PolylineAnnotation(parameters);\n      case \"Polygon\":\n        return new PolygonAnnotation(parameters);\n      case \"Caret\":\n        return new CaretAnnotation(parameters);\n      case \"Ink\":\n        return new InkAnnotation(parameters);\n      case \"Highlight\":\n        return new HighlightAnnotation(parameters);\n      case \"Underline\":\n        return new UnderlineAnnotation(parameters);\n      case \"Squiggly\":\n        return new SquigglyAnnotation(parameters);\n      case \"StrikeOut\":\n        return new StrikeOutAnnotation(parameters);\n      case \"Stamp\":\n        return new StampAnnotation(parameters);\n      case \"FileAttachment\":\n        return new FileAttachmentAnnotation(parameters);\n      default:\n        if (!collectFields) {\n          if (!subtype) {\n            warn(\"Annotation is missing the required /Subtype.\");\n          } else {\n            warn(`Unimplemented annotation type \"${subtype}\", ` + \"falling back to base annotation.\");\n          }\n        }\n        return new Annotation(parameters);\n    }\n  }\n  static async _getPageIndex(xref, ref, pdfManager) {\n    try {\n      const annotDict = await xref.fetchIfRefAsync(ref);\n      if (!(annotDict instanceof Dict)) {\n        return -1;\n      }\n      const pageRef = annotDict.getRaw(\"P\");\n      if (pageRef instanceof Ref) {\n        try {\n          const pageIndex = await pdfManager.ensureCatalog(\"getPageIndex\", [pageRef]);\n          return pageIndex;\n        } catch (ex) {\n          info(`_getPageIndex -- not a valid page reference: \"${ex}\".`);\n        }\n      }\n      if (annotDict.has(\"Kids\")) {\n        return -1;\n      }\n      const numPages = await pdfManager.ensureDoc(\"numPages\");\n      for (let pageIndex = 0; pageIndex < numPages; pageIndex++) {\n        const page = await pdfManager.getPage(pageIndex);\n        const annotations = await pdfManager.ensure(page, \"annotations\");\n        for (const annotRef of annotations) {\n          if (annotRef instanceof Ref && isRefsEqual(annotRef, ref)) {\n            return pageIndex;\n          }\n        }\n      }\n    } catch (ex) {\n      warn(`_getPageIndex: \"${ex}\".`);\n    }\n    return -1;\n  }\n  static generateImages(annotations, xref, isOffscreenCanvasSupported) {\n    if (!isOffscreenCanvasSupported) {\n      warn(\"generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images.\");\n      return null;\n    }\n    let imagePromises;\n    for (const {\n      bitmapId,\n      bitmap\n    } of annotations) {\n      if (!bitmap) {\n        continue;\n      }\n      imagePromises ||= new Map();\n      imagePromises.set(bitmapId, StampAnnotation.createImage(bitmap, xref));\n    }\n    return imagePromises;\n  }\n  static async saveNewAnnotations(evaluator, task, annotations, imagePromises) {\n    const xref = evaluator.xref;\n    let baseFontRef;\n    const dependencies = [];\n    const promises = [];\n    const {\n      isOffscreenCanvasSupported\n    } = evaluator.options;\n    for (const annotation of annotations) {\n      if (annotation.deleted) {\n        continue;\n      }\n      switch (annotation.annotationType) {\n        case AnnotationEditorType.FREETEXT:\n          if (!baseFontRef) {\n            const baseFont = new Dict(xref);\n            baseFont.set(\"BaseFont\", Name.get(\"Helvetica\"));\n            baseFont.set(\"Type\", Name.get(\"Font\"));\n            baseFont.set(\"Subtype\", Name.get(\"Type1\"));\n            baseFont.set(\"Encoding\", Name.get(\"WinAnsiEncoding\"));\n            const buffer = [];\n            baseFontRef = xref.getNewTemporaryRef();\n            await writeObject(baseFontRef, baseFont, buffer, xref);\n            dependencies.push({\n              ref: baseFontRef,\n              data: buffer.join(\"\")\n            });\n          }\n          promises.push(FreeTextAnnotation.createNewAnnotation(xref, annotation, dependencies, {\n            evaluator,\n            task,\n            baseFontRef\n          }));\n          break;\n        case AnnotationEditorType.HIGHLIGHT:\n          if (annotation.quadPoints) {\n            promises.push(HighlightAnnotation.createNewAnnotation(xref, annotation, dependencies));\n          } else {\n            promises.push(InkAnnotation.createNewAnnotation(xref, annotation, dependencies));\n          }\n          break;\n        case AnnotationEditorType.INK:\n          promises.push(InkAnnotation.createNewAnnotation(xref, annotation, dependencies));\n          break;\n        case AnnotationEditorType.STAMP:\n          if (!isOffscreenCanvasSupported) {\n            break;\n          }\n          const image = await imagePromises.get(annotation.bitmapId);\n          if (image.imageStream) {\n            const {\n              imageStream,\n              smaskStream\n            } = image;\n            const buffer = [];\n            if (smaskStream) {\n              const smaskRef = xref.getNewTemporaryRef();\n              await writeObject(smaskRef, smaskStream, buffer, xref);\n              dependencies.push({\n                ref: smaskRef,\n                data: buffer.join(\"\")\n              });\n              imageStream.dict.set(\"SMask\", smaskRef);\n              buffer.length = 0;\n            }\n            const imageRef = image.imageRef = xref.getNewTemporaryRef();\n            await writeObject(imageRef, imageStream, buffer, xref);\n            dependencies.push({\n              ref: imageRef,\n              data: buffer.join(\"\")\n            });\n            image.imageStream = image.smaskStream = null;\n          }\n          promises.push(StampAnnotation.createNewAnnotation(xref, annotation, dependencies, {\n            image\n          }));\n          break;\n      }\n    }\n    return {\n      annotations: await Promise.all(promises),\n      dependencies\n    };\n  }\n  static async printNewAnnotations(annotationGlobals, evaluator, task, annotations, imagePromises) {\n    if (!annotations) {\n      return null;\n    }\n    const {\n      options,\n      xref\n    } = evaluator;\n    const promises = [];\n    for (const annotation of annotations) {\n      if (annotation.deleted) {\n        continue;\n      }\n      switch (annotation.annotationType) {\n        case AnnotationEditorType.FREETEXT:\n          promises.push(FreeTextAnnotation.createNewPrintAnnotation(annotationGlobals, xref, annotation, {\n            evaluator,\n            task,\n            evaluatorOptions: options\n          }));\n          break;\n        case AnnotationEditorType.HIGHLIGHT:\n          if (annotation.quadPoints) {\n            promises.push(HighlightAnnotation.createNewPrintAnnotation(annotationGlobals, xref, annotation, {\n              evaluatorOptions: options\n            }));\n          } else {\n            promises.push(InkAnnotation.createNewPrintAnnotation(annotationGlobals, xref, annotation, {\n              evaluatorOptions: options\n            }));\n          }\n          break;\n        case AnnotationEditorType.INK:\n          promises.push(InkAnnotation.createNewPrintAnnotation(annotationGlobals, xref, annotation, {\n            evaluatorOptions: options\n          }));\n          break;\n        case AnnotationEditorType.STAMP:\n          if (!options.isOffscreenCanvasSupported) {\n            break;\n          }\n          const image = await imagePromises.get(annotation.bitmapId);\n          if (image.imageStream) {\n            const {\n              imageStream,\n              smaskStream\n            } = image;\n            if (smaskStream) {\n              imageStream.dict.set(\"SMask\", smaskStream);\n            }\n            image.imageRef = new JpegStream(imageStream, imageStream.length);\n            image.imageStream = image.smaskStream = null;\n          }\n          promises.push(StampAnnotation.createNewPrintAnnotation(annotationGlobals, xref, annotation, {\n            image,\n            evaluatorOptions: options\n          }));\n          break;\n      }\n    }\n    return Promise.all(promises);\n  }\n}\nfunction getRgbColor(color, defaultColor = new Uint8ClampedArray(3)) {\n  if (!Array.isArray(color)) {\n    return defaultColor;\n  }\n  const rgbColor = defaultColor || new Uint8ClampedArray(3);\n  switch (color.length) {\n    case 0:\n      return null;\n    case 1:\n      ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);\n      return rgbColor;\n    case 3:\n      ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);\n      return rgbColor;\n    case 4:\n      ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);\n      return rgbColor;\n    default:\n      return defaultColor;\n  }\n}\nfunction getPdfColorArray(color) {\n  return Array.from(color, c => c / 255);\n}\nfunction getQuadPoints(dict, rect) {\n  const quadPoints = dict.getArray(\"QuadPoints\");\n  if (!Array.isArray(quadPoints) || quadPoints.length === 0 || quadPoints.length % 8 > 0) {\n    return null;\n  }\n  const quadPointsLists = [];\n  for (let i = 0, ii = quadPoints.length / 8; i < ii; i++) {\n    let minX = Infinity,\n      maxX = -Infinity,\n      minY = Infinity,\n      maxY = -Infinity;\n    for (let j = i * 8, jj = i * 8 + 8; j < jj; j += 2) {\n      const x = quadPoints[j];\n      const y = quadPoints[j + 1];\n      minX = Math.min(x, minX);\n      maxX = Math.max(x, maxX);\n      minY = Math.min(y, minY);\n      maxY = Math.max(y, maxY);\n    }\n    if (rect !== null && (minX < rect[0] || maxX > rect[2] || minY < rect[1] || maxY > rect[3])) {\n      return null;\n    }\n    quadPointsLists.push([{\n      x: minX,\n      y: maxY\n    }, {\n      x: maxX,\n      y: maxY\n    }, {\n      x: minX,\n      y: minY\n    }, {\n      x: maxX,\n      y: minY\n    }]);\n  }\n  return quadPointsLists;\n}\nfunction getTransformMatrix(rect, bbox, matrix) {\n  const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox(bbox, matrix);\n  if (minX === maxX || minY === maxY) {\n    return [1, 0, 0, 1, rect[0], rect[1]];\n  }\n  const xRatio = (rect[2] - rect[0]) / (maxX - minX);\n  const yRatio = (rect[3] - rect[1]) / (maxY - minY);\n  return [xRatio, 0, 0, yRatio, rect[0] - minX * xRatio, rect[1] - minY * yRatio];\n}\nclass Annotation {\n  constructor(params) {\n    const {\n      dict,\n      xref,\n      annotationGlobals\n    } = params;\n    this.setTitle(dict.get(\"T\"));\n    this.setContents(dict.get(\"Contents\"));\n    this.setModificationDate(dict.get(\"M\"));\n    this.setFlags(dict.get(\"F\"));\n    this.setRectangle(dict.getArray(\"Rect\"));\n    this.setColor(dict.getArray(\"C\"));\n    this.setBorderStyle(dict);\n    this.setAppearance(dict);\n    this.setOptionalContent(dict);\n    const MK = dict.get(\"MK\");\n    this.setBorderAndBackgroundColors(MK);\n    this.setRotation(MK, dict);\n    this.ref = params.ref instanceof Ref ? params.ref : null;\n    this._streams = [];\n    if (this.appearance) {\n      this._streams.push(this.appearance);\n    }\n    const isLocked = !!(this.flags & AnnotationFlag.LOCKED);\n    const isContentLocked = !!(this.flags & AnnotationFlag.LOCKEDCONTENTS);\n    if (annotationGlobals.structTreeRoot) {\n      let structParent = dict.get(\"StructParent\");\n      structParent = Number.isInteger(structParent) && structParent >= 0 ? structParent : -1;\n      annotationGlobals.structTreeRoot.addAnnotationIdToPage(params.pageRef, structParent);\n    }\n    this.data = {\n      annotationFlags: this.flags,\n      borderStyle: this.borderStyle,\n      color: this.color,\n      backgroundColor: this.backgroundColor,\n      borderColor: this.borderColor,\n      rotation: this.rotation,\n      contentsObj: this._contents,\n      hasAppearance: !!this.appearance,\n      id: params.id,\n      modificationDate: this.modificationDate,\n      rect: this.rectangle,\n      subtype: params.subtype,\n      hasOwnCanvas: false,\n      noRotate: !!(this.flags & AnnotationFlag.NOROTATE),\n      noHTML: isLocked && isContentLocked\n    };\n    if (params.collectFields) {\n      const kids = dict.get(\"Kids\");\n      if (Array.isArray(kids)) {\n        const kidIds = [];\n        for (const kid of kids) {\n          if (kid instanceof Ref) {\n            kidIds.push(kid.toString());\n          }\n        }\n        if (kidIds.length !== 0) {\n          this.data.kidIds = kidIds;\n        }\n      }\n      this.data.actions = collectActions(xref, dict, AnnotationActionEventType);\n      this.data.fieldName = this._constructFieldName(dict);\n      this.data.pageIndex = params.pageIndex;\n    }\n    this._isOffscreenCanvasSupported = params.evaluatorOptions.isOffscreenCanvasSupported;\n    this._fallbackFontDict = null;\n    this._needAppearances = false;\n  }\n  _hasFlag(flags, flag) {\n    return !!(flags & flag);\n  }\n  _isViewable(flags) {\n    return !this._hasFlag(flags, AnnotationFlag.INVISIBLE) && !this._hasFlag(flags, AnnotationFlag.NOVIEW);\n  }\n  _isPrintable(flags) {\n    return this._hasFlag(flags, AnnotationFlag.PRINT) && !this._hasFlag(flags, AnnotationFlag.HIDDEN) && !this._hasFlag(flags, AnnotationFlag.INVISIBLE);\n  }\n  mustBeViewed(annotationStorage, _renderForms) {\n    const noView = annotationStorage?.get(this.data.id)?.noView;\n    if (noView !== undefined) {\n      return !noView;\n    }\n    return this.viewable && !this._hasFlag(this.flags, AnnotationFlag.HIDDEN);\n  }\n  mustBePrinted(annotationStorage) {\n    const noPrint = annotationStorage?.get(this.data.id)?.noPrint;\n    if (noPrint !== undefined) {\n      return !noPrint;\n    }\n    return this.printable;\n  }\n  get viewable() {\n    if (this.data.quadPoints === null) {\n      return false;\n    }\n    if (this.flags === 0) {\n      return true;\n    }\n    return this._isViewable(this.flags);\n  }\n  get printable() {\n    if (this.data.quadPoints === null) {\n      return false;\n    }\n    if (this.flags === 0) {\n      return false;\n    }\n    return this._isPrintable(this.flags);\n  }\n  _parseStringHelper(data) {\n    const str = typeof data === \"string\" ? stringToPDFString(data) : \"\";\n    const dir = str && bidi(str).dir === \"rtl\" ? \"rtl\" : \"ltr\";\n    return {\n      str,\n      dir\n    };\n  }\n  setDefaultAppearance(params) {\n    const {\n      dict,\n      annotationGlobals\n    } = params;\n    const defaultAppearance = getInheritableProperty({\n      dict,\n      key: \"DA\"\n    }) || annotationGlobals.acroForm.get(\"DA\");\n    this._defaultAppearance = typeof defaultAppearance === \"string\" ? defaultAppearance : \"\";\n    this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance);\n  }\n  setTitle(title) {\n    this._title = this._parseStringHelper(title);\n  }\n  setContents(contents) {\n    this._contents = this._parseStringHelper(contents);\n  }\n  setModificationDate(modificationDate) {\n    this.modificationDate = typeof modificationDate === \"string\" ? modificationDate : null;\n  }\n  setFlags(flags) {\n    this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;\n    if (this.flags & AnnotationFlag.INVISIBLE && this.constructor.name !== \"Annotation\") {\n      this.flags ^= AnnotationFlag.INVISIBLE;\n    }\n  }\n  hasFlag(flag) {\n    return this._hasFlag(this.flags, flag);\n  }\n  setRectangle(rectangle) {\n    this.rectangle = Array.isArray(rectangle) && rectangle.length === 4 ? Util.normalizeRect(rectangle) : [0, 0, 0, 0];\n  }\n  setColor(color) {\n    this.color = getRgbColor(color);\n  }\n  setLineEndings(lineEndings) {\n    this.lineEndings = [\"None\", \"None\"];\n    if (Array.isArray(lineEndings) && lineEndings.length === 2) {\n      for (let i = 0; i < 2; i++) {\n        const obj = lineEndings[i];\n        if (obj instanceof Name) {\n          switch (obj.name) {\n            case \"None\":\n              continue;\n            case \"Square\":\n            case \"Circle\":\n            case \"Diamond\":\n            case \"OpenArrow\":\n            case \"ClosedArrow\":\n            case \"Butt\":\n            case \"ROpenArrow\":\n            case \"RClosedArrow\":\n            case \"Slash\":\n              this.lineEndings[i] = obj.name;\n              continue;\n          }\n        }\n        warn(`Ignoring invalid lineEnding: ${obj}`);\n      }\n    }\n  }\n  setRotation(mk, dict) {\n    this.rotation = 0;\n    let angle = mk instanceof Dict ? mk.get(\"R\") || 0 : dict.get(\"Rotate\") || 0;\n    if (Number.isInteger(angle) && angle !== 0) {\n      angle %= 360;\n      if (angle < 0) {\n        angle += 360;\n      }\n      if (angle % 90 === 0) {\n        this.rotation = angle;\n      }\n    }\n  }\n  setBorderAndBackgroundColors(mk) {\n    if (mk instanceof Dict) {\n      this.borderColor = getRgbColor(mk.getArray(\"BC\"), null);\n      this.backgroundColor = getRgbColor(mk.getArray(\"BG\"), null);\n    } else {\n      this.borderColor = this.backgroundColor = null;\n    }\n  }\n  setBorderStyle(borderStyle) {\n    this.borderStyle = new AnnotationBorderStyle();\n    if (!(borderStyle instanceof Dict)) {\n      return;\n    }\n    if (borderStyle.has(\"BS\")) {\n      const dict = borderStyle.get(\"BS\");\n      if (dict instanceof Dict) {\n        const dictType = dict.get(\"Type\");\n        if (!dictType || isName(dictType, \"Border\")) {\n          this.borderStyle.setWidth(dict.get(\"W\"), this.rectangle);\n          this.borderStyle.setStyle(dict.get(\"S\"));\n          this.borderStyle.setDashArray(dict.getArray(\"D\"));\n        }\n      }\n    } else if (borderStyle.has(\"Border\")) {\n      const array = borderStyle.getArray(\"Border\");\n      if (Array.isArray(array) && array.length >= 3) {\n        this.borderStyle.setHorizontalCornerRadius(array[0]);\n        this.borderStyle.setVerticalCornerRadius(array[1]);\n        this.borderStyle.setWidth(array[2], this.rectangle);\n        if (array.length === 4) {\n          this.borderStyle.setDashArray(array[3], true);\n        }\n      }\n    } else {\n      this.borderStyle.setWidth(0);\n    }\n  }\n  setAppearance(dict) {\n    this.appearance = null;\n    const appearanceStates = dict.get(\"AP\");\n    if (!(appearanceStates instanceof Dict)) {\n      return;\n    }\n    const normalAppearanceState = appearanceStates.get(\"N\");\n    if (normalAppearanceState instanceof BaseStream) {\n      this.appearance = normalAppearanceState;\n      return;\n    }\n    if (!(normalAppearanceState instanceof Dict)) {\n      return;\n    }\n    const as = dict.get(\"AS\");\n    if (!(as instanceof Name) || !normalAppearanceState.has(as.name)) {\n      return;\n    }\n    const appearance = normalAppearanceState.get(as.name);\n    if (appearance instanceof BaseStream) {\n      this.appearance = appearance;\n    }\n  }\n  setOptionalContent(dict) {\n    this.oc = null;\n    const oc = dict.get(\"OC\");\n    if (oc instanceof Name) {\n      warn(\"setOptionalContent: Support for /Name-entry is not implemented.\");\n    } else if (oc instanceof Dict) {\n      this.oc = oc;\n    }\n  }\n  loadResources(keys, appearance) {\n    return appearance.dict.getAsync(\"Resources\").then(resources => {\n      if (!resources) {\n        return undefined;\n      }\n      const objectLoader = new ObjectLoader(resources, keys, resources.xref);\n      return objectLoader.load().then(function () {\n        return resources;\n      });\n    });\n  }\n  async getOperatorList(evaluator, task, intent, renderForms, annotationStorage) {\n    const {\n      hasOwnCanvas,\n      id,\n      rect\n    } = this.data;\n    let appearance = this.appearance;\n    const isUsingOwnCanvas = !!(hasOwnCanvas && intent & RenderingIntentFlag.DISPLAY);\n    if (isUsingOwnCanvas && (rect[0] === rect[2] || rect[1] === rect[3])) {\n      this.data.hasOwnCanvas = false;\n      return {\n        opList: new OperatorList(),\n        separateForm: false,\n        separateCanvas: false\n      };\n    }\n    if (!appearance) {\n      if (!isUsingOwnCanvas) {\n        return {\n          opList: new OperatorList(),\n          separateForm: false,\n          separateCanvas: false\n        };\n      }\n      appearance = new StringStream(\"\");\n      appearance.dict = new Dict();\n    }\n    const appearanceDict = appearance.dict;\n    const resources = await this.loadResources([\"ExtGState\", \"ColorSpace\", \"Pattern\", \"Shading\", \"XObject\", \"Font\"], appearance);\n    const bbox = appearanceDict.getArray(\"BBox\") || [0, 0, 1, 1];\n    const matrix = appearanceDict.getArray(\"Matrix\") || [1, 0, 0, 1, 0, 0];\n    const transform = getTransformMatrix(rect, bbox, matrix);\n    const opList = new OperatorList();\n    let optionalContent;\n    if (this.oc) {\n      optionalContent = await evaluator.parseMarkedContentProps(this.oc, null);\n    }\n    if (optionalContent !== undefined) {\n      opList.addOp(OPS.beginMarkedContentProps, [\"OC\", optionalContent]);\n    }\n    opList.addOp(OPS.beginAnnotation, [id, rect, transform, matrix, isUsingOwnCanvas]);\n    await evaluator.getOperatorList({\n      stream: appearance,\n      task,\n      resources,\n      operatorList: opList,\n      fallbackFontDict: this._fallbackFontDict\n    });\n    opList.addOp(OPS.endAnnotation, []);\n    if (optionalContent !== undefined) {\n      opList.addOp(OPS.endMarkedContent, []);\n    }\n    this.reset();\n    return {\n      opList,\n      separateForm: false,\n      separateCanvas: isUsingOwnCanvas\n    };\n  }\n  async save(evaluator, task, annotationStorage) {\n    return null;\n  }\n  get hasTextContent() {\n    return false;\n  }\n  async extractTextContent(evaluator, task, viewBox) {\n    if (!this.appearance) {\n      return;\n    }\n    const resources = await this.loadResources([\"ExtGState\", \"Font\", \"Properties\", \"XObject\"], this.appearance);\n    const text = [];\n    const buffer = [];\n    let firstPosition = null;\n    const sink = {\n      desiredSize: Math.Infinity,\n      ready: true,\n      enqueue(chunk, size) {\n        for (const item of chunk.items) {\n          if (item.str === undefined) {\n            continue;\n          }\n          firstPosition ||= item.transform.slice(-2);\n          buffer.push(item.str);\n          if (item.hasEOL) {\n            text.push(buffer.join(\"\").trimEnd());\n            buffer.length = 0;\n          }\n        }\n      }\n    };\n    await evaluator.getTextContent({\n      stream: this.appearance,\n      task,\n      resources,\n      includeMarkedContent: true,\n      keepWhiteSpace: true,\n      sink,\n      viewBox\n    });\n    this.reset();\n    if (buffer.length) {\n      text.push(buffer.join(\"\").trimEnd());\n    }\n    if (text.length > 1 || text[0]) {\n      const appearanceDict = this.appearance.dict;\n      this.data.textPosition = this._transformPoint(firstPosition, appearanceDict.getArray(\"BBox\"), appearanceDict.getArray(\"Matrix\"));\n      this.data.textContent = text;\n    }\n  }\n  _transformPoint(coords, bbox, matrix) {\n    const {\n      rect\n    } = this.data;\n    bbox ||= [0, 0, 1, 1];\n    matrix ||= [1, 0, 0, 1, 0, 0];\n    const transform = getTransformMatrix(rect, bbox, matrix);\n    transform[4] -= rect[0];\n    transform[5] -= rect[1];\n    coords = Util.applyTransform(coords, transform);\n    return Util.applyTransform(coords, matrix);\n  }\n  getFieldObject() {\n    if (this.data.kidIds) {\n      return {\n        id: this.data.id,\n        actions: this.data.actions,\n        name: this.data.fieldName,\n        strokeColor: this.data.borderColor,\n        fillColor: this.data.backgroundColor,\n        type: \"\",\n        kidIds: this.data.kidIds,\n        page: this.data.pageIndex,\n        rotation: this.rotation\n      };\n    }\n    return null;\n  }\n  reset() {\n    for (const stream of this._streams) {\n      stream.reset();\n    }\n  }\n  _constructFieldName(dict) {\n    if (!dict.has(\"T\") && !dict.has(\"Parent\")) {\n      warn(\"Unknown field name, falling back to empty field name.\");\n      return \"\";\n    }\n    if (!dict.has(\"Parent\")) {\n      return stringToPDFString(dict.get(\"T\"));\n    }\n    const fieldName = [];\n    if (dict.has(\"T\")) {\n      fieldName.unshift(stringToPDFString(dict.get(\"T\")));\n    }\n    let loopDict = dict;\n    const visited = new RefSet();\n    if (dict.objId) {\n      visited.put(dict.objId);\n    }\n    while (loopDict.has(\"Parent\")) {\n      loopDict = loopDict.get(\"Parent\");\n      if (!(loopDict instanceof Dict) || loopDict.objId && visited.has(loopDict.objId)) {\n        break;\n      }\n      if (loopDict.objId) {\n        visited.put(loopDict.objId);\n      }\n      if (loopDict.has(\"T\")) {\n        fieldName.unshift(stringToPDFString(loopDict.get(\"T\")));\n      }\n    }\n    return fieldName.join(\".\");\n  }\n}\nclass AnnotationBorderStyle {\n  constructor() {\n    this.width = 1;\n    this.style = AnnotationBorderStyleType.SOLID;\n    this.dashArray = [3];\n    this.horizontalCornerRadius = 0;\n    this.verticalCornerRadius = 0;\n  }\n  setWidth(width, rect = [0, 0, 0, 0]) {\n    if (width instanceof Name) {\n      this.width = 0;\n      return;\n    }\n    if (typeof width === \"number\") {\n      if (width > 0) {\n        const maxWidth = (rect[2] - rect[0]) / 2;\n        const maxHeight = (rect[3] - rect[1]) / 2;\n        if (maxWidth > 0 && maxHeight > 0 && (width > maxWidth || width > maxHeight)) {\n          warn(`AnnotationBorderStyle.setWidth - ignoring width: ${width}`);\n          width = 1;\n        }\n      }\n      this.width = width;\n    }\n  }\n  setStyle(style) {\n    if (!(style instanceof Name)) {\n      return;\n    }\n    switch (style.name) {\n      case \"S\":\n        this.style = AnnotationBorderStyleType.SOLID;\n        break;\n      case \"D\":\n        this.style = AnnotationBorderStyleType.DASHED;\n        break;\n      case \"B\":\n        this.style = AnnotationBorderStyleType.BEVELED;\n        break;\n      case \"I\":\n        this.style = AnnotationBorderStyleType.INSET;\n        break;\n      case \"U\":\n        this.style = AnnotationBorderStyleType.UNDERLINE;\n        break;\n      default:\n        break;\n    }\n  }\n  setDashArray(dashArray, forceStyle = false) {\n    if (Array.isArray(dashArray)) {\n      let isValid = true;\n      let allZeros = true;\n      for (const element of dashArray) {\n        const validNumber = +element >= 0;\n        if (!validNumber) {\n          isValid = false;\n          break;\n        } else if (element > 0) {\n          allZeros = false;\n        }\n      }\n      if (dashArray.length === 0 || isValid && !allZeros) {\n        this.dashArray = dashArray;\n        if (forceStyle) {\n          this.setStyle(Name.get(\"D\"));\n        }\n      } else {\n        this.width = 0;\n      }\n    } else if (dashArray) {\n      this.width = 0;\n    }\n  }\n  setHorizontalCornerRadius(radius) {\n    if (Number.isInteger(radius)) {\n      this.horizontalCornerRadius = radius;\n    }\n  }\n  setVerticalCornerRadius(radius) {\n    if (Number.isInteger(radius)) {\n      this.verticalCornerRadius = radius;\n    }\n  }\n}\nclass MarkupAnnotation extends Annotation {\n  constructor(params) {\n    super(params);\n    const {\n      dict\n    } = params;\n    if (dict.has(\"IRT\")) {\n      const rawIRT = dict.getRaw(\"IRT\");\n      this.data.inReplyTo = rawIRT instanceof Ref ? rawIRT.toString() : null;\n      const rt = dict.get(\"RT\");\n      this.data.replyType = rt instanceof Name ? rt.name : AnnotationReplyType.REPLY;\n    }\n    let popupRef = null;\n    if (this.data.replyType === AnnotationReplyType.GROUP) {\n      const parent = dict.get(\"IRT\");\n      this.setTitle(parent.get(\"T\"));\n      this.data.titleObj = this._title;\n      this.setContents(parent.get(\"Contents\"));\n      this.data.contentsObj = this._contents;\n      if (!parent.has(\"CreationDate\")) {\n        this.data.creationDate = null;\n      } else {\n        this.setCreationDate(parent.get(\"CreationDate\"));\n        this.data.creationDate = this.creationDate;\n      }\n      if (!parent.has(\"M\")) {\n        this.data.modificationDate = null;\n      } else {\n        this.setModificationDate(parent.get(\"M\"));\n        this.data.modificationDate = this.modificationDate;\n      }\n      popupRef = parent.getRaw(\"Popup\");\n      if (!parent.has(\"C\")) {\n        this.data.color = null;\n      } else {\n        this.setColor(parent.getArray(\"C\"));\n        this.data.color = this.color;\n      }\n    } else {\n      this.data.titleObj = this._title;\n      this.setCreationDate(dict.get(\"CreationDate\"));\n      this.data.creationDate = this.creationDate;\n      popupRef = dict.getRaw(\"Popup\");\n      if (!dict.has(\"C\")) {\n        this.data.color = null;\n      }\n    }\n    this.data.popupRef = popupRef instanceof Ref ? popupRef.toString() : null;\n    if (dict.has(\"RC\")) {\n      this.data.richText = XFAFactory.getRichTextAsHtml(dict.get(\"RC\"));\n    }\n  }\n  setCreationDate(creationDate) {\n    this.creationDate = typeof creationDate === \"string\" ? creationDate : null;\n  }\n  _setDefaultAppearance({\n    xref,\n    extra,\n    strokeColor,\n    fillColor,\n    blendMode,\n    strokeAlpha,\n    fillAlpha,\n    pointsCallback\n  }) {\n    let minX = Number.MAX_VALUE;\n    let minY = Number.MAX_VALUE;\n    let maxX = Number.MIN_VALUE;\n    let maxY = Number.MIN_VALUE;\n    const buffer = [\"q\"];\n    if (extra) {\n      buffer.push(extra);\n    }\n    if (strokeColor) {\n      buffer.push(`${strokeColor[0]} ${strokeColor[1]} ${strokeColor[2]} RG`);\n    }\n    if (fillColor) {\n      buffer.push(`${fillColor[0]} ${fillColor[1]} ${fillColor[2]} rg`);\n    }\n    let pointsArray = this.data.quadPoints;\n    if (!pointsArray) {\n      pointsArray = [[{\n        x: this.rectangle[0],\n        y: this.rectangle[3]\n      }, {\n        x: this.rectangle[2],\n        y: this.rectangle[3]\n      }, {\n        x: this.rectangle[0],\n        y: this.rectangle[1]\n      }, {\n        x: this.rectangle[2],\n        y: this.rectangle[1]\n      }]];\n    }\n    for (const points of pointsArray) {\n      const [mX, MX, mY, MY] = pointsCallback(buffer, points);\n      minX = Math.min(minX, mX);\n      maxX = Math.max(maxX, MX);\n      minY = Math.min(minY, mY);\n      maxY = Math.max(maxY, MY);\n    }\n    buffer.push(\"Q\");\n    const formDict = new Dict(xref);\n    const appearanceStreamDict = new Dict(xref);\n    appearanceStreamDict.set(\"Subtype\", Name.get(\"Form\"));\n    const appearanceStream = new StringStream(buffer.join(\" \"));\n    appearanceStream.dict = appearanceStreamDict;\n    formDict.set(\"Fm0\", appearanceStream);\n    const gsDict = new Dict(xref);\n    if (blendMode) {\n      gsDict.set(\"BM\", Name.get(blendMode));\n    }\n    if (typeof strokeAlpha === \"number\") {\n      gsDict.set(\"CA\", strokeAlpha);\n    }\n    if (typeof fillAlpha === \"number\") {\n      gsDict.set(\"ca\", fillAlpha);\n    }\n    const stateDict = new Dict(xref);\n    stateDict.set(\"GS0\", gsDict);\n    const resources = new Dict(xref);\n    resources.set(\"ExtGState\", stateDict);\n    resources.set(\"XObject\", formDict);\n    const appearanceDict = new Dict(xref);\n    appearanceDict.set(\"Resources\", resources);\n    const bbox = this.data.rect = [minX, minY, maxX, maxY];\n    appearanceDict.set(\"BBox\", bbox);\n    this.appearance = new StringStream(\"/GS0 gs /Fm0 Do\");\n    this.appearance.dict = appearanceDict;\n    this._streams.push(this.appearance, appearanceStream);\n  }\n  static async createNewAnnotation(xref, annotation, dependencies, params) {\n    const annotationRef = annotation.ref ||= xref.getNewTemporaryRef();\n    const ap = await this.createNewAppearanceStream(annotation, xref, params);\n    const buffer = [];\n    let annotationDict;\n    if (ap) {\n      const apRef = xref.getNewTemporaryRef();\n      annotationDict = this.createNewDict(annotation, xref, {\n        apRef\n      });\n      await writeObject(apRef, ap, buffer, xref);\n      dependencies.push({\n        ref: apRef,\n        data: buffer.join(\"\")\n      });\n    } else {\n      annotationDict = this.createNewDict(annotation, xref, {});\n    }\n    if (Number.isInteger(annotation.parentTreeId)) {\n      annotationDict.set(\"StructParent\", annotation.parentTreeId);\n    }\n    buffer.length = 0;\n    await writeObject(annotationRef, annotationDict, buffer, xref);\n    return {\n      ref: annotationRef,\n      data: buffer.join(\"\")\n    };\n  }\n  static async createNewPrintAnnotation(annotationGlobals, xref, annotation, params) {\n    const ap = await this.createNewAppearanceStream(annotation, xref, params);\n    const annotationDict = this.createNewDict(annotation, xref, {\n      ap\n    });\n    const newAnnotation = new this.prototype.constructor({\n      dict: annotationDict,\n      xref,\n      annotationGlobals,\n      evaluatorOptions: params.evaluatorOptions\n    });\n    if (annotation.ref) {\n      newAnnotation.ref = newAnnotation.refToReplace = annotation.ref;\n    }\n    return newAnnotation;\n  }\n}\nclass WidgetAnnotation extends Annotation {\n  constructor(params) {\n    super(params);\n    const {\n      dict,\n      xref,\n      annotationGlobals\n    } = params;\n    const data = this.data;\n    this._needAppearances = params.needAppearances;\n    data.annotationType = AnnotationType.WIDGET;\n    if (data.fieldName === undefined) {\n      data.fieldName = this._constructFieldName(dict);\n    }\n    if (data.actions === undefined) {\n      data.actions = collectActions(xref, dict, AnnotationActionEventType);\n    }\n    let fieldValue = getInheritableProperty({\n      dict,\n      key: \"V\",\n      getArray: true\n    });\n    data.fieldValue = this._decodeFormValue(fieldValue);\n    const defaultFieldValue = getInheritableProperty({\n      dict,\n      key: \"DV\",\n      getArray: true\n    });\n    data.defaultFieldValue = this._decodeFormValue(defaultFieldValue);\n    if (fieldValue === undefined && annotationGlobals.xfaDatasets) {\n      const path = this._title.str;\n      if (path) {\n        this._hasValueFromXFA = true;\n        data.fieldValue = fieldValue = annotationGlobals.xfaDatasets.getValue(path);\n      }\n    }\n    if (fieldValue === undefined && data.defaultFieldValue !== null) {\n      data.fieldValue = data.defaultFieldValue;\n    }\n    data.alternativeText = stringToPDFString(dict.get(\"TU\") || \"\");\n    this.setDefaultAppearance(params);\n    data.hasAppearance ||= this._needAppearances && data.fieldValue !== undefined && data.fieldValue !== null;\n    const fieldType = getInheritableProperty({\n      dict,\n      key: \"FT\"\n    });\n    data.fieldType = fieldType instanceof Name ? fieldType.name : null;\n    const localResources = getInheritableProperty({\n      dict,\n      key: \"DR\"\n    });\n    const acroFormResources = annotationGlobals.acroForm.get(\"DR\");\n    const appearanceResources = this.appearance?.dict.get(\"Resources\");\n    this._fieldResources = {\n      localResources,\n      acroFormResources,\n      appearanceResources,\n      mergedResources: Dict.merge({\n        xref,\n        dictArray: [localResources, appearanceResources, acroFormResources],\n        mergeSubDicts: true\n      })\n    };\n    data.fieldFlags = getInheritableProperty({\n      dict,\n      key: \"Ff\"\n    });\n    if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {\n      data.fieldFlags = 0;\n    }\n    data.readOnly = this.hasFieldFlag(AnnotationFieldFlag.READONLY);\n    data.required = this.hasFieldFlag(AnnotationFieldFlag.REQUIRED);\n    data.hidden = this._hasFlag(data.annotationFlags, AnnotationFlag.HIDDEN) || this._hasFlag(data.annotationFlags, AnnotationFlag.NOVIEW);\n  }\n  _decodeFormValue(formValue) {\n    if (Array.isArray(formValue)) {\n      return formValue.filter(item => typeof item === \"string\").map(item => stringToPDFString(item));\n    } else if (formValue instanceof Name) {\n      return stringToPDFString(formValue.name);\n    } else if (typeof formValue === \"string\") {\n      return stringToPDFString(formValue);\n    }\n    return null;\n  }\n  hasFieldFlag(flag) {\n    return !!(this.data.fieldFlags & flag);\n  }\n  _isViewable(flags) {\n    return true;\n  }\n  mustBeViewed(annotationStorage, renderForms) {\n    if (renderForms) {\n      return this.viewable;\n    }\n    return super.mustBeViewed(annotationStorage, renderForms) && !this._hasFlag(this.flags, AnnotationFlag.NOVIEW);\n  }\n  getRotationMatrix(annotationStorage) {\n    let rotation = annotationStorage?.get(this.data.id)?.rotation;\n    if (rotation === undefined) {\n      rotation = this.rotation;\n    }\n    if (rotation === 0) {\n      return IDENTITY_MATRIX;\n    }\n    const width = this.data.rect[2] - this.data.rect[0];\n    const height = this.data.rect[3] - this.data.rect[1];\n    return getRotationMatrix(rotation, width, height);\n  }\n  getBorderAndBackgroundAppearances(annotationStorage) {\n    let rotation = annotationStorage?.get(this.data.id)?.rotation;\n    if (rotation === undefined) {\n      rotation = this.rotation;\n    }\n    if (!this.backgroundColor && !this.borderColor) {\n      return \"\";\n    }\n    const width = this.data.rect[2] - this.data.rect[0];\n    const height = this.data.rect[3] - this.data.rect[1];\n    const rect = rotation === 0 || rotation === 180 ? `0 0 ${width} ${height} re` : `0 0 ${height} ${width} re`;\n    let str = \"\";\n    if (this.backgroundColor) {\n      str = `${getPdfColor(this.backgroundColor, true)} ${rect} f `;\n    }\n    if (this.borderColor) {\n      const borderWidth = this.borderStyle.width || 1;\n      str += `${borderWidth} w ${getPdfColor(this.borderColor, false)} ${rect} S `;\n    }\n    return str;\n  }\n  async getOperatorList(evaluator, task, intent, renderForms, annotationStorage) {\n    if (renderForms && !(this instanceof SignatureWidgetAnnotation) && !this.data.noHTML && !this.data.hasOwnCanvas) {\n      return {\n        opList: new OperatorList(),\n        separateForm: true,\n        separateCanvas: false\n      };\n    }\n    if (!this._hasText) {\n      return super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage);\n    }\n    const content = await this._getAppearance(evaluator, task, intent, annotationStorage);\n    if (this.appearance && content === null) {\n      return super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage);\n    }\n    const opList = new OperatorList();\n    if (!this._defaultAppearance || content === null) {\n      return {\n        opList,\n        separateForm: false,\n        separateCanvas: false\n      };\n    }\n    const isUsingOwnCanvas = !!(this.data.hasOwnCanvas && intent & RenderingIntentFlag.DISPLAY);\n    const matrix = [1, 0, 0, 1, 0, 0];\n    const bbox = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]];\n    const transform = getTransformMatrix(this.data.rect, bbox, matrix);\n    let optionalContent;\n    if (this.oc) {\n      optionalContent = await evaluator.parseMarkedContentProps(this.oc, null);\n    }\n    if (optionalContent !== undefined) {\n      opList.addOp(OPS.beginMarkedContentProps, [\"OC\", optionalContent]);\n    }\n    opList.addOp(OPS.beginAnnotation, [this.data.id, this.data.rect, transform, this.getRotationMatrix(annotationStorage), isUsingOwnCanvas]);\n    const stream = new StringStream(content);\n    await evaluator.getOperatorList({\n      stream,\n      task,\n      resources: this._fieldResources.mergedResources,\n      operatorList: opList\n    });\n    opList.addOp(OPS.endAnnotation, []);\n    if (optionalContent !== undefined) {\n      opList.addOp(OPS.endMarkedContent, []);\n    }\n    return {\n      opList,\n      separateForm: false,\n      separateCanvas: isUsingOwnCanvas\n    };\n  }\n  _getMKDict(rotation) {\n    const mk = new Dict(null);\n    if (rotation) {\n      mk.set(\"R\", rotation);\n    }\n    if (this.borderColor) {\n      mk.set(\"BC\", getPdfColorArray(this.borderColor));\n    }\n    if (this.backgroundColor) {\n      mk.set(\"BG\", getPdfColorArray(this.backgroundColor));\n    }\n    return mk.size > 0 ? mk : null;\n  }\n  amendSavedDict(annotationStorage, dict) {}\n  async save(evaluator, task, annotationStorage) {\n    const storageEntry = annotationStorage?.get(this.data.id);\n    let value = storageEntry?.value,\n      rotation = storageEntry?.rotation;\n    if (value === this.data.fieldValue || value === undefined) {\n      if (!this._hasValueFromXFA && rotation === undefined) {\n        return null;\n      }\n      value ||= this.data.fieldValue;\n    }\n    if (rotation === undefined && !this._hasValueFromXFA && Array.isArray(value) && Array.isArray(this.data.fieldValue) && value.length === this.data.fieldValue.length && value.every((x, i) => x === this.data.fieldValue[i])) {\n      return null;\n    }\n    if (rotation === undefined) {\n      rotation = this.rotation;\n    }\n    let appearance = null;\n    if (!this._needAppearances) {\n      appearance = await this._getAppearance(evaluator, task, RenderingIntentFlag.SAVE, annotationStorage);\n      if (appearance === null) {\n        return null;\n      }\n    } else {}\n    let needAppearances = false;\n    if (appearance?.needAppearances) {\n      needAppearances = true;\n      appearance = null;\n    }\n    const {\n      xref\n    } = evaluator;\n    const originalDict = xref.fetchIfRef(this.ref);\n    if (!(originalDict instanceof Dict)) {\n      return null;\n    }\n    const dict = new Dict(xref);\n    for (const key of originalDict.getKeys()) {\n      if (key !== \"AP\") {\n        dict.set(key, originalDict.getRaw(key));\n      }\n    }\n    const xfa = {\n      path: this.data.fieldName,\n      value\n    };\n    const encoder = val => isAscii(val) ? val : stringToUTF16String(val, true);\n    dict.set(\"V\", Array.isArray(value) ? value.map(encoder) : encoder(value));\n    this.amendSavedDict(annotationStorage, dict);\n    const maybeMK = this._getMKDict(rotation);\n    if (maybeMK) {\n      dict.set(\"MK\", maybeMK);\n    }\n    const buffer = [];\n    const changes = [{\n      ref: this.ref,\n      data: \"\",\n      xfa,\n      needAppearances\n    }];\n    if (appearance !== null) {\n      const newRef = xref.getNewTemporaryRef();\n      const AP = new Dict(xref);\n      dict.set(\"AP\", AP);\n      AP.set(\"N\", newRef);\n      const resources = this._getSaveFieldResources(xref);\n      const appearanceStream = new StringStream(appearance);\n      const appearanceDict = appearanceStream.dict = new Dict(xref);\n      appearanceDict.set(\"Subtype\", Name.get(\"Form\"));\n      appearanceDict.set(\"Resources\", resources);\n      appearanceDict.set(\"BBox\", [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]]);\n      const rotationMatrix = this.getRotationMatrix(annotationStorage);\n      if (rotationMatrix !== IDENTITY_MATRIX) {\n        appearanceDict.set(\"Matrix\", rotationMatrix);\n      }\n      await writeObject(newRef, appearanceStream, buffer, xref);\n      changes.push({\n        ref: newRef,\n        data: buffer.join(\"\"),\n        xfa: null,\n        needAppearances: false\n      });\n      buffer.length = 0;\n    }\n    dict.set(\"M\", `D:${getModificationDate()}`);\n    await writeObject(this.ref, dict, buffer, xref);\n    changes[0].data = buffer.join(\"\");\n    return changes;\n  }\n  async _getAppearance(evaluator, task, intent, annotationStorage) {\n    const isPassword = this.hasFieldFlag(AnnotationFieldFlag.PASSWORD);\n    if (isPassword) {\n      return null;\n    }\n    const storageEntry = annotationStorage?.get(this.data.id);\n    let value, rotation;\n    if (storageEntry) {\n      value = storageEntry.formattedValue || storageEntry.value;\n      rotation = storageEntry.rotation;\n    }\n    if (rotation === undefined && value === undefined && !this._needAppearances) {\n      if (!this._hasValueFromXFA || this.appearance) {\n        return null;\n      }\n    }\n    const colors = this.getBorderAndBackgroundAppearances(annotationStorage);\n    if (value === undefined) {\n      value = this.data.fieldValue;\n      if (!value) {\n        return `/Tx BMC q ${colors}Q EMC`;\n      }\n    }\n    if (Array.isArray(value) && value.length === 1) {\n      value = value[0];\n    }\n    assert(typeof value === \"string\", \"Expected `value` to be a string.\");\n    value = value.trim();\n    if (this.data.combo) {\n      const option = this.data.options.find(({\n        exportValue\n      }) => value === exportValue);\n      value = option?.displayValue || value;\n    }\n    if (value === \"\") {\n      return `/Tx BMC q ${colors}Q EMC`;\n    }\n    if (rotation === undefined) {\n      rotation = this.rotation;\n    }\n    let lineCount = -1;\n    let lines;\n    if (this.data.multiLine) {\n      lines = value.split(/\\r\\n?|\\n/).map(line => line.normalize(\"NFC\"));\n      lineCount = lines.length;\n    } else {\n      lines = [value.replace(/\\r\\n?|\\n/, \"\").normalize(\"NFC\")];\n    }\n    const defaultPadding = 1;\n    const defaultHPadding = 2;\n    let totalHeight = this.data.rect[3] - this.data.rect[1];\n    let totalWidth = this.data.rect[2] - this.data.rect[0];\n    if (rotation === 90 || rotation === 270) {\n      [totalWidth, totalHeight] = [totalHeight, totalWidth];\n    }\n    if (!this._defaultAppearance) {\n      this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = \"/Helvetica 0 Tf 0 g\");\n    }\n    let font = await WidgetAnnotation._getFontData(evaluator, task, this.data.defaultAppearanceData, this._fieldResources.mergedResources);\n    let defaultAppearance, fontSize, lineHeight;\n    const encodedLines = [];\n    let encodingError = false;\n    for (const line of lines) {\n      const encodedString = font.encodeString(line);\n      if (encodedString.length > 1) {\n        encodingError = true;\n      }\n      encodedLines.push(encodedString.join(\"\"));\n    }\n    if (encodingError && intent & RenderingIntentFlag.SAVE) {\n      return {\n        needAppearances: true\n      };\n    }\n    if (encodingError && this._isOffscreenCanvasSupported) {\n      const fontFamily = this.data.comb ? \"monospace\" : \"sans-serif\";\n      const fakeUnicodeFont = new FakeUnicodeFont(evaluator.xref, fontFamily);\n      const resources = fakeUnicodeFont.createFontResources(lines.join(\"\"));\n      const newFont = resources.getRaw(\"Font\");\n      if (this._fieldResources.mergedResources.has(\"Font\")) {\n        const oldFont = this._fieldResources.mergedResources.get(\"Font\");\n        for (const key of newFont.getKeys()) {\n          oldFont.set(key, newFont.getRaw(key));\n        }\n      } else {\n        this._fieldResources.mergedResources.set(\"Font\", newFont);\n      }\n      const fontName = fakeUnicodeFont.fontName.name;\n      font = await WidgetAnnotation._getFontData(evaluator, task, {\n        fontName,\n        fontSize: 0\n      }, resources);\n      for (let i = 0, ii = encodedLines.length; i < ii; i++) {\n        encodedLines[i] = stringToUTF16String(lines[i]);\n      }\n      const savedDefaultAppearance = Object.assign(Object.create(null), this.data.defaultAppearanceData);\n      this.data.defaultAppearanceData.fontSize = 0;\n      this.data.defaultAppearanceData.fontName = fontName;\n      [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(totalHeight - 2 * defaultPadding, totalWidth - 2 * defaultHPadding, value, font, lineCount);\n      this.data.defaultAppearanceData = savedDefaultAppearance;\n    } else {\n      if (!this._isOffscreenCanvasSupported) {\n        warn(\"_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly.\");\n      }\n      [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(totalHeight - 2 * defaultPadding, totalWidth - 2 * defaultHPadding, value, font, lineCount);\n    }\n    let descent = font.descent;\n    if (isNaN(descent)) {\n      descent = BASELINE_FACTOR * lineHeight;\n    } else {\n      descent = Math.max(BASELINE_FACTOR * lineHeight, Math.abs(descent) * fontSize);\n    }\n    const defaultVPadding = Math.min(Math.floor((totalHeight - fontSize) / 2), defaultPadding);\n    const alignment = this.data.textAlignment;\n    if (this.data.multiLine) {\n      return this._getMultilineAppearance(defaultAppearance, encodedLines, font, fontSize, totalWidth, totalHeight, alignment, defaultHPadding, defaultVPadding, descent, lineHeight, annotationStorage);\n    }\n    if (this.data.comb) {\n      return this._getCombAppearance(defaultAppearance, font, encodedLines[0], fontSize, totalWidth, totalHeight, defaultHPadding, defaultVPadding, descent, lineHeight, annotationStorage);\n    }\n    const bottomPadding = defaultVPadding + descent;\n    if (alignment === 0 || alignment > 2) {\n      return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 ${numberToString(defaultHPadding)} ${numberToString(bottomPadding)} Tm (${escapeString(encodedLines[0])}) Tj` + \" ET Q EMC\";\n    }\n    const prevInfo = {\n      shift: 0\n    };\n    const renderedText = this._renderText(encodedLines[0], font, fontSize, totalWidth, alignment, prevInfo, defaultHPadding, bottomPadding);\n    return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 0 0 Tm ${renderedText}` + \" ET Q EMC\";\n  }\n  static async _getFontData(evaluator, task, appearanceData, resources) {\n    const operatorList = new OperatorList();\n    const initialState = {\n      font: null,\n      clone() {\n        return this;\n      }\n    };\n    const {\n      fontName,\n      fontSize\n    } = appearanceData;\n    await evaluator.handleSetFont(resources, [fontName && Name.get(fontName), fontSize], null, operatorList, task, initialState, null);\n    return initialState.font;\n  }\n  _getTextWidth(text, font) {\n    return font.charsToGlyphs(text).reduce((width, glyph) => width + glyph.width, 0) / 1000;\n  }\n  _computeFontSize(height, width, text, font, lineCount) {\n    let {\n      fontSize\n    } = this.data.defaultAppearanceData;\n    let lineHeight = (fontSize || 12) * LINE_FACTOR,\n      numberOfLines = Math.round(height / lineHeight);\n    if (!fontSize) {\n      const roundWithTwoDigits = x => Math.floor(x * 100) / 100;\n      if (lineCount === -1) {\n        const textWidth = this._getTextWidth(text, font);\n        fontSize = roundWithTwoDigits(Math.min(height / LINE_FACTOR, textWidth > width ? width / textWidth : Infinity));\n        numberOfLines = 1;\n      } else {\n        const lines = text.split(/\\r\\n?|\\n/);\n        const cachedLines = [];\n        for (const line of lines) {\n          const encoded = font.encodeString(line).join(\"\");\n          const glyphs = font.charsToGlyphs(encoded);\n          const positions = font.getCharPositions(encoded);\n          cachedLines.push({\n            line: encoded,\n            glyphs,\n            positions\n          });\n        }\n        const isTooBig = fsize => {\n          let totalHeight = 0;\n          for (const cache of cachedLines) {\n            const chunks = this._splitLine(null, font, fsize, width, cache);\n            totalHeight += chunks.length * fsize;\n            if (totalHeight > height) {\n              return true;\n            }\n          }\n          return false;\n        };\n        numberOfLines = Math.max(numberOfLines, lineCount);\n        while (true) {\n          lineHeight = height / numberOfLines;\n          fontSize = roundWithTwoDigits(lineHeight / LINE_FACTOR);\n          if (isTooBig(fontSize)) {\n            numberOfLines++;\n            continue;\n          }\n          break;\n        }\n      }\n      const {\n        fontName,\n        fontColor\n      } = this.data.defaultAppearanceData;\n      this._defaultAppearance = createDefaultAppearance({\n        fontSize,\n        fontName,\n        fontColor\n      });\n    }\n    return [this._defaultAppearance, fontSize, height / numberOfLines];\n  }\n  _renderText(text, font, fontSize, totalWidth, alignment, prevInfo, hPadding, vPadding) {\n    let shift;\n    if (alignment === 1) {\n      const width = this._getTextWidth(text, font) * fontSize;\n      shift = (totalWidth - width) / 2;\n    } else if (alignment === 2) {\n      const width = this._getTextWidth(text, font) * fontSize;\n      shift = totalWidth - width - hPadding;\n    } else {\n      shift = hPadding;\n    }\n    const shiftStr = numberToString(shift - prevInfo.shift);\n    prevInfo.shift = shift;\n    vPadding = numberToString(vPadding);\n    return `${shiftStr} ${vPadding} Td (${escapeString(text)}) Tj`;\n  }\n  _getSaveFieldResources(xref) {\n    const {\n      localResources,\n      appearanceResources,\n      acroFormResources\n    } = this._fieldResources;\n    const fontName = this.data.defaultAppearanceData?.fontName;\n    if (!fontName) {\n      return localResources || Dict.empty;\n    }\n    for (const resources of [localResources, appearanceResources]) {\n      if (resources instanceof Dict) {\n        const localFont = resources.get(\"Font\");\n        if (localFont instanceof Dict && localFont.has(fontName)) {\n          return resources;\n        }\n      }\n    }\n    if (acroFormResources instanceof Dict) {\n      const acroFormFont = acroFormResources.get(\"Font\");\n      if (acroFormFont instanceof Dict && acroFormFont.has(fontName)) {\n        const subFontDict = new Dict(xref);\n        subFontDict.set(fontName, acroFormFont.getRaw(fontName));\n        const subResourcesDict = new Dict(xref);\n        subResourcesDict.set(\"Font\", subFontDict);\n        return Dict.merge({\n          xref,\n          dictArray: [subResourcesDict, localResources],\n          mergeSubDicts: true\n        });\n      }\n    }\n    return localResources || Dict.empty;\n  }\n  getFieldObject() {\n    return null;\n  }\n}\nclass TextWidgetAnnotation extends WidgetAnnotation {\n  constructor(params) {\n    super(params);\n    this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;\n    this._hasText = true;\n    const dict = params.dict;\n    if (typeof this.data.fieldValue !== \"string\") {\n      this.data.fieldValue = \"\";\n    }\n    let alignment = getInheritableProperty({\n      dict,\n      key: \"Q\"\n    });\n    if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {\n      alignment = null;\n    }\n    this.data.textAlignment = alignment;\n    let maximumLength = getInheritableProperty({\n      dict,\n      key: \"MaxLen\"\n    });\n    if (!Number.isInteger(maximumLength) || maximumLength < 0) {\n      maximumLength = 0;\n    }\n    this.data.maxLen = maximumLength;\n    this.data.multiLine = this.hasFieldFlag(AnnotationFieldFlag.MULTILINE);\n    this.data.comb = this.hasFieldFlag(AnnotationFieldFlag.COMB) && !this.hasFieldFlag(AnnotationFieldFlag.MULTILINE) && !this.hasFieldFlag(AnnotationFieldFlag.PASSWORD) && !this.hasFieldFlag(AnnotationFieldFlag.FILESELECT) && this.data.maxLen !== 0;\n    this.data.doNotScroll = this.hasFieldFlag(AnnotationFieldFlag.DONOTSCROLL);\n  }\n  get hasTextContent() {\n    return !!this.appearance && !this._needAppearances;\n  }\n  _getCombAppearance(defaultAppearance, font, text, fontSize, width, height, hPadding, vPadding, descent, lineHeight, annotationStorage) {\n    const combWidth = width / this.data.maxLen;\n    const colors = this.getBorderAndBackgroundAppearances(annotationStorage);\n    const buf = [];\n    const positions = font.getCharPositions(text);\n    for (const [start, end] of positions) {\n      buf.push(`(${escapeString(text.substring(start, end))}) Tj`);\n    }\n    const renderedComb = buf.join(` ${numberToString(combWidth)} 0 Td `);\n    return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 ${numberToString(hPadding)} ${numberToString(vPadding + descent)} Tm ${renderedComb}` + \" ET Q EMC\";\n  }\n  _getMultilineAppearance(defaultAppearance, lines, font, fontSize, width, height, alignment, hPadding, vPadding, descent, lineHeight, annotationStorage) {\n    const buf = [];\n    const totalWidth = width - 2 * hPadding;\n    const prevInfo = {\n      shift: 0\n    };\n    for (let i = 0, ii = lines.length; i < ii; i++) {\n      const line = lines[i];\n      const chunks = this._splitLine(line, font, fontSize, totalWidth);\n      for (let j = 0, jj = chunks.length; j < jj; j++) {\n        const chunk = chunks[j];\n        const vShift = i === 0 && j === 0 ? -vPadding - (lineHeight - descent) : -lineHeight;\n        buf.push(this._renderText(chunk, font, fontSize, width, alignment, prevInfo, hPadding, vShift));\n      }\n    }\n    const colors = this.getBorderAndBackgroundAppearances(annotationStorage);\n    const renderedText = buf.join(\"\\n\");\n    return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 0 ${numberToString(height)} Tm ${renderedText}` + \" ET Q EMC\";\n  }\n  _splitLine(line, font, fontSize, width, cache = {}) {\n    line = cache.line || line;\n    const glyphs = cache.glyphs || font.charsToGlyphs(line);\n    if (glyphs.length <= 1) {\n      return [line];\n    }\n    const positions = cache.positions || font.getCharPositions(line);\n    const scale = fontSize / 1000;\n    const chunks = [];\n    let lastSpacePosInStringStart = -1,\n      lastSpacePosInStringEnd = -1,\n      lastSpacePos = -1,\n      startChunk = 0,\n      currentWidth = 0;\n    for (let i = 0, ii = glyphs.length; i < ii; i++) {\n      const [start, end] = positions[i];\n      const glyph = glyphs[i];\n      const glyphWidth = glyph.width * scale;\n      if (glyph.unicode === \" \") {\n        if (currentWidth + glyphWidth > width) {\n          chunks.push(line.substring(startChunk, start));\n          startChunk = start;\n          currentWidth = glyphWidth;\n          lastSpacePosInStringStart = -1;\n          lastSpacePos = -1;\n        } else {\n          currentWidth += glyphWidth;\n          lastSpacePosInStringStart = start;\n          lastSpacePosInStringEnd = end;\n          lastSpacePos = i;\n        }\n      } else if (currentWidth + glyphWidth > width) {\n        if (lastSpacePosInStringStart !== -1) {\n          chunks.push(line.substring(startChunk, lastSpacePosInStringEnd));\n          startChunk = lastSpacePosInStringEnd;\n          i = lastSpacePos + 1;\n          lastSpacePosInStringStart = -1;\n          currentWidth = 0;\n        } else {\n          chunks.push(line.substring(startChunk, start));\n          startChunk = start;\n          currentWidth = glyphWidth;\n        }\n      } else {\n        currentWidth += glyphWidth;\n      }\n    }\n    if (startChunk < line.length) {\n      chunks.push(line.substring(startChunk, line.length));\n    }\n    return chunks;\n  }\n  getFieldObject() {\n    return {\n      id: this.data.id,\n      value: this.data.fieldValue,\n      defaultValue: this.data.defaultFieldValue || \"\",\n      multiline: this.data.multiLine,\n      password: this.hasFieldFlag(AnnotationFieldFlag.PASSWORD),\n      charLimit: this.data.maxLen,\n      comb: this.data.comb,\n      editable: !this.data.readOnly,\n      hidden: this.data.hidden,\n      name: this.data.fieldName,\n      rect: this.data.rect,\n      actions: this.data.actions,\n      page: this.data.pageIndex,\n      strokeColor: this.data.borderColor,\n      fillColor: this.data.backgroundColor,\n      rotation: this.rotation,\n      type: \"text\"\n    };\n  }\n}\nclass ButtonWidgetAnnotation extends WidgetAnnotation {\n  constructor(params) {\n    super(params);\n    this.checkedAppearance = null;\n    this.uncheckedAppearance = null;\n    this.data.checkBox = !this.hasFieldFlag(AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);\n    this.data.radioButton = this.hasFieldFlag(AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);\n    this.data.pushButton = this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);\n    this.data.isTooltipOnly = false;\n    if (this.data.checkBox) {\n      this._processCheckBox(params);\n    } else if (this.data.radioButton) {\n      this._processRadioButton(params);\n    } else if (this.data.pushButton) {\n      this.data.hasOwnCanvas = true;\n      this.data.noHTML = false;\n      this._processPushButton(params);\n    } else {\n      warn(\"Invalid field flags for button widget annotation\");\n    }\n  }\n  async getOperatorList(evaluator, task, intent, renderForms, annotationStorage) {\n    if (this.data.pushButton) {\n      return super.getOperatorList(evaluator, task, intent, false, annotationStorage);\n    }\n    let value = null;\n    let rotation = null;\n    if (annotationStorage) {\n      const storageEntry = annotationStorage.get(this.data.id);\n      value = storageEntry ? storageEntry.value : null;\n      rotation = storageEntry ? storageEntry.rotation : null;\n    }\n    if (value === null && this.appearance) {\n      return super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage);\n    }\n    if (value === null || value === undefined) {\n      value = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue;\n    }\n    const appearance = value ? this.checkedAppearance : this.uncheckedAppearance;\n    if (appearance) {\n      const savedAppearance = this.appearance;\n      const savedMatrix = appearance.dict.getArray(\"Matrix\") || IDENTITY_MATRIX;\n      if (rotation) {\n        appearance.dict.set(\"Matrix\", this.getRotationMatrix(annotationStorage));\n      }\n      this.appearance = appearance;\n      const operatorList = super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage);\n      this.appearance = savedAppearance;\n      appearance.dict.set(\"Matrix\", savedMatrix);\n      return operatorList;\n    }\n    return {\n      opList: new OperatorList(),\n      separateForm: false,\n      separateCanvas: false\n    };\n  }\n  async save(evaluator, task, annotationStorage) {\n    if (this.data.checkBox) {\n      return this._saveCheckbox(evaluator, task, annotationStorage);\n    }\n    if (this.data.radioButton) {\n      return this._saveRadioButton(evaluator, task, annotationStorage);\n    }\n    return null;\n  }\n  async _saveCheckbox(evaluator, task, annotationStorage) {\n    if (!annotationStorage) {\n      return null;\n    }\n    const storageEntry = annotationStorage.get(this.data.id);\n    let rotation = storageEntry?.rotation,\n      value = storageEntry?.value;\n    if (rotation === undefined) {\n      if (value === undefined) {\n        return null;\n      }\n      const defaultValue = this.data.fieldValue === this.data.exportValue;\n      if (defaultValue === value) {\n        return null;\n      }\n    }\n    const dict = evaluator.xref.fetchIfRef(this.ref);\n    if (!(dict instanceof Dict)) {\n      return null;\n    }\n    if (rotation === undefined) {\n      rotation = this.rotation;\n    }\n    if (value === undefined) {\n      value = this.data.fieldValue === this.data.exportValue;\n    }\n    const xfa = {\n      path: this.data.fieldName,\n      value: value ? this.data.exportValue : \"\"\n    };\n    const name = Name.get(value ? this.data.exportValue : \"Off\");\n    dict.set(\"V\", name);\n    dict.set(\"AS\", name);\n    dict.set(\"M\", `D:${getModificationDate()}`);\n    const maybeMK = this._getMKDict(rotation);\n    if (maybeMK) {\n      dict.set(\"MK\", maybeMK);\n    }\n    const buffer = [];\n    await writeObject(this.ref, dict, buffer, evaluator.xref);\n    return [{\n      ref: this.ref,\n      data: buffer.join(\"\"),\n      xfa\n    }];\n  }\n  async _saveRadioButton(evaluator, task, annotationStorage) {\n    if (!annotationStorage) {\n      return null;\n    }\n    const storageEntry = annotationStorage.get(this.data.id);\n    let rotation = storageEntry?.rotation,\n      value = storageEntry?.value;\n    if (rotation === undefined) {\n      if (value === undefined) {\n        return null;\n      }\n      const defaultValue = this.data.fieldValue === this.data.buttonValue;\n      if (defaultValue === value) {\n        return null;\n      }\n    }\n    const dict = evaluator.xref.fetchIfRef(this.ref);\n    if (!(dict instanceof Dict)) {\n      return null;\n    }\n    if (value === undefined) {\n      value = this.data.fieldValue === this.data.buttonValue;\n    }\n    if (rotation === undefined) {\n      rotation = this.rotation;\n    }\n    const xfa = {\n      path: this.data.fieldName,\n      value: value ? this.data.buttonValue : \"\"\n    };\n    const name = Name.get(value ? this.data.buttonValue : \"Off\");\n    const buffer = [];\n    let parentData = null;\n    if (value) {\n      if (this.parent instanceof Ref) {\n        const parent = evaluator.xref.fetch(this.parent);\n        parent.set(\"V\", name);\n        await writeObject(this.parent, parent, buffer, evaluator.xref);\n        parentData = buffer.join(\"\");\n        buffer.length = 0;\n      } else if (this.parent instanceof Dict) {\n        this.parent.set(\"V\", name);\n      }\n    }\n    dict.set(\"AS\", name);\n    dict.set(\"M\", `D:${getModificationDate()}`);\n    const maybeMK = this._getMKDict(rotation);\n    if (maybeMK) {\n      dict.set(\"MK\", maybeMK);\n    }\n    await writeObject(this.ref, dict, buffer, evaluator.xref);\n    const newRefs = [{\n      ref: this.ref,\n      data: buffer.join(\"\"),\n      xfa\n    }];\n    if (parentData) {\n      newRefs.push({\n        ref: this.parent,\n        data: parentData,\n        xfa: null\n      });\n    }\n    return newRefs;\n  }\n  _getDefaultCheckedAppearance(params, type) {\n    const width = this.data.rect[2] - this.data.rect[0];\n    const height = this.data.rect[3] - this.data.rect[1];\n    const bbox = [0, 0, width, height];\n    const FONT_RATIO = 0.8;\n    const fontSize = Math.min(width, height) * FONT_RATIO;\n    let metrics, char;\n    if (type === \"check\") {\n      metrics = {\n        width: 0.755 * fontSize,\n        height: 0.705 * fontSize\n      };\n      char = \"\\x33\";\n    } else if (type === \"disc\") {\n      metrics = {\n        width: 0.791 * fontSize,\n        height: 0.705 * fontSize\n      };\n      char = \"\\x6C\";\n    } else {\n      unreachable(`_getDefaultCheckedAppearance - unsupported type: ${type}`);\n    }\n    const xShift = numberToString((width - metrics.width) / 2);\n    const yShift = numberToString((height - metrics.height) / 2);\n    const appearance = `q BT /PdfJsZaDb ${fontSize} Tf 0 g ${xShift} ${yShift} Td (${char}) Tj ET Q`;\n    const appearanceStreamDict = new Dict(params.xref);\n    appearanceStreamDict.set(\"FormType\", 1);\n    appearanceStreamDict.set(\"Subtype\", Name.get(\"Form\"));\n    appearanceStreamDict.set(\"Type\", Name.get(\"XObject\"));\n    appearanceStreamDict.set(\"BBox\", bbox);\n    appearanceStreamDict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n    appearanceStreamDict.set(\"Length\", appearance.length);\n    const resources = new Dict(params.xref);\n    const font = new Dict(params.xref);\n    font.set(\"PdfJsZaDb\", this.fallbackFontDict);\n    resources.set(\"Font\", font);\n    appearanceStreamDict.set(\"Resources\", resources);\n    this.checkedAppearance = new StringStream(appearance);\n    this.checkedAppearance.dict = appearanceStreamDict;\n    this._streams.push(this.checkedAppearance);\n  }\n  _processCheckBox(params) {\n    const customAppearance = params.dict.get(\"AP\");\n    if (!(customAppearance instanceof Dict)) {\n      return;\n    }\n    const normalAppearance = customAppearance.get(\"N\");\n    if (!(normalAppearance instanceof Dict)) {\n      return;\n    }\n    const asValue = this._decodeFormValue(params.dict.get(\"AS\"));\n    if (typeof asValue === \"string\") {\n      this.data.fieldValue = asValue;\n    }\n    const yes = this.data.fieldValue !== null && this.data.fieldValue !== \"Off\" ? this.data.fieldValue : \"Yes\";\n    const exportValues = normalAppearance.getKeys();\n    if (exportValues.length === 0) {\n      exportValues.push(\"Off\", yes);\n    } else if (exportValues.length === 1) {\n      if (exportValues[0] === \"Off\") {\n        exportValues.push(yes);\n      } else {\n        exportValues.unshift(\"Off\");\n      }\n    } else if (exportValues.includes(yes)) {\n      exportValues.length = 0;\n      exportValues.push(\"Off\", yes);\n    } else {\n      const otherYes = exportValues.find(v => v !== \"Off\");\n      exportValues.length = 0;\n      exportValues.push(\"Off\", otherYes);\n    }\n    if (!exportValues.includes(this.data.fieldValue)) {\n      this.data.fieldValue = \"Off\";\n    }\n    this.data.exportValue = exportValues[1];\n    const checkedAppearance = normalAppearance.get(this.data.exportValue);\n    this.checkedAppearance = checkedAppearance instanceof BaseStream ? checkedAppearance : null;\n    const uncheckedAppearance = normalAppearance.get(\"Off\");\n    this.uncheckedAppearance = uncheckedAppearance instanceof BaseStream ? uncheckedAppearance : null;\n    if (this.checkedAppearance) {\n      this._streams.push(this.checkedAppearance);\n    } else {\n      this._getDefaultCheckedAppearance(params, \"check\");\n    }\n    if (this.uncheckedAppearance) {\n      this._streams.push(this.uncheckedAppearance);\n    }\n    this._fallbackFontDict = this.fallbackFontDict;\n    if (this.data.defaultFieldValue === null) {\n      this.data.defaultFieldValue = \"Off\";\n    }\n  }\n  _processRadioButton(params) {\n    this.data.buttonValue = null;\n    const fieldParent = params.dict.get(\"Parent\");\n    if (fieldParent instanceof Dict) {\n      this.parent = params.dict.getRaw(\"Parent\");\n      const fieldParentValue = fieldParent.get(\"V\");\n      if (fieldParentValue instanceof Name) {\n        this.data.fieldValue = this._decodeFormValue(fieldParentValue);\n      }\n    }\n    const appearanceStates = params.dict.get(\"AP\");\n    if (!(appearanceStates instanceof Dict)) {\n      return;\n    }\n    const normalAppearance = appearanceStates.get(\"N\");\n    if (!(normalAppearance instanceof Dict)) {\n      return;\n    }\n    for (const key of normalAppearance.getKeys()) {\n      if (key !== \"Off\") {\n        this.data.buttonValue = this._decodeFormValue(key);\n        break;\n      }\n    }\n    const checkedAppearance = normalAppearance.get(this.data.buttonValue);\n    this.checkedAppearance = checkedAppearance instanceof BaseStream ? checkedAppearance : null;\n    const uncheckedAppearance = normalAppearance.get(\"Off\");\n    this.uncheckedAppearance = uncheckedAppearance instanceof BaseStream ? uncheckedAppearance : null;\n    if (this.checkedAppearance) {\n      this._streams.push(this.checkedAppearance);\n    } else {\n      this._getDefaultCheckedAppearance(params, \"disc\");\n    }\n    if (this.uncheckedAppearance) {\n      this._streams.push(this.uncheckedAppearance);\n    }\n    this._fallbackFontDict = this.fallbackFontDict;\n    if (this.data.defaultFieldValue === null) {\n      this.data.defaultFieldValue = \"Off\";\n    }\n  }\n  _processPushButton(params) {\n    const {\n      dict,\n      annotationGlobals\n    } = params;\n    if (!dict.has(\"A\") && !dict.has(\"AA\") && !this.data.alternativeText) {\n      warn(\"Push buttons without action dictionaries are not supported\");\n      return;\n    }\n    this.data.isTooltipOnly = !dict.has(\"A\") && !dict.has(\"AA\");\n    Catalog.parseDestDictionary({\n      destDict: dict,\n      resultObj: this.data,\n      docBaseUrl: annotationGlobals.baseUrl,\n      docAttachments: annotationGlobals.attachments\n    });\n  }\n  getFieldObject() {\n    let type = \"button\";\n    let exportValues;\n    if (this.data.checkBox) {\n      type = \"checkbox\";\n      exportValues = this.data.exportValue;\n    } else if (this.data.radioButton) {\n      type = \"radiobutton\";\n      exportValues = this.data.buttonValue;\n    }\n    return {\n      id: this.data.id,\n      value: this.data.fieldValue || \"Off\",\n      defaultValue: this.data.defaultFieldValue,\n      exportValues,\n      editable: !this.data.readOnly,\n      name: this.data.fieldName,\n      rect: this.data.rect,\n      hidden: this.data.hidden,\n      actions: this.data.actions,\n      page: this.data.pageIndex,\n      strokeColor: this.data.borderColor,\n      fillColor: this.data.backgroundColor,\n      rotation: this.rotation,\n      type\n    };\n  }\n  get fallbackFontDict() {\n    const dict = new Dict();\n    dict.set(\"BaseFont\", Name.get(\"ZapfDingbats\"));\n    dict.set(\"Type\", Name.get(\"FallbackType\"));\n    dict.set(\"Subtype\", Name.get(\"FallbackType\"));\n    dict.set(\"Encoding\", Name.get(\"ZapfDingbatsEncoding\"));\n    return shadow(this, \"fallbackFontDict\", dict);\n  }\n}\nclass ChoiceWidgetAnnotation extends WidgetAnnotation {\n  constructor(params) {\n    super(params);\n    const {\n      dict,\n      xref\n    } = params;\n    this.indices = dict.getArray(\"I\");\n    this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;\n    this.data.options = [];\n    const options = getInheritableProperty({\n      dict,\n      key: \"Opt\"\n    });\n    if (Array.isArray(options)) {\n      for (let i = 0, ii = options.length; i < ii; i++) {\n        const option = xref.fetchIfRef(options[i]);\n        const isOptionArray = Array.isArray(option);\n        this.data.options[i] = {\n          exportValue: this._decodeFormValue(isOptionArray ? xref.fetchIfRef(option[0]) : option),\n          displayValue: this._decodeFormValue(isOptionArray ? xref.fetchIfRef(option[1]) : option)\n        };\n      }\n    }\n    if (!this.hasIndices) {\n      if (typeof this.data.fieldValue === \"string\") {\n        this.data.fieldValue = [this.data.fieldValue];\n      } else if (!this.data.fieldValue) {\n        this.data.fieldValue = [];\n      }\n    } else {\n      this.data.fieldValue = [];\n      const ii = this.data.options.length;\n      for (const i of this.indices) {\n        if (Number.isInteger(i) && i >= 0 && i < ii) {\n          this.data.fieldValue.push(this.data.options[i].exportValue);\n        }\n      }\n    }\n    this.data.combo = this.hasFieldFlag(AnnotationFieldFlag.COMBO);\n    this.data.multiSelect = this.hasFieldFlag(AnnotationFieldFlag.MULTISELECT);\n    this._hasText = true;\n  }\n  getFieldObject() {\n    const type = this.data.combo ? \"combobox\" : \"listbox\";\n    const value = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;\n    return {\n      id: this.data.id,\n      value,\n      defaultValue: this.data.defaultFieldValue,\n      editable: !this.data.readOnly,\n      name: this.data.fieldName,\n      rect: this.data.rect,\n      numItems: this.data.fieldValue.length,\n      multipleSelection: this.data.multiSelect,\n      hidden: this.data.hidden,\n      actions: this.data.actions,\n      items: this.data.options,\n      page: this.data.pageIndex,\n      strokeColor: this.data.borderColor,\n      fillColor: this.data.backgroundColor,\n      rotation: this.rotation,\n      type\n    };\n  }\n  amendSavedDict(annotationStorage, dict) {\n    if (!this.hasIndices) {\n      return;\n    }\n    let values = annotationStorage?.get(this.data.id)?.value;\n    if (!Array.isArray(values)) {\n      values = [values];\n    }\n    const indices = [];\n    const {\n      options\n    } = this.data;\n    for (let i = 0, j = 0, ii = options.length; i < ii; i++) {\n      if (options[i].exportValue === values[j]) {\n        indices.push(i);\n        j += 1;\n      }\n    }\n    dict.set(\"I\", indices);\n  }\n  async _getAppearance(evaluator, task, intent, annotationStorage) {\n    if (this.data.combo) {\n      return super._getAppearance(evaluator, task, intent, annotationStorage);\n    }\n    let exportedValue, rotation;\n    const storageEntry = annotationStorage?.get(this.data.id);\n    if (storageEntry) {\n      rotation = storageEntry.rotation;\n      exportedValue = storageEntry.value;\n    }\n    if (rotation === undefined && exportedValue === undefined && !this._needAppearances) {\n      return null;\n    }\n    if (exportedValue === undefined) {\n      exportedValue = this.data.fieldValue;\n    } else if (!Array.isArray(exportedValue)) {\n      exportedValue = [exportedValue];\n    }\n    const defaultPadding = 1;\n    const defaultHPadding = 2;\n    let totalHeight = this.data.rect[3] - this.data.rect[1];\n    let totalWidth = this.data.rect[2] - this.data.rect[0];\n    if (rotation === 90 || rotation === 270) {\n      [totalWidth, totalHeight] = [totalHeight, totalWidth];\n    }\n    const lineCount = this.data.options.length;\n    const valueIndices = [];\n    for (let i = 0; i < lineCount; i++) {\n      const {\n        exportValue\n      } = this.data.options[i];\n      if (exportedValue.includes(exportValue)) {\n        valueIndices.push(i);\n      }\n    }\n    if (!this._defaultAppearance) {\n      this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = \"/Helvetica 0 Tf 0 g\");\n    }\n    const font = await WidgetAnnotation._getFontData(evaluator, task, this.data.defaultAppearanceData, this._fieldResources.mergedResources);\n    let defaultAppearance;\n    let {\n      fontSize\n    } = this.data.defaultAppearanceData;\n    if (!fontSize) {\n      const lineHeight = (totalHeight - defaultPadding) / lineCount;\n      let lineWidth = -1;\n      let value;\n      for (const {\n        displayValue\n      } of this.data.options) {\n        const width = this._getTextWidth(displayValue, font);\n        if (width > lineWidth) {\n          lineWidth = width;\n          value = displayValue;\n        }\n      }\n      [defaultAppearance, fontSize] = this._computeFontSize(lineHeight, totalWidth - 2 * defaultHPadding, value, font, -1);\n    } else {\n      defaultAppearance = this._defaultAppearance;\n    }\n    const lineHeight = fontSize * LINE_FACTOR;\n    const vPadding = (lineHeight - fontSize) / 2;\n    const numberOfVisibleLines = Math.floor(totalHeight / lineHeight);\n    let firstIndex = 0;\n    if (valueIndices.length > 0) {\n      const minIndex = Math.min(...valueIndices);\n      const maxIndex = Math.max(...valueIndices);\n      firstIndex = Math.max(0, maxIndex - numberOfVisibleLines + 1);\n      if (firstIndex > minIndex) {\n        firstIndex = minIndex;\n      }\n    }\n    const end = Math.min(firstIndex + numberOfVisibleLines + 1, lineCount);\n    const buf = [\"/Tx BMC q\", `1 1 ${totalWidth} ${totalHeight} re W n`];\n    if (valueIndices.length) {\n      buf.push(\"0.600006 0.756866 0.854904 rg\");\n      for (const index of valueIndices) {\n        if (firstIndex <= index && index < end) {\n          buf.push(`1 ${totalHeight - (index - firstIndex + 1) * lineHeight} ${totalWidth} ${lineHeight} re f`);\n        }\n      }\n    }\n    buf.push(\"BT\", defaultAppearance, `1 0 0 1 0 ${totalHeight} Tm`);\n    const prevInfo = {\n      shift: 0\n    };\n    for (let i = firstIndex; i < end; i++) {\n      const {\n        displayValue\n      } = this.data.options[i];\n      const vpadding = i === firstIndex ? vPadding : 0;\n      buf.push(this._renderText(displayValue, font, fontSize, totalWidth, 0, prevInfo, defaultHPadding, -lineHeight + vpadding));\n    }\n    buf.push(\"ET Q EMC\");\n    return buf.join(\"\\n\");\n  }\n}\nclass SignatureWidgetAnnotation extends WidgetAnnotation {\n  constructor(params) {\n    super(params);\n    this.data.fieldValue = null;\n    this.data.hasOwnCanvas = this.data.noRotate;\n    this.data.noHTML = !this.data.hasOwnCanvas;\n  }\n  getFieldObject() {\n    return {\n      id: this.data.id,\n      value: null,\n      page: this.data.pageIndex,\n      type: \"signature\"\n    };\n  }\n}\nclass TextAnnotation extends MarkupAnnotation {\n  constructor(params) {\n    const DEFAULT_ICON_SIZE = 22;\n    super(params);\n    this.data.noRotate = true;\n    this.data.hasOwnCanvas = this.data.noRotate;\n    this.data.noHTML = false;\n    const {\n      dict\n    } = params;\n    this.data.annotationType = AnnotationType.TEXT;\n    if (this.data.hasAppearance) {\n      this.data.name = \"NoIcon\";\n    } else {\n      this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE;\n      this.data.rect[2] = this.data.rect[0] + DEFAULT_ICON_SIZE;\n      this.data.name = dict.has(\"Name\") ? dict.get(\"Name\").name : \"Note\";\n    }\n    if (dict.has(\"State\")) {\n      this.data.state = dict.get(\"State\") || null;\n      this.data.stateModel = dict.get(\"StateModel\") || null;\n    } else {\n      this.data.state = null;\n      this.data.stateModel = null;\n    }\n  }\n}\nclass LinkAnnotation extends Annotation {\n  constructor(params) {\n    super(params);\n    const {\n      dict,\n      annotationGlobals\n    } = params;\n    this.data.annotationType = AnnotationType.LINK;\n    this.data.noHTML = false;\n    const quadPoints = getQuadPoints(dict, this.rectangle);\n    if (quadPoints) {\n      this.data.quadPoints = quadPoints;\n    }\n    this.data.borderColor ||= this.data.color;\n    Catalog.parseDestDictionary({\n      destDict: dict,\n      resultObj: this.data,\n      docBaseUrl: annotationGlobals.baseUrl,\n      docAttachments: annotationGlobals.attachments\n    });\n  }\n}\nclass PopupAnnotation extends Annotation {\n  constructor(params) {\n    super(params);\n    const {\n      dict\n    } = params;\n    this.data.annotationType = AnnotationType.POPUP;\n    this.data.noHTML = false;\n    if (this.data.rect[0] === this.data.rect[2] || this.data.rect[1] === this.data.rect[3]) {\n      this.data.rect = null;\n    }\n    let parentItem = dict.get(\"Parent\");\n    if (!parentItem) {\n      warn(\"Popup annotation has a missing or invalid parent annotation.\");\n      return;\n    }\n    const parentRect = parentItem.getArray(\"Rect\");\n    this.data.parentRect = Array.isArray(parentRect) && parentRect.length === 4 ? Util.normalizeRect(parentRect) : null;\n    const rt = parentItem.get(\"RT\");\n    if (isName(rt, AnnotationReplyType.GROUP)) {\n      parentItem = parentItem.get(\"IRT\");\n    }\n    if (!parentItem.has(\"M\")) {\n      this.data.modificationDate = null;\n    } else {\n      this.setModificationDate(parentItem.get(\"M\"));\n      this.data.modificationDate = this.modificationDate;\n    }\n    if (!parentItem.has(\"C\")) {\n      this.data.color = null;\n    } else {\n      this.setColor(parentItem.getArray(\"C\"));\n      this.data.color = this.color;\n    }\n    if (!this.viewable) {\n      const parentFlags = parentItem.get(\"F\");\n      if (this._isViewable(parentFlags)) {\n        this.setFlags(parentFlags);\n      }\n    }\n    this.setTitle(parentItem.get(\"T\"));\n    this.data.titleObj = this._title;\n    this.setContents(parentItem.get(\"Contents\"));\n    this.data.contentsObj = this._contents;\n    if (parentItem.has(\"RC\")) {\n      this.data.richText = XFAFactory.getRichTextAsHtml(parentItem.get(\"RC\"));\n    }\n    this.data.open = !!dict.get(\"Open\");\n  }\n}\nclass FreeTextAnnotation extends MarkupAnnotation {\n  constructor(params) {\n    super(params);\n    this.data.hasOwnCanvas = !this.data.noHTML;\n    this.data.noHTML = false;\n    const {\n      evaluatorOptions,\n      xref\n    } = params;\n    this.data.annotationType = AnnotationType.FREETEXT;\n    this.setDefaultAppearance(params);\n    this._hasAppearance = !!this.appearance;\n    if (this._hasAppearance) {\n      const {\n        fontColor,\n        fontSize\n      } = parseAppearanceStream(this.appearance, evaluatorOptions, xref);\n      this.data.defaultAppearanceData.fontColor = fontColor;\n      this.data.defaultAppearanceData.fontSize = fontSize || 10;\n    } else {\n      this.data.defaultAppearanceData.fontSize ||= 10;\n      const {\n        fontColor,\n        fontSize\n      } = this.data.defaultAppearanceData;\n      if (this._contents.str) {\n        this.data.textContent = this._contents.str.split(/\\r\\n?|\\n/).map(line => line.trimEnd());\n        const {\n          coords,\n          bbox,\n          matrix\n        } = FakeUnicodeFont.getFirstPositionInfo(this.rectangle, this.rotation, fontSize);\n        this.data.textPosition = this._transformPoint(coords, bbox, matrix);\n      }\n      if (this._isOffscreenCanvasSupported) {\n        const strokeAlpha = params.dict.get(\"CA\");\n        const fakeUnicodeFont = new FakeUnicodeFont(xref, \"sans-serif\");\n        this.appearance = fakeUnicodeFont.createAppearance(this._contents.str, this.rectangle, this.rotation, fontSize, fontColor, strokeAlpha);\n        this._streams.push(this.appearance);\n      } else {\n        warn(\"FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.\");\n      }\n    }\n  }\n  get hasTextContent() {\n    return this._hasAppearance;\n  }\n  static createNewDict(annotation, xref, {\n    apRef,\n    ap\n  }) {\n    const {\n      color,\n      fontSize,\n      rect,\n      rotation,\n      user,\n      value\n    } = annotation;\n    const freetext = new Dict(xref);\n    freetext.set(\"Type\", Name.get(\"Annot\"));\n    freetext.set(\"Subtype\", Name.get(\"FreeText\"));\n    freetext.set(\"CreationDate\", `D:${getModificationDate()}`);\n    freetext.set(\"Rect\", rect);\n    const da = `/Helv ${fontSize} Tf ${getPdfColor(color, true)}`;\n    freetext.set(\"DA\", da);\n    freetext.set(\"Contents\", isAscii(value) ? value : stringToUTF16String(value, true));\n    freetext.set(\"F\", 4);\n    freetext.set(\"Border\", [0, 0, 0]);\n    freetext.set(\"Rotate\", rotation);\n    if (user) {\n      freetext.set(\"T\", isAscii(user) ? user : stringToUTF16String(user, true));\n    }\n    if (apRef || ap) {\n      const n = new Dict(xref);\n      freetext.set(\"AP\", n);\n      if (apRef) {\n        n.set(\"N\", apRef);\n      } else {\n        n.set(\"N\", ap);\n      }\n    }\n    return freetext;\n  }\n  static async createNewAppearanceStream(annotation, xref, params) {\n    const {\n      baseFontRef,\n      evaluator,\n      task\n    } = params;\n    const {\n      color,\n      fontSize,\n      rect,\n      rotation,\n      value\n    } = annotation;\n    const resources = new Dict(xref);\n    const font = new Dict(xref);\n    if (baseFontRef) {\n      font.set(\"Helv\", baseFontRef);\n    } else {\n      const baseFont = new Dict(xref);\n      baseFont.set(\"BaseFont\", Name.get(\"Helvetica\"));\n      baseFont.set(\"Type\", Name.get(\"Font\"));\n      baseFont.set(\"Subtype\", Name.get(\"Type1\"));\n      baseFont.set(\"Encoding\", Name.get(\"WinAnsiEncoding\"));\n      font.set(\"Helv\", baseFont);\n    }\n    resources.set(\"Font\", font);\n    const helv = await WidgetAnnotation._getFontData(evaluator, task, {\n      fontName: \"Helv\",\n      fontSize\n    }, resources);\n    const [x1, y1, x2, y2] = rect;\n    let w = x2 - x1;\n    let h = y2 - y1;\n    if (rotation % 180 !== 0) {\n      [w, h] = [h, w];\n    }\n    const lines = value.split(\"\\n\");\n    const scale = fontSize / 1000;\n    let totalWidth = -Infinity;\n    const encodedLines = [];\n    for (let line of lines) {\n      const encoded = helv.encodeString(line);\n      if (encoded.length > 1) {\n        return null;\n      }\n      line = encoded.join(\"\");\n      encodedLines.push(line);\n      let lineWidth = 0;\n      const glyphs = helv.charsToGlyphs(line);\n      for (const glyph of glyphs) {\n        lineWidth += glyph.width * scale;\n      }\n      totalWidth = Math.max(totalWidth, lineWidth);\n    }\n    let hscale = 1;\n    if (totalWidth > w) {\n      hscale = w / totalWidth;\n    }\n    let vscale = 1;\n    const lineHeight = LINE_FACTOR * fontSize;\n    const lineAscent = (LINE_FACTOR - LINE_DESCENT_FACTOR) * fontSize;\n    const totalHeight = lineHeight * lines.length;\n    if (totalHeight > h) {\n      vscale = h / totalHeight;\n    }\n    const fscale = Math.min(hscale, vscale);\n    const newFontSize = fontSize * fscale;\n    let firstPoint, clipBox, matrix;\n    switch (rotation) {\n      case 0:\n        matrix = [1, 0, 0, 1];\n        clipBox = [rect[0], rect[1], w, h];\n        firstPoint = [rect[0], rect[3] - lineAscent];\n        break;\n      case 90:\n        matrix = [0, 1, -1, 0];\n        clipBox = [rect[1], -rect[2], w, h];\n        firstPoint = [rect[1], -rect[0] - lineAscent];\n        break;\n      case 180:\n        matrix = [-1, 0, 0, -1];\n        clipBox = [-rect[2], -rect[3], w, h];\n        firstPoint = [-rect[2], -rect[1] - lineAscent];\n        break;\n      case 270:\n        matrix = [0, -1, 1, 0];\n        clipBox = [-rect[3], rect[0], w, h];\n        firstPoint = [-rect[3], rect[2] - lineAscent];\n        break;\n    }\n    const buffer = [\"q\", `${matrix.join(\" \")} 0 0 cm`, `${clipBox.join(\" \")} re W n`, `BT`, `${getPdfColor(color, true)}`, `0 Tc /Helv ${numberToString(newFontSize)} Tf`];\n    buffer.push(`${firstPoint.join(\" \")} Td (${escapeString(encodedLines[0])}) Tj`);\n    const vShift = numberToString(lineHeight);\n    for (let i = 1, ii = encodedLines.length; i < ii; i++) {\n      const line = encodedLines[i];\n      buffer.push(`0 -${vShift} Td (${escapeString(line)}) Tj`);\n    }\n    buffer.push(\"ET\", \"Q\");\n    const appearance = buffer.join(\"\\n\");\n    const appearanceStreamDict = new Dict(xref);\n    appearanceStreamDict.set(\"FormType\", 1);\n    appearanceStreamDict.set(\"Subtype\", Name.get(\"Form\"));\n    appearanceStreamDict.set(\"Type\", Name.get(\"XObject\"));\n    appearanceStreamDict.set(\"BBox\", rect);\n    appearanceStreamDict.set(\"Resources\", resources);\n    appearanceStreamDict.set(\"Matrix\", [1, 0, 0, 1, -rect[0], -rect[1]]);\n    const ap = new StringStream(appearance);\n    ap.dict = appearanceStreamDict;\n    return ap;\n  }\n}\nclass LineAnnotation extends MarkupAnnotation {\n  constructor(params) {\n    super(params);\n    const {\n      dict,\n      xref\n    } = params;\n    this.data.annotationType = AnnotationType.LINE;\n    this.data.hasOwnCanvas = this.data.noRotate;\n    this.data.noHTML = false;\n    const lineCoordinates = dict.getArray(\"L\");\n    this.data.lineCoordinates = Util.normalizeRect(lineCoordinates);\n    this.setLineEndings(dict.getArray(\"LE\"));\n    this.data.lineEndings = this.lineEndings;\n    if (!this.appearance) {\n      const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];\n      const strokeAlpha = dict.get(\"CA\");\n      const interiorColor = getRgbColor(dict.getArray(\"IC\"), null);\n      const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;\n      const fillAlpha = fillColor ? strokeAlpha : null;\n      const borderWidth = this.borderStyle.width || 1,\n        borderAdjust = 2 * borderWidth;\n      const bbox = [this.data.lineCoordinates[0] - borderAdjust, this.data.lineCoordinates[1] - borderAdjust, this.data.lineCoordinates[2] + borderAdjust, this.data.lineCoordinates[3] + borderAdjust];\n      if (!Util.intersect(this.rectangle, bbox)) {\n        this.rectangle = bbox;\n      }\n      this._setDefaultAppearance({\n        xref,\n        extra: `${borderWidth} w`,\n        strokeColor,\n        fillColor,\n        strokeAlpha,\n        fillAlpha,\n        pointsCallback: (buffer, points) => {\n          buffer.push(`${lineCoordinates[0]} ${lineCoordinates[1]} m`, `${lineCoordinates[2]} ${lineCoordinates[3]} l`, \"S\");\n          return [points[0].x - borderWidth, points[1].x + borderWidth, points[3].y - borderWidth, points[1].y + borderWidth];\n        }\n      });\n    }\n  }\n}\nclass SquareAnnotation extends MarkupAnnotation {\n  constructor(params) {\n    super(params);\n    const {\n      dict,\n      xref\n    } = params;\n    this.data.annotationType = AnnotationType.SQUARE;\n    this.data.hasOwnCanvas = this.data.noRotate;\n    this.data.noHTML = false;\n    if (!this.appearance) {\n      const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];\n      const strokeAlpha = dict.get(\"CA\");\n      const interiorColor = getRgbColor(dict.getArray(\"IC\"), null);\n      const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;\n      const fillAlpha = fillColor ? strokeAlpha : null;\n      if (this.borderStyle.width === 0 && !fillColor) {\n        return;\n      }\n      this._setDefaultAppearance({\n        xref,\n        extra: `${this.borderStyle.width} w`,\n        strokeColor,\n        fillColor,\n        strokeAlpha,\n        fillAlpha,\n        pointsCallback: (buffer, points) => {\n          const x = points[2].x + this.borderStyle.width / 2;\n          const y = points[2].y + this.borderStyle.width / 2;\n          const width = points[3].x - points[2].x - this.borderStyle.width;\n          const height = points[1].y - points[3].y - this.borderStyle.width;\n          buffer.push(`${x} ${y} ${width} ${height} re`);\n          if (fillColor) {\n            buffer.push(\"B\");\n          } else {\n            buffer.push(\"S\");\n          }\n          return [points[0].x, points[1].x, points[3].y, points[1].y];\n        }\n      });\n    }\n  }\n}\nclass CircleAnnotation extends MarkupAnnotation {\n  constructor(params) {\n    super(params);\n    const {\n      dict,\n      xref\n    } = params;\n    this.data.annotationType = AnnotationType.CIRCLE;\n    if (!this.appearance) {\n      const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];\n      const strokeAlpha = dict.get(\"CA\");\n      const interiorColor = getRgbColor(dict.getArray(\"IC\"), null);\n      const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;\n      const fillAlpha = fillColor ? strokeAlpha : null;\n      if (this.borderStyle.width === 0 && !fillColor) {\n        return;\n      }\n      const controlPointsDistance = 4 / 3 * Math.tan(Math.PI / (2 * 4));\n      this._setDefaultAppearance({\n        xref,\n        extra: `${this.borderStyle.width} w`,\n        strokeColor,\n        fillColor,\n        strokeAlpha,\n        fillAlpha,\n        pointsCallback: (buffer, points) => {\n          const x0 = points[0].x + this.borderStyle.width / 2;\n          const y0 = points[0].y - this.borderStyle.width / 2;\n          const x1 = points[3].x - this.borderStyle.width / 2;\n          const y1 = points[3].y + this.borderStyle.width / 2;\n          const xMid = x0 + (x1 - x0) / 2;\n          const yMid = y0 + (y1 - y0) / 2;\n          const xOffset = (x1 - x0) / 2 * controlPointsDistance;\n          const yOffset = (y1 - y0) / 2 * controlPointsDistance;\n          buffer.push(`${xMid} ${y1} m`, `${xMid + xOffset} ${y1} ${x1} ${yMid + yOffset} ${x1} ${yMid} c`, `${x1} ${yMid - yOffset} ${xMid + xOffset} ${y0} ${xMid} ${y0} c`, `${xMid - xOffset} ${y0} ${x0} ${yMid - yOffset} ${x0} ${yMid} c`, `${x0} ${yMid + yOffset} ${xMid - xOffset} ${y1} ${xMid} ${y1} c`, \"h\");\n          if (fillColor) {\n            buffer.push(\"B\");\n          } else {\n            buffer.push(\"S\");\n          }\n          return [points[0].x, points[1].x, points[3].y, points[1].y];\n        }\n      });\n    }\n  }\n}\nclass PolylineAnnotation extends MarkupAnnotation {\n  constructor(params) {\n    super(params);\n    const {\n      dict,\n      xref\n    } = params;\n    this.data.annotationType = AnnotationType.POLYLINE;\n    this.data.hasOwnCanvas = this.data.noRotate;\n    this.data.noHTML = false;\n    this.data.vertices = [];\n    if (!(this instanceof PolygonAnnotation)) {\n      this.setLineEndings(dict.getArray(\"LE\"));\n      this.data.lineEndings = this.lineEndings;\n    }\n    const rawVertices = dict.getArray(\"Vertices\");\n    if (!Array.isArray(rawVertices)) {\n      return;\n    }\n    for (let i = 0, ii = rawVertices.length; i < ii; i += 2) {\n      this.data.vertices.push({\n        x: rawVertices[i],\n        y: rawVertices[i + 1]\n      });\n    }\n    if (!this.appearance) {\n      const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];\n      const strokeAlpha = dict.get(\"CA\");\n      const borderWidth = this.borderStyle.width || 1,\n        borderAdjust = 2 * borderWidth;\n      const bbox = [Infinity, Infinity, -Infinity, -Infinity];\n      for (const vertex of this.data.vertices) {\n        bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust);\n        bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust);\n        bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust);\n        bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust);\n      }\n      if (!Util.intersect(this.rectangle, bbox)) {\n        this.rectangle = bbox;\n      }\n      this._setDefaultAppearance({\n        xref,\n        extra: `${borderWidth} w`,\n        strokeColor,\n        strokeAlpha,\n        pointsCallback: (buffer, points) => {\n          const vertices = this.data.vertices;\n          for (let i = 0, ii = vertices.length; i < ii; i++) {\n            buffer.push(`${vertices[i].x} ${vertices[i].y} ${i === 0 ? \"m\" : \"l\"}`);\n          }\n          buffer.push(\"S\");\n          return [points[0].x, points[1].x, points[3].y, points[1].y];\n        }\n      });\n    }\n  }\n}\nclass PolygonAnnotation extends PolylineAnnotation {\n  constructor(params) {\n    super(params);\n    this.data.annotationType = AnnotationType.POLYGON;\n  }\n}\nclass CaretAnnotation extends MarkupAnnotation {\n  constructor(params) {\n    super(params);\n    this.data.annotationType = AnnotationType.CARET;\n  }\n}\nclass InkAnnotation extends MarkupAnnotation {\n  constructor(params) {\n    super(params);\n    this.data.hasOwnCanvas = this.data.noRotate;\n    this.data.noHTML = false;\n    const {\n      dict,\n      xref\n    } = params;\n    this.data.annotationType = AnnotationType.INK;\n    this.data.inkLists = [];\n    const rawInkLists = dict.getArray(\"InkList\");\n    if (!Array.isArray(rawInkLists)) {\n      return;\n    }\n    for (let i = 0, ii = rawInkLists.length; i < ii; ++i) {\n      this.data.inkLists.push([]);\n      for (let j = 0, jj = rawInkLists[i].length; j < jj; j += 2) {\n        this.data.inkLists[i].push({\n          x: xref.fetchIfRef(rawInkLists[i][j]),\n          y: xref.fetchIfRef(rawInkLists[i][j + 1])\n        });\n      }\n    }\n    if (!this.appearance) {\n      const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];\n      const strokeAlpha = dict.get(\"CA\");\n      const borderWidth = this.borderStyle.width || 1,\n        borderAdjust = 2 * borderWidth;\n      const bbox = [Infinity, Infinity, -Infinity, -Infinity];\n      for (const inkLists of this.data.inkLists) {\n        for (const vertex of inkLists) {\n          bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust);\n          bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust);\n          bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust);\n          bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust);\n        }\n      }\n      if (!Util.intersect(this.rectangle, bbox)) {\n        this.rectangle = bbox;\n      }\n      this._setDefaultAppearance({\n        xref,\n        extra: `${borderWidth} w`,\n        strokeColor,\n        strokeAlpha,\n        pointsCallback: (buffer, points) => {\n          for (const inkList of this.data.inkLists) {\n            for (let i = 0, ii = inkList.length; i < ii; i++) {\n              buffer.push(`${inkList[i].x} ${inkList[i].y} ${i === 0 ? \"m\" : \"l\"}`);\n            }\n            buffer.push(\"S\");\n          }\n          return [points[0].x, points[1].x, points[3].y, points[1].y];\n        }\n      });\n    }\n  }\n  static createNewDict(annotation, xref, {\n    apRef,\n    ap\n  }) {\n    const {\n      color,\n      opacity,\n      paths,\n      outlines,\n      rect,\n      rotation,\n      thickness\n    } = annotation;\n    const ink = new Dict(xref);\n    ink.set(\"Type\", Name.get(\"Annot\"));\n    ink.set(\"Subtype\", Name.get(\"Ink\"));\n    ink.set(\"CreationDate\", `D:${getModificationDate()}`);\n    ink.set(\"Rect\", rect);\n    ink.set(\"InkList\", outlines?.points || paths.map(p => p.points));\n    ink.set(\"F\", 4);\n    ink.set(\"Rotate\", rotation);\n    if (outlines) {\n      ink.set(\"IT\", Name.get(\"InkHighlight\"));\n    }\n    const bs = new Dict(xref);\n    ink.set(\"BS\", bs);\n    bs.set(\"W\", thickness);\n    ink.set(\"C\", Array.from(color, c => c / 255));\n    ink.set(\"CA\", opacity);\n    const n = new Dict(xref);\n    ink.set(\"AP\", n);\n    if (apRef) {\n      n.set(\"N\", apRef);\n    } else {\n      n.set(\"N\", ap);\n    }\n    return ink;\n  }\n  static async createNewAppearanceStream(annotation, xref, params) {\n    if (annotation.outlines) {\n      return this.createNewAppearanceStreamForHighlight(annotation, xref, params);\n    }\n    const {\n      color,\n      rect,\n      paths,\n      thickness,\n      opacity\n    } = annotation;\n    const appearanceBuffer = [`${thickness} w 1 J 1 j`, `${getPdfColor(color, false)}`];\n    if (opacity !== 1) {\n      appearanceBuffer.push(\"/R0 gs\");\n    }\n    const buffer = [];\n    for (const {\n      bezier\n    } of paths) {\n      buffer.length = 0;\n      buffer.push(`${numberToString(bezier[0])} ${numberToString(bezier[1])} m`);\n      if (bezier.length === 2) {\n        buffer.push(`${numberToString(bezier[0])} ${numberToString(bezier[1])} l S`);\n      } else {\n        for (let i = 2, ii = bezier.length; i < ii; i += 6) {\n          const curve = bezier.slice(i, i + 6).map(numberToString).join(\" \");\n          buffer.push(`${curve} c`);\n        }\n        buffer.push(\"S\");\n      }\n      appearanceBuffer.push(buffer.join(\"\\n\"));\n    }\n    const appearance = appearanceBuffer.join(\"\\n\");\n    const appearanceStreamDict = new Dict(xref);\n    appearanceStreamDict.set(\"FormType\", 1);\n    appearanceStreamDict.set(\"Subtype\", Name.get(\"Form\"));\n    appearanceStreamDict.set(\"Type\", Name.get(\"XObject\"));\n    appearanceStreamDict.set(\"BBox\", rect);\n    appearanceStreamDict.set(\"Length\", appearance.length);\n    if (opacity !== 1) {\n      const resources = new Dict(xref);\n      const extGState = new Dict(xref);\n      const r0 = new Dict(xref);\n      r0.set(\"CA\", opacity);\n      r0.set(\"Type\", Name.get(\"ExtGState\"));\n      extGState.set(\"R0\", r0);\n      resources.set(\"ExtGState\", extGState);\n      appearanceStreamDict.set(\"Resources\", resources);\n    }\n    const ap = new StringStream(appearance);\n    ap.dict = appearanceStreamDict;\n    return ap;\n  }\n  static async createNewAppearanceStreamForHighlight(annotation, xref, params) {\n    const {\n      color,\n      rect,\n      outlines: {\n        outline\n      },\n      opacity\n    } = annotation;\n    const appearanceBuffer = [`${getPdfColor(color, true)}`, \"/R0 gs\"];\n    appearanceBuffer.push(`${numberToString(outline[4])} ${numberToString(outline[5])} m`);\n    for (let i = 6, ii = outline.length; i < ii; i += 6) {\n      if (isNaN(outline[i]) || outline[i] === null) {\n        appearanceBuffer.push(`${numberToString(outline[i + 4])} ${numberToString(outline[i + 5])} l`);\n      } else {\n        const curve = outline.slice(i, i + 6).map(numberToString).join(\" \");\n        appearanceBuffer.push(`${curve} c`);\n      }\n    }\n    appearanceBuffer.push(\"h f\");\n    const appearance = appearanceBuffer.join(\"\\n\");\n    const appearanceStreamDict = new Dict(xref);\n    appearanceStreamDict.set(\"FormType\", 1);\n    appearanceStreamDict.set(\"Subtype\", Name.get(\"Form\"));\n    appearanceStreamDict.set(\"Type\", Name.get(\"XObject\"));\n    appearanceStreamDict.set(\"BBox\", rect);\n    appearanceStreamDict.set(\"Length\", appearance.length);\n    const resources = new Dict(xref);\n    const extGState = new Dict(xref);\n    resources.set(\"ExtGState\", extGState);\n    appearanceStreamDict.set(\"Resources\", resources);\n    const r0 = new Dict(xref);\n    extGState.set(\"R0\", r0);\n    r0.set(\"BM\", Name.get(\"Multiply\"));\n    if (opacity !== 1) {\n      r0.set(\"ca\", opacity);\n      r0.set(\"Type\", Name.get(\"ExtGState\"));\n    }\n    const ap = new StringStream(appearance);\n    ap.dict = appearanceStreamDict;\n    return ap;\n  }\n}\nclass HighlightAnnotation extends MarkupAnnotation {\n  constructor(params) {\n    super(params);\n    const {\n      dict,\n      xref\n    } = params;\n    this.data.annotationType = AnnotationType.HIGHLIGHT;\n    const quadPoints = this.data.quadPoints = getQuadPoints(dict, null);\n    if (quadPoints) {\n      const resources = this.appearance?.dict.get(\"Resources\");\n      if (!this.appearance || !resources?.has(\"ExtGState\")) {\n        if (this.appearance) {\n          warn(\"HighlightAnnotation - ignoring built-in appearance stream.\");\n        }\n        const fillColor = this.color ? getPdfColorArray(this.color) : [1, 1, 0];\n        const fillAlpha = dict.get(\"CA\");\n        this._setDefaultAppearance({\n          xref,\n          fillColor,\n          blendMode: \"Multiply\",\n          fillAlpha,\n          pointsCallback: (buffer, points) => {\n            buffer.push(`${points[0].x} ${points[0].y} m`, `${points[1].x} ${points[1].y} l`, `${points[3].x} ${points[3].y} l`, `${points[2].x} ${points[2].y} l`, \"f\");\n            return [points[0].x, points[1].x, points[3].y, points[1].y];\n          }\n        });\n      }\n    } else {\n      this.data.popupRef = null;\n    }\n  }\n  static createNewDict(annotation, xref, {\n    apRef,\n    ap\n  }) {\n    const {\n      color,\n      opacity,\n      rect,\n      rotation,\n      user,\n      quadPoints\n    } = annotation;\n    const highlight = new Dict(xref);\n    highlight.set(\"Type\", Name.get(\"Annot\"));\n    highlight.set(\"Subtype\", Name.get(\"Highlight\"));\n    highlight.set(\"CreationDate\", `D:${getModificationDate()}`);\n    highlight.set(\"Rect\", rect);\n    highlight.set(\"F\", 4);\n    highlight.set(\"Border\", [0, 0, 0]);\n    highlight.set(\"Rotate\", rotation);\n    highlight.set(\"QuadPoints\", quadPoints);\n    highlight.set(\"C\", Array.from(color, c => c / 255));\n    highlight.set(\"CA\", opacity);\n    if (user) {\n      highlight.set(\"T\", isAscii(user) ? user : stringToUTF16String(user, true));\n    }\n    if (apRef || ap) {\n      const n = new Dict(xref);\n      highlight.set(\"AP\", n);\n      n.set(\"N\", apRef || ap);\n    }\n    return highlight;\n  }\n  static async createNewAppearanceStream(annotation, xref, params) {\n    const {\n      color,\n      rect,\n      outlines,\n      opacity\n    } = annotation;\n    const appearanceBuffer = [`${getPdfColor(color, true)}`, \"/R0 gs\"];\n    const buffer = [];\n    for (const outline of outlines) {\n      buffer.length = 0;\n      buffer.push(`${numberToString(outline[0])} ${numberToString(outline[1])} m`);\n      for (let i = 2, ii = outline.length; i < ii; i += 2) {\n        buffer.push(`${numberToString(outline[i])} ${numberToString(outline[i + 1])} l`);\n      }\n      buffer.push(\"h\");\n      appearanceBuffer.push(buffer.join(\"\\n\"));\n    }\n    appearanceBuffer.push(\"f*\");\n    const appearance = appearanceBuffer.join(\"\\n\");\n    const appearanceStreamDict = new Dict(xref);\n    appearanceStreamDict.set(\"FormType\", 1);\n    appearanceStreamDict.set(\"Subtype\", Name.get(\"Form\"));\n    appearanceStreamDict.set(\"Type\", Name.get(\"XObject\"));\n    appearanceStreamDict.set(\"BBox\", rect);\n    appearanceStreamDict.set(\"Length\", appearance.length);\n    const resources = new Dict(xref);\n    const extGState = new Dict(xref);\n    resources.set(\"ExtGState\", extGState);\n    appearanceStreamDict.set(\"Resources\", resources);\n    const r0 = new Dict(xref);\n    extGState.set(\"R0\", r0);\n    r0.set(\"BM\", Name.get(\"Multiply\"));\n    if (opacity !== 1) {\n      r0.set(\"ca\", opacity);\n      r0.set(\"Type\", Name.get(\"ExtGState\"));\n    }\n    const ap = new StringStream(appearance);\n    ap.dict = appearanceStreamDict;\n    return ap;\n  }\n}\nclass UnderlineAnnotation extends MarkupAnnotation {\n  constructor(params) {\n    super(params);\n    const {\n      dict,\n      xref\n    } = params;\n    this.data.annotationType = AnnotationType.UNDERLINE;\n    const quadPoints = this.data.quadPoints = getQuadPoints(dict, null);\n    if (quadPoints) {\n      if (!this.appearance) {\n        const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];\n        const strokeAlpha = dict.get(\"CA\");\n        this._setDefaultAppearance({\n          xref,\n          extra: \"[] 0 d 0.571 w\",\n          strokeColor,\n          strokeAlpha,\n          pointsCallback: (buffer, points) => {\n            buffer.push(`${points[2].x} ${points[2].y + 1.3} m`, `${points[3].x} ${points[3].y + 1.3} l`, \"S\");\n            return [points[0].x, points[1].x, points[3].y, points[1].y];\n          }\n        });\n      }\n    } else {\n      this.data.popupRef = null;\n    }\n  }\n}\nclass SquigglyAnnotation extends MarkupAnnotation {\n  constructor(params) {\n    super(params);\n    const {\n      dict,\n      xref\n    } = params;\n    this.data.annotationType = AnnotationType.SQUIGGLY;\n    const quadPoints = this.data.quadPoints = getQuadPoints(dict, null);\n    if (quadPoints) {\n      if (!this.appearance) {\n        const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];\n        const strokeAlpha = dict.get(\"CA\");\n        this._setDefaultAppearance({\n          xref,\n          extra: \"[] 0 d 1 w\",\n          strokeColor,\n          strokeAlpha,\n          pointsCallback: (buffer, points) => {\n            const dy = (points[0].y - points[2].y) / 6;\n            let shift = dy;\n            let x = points[2].x;\n            const y = points[2].y;\n            const xEnd = points[3].x;\n            buffer.push(`${x} ${y + shift} m`);\n            do {\n              x += 2;\n              shift = shift === 0 ? dy : 0;\n              buffer.push(`${x} ${y + shift} l`);\n            } while (x < xEnd);\n            buffer.push(\"S\");\n            return [points[2].x, xEnd, y - 2 * dy, y + 2 * dy];\n          }\n        });\n      }\n    } else {\n      this.data.popupRef = null;\n    }\n  }\n}\nclass StrikeOutAnnotation extends MarkupAnnotation {\n  constructor(params) {\n    super(params);\n    const {\n      dict,\n      xref\n    } = params;\n    this.data.annotationType = AnnotationType.STRIKEOUT;\n    const quadPoints = this.data.quadPoints = getQuadPoints(dict, null);\n    if (quadPoints) {\n      if (!this.appearance) {\n        const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];\n        const strokeAlpha = dict.get(\"CA\");\n        this._setDefaultAppearance({\n          xref,\n          extra: \"[] 0 d 1 w\",\n          strokeColor,\n          strokeAlpha,\n          pointsCallback: (buffer, points) => {\n            buffer.push(`${(points[0].x + points[2].x) / 2} ` + `${(points[0].y + points[2].y) / 2} m`, `${(points[1].x + points[3].x) / 2} ` + `${(points[1].y + points[3].y) / 2} l`, \"S\");\n            return [points[0].x, points[1].x, points[3].y, points[1].y];\n          }\n        });\n      }\n    } else {\n      this.data.popupRef = null;\n    }\n  }\n}\nclass StampAnnotation extends MarkupAnnotation {\n  constructor(params) {\n    super(params);\n    this.data.annotationType = AnnotationType.STAMP;\n    this.data.hasOwnCanvas = this.data.noRotate;\n    this.data.noHTML = false;\n  }\n  static async createImage(bitmap, xref) {\n    const {\n      width,\n      height\n    } = bitmap;\n    const canvas = new OffscreenCanvas(width, height);\n    const ctx = canvas.getContext(\"2d\", {\n      alpha: true\n    });\n    ctx.drawImage(bitmap, 0, 0);\n    const data = ctx.getImageData(0, 0, width, height).data;\n    const buf32 = new Uint32Array(data.buffer);\n    const hasAlpha = buf32.some(FeatureTest.isLittleEndian ? x => x >>> 24 !== 0xff : x => (x & 0xff) !== 0xff);\n    if (hasAlpha) {\n      ctx.fillStyle = \"white\";\n      ctx.fillRect(0, 0, width, height);\n      ctx.drawImage(bitmap, 0, 0);\n    }\n    const jpegBufferPromise = canvas.convertToBlob({\n      type: \"image/jpeg\",\n      quality: 1\n    }).then(blob => blob.arrayBuffer());\n    const xobjectName = Name.get(\"XObject\");\n    const imageName = Name.get(\"Image\");\n    const image = new Dict(xref);\n    image.set(\"Type\", xobjectName);\n    image.set(\"Subtype\", imageName);\n    image.set(\"BitsPerComponent\", 8);\n    image.set(\"ColorSpace\", Name.get(\"DeviceRGB\"));\n    image.set(\"Filter\", Name.get(\"DCTDecode\"));\n    image.set(\"BBox\", [0, 0, width, height]);\n    image.set(\"Width\", width);\n    image.set(\"Height\", height);\n    let smaskStream = null;\n    if (hasAlpha) {\n      const alphaBuffer = new Uint8Array(buf32.length);\n      if (FeatureTest.isLittleEndian) {\n        for (let i = 0, ii = buf32.length; i < ii; i++) {\n          alphaBuffer[i] = buf32[i] >>> 24;\n        }\n      } else {\n        for (let i = 0, ii = buf32.length; i < ii; i++) {\n          alphaBuffer[i] = buf32[i] & 0xff;\n        }\n      }\n      const smask = new Dict(xref);\n      smask.set(\"Type\", xobjectName);\n      smask.set(\"Subtype\", imageName);\n      smask.set(\"BitsPerComponent\", 8);\n      smask.set(\"ColorSpace\", Name.get(\"DeviceGray\"));\n      smask.set(\"Width\", width);\n      smask.set(\"Height\", height);\n      smaskStream = new Stream(alphaBuffer, 0, 0, smask);\n    }\n    const imageStream = new Stream(await jpegBufferPromise, 0, 0, image);\n    return {\n      imageStream,\n      smaskStream,\n      width,\n      height\n    };\n  }\n  static createNewDict(annotation, xref, {\n    apRef,\n    ap\n  }) {\n    const {\n      rect,\n      rotation,\n      user\n    } = annotation;\n    const stamp = new Dict(xref);\n    stamp.set(\"Type\", Name.get(\"Annot\"));\n    stamp.set(\"Subtype\", Name.get(\"Stamp\"));\n    stamp.set(\"CreationDate\", `D:${getModificationDate()}`);\n    stamp.set(\"Rect\", rect);\n    stamp.set(\"F\", 4);\n    stamp.set(\"Border\", [0, 0, 0]);\n    stamp.set(\"Rotate\", rotation);\n    if (user) {\n      stamp.set(\"T\", isAscii(user) ? user : stringToUTF16String(user, true));\n    }\n    if (apRef || ap) {\n      const n = new Dict(xref);\n      stamp.set(\"AP\", n);\n      if (apRef) {\n        n.set(\"N\", apRef);\n      } else {\n        n.set(\"N\", ap);\n      }\n    }\n    return stamp;\n  }\n  static async createNewAppearanceStream(annotation, xref, params) {\n    const {\n      rotation\n    } = annotation;\n    const {\n      imageRef,\n      width,\n      height\n    } = params.image;\n    const resources = new Dict(xref);\n    const xobject = new Dict(xref);\n    resources.set(\"XObject\", xobject);\n    xobject.set(\"Im0\", imageRef);\n    const appearance = `q ${width} 0 0 ${height} 0 0 cm /Im0 Do Q`;\n    const appearanceStreamDict = new Dict(xref);\n    appearanceStreamDict.set(\"FormType\", 1);\n    appearanceStreamDict.set(\"Subtype\", Name.get(\"Form\"));\n    appearanceStreamDict.set(\"Type\", Name.get(\"XObject\"));\n    appearanceStreamDict.set(\"BBox\", [0, 0, width, height]);\n    appearanceStreamDict.set(\"Resources\", resources);\n    if (rotation) {\n      const matrix = getRotationMatrix(rotation, width, height);\n      appearanceStreamDict.set(\"Matrix\", matrix);\n    }\n    const ap = new StringStream(appearance);\n    ap.dict = appearanceStreamDict;\n    return ap;\n  }\n}\nclass FileAttachmentAnnotation extends MarkupAnnotation {\n  constructor(params) {\n    super(params);\n    const {\n      dict,\n      xref\n    } = params;\n    const file = new FileSpec(dict.get(\"FS\"), xref);\n    this.data.annotationType = AnnotationType.FILEATTACHMENT;\n    this.data.hasOwnCanvas = this.data.noRotate;\n    this.data.noHTML = false;\n    this.data.file = file.serializable;\n    const name = dict.get(\"Name\");\n    this.data.name = name instanceof Name ? stringToPDFString(name.name) : \"PushPin\";\n    const fillAlpha = dict.get(\"ca\");\n    this.data.fillAlpha = typeof fillAlpha === \"number\" && fillAlpha >= 0 && fillAlpha <= 1 ? fillAlpha : null;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/dataset_reader.js\n\n\n\nfunction decodeString(str) {\n  try {\n    return stringToUTF8String(str);\n  } catch (ex) {\n    warn(`UTF-8 decoding failed: \"${ex}\".`);\n    return str;\n  }\n}\nclass DatasetXMLParser extends SimpleXMLParser {\n  constructor(options) {\n    super(options);\n    this.node = null;\n  }\n  onEndElement(name) {\n    const node = super.onEndElement(name);\n    if (node && name === \"xfa:datasets\") {\n      this.node = node;\n      throw new Error(\"Aborting DatasetXMLParser.\");\n    }\n  }\n}\nclass DatasetReader {\n  constructor(data) {\n    if (data.datasets) {\n      this.node = new SimpleXMLParser({\n        hasAttributes: true\n      }).parseFromString(data.datasets).documentElement;\n    } else {\n      const parser = new DatasetXMLParser({\n        hasAttributes: true\n      });\n      try {\n        parser.parseFromString(data[\"xdp:xdp\"]);\n      } catch {}\n      this.node = parser.node;\n    }\n  }\n  getValue(path) {\n    if (!this.node || !path) {\n      return \"\";\n    }\n    const node = this.node.searchNode(parseXFAPath(path), 0);\n    if (!node) {\n      return \"\";\n    }\n    const first = node.firstChild;\n    if (first?.nodeName === \"value\") {\n      return node.children.map(child => decodeString(child.textContent));\n    }\n    return decodeString(node.textContent);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/xref.js\n\n\n\n\n\n\nclass XRef {\n  #firstXRefStmPos = null;\n  constructor(stream, pdfManager) {\n    this.stream = stream;\n    this.pdfManager = pdfManager;\n    this.entries = [];\n    this._xrefStms = new Set();\n    this._cacheMap = new Map();\n    this._pendingRefs = new RefSet();\n    this._newPersistentRefNum = null;\n    this._newTemporaryRefNum = null;\n    this._persistentRefsCache = null;\n  }\n  getNewPersistentRef(obj) {\n    if (this._newPersistentRefNum === null) {\n      this._newPersistentRefNum = this.entries.length || 1;\n    }\n    const num = this._newPersistentRefNum++;\n    this._cacheMap.set(num, obj);\n    return Ref.get(num, 0);\n  }\n  getNewTemporaryRef() {\n    if (this._newTemporaryRefNum === null) {\n      this._newTemporaryRefNum = this.entries.length || 1;\n      if (this._newPersistentRefNum) {\n        this._persistentRefsCache = new Map();\n        for (let i = this._newTemporaryRefNum; i < this._newPersistentRefNum; i++) {\n          this._persistentRefsCache.set(i, this._cacheMap.get(i));\n          this._cacheMap.delete(i);\n        }\n      }\n    }\n    return Ref.get(this._newTemporaryRefNum++, 0);\n  }\n  resetNewTemporaryRef() {\n    this._newTemporaryRefNum = null;\n    if (this._persistentRefsCache) {\n      for (const [num, obj] of this._persistentRefsCache) {\n        this._cacheMap.set(num, obj);\n      }\n    }\n    this._persistentRefsCache = null;\n  }\n  setStartXRef(startXRef) {\n    this.startXRefQueue = [startXRef];\n  }\n  parse(recoveryMode = false) {\n    let trailerDict;\n    if (!recoveryMode) {\n      trailerDict = this.readXRef();\n    } else {\n      warn(\"Indexing all PDF objects\");\n      trailerDict = this.indexObjects();\n    }\n    trailerDict.assignXref(this);\n    this.trailer = trailerDict;\n    let encrypt;\n    try {\n      encrypt = trailerDict.get(\"Encrypt\");\n    } catch (ex) {\n      if (ex instanceof MissingDataException) {\n        throw ex;\n      }\n      warn(`XRef.parse - Invalid \"Encrypt\" reference: \"${ex}\".`);\n    }\n    if (encrypt instanceof Dict) {\n      const ids = trailerDict.get(\"ID\");\n      const fileId = ids?.length ? ids[0] : \"\";\n      encrypt.suppressEncryption = true;\n      this.encrypt = new CipherTransformFactory(encrypt, fileId, this.pdfManager.password);\n    }\n    let root;\n    try {\n      root = trailerDict.get(\"Root\");\n    } catch (ex) {\n      if (ex instanceof MissingDataException) {\n        throw ex;\n      }\n      warn(`XRef.parse - Invalid \"Root\" reference: \"${ex}\".`);\n    }\n    if (root instanceof Dict) {\n      try {\n        const pages = root.get(\"Pages\");\n        if (pages instanceof Dict) {\n          this.root = root;\n          return;\n        }\n      } catch (ex) {\n        if (ex instanceof MissingDataException) {\n          throw ex;\n        }\n        warn(`XRef.parse - Invalid \"Pages\" reference: \"${ex}\".`);\n      }\n    }\n    if (!recoveryMode) {\n      throw new XRefParseException();\n    }\n    throw new InvalidPDFException(\"Invalid Root reference.\");\n  }\n  processXRefTable(parser) {\n    if (!(\"tableState\" in this)) {\n      this.tableState = {\n        entryNum: 0,\n        streamPos: parser.lexer.stream.pos,\n        parserBuf1: parser.buf1,\n        parserBuf2: parser.buf2\n      };\n    }\n    const obj = this.readXRefTable(parser);\n    if (!isCmd(obj, \"trailer\")) {\n      throw new FormatError(\"Invalid XRef table: could not find trailer dictionary\");\n    }\n    let dict = parser.getObj();\n    if (!(dict instanceof Dict) && dict.dict) {\n      dict = dict.dict;\n    }\n    if (!(dict instanceof Dict)) {\n      throw new FormatError(\"Invalid XRef table: could not parse trailer dictionary\");\n    }\n    delete this.tableState;\n    return dict;\n  }\n  readXRefTable(parser) {\n    const stream = parser.lexer.stream;\n    const tableState = this.tableState;\n    stream.pos = tableState.streamPos;\n    parser.buf1 = tableState.parserBuf1;\n    parser.buf2 = tableState.parserBuf2;\n    let obj;\n    while (true) {\n      if (!(\"firstEntryNum\" in tableState) || !(\"entryCount\" in tableState)) {\n        if (isCmd(obj = parser.getObj(), \"trailer\")) {\n          break;\n        }\n        tableState.firstEntryNum = obj;\n        tableState.entryCount = parser.getObj();\n      }\n      let first = tableState.firstEntryNum;\n      const count = tableState.entryCount;\n      if (!Number.isInteger(first) || !Number.isInteger(count)) {\n        throw new FormatError(\"Invalid XRef table: wrong types in subsection header\");\n      }\n      for (let i = tableState.entryNum; i < count; i++) {\n        tableState.streamPos = stream.pos;\n        tableState.entryNum = i;\n        tableState.parserBuf1 = parser.buf1;\n        tableState.parserBuf2 = parser.buf2;\n        const entry = {};\n        entry.offset = parser.getObj();\n        entry.gen = parser.getObj();\n        const type = parser.getObj();\n        if (type instanceof Cmd) {\n          switch (type.cmd) {\n            case \"f\":\n              entry.free = true;\n              break;\n            case \"n\":\n              entry.uncompressed = true;\n              break;\n          }\n        }\n        if (!Number.isInteger(entry.offset) || !Number.isInteger(entry.gen) || !(entry.free || entry.uncompressed)) {\n          throw new FormatError(`Invalid entry in XRef subsection: ${first}, ${count}`);\n        }\n        if (i === 0 && entry.free && first === 1) {\n          first = 0;\n        }\n        if (!this.entries[i + first]) {\n          this.entries[i + first] = entry;\n        }\n      }\n      tableState.entryNum = 0;\n      tableState.streamPos = stream.pos;\n      tableState.parserBuf1 = parser.buf1;\n      tableState.parserBuf2 = parser.buf2;\n      delete tableState.firstEntryNum;\n      delete tableState.entryCount;\n    }\n    if (this.entries[0] && !this.entries[0].free) {\n      throw new FormatError(\"Invalid XRef table: unexpected first object\");\n    }\n    return obj;\n  }\n  processXRefStream(stream) {\n    if (!(\"streamState\" in this)) {\n      const streamParameters = stream.dict;\n      const byteWidths = streamParameters.get(\"W\");\n      let range = streamParameters.get(\"Index\");\n      if (!range) {\n        range = [0, streamParameters.get(\"Size\")];\n      }\n      this.streamState = {\n        entryRanges: range,\n        byteWidths,\n        entryNum: 0,\n        streamPos: stream.pos\n      };\n    }\n    this.readXRefStream(stream);\n    delete this.streamState;\n    return stream.dict;\n  }\n  readXRefStream(stream) {\n    const streamState = this.streamState;\n    stream.pos = streamState.streamPos;\n    const [typeFieldWidth, offsetFieldWidth, generationFieldWidth] = streamState.byteWidths;\n    const entryRanges = streamState.entryRanges;\n    while (entryRanges.length > 0) {\n      const [first, n] = entryRanges;\n      if (!Number.isInteger(first) || !Number.isInteger(n)) {\n        throw new FormatError(`Invalid XRef range fields: ${first}, ${n}`);\n      }\n      if (!Number.isInteger(typeFieldWidth) || !Number.isInteger(offsetFieldWidth) || !Number.isInteger(generationFieldWidth)) {\n        throw new FormatError(`Invalid XRef entry fields length: ${first}, ${n}`);\n      }\n      for (let i = streamState.entryNum; i < n; ++i) {\n        streamState.entryNum = i;\n        streamState.streamPos = stream.pos;\n        let type = 0,\n          offset = 0,\n          generation = 0;\n        for (let j = 0; j < typeFieldWidth; ++j) {\n          const typeByte = stream.getByte();\n          if (typeByte === -1) {\n            throw new FormatError(\"Invalid XRef byteWidths 'type'.\");\n          }\n          type = type << 8 | typeByte;\n        }\n        if (typeFieldWidth === 0) {\n          type = 1;\n        }\n        for (let j = 0; j < offsetFieldWidth; ++j) {\n          const offsetByte = stream.getByte();\n          if (offsetByte === -1) {\n            throw new FormatError(\"Invalid XRef byteWidths 'offset'.\");\n          }\n          offset = offset << 8 | offsetByte;\n        }\n        for (let j = 0; j < generationFieldWidth; ++j) {\n          const generationByte = stream.getByte();\n          if (generationByte === -1) {\n            throw new FormatError(\"Invalid XRef byteWidths 'generation'.\");\n          }\n          generation = generation << 8 | generationByte;\n        }\n        const entry = {};\n        entry.offset = offset;\n        entry.gen = generation;\n        switch (type) {\n          case 0:\n            entry.free = true;\n            break;\n          case 1:\n            entry.uncompressed = true;\n            break;\n          case 2:\n            break;\n          default:\n            throw new FormatError(`Invalid XRef entry type: ${type}`);\n        }\n        if (!this.entries[first + i]) {\n          this.entries[first + i] = entry;\n        }\n      }\n      streamState.entryNum = 0;\n      streamState.streamPos = stream.pos;\n      entryRanges.splice(0, 2);\n    }\n  }\n  indexObjects() {\n    const TAB = 0x9,\n      LF = 0xa,\n      CR = 0xd,\n      SPACE = 0x20;\n    const PERCENT = 0x25,\n      LT = 0x3c;\n    function readToken(data, offset) {\n      let token = \"\",\n        ch = data[offset];\n      while (ch !== LF && ch !== CR && ch !== LT) {\n        if (++offset >= data.length) {\n          break;\n        }\n        token += String.fromCharCode(ch);\n        ch = data[offset];\n      }\n      return token;\n    }\n    function skipUntil(data, offset, what) {\n      const length = what.length,\n        dataLength = data.length;\n      let skipped = 0;\n      while (offset < dataLength) {\n        let i = 0;\n        while (i < length && data[offset + i] === what[i]) {\n          ++i;\n        }\n        if (i >= length) {\n          break;\n        }\n        offset++;\n        skipped++;\n      }\n      return skipped;\n    }\n    const gEndobjRegExp = /\\b(endobj|\\d+\\s+\\d+\\s+obj|xref|trailer\\s*<<)\\b/g;\n    const gStartxrefRegExp = /\\b(startxref|\\d+\\s+\\d+\\s+obj)\\b/g;\n    const objRegExp = /^(\\d+)\\s+(\\d+)\\s+obj\\b/;\n    const trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);\n    const startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);\n    const xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);\n    this.entries.length = 0;\n    this._cacheMap.clear();\n    const stream = this.stream;\n    stream.pos = 0;\n    const buffer = stream.getBytes(),\n      bufferStr = bytesToString(buffer),\n      length = buffer.length;\n    let position = stream.start;\n    const trailers = [],\n      xrefStms = [];\n    while (position < length) {\n      let ch = buffer[position];\n      if (ch === TAB || ch === LF || ch === CR || ch === SPACE) {\n        ++position;\n        continue;\n      }\n      if (ch === PERCENT) {\n        do {\n          ++position;\n          if (position >= length) {\n            break;\n          }\n          ch = buffer[position];\n        } while (ch !== LF && ch !== CR);\n        continue;\n      }\n      const token = readToken(buffer, position);\n      let m;\n      if (token.startsWith(\"xref\") && (token.length === 4 || /\\s/.test(token[4]))) {\n        position += skipUntil(buffer, position, trailerBytes);\n        trailers.push(position);\n        position += skipUntil(buffer, position, startxrefBytes);\n      } else if (m = objRegExp.exec(token)) {\n        const num = m[1] | 0,\n          gen = m[2] | 0;\n        const startPos = position + token.length;\n        let contentLength,\n          updateEntries = false;\n        if (!this.entries[num]) {\n          updateEntries = true;\n        } else if (this.entries[num].gen === gen) {\n          try {\n            const parser = new Parser({\n              lexer: new Lexer(stream.makeSubStream(startPos))\n            });\n            parser.getObj();\n            updateEntries = true;\n          } catch (ex) {\n            if (ex instanceof ParserEOFException) {\n              warn(`indexObjects -- checking object (${token}): \"${ex}\".`);\n            } else {\n              updateEntries = true;\n            }\n          }\n        }\n        if (updateEntries) {\n          this.entries[num] = {\n            offset: position - stream.start,\n            gen,\n            uncompressed: true\n          };\n        }\n        gEndobjRegExp.lastIndex = startPos;\n        const match = gEndobjRegExp.exec(bufferStr);\n        if (match) {\n          const endPos = gEndobjRegExp.lastIndex + 1;\n          contentLength = endPos - position;\n          if (match[1] !== \"endobj\") {\n            warn(`indexObjects: Found \"${match[1]}\" inside of another \"obj\", ` + 'caused by missing \"endobj\" -- trying to recover.');\n            contentLength -= match[1].length + 1;\n          }\n        } else {\n          contentLength = length - position;\n        }\n        const content = buffer.subarray(position, position + contentLength);\n        const xrefTagOffset = skipUntil(content, 0, xrefBytes);\n        if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {\n          xrefStms.push(position - stream.start);\n          this._xrefStms.add(position - stream.start);\n        }\n        position += contentLength;\n      } else if (token.startsWith(\"trailer\") && (token.length === 7 || /\\s/.test(token[7]))) {\n        trailers.push(position);\n        const startPos = position + token.length;\n        let contentLength;\n        gStartxrefRegExp.lastIndex = startPos;\n        const match = gStartxrefRegExp.exec(bufferStr);\n        if (match) {\n          const endPos = gStartxrefRegExp.lastIndex + 1;\n          contentLength = endPos - position;\n          if (match[1] !== \"startxref\") {\n            warn(`indexObjects: Found \"${match[1]}\" after \"trailer\", ` + 'caused by missing \"startxref\" -- trying to recover.');\n            contentLength -= match[1].length + 1;\n          }\n        } else {\n          contentLength = length - position;\n        }\n        position += contentLength;\n      } else {\n        position += token.length + 1;\n      }\n    }\n    for (const xrefStm of xrefStms) {\n      this.startXRefQueue.push(xrefStm);\n      this.readXRef(true);\n    }\n    const trailerDicts = [];\n    let isEncrypted = false;\n    for (const trailer of trailers) {\n      stream.pos = trailer;\n      const parser = new Parser({\n        lexer: new Lexer(stream),\n        xref: this,\n        allowStreams: true,\n        recoveryMode: true\n      });\n      const obj = parser.getObj();\n      if (!isCmd(obj, \"trailer\")) {\n        continue;\n      }\n      const dict = parser.getObj();\n      if (!(dict instanceof Dict)) {\n        continue;\n      }\n      trailerDicts.push(dict);\n      if (dict.has(\"Encrypt\")) {\n        isEncrypted = true;\n      }\n    }\n    let trailerDict, trailerError;\n    for (const dict of [...trailerDicts, \"genFallback\", ...trailerDicts]) {\n      if (dict === \"genFallback\") {\n        if (!trailerError) {\n          break;\n        }\n        this._generationFallback = true;\n        continue;\n      }\n      let validPagesDict = false;\n      try {\n        const rootDict = dict.get(\"Root\");\n        if (!(rootDict instanceof Dict)) {\n          continue;\n        }\n        const pagesDict = rootDict.get(\"Pages\");\n        if (!(pagesDict instanceof Dict)) {\n          continue;\n        }\n        const pagesCount = pagesDict.get(\"Count\");\n        if (Number.isInteger(pagesCount)) {\n          validPagesDict = true;\n        }\n      } catch (ex) {\n        trailerError = ex;\n        continue;\n      }\n      if (validPagesDict && (!isEncrypted || dict.has(\"Encrypt\")) && dict.has(\"ID\")) {\n        return dict;\n      }\n      trailerDict = dict;\n    }\n    if (trailerDict) {\n      return trailerDict;\n    }\n    if (this.topDict) {\n      return this.topDict;\n    }\n    throw new InvalidPDFException(\"Invalid PDF structure.\");\n  }\n  readXRef(recoveryMode = false) {\n    const stream = this.stream;\n    const startXRefParsedCache = new Set();\n    while (this.startXRefQueue.length) {\n      try {\n        const startXRef = this.startXRefQueue[0];\n        if (startXRefParsedCache.has(startXRef)) {\n          warn(\"readXRef - skipping XRef table since it was already parsed.\");\n          this.startXRefQueue.shift();\n          continue;\n        }\n        startXRefParsedCache.add(startXRef);\n        stream.pos = startXRef + stream.start;\n        const parser = new Parser({\n          lexer: new Lexer(stream),\n          xref: this,\n          allowStreams: true\n        });\n        let obj = parser.getObj();\n        let dict;\n        if (isCmd(obj, \"xref\")) {\n          dict = this.processXRefTable(parser);\n          if (!this.topDict) {\n            this.topDict = dict;\n          }\n          obj = dict.get(\"XRefStm\");\n          if (Number.isInteger(obj) && !this._xrefStms.has(obj)) {\n            this._xrefStms.add(obj);\n            this.startXRefQueue.push(obj);\n            this.#firstXRefStmPos ??= obj;\n          }\n        } else if (Number.isInteger(obj)) {\n          if (!Number.isInteger(parser.getObj()) || !isCmd(parser.getObj(), \"obj\") || !((obj = parser.getObj()) instanceof BaseStream)) {\n            throw new FormatError(\"Invalid XRef stream\");\n          }\n          dict = this.processXRefStream(obj);\n          if (!this.topDict) {\n            this.topDict = dict;\n          }\n          if (!dict) {\n            throw new FormatError(\"Failed to read XRef stream\");\n          }\n        } else {\n          throw new FormatError(\"Invalid XRef stream header\");\n        }\n        obj = dict.get(\"Prev\");\n        if (Number.isInteger(obj)) {\n          this.startXRefQueue.push(obj);\n        } else if (obj instanceof Ref) {\n          this.startXRefQueue.push(obj.num);\n        }\n      } catch (e) {\n        if (e instanceof MissingDataException) {\n          throw e;\n        }\n        info(\"(while reading XRef): \" + e);\n      }\n      this.startXRefQueue.shift();\n    }\n    if (this.topDict) {\n      return this.topDict;\n    }\n    if (recoveryMode) {\n      return undefined;\n    }\n    throw new XRefParseException();\n  }\n  get lastXRefStreamPos() {\n    return this.#firstXRefStmPos ?? (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null);\n  }\n  getEntry(i) {\n    const xrefEntry = this.entries[i];\n    if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {\n      return xrefEntry;\n    }\n    return null;\n  }\n  fetchIfRef(obj, suppressEncryption = false) {\n    if (obj instanceof Ref) {\n      return this.fetch(obj, suppressEncryption);\n    }\n    return obj;\n  }\n  fetch(ref, suppressEncryption = false) {\n    if (!(ref instanceof Ref)) {\n      throw new Error(\"ref object is not a reference\");\n    }\n    const num = ref.num;\n    const cacheEntry = this._cacheMap.get(num);\n    if (cacheEntry !== undefined) {\n      if (cacheEntry instanceof Dict && !cacheEntry.objId) {\n        cacheEntry.objId = ref.toString();\n      }\n      return cacheEntry;\n    }\n    let xrefEntry = this.getEntry(num);\n    if (xrefEntry === null) {\n      this._cacheMap.set(num, xrefEntry);\n      return xrefEntry;\n    }\n    if (this._pendingRefs.has(ref)) {\n      this._pendingRefs.remove(ref);\n      warn(`Ignoring circular reference: ${ref}.`);\n      return CIRCULAR_REF;\n    }\n    this._pendingRefs.put(ref);\n    try {\n      xrefEntry = xrefEntry.uncompressed ? this.fetchUncompressed(ref, xrefEntry, suppressEncryption) : this.fetchCompressed(ref, xrefEntry, suppressEncryption);\n      this._pendingRefs.remove(ref);\n    } catch (ex) {\n      this._pendingRefs.remove(ref);\n      throw ex;\n    }\n    if (xrefEntry instanceof Dict) {\n      xrefEntry.objId = ref.toString();\n    } else if (xrefEntry instanceof BaseStream) {\n      xrefEntry.dict.objId = ref.toString();\n    }\n    return xrefEntry;\n  }\n  fetchUncompressed(ref, xrefEntry, suppressEncryption = false) {\n    const gen = ref.gen;\n    let num = ref.num;\n    if (xrefEntry.gen !== gen) {\n      const msg = `Inconsistent generation in XRef: ${ref}`;\n      if (this._generationFallback && xrefEntry.gen < gen) {\n        warn(msg);\n        return this.fetchUncompressed(Ref.get(num, xrefEntry.gen), xrefEntry, suppressEncryption);\n      }\n      throw new XRefEntryException(msg);\n    }\n    const stream = this.stream.makeSubStream(xrefEntry.offset + this.stream.start);\n    const parser = new Parser({\n      lexer: new Lexer(stream),\n      xref: this,\n      allowStreams: true\n    });\n    const obj1 = parser.getObj();\n    const obj2 = parser.getObj();\n    const obj3 = parser.getObj();\n    if (obj1 !== num || obj2 !== gen || !(obj3 instanceof Cmd)) {\n      throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);\n    }\n    if (obj3.cmd !== \"obj\") {\n      if (obj3.cmd.startsWith(\"obj\")) {\n        num = parseInt(obj3.cmd.substring(3), 10);\n        if (!Number.isNaN(num)) {\n          return num;\n        }\n      }\n      throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);\n    }\n    xrefEntry = this.encrypt && !suppressEncryption ? parser.getObj(this.encrypt.createCipherTransform(num, gen)) : parser.getObj();\n    if (!(xrefEntry instanceof BaseStream)) {\n      this._cacheMap.set(num, xrefEntry);\n    }\n    return xrefEntry;\n  }\n  fetchCompressed(ref, xrefEntry, suppressEncryption = false) {\n    const tableOffset = xrefEntry.offset;\n    const stream = this.fetch(Ref.get(tableOffset, 0));\n    if (!(stream instanceof BaseStream)) {\n      throw new FormatError(\"bad ObjStm stream\");\n    }\n    const first = stream.dict.get(\"First\");\n    const n = stream.dict.get(\"N\");\n    if (!Number.isInteger(first) || !Number.isInteger(n)) {\n      throw new FormatError(\"invalid first and n parameters for ObjStm stream\");\n    }\n    let parser = new Parser({\n      lexer: new Lexer(stream),\n      xref: this,\n      allowStreams: true\n    });\n    const nums = new Array(n);\n    const offsets = new Array(n);\n    for (let i = 0; i < n; ++i) {\n      const num = parser.getObj();\n      if (!Number.isInteger(num)) {\n        throw new FormatError(`invalid object number in the ObjStm stream: ${num}`);\n      }\n      const offset = parser.getObj();\n      if (!Number.isInteger(offset)) {\n        throw new FormatError(`invalid object offset in the ObjStm stream: ${offset}`);\n      }\n      nums[i] = num;\n      offsets[i] = offset;\n    }\n    const start = (stream.start || 0) + first;\n    const entries = new Array(n);\n    for (let i = 0; i < n; ++i) {\n      const length = i < n - 1 ? offsets[i + 1] - offsets[i] : undefined;\n      if (length < 0) {\n        throw new FormatError(\"Invalid offset in the ObjStm stream.\");\n      }\n      parser = new Parser({\n        lexer: new Lexer(stream.makeSubStream(start + offsets[i], length, stream.dict)),\n        xref: this,\n        allowStreams: true\n      });\n      const obj = parser.getObj();\n      entries[i] = obj;\n      if (obj instanceof BaseStream) {\n        continue;\n      }\n      const num = nums[i],\n        entry = this.entries[num];\n      if (entry && entry.offset === tableOffset && entry.gen === i) {\n        this._cacheMap.set(num, obj);\n      }\n    }\n    xrefEntry = entries[xrefEntry.gen];\n    if (xrefEntry === undefined) {\n      throw new XRefEntryException(`Bad (compressed) XRef entry: ${ref}`);\n    }\n    return xrefEntry;\n  }\n  async fetchIfRefAsync(obj, suppressEncryption) {\n    if (obj instanceof Ref) {\n      return this.fetchAsync(obj, suppressEncryption);\n    }\n    return obj;\n  }\n  async fetchAsync(ref, suppressEncryption) {\n    try {\n      return this.fetch(ref, suppressEncryption);\n    } catch (ex) {\n      if (!(ex instanceof MissingDataException)) {\n        throw ex;\n      }\n      await this.pdfManager.requestRange(ex.begin, ex.end);\n      return this.fetchAsync(ref, suppressEncryption);\n    }\n  }\n  getCatalogObj() {\n    return this.root;\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/document.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_USER_UNIT = 1.0;\nconst LETTER_SIZE_MEDIABOX = [0, 0, 612, 792];\nclass Page {\n  constructor({\n    pdfManager,\n    xref,\n    pageIndex,\n    pageDict,\n    ref,\n    globalIdFactory,\n    fontCache,\n    builtInCMapCache,\n    standardFontDataCache,\n    globalImageCache,\n    systemFontCache,\n    nonBlendModesSet,\n    xfaFactory\n  }) {\n    this.pdfManager = pdfManager;\n    this.pageIndex = pageIndex;\n    this.pageDict = pageDict;\n    this.xref = xref;\n    this.ref = ref;\n    this.fontCache = fontCache;\n    this.builtInCMapCache = builtInCMapCache;\n    this.standardFontDataCache = standardFontDataCache;\n    this.globalImageCache = globalImageCache;\n    this.systemFontCache = systemFontCache;\n    this.nonBlendModesSet = nonBlendModesSet;\n    this.evaluatorOptions = pdfManager.evaluatorOptions;\n    this.resourcesPromise = null;\n    this.xfaFactory = xfaFactory;\n    const idCounters = {\n      obj: 0\n    };\n    this._localIdFactory = class extends globalIdFactory {\n      static createObjId() {\n        return `p${pageIndex}_${++idCounters.obj}`;\n      }\n      static getPageObjId() {\n        return `p${ref.toString()}`;\n      }\n    };\n  }\n  _getInheritableProperty(key, getArray = false) {\n    const value = getInheritableProperty({\n      dict: this.pageDict,\n      key,\n      getArray,\n      stopWhenFound: false\n    });\n    if (!Array.isArray(value)) {\n      return value;\n    }\n    if (value.length === 1 || !(value[0] instanceof Dict)) {\n      return value[0];\n    }\n    return Dict.merge({\n      xref: this.xref,\n      dictArray: value\n    });\n  }\n  get content() {\n    return this.pageDict.getArray(\"Contents\");\n  }\n  get resources() {\n    const resources = this._getInheritableProperty(\"Resources\");\n    return shadow(this, \"resources\", resources instanceof Dict ? resources : Dict.empty);\n  }\n  _getBoundingBox(name) {\n    if (this.xfaData) {\n      return this.xfaData.bbox;\n    }\n    let box = this._getInheritableProperty(name, true);\n    if (Array.isArray(box) && box.length === 4) {\n      box = Util.normalizeRect(box);\n      if (box[2] - box[0] > 0 && box[3] - box[1] > 0) {\n        return box;\n      }\n      warn(`Empty, or invalid, /${name} entry.`);\n    }\n    return null;\n  }\n  get mediaBox() {\n    return shadow(this, \"mediaBox\", this._getBoundingBox(\"MediaBox\") || LETTER_SIZE_MEDIABOX);\n  }\n  get cropBox() {\n    return shadow(this, \"cropBox\", this._getBoundingBox(\"CropBox\") || this.mediaBox);\n  }\n  get userUnit() {\n    let obj = this.pageDict.get(\"UserUnit\");\n    if (typeof obj !== \"number\" || obj <= 0) {\n      obj = DEFAULT_USER_UNIT;\n    }\n    return shadow(this, \"userUnit\", obj);\n  }\n  get view() {\n    const {\n      cropBox,\n      mediaBox\n    } = this;\n    if (cropBox !== mediaBox && !isArrayEqual(cropBox, mediaBox)) {\n      const box = Util.intersect(cropBox, mediaBox);\n      if (box && box[2] - box[0] > 0 && box[3] - box[1] > 0) {\n        return shadow(this, \"view\", box);\n      }\n      warn(\"Empty /CropBox and /MediaBox intersection.\");\n    }\n    return shadow(this, \"view\", mediaBox);\n  }\n  get rotate() {\n    let rotate = this._getInheritableProperty(\"Rotate\") || 0;\n    if (rotate % 90 !== 0) {\n      rotate = 0;\n    } else if (rotate >= 360) {\n      rotate %= 360;\n    } else if (rotate < 0) {\n      rotate = (rotate % 360 + 360) % 360;\n    }\n    return shadow(this, \"rotate\", rotate);\n  }\n  _onSubStreamError(reason, objId) {\n    if (this.evaluatorOptions.ignoreErrors) {\n      warn(`getContentStream - ignoring sub-stream (${objId}): \"${reason}\".`);\n      return;\n    }\n    throw reason;\n  }\n  getContentStream() {\n    return this.pdfManager.ensure(this, \"content\").then(content => {\n      if (content instanceof BaseStream) {\n        return content;\n      }\n      if (Array.isArray(content)) {\n        return new StreamsSequenceStream(content, this._onSubStreamError.bind(this));\n      }\n      return new NullStream();\n    });\n  }\n  get xfaData() {\n    return shadow(this, \"xfaData\", this.xfaFactory ? {\n      bbox: this.xfaFactory.getBoundingBox(this.pageIndex)\n    } : null);\n  }\n  #replaceIdByRef(annotations, deletedAnnotations, existingAnnotations) {\n    for (const annotation of annotations) {\n      if (annotation.id) {\n        const ref = Ref.fromString(annotation.id);\n        if (!ref) {\n          warn(`A non-linked annotation cannot be modified: ${annotation.id}`);\n          continue;\n        }\n        if (annotation.deleted) {\n          deletedAnnotations.put(ref, ref);\n          continue;\n        }\n        existingAnnotations?.put(ref);\n        annotation.ref = ref;\n        delete annotation.id;\n      }\n    }\n  }\n  async saveNewAnnotations(handler, task, annotations, imagePromises) {\n    if (this.xfaFactory) {\n      throw new Error(\"XFA: Cannot save new annotations.\");\n    }\n    const partialEvaluator = new PartialEvaluator({\n      xref: this.xref,\n      handler,\n      pageIndex: this.pageIndex,\n      idFactory: this._localIdFactory,\n      fontCache: this.fontCache,\n      builtInCMapCache: this.builtInCMapCache,\n      standardFontDataCache: this.standardFontDataCache,\n      globalImageCache: this.globalImageCache,\n      systemFontCache: this.systemFontCache,\n      options: this.evaluatorOptions\n    });\n    const deletedAnnotations = new RefSetCache();\n    const existingAnnotations = new RefSet();\n    this.#replaceIdByRef(annotations, deletedAnnotations, existingAnnotations);\n    const pageDict = this.pageDict;\n    const annotationsArray = this.annotations.filter(a => !(a instanceof Ref && deletedAnnotations.has(a)));\n    const newData = await AnnotationFactory.saveNewAnnotations(partialEvaluator, task, annotations, imagePromises);\n    for (const {\n      ref\n    } of newData.annotations) {\n      if (ref instanceof Ref && !existingAnnotations.has(ref)) {\n        annotationsArray.push(ref);\n      }\n    }\n    const savedDict = pageDict.get(\"Annots\");\n    pageDict.set(\"Annots\", annotationsArray);\n    const buffer = [];\n    await writeObject(this.ref, pageDict, buffer, this.xref);\n    if (savedDict) {\n      pageDict.set(\"Annots\", savedDict);\n    }\n    const objects = newData.dependencies;\n    objects.push({\n      ref: this.ref,\n      data: buffer.join(\"\")\n    }, ...newData.annotations);\n    for (const deletedRef of deletedAnnotations) {\n      objects.push({\n        ref: deletedRef,\n        data: null\n      });\n    }\n    return objects;\n  }\n  save(handler, task, annotationStorage) {\n    const partialEvaluator = new PartialEvaluator({\n      xref: this.xref,\n      handler,\n      pageIndex: this.pageIndex,\n      idFactory: this._localIdFactory,\n      fontCache: this.fontCache,\n      builtInCMapCache: this.builtInCMapCache,\n      standardFontDataCache: this.standardFontDataCache,\n      globalImageCache: this.globalImageCache,\n      systemFontCache: this.systemFontCache,\n      options: this.evaluatorOptions\n    });\n    return this._parsedAnnotations.then(function (annotations) {\n      const newRefsPromises = [];\n      for (const annotation of annotations) {\n        if (!annotation.mustBePrinted(annotationStorage)) {\n          continue;\n        }\n        newRefsPromises.push(annotation.save(partialEvaluator, task, annotationStorage).catch(function (reason) {\n          warn(\"save - ignoring annotation data during \" + `\"${task.name}\" task: \"${reason}\".`);\n          return null;\n        }));\n      }\n      return Promise.all(newRefsPromises).then(function (newRefs) {\n        return newRefs.filter(newRef => !!newRef);\n      });\n    });\n  }\n  loadResources(keys) {\n    if (!this.resourcesPromise) {\n      this.resourcesPromise = this.pdfManager.ensure(this, \"resources\");\n    }\n    return this.resourcesPromise.then(() => {\n      const objectLoader = new ObjectLoader(this.resources, keys, this.xref);\n      return objectLoader.load();\n    });\n  }\n  getOperatorList({\n    handler,\n    sink,\n    task,\n    intent,\n    cacheKey,\n    annotationStorage = null\n  }) {\n    const contentStreamPromise = this.getContentStream();\n    const resourcesPromise = this.loadResources([\"ColorSpace\", \"ExtGState\", \"Font\", \"Pattern\", \"Properties\", \"Shading\", \"XObject\"]);\n    const partialEvaluator = new PartialEvaluator({\n      xref: this.xref,\n      handler,\n      pageIndex: this.pageIndex,\n      idFactory: this._localIdFactory,\n      fontCache: this.fontCache,\n      builtInCMapCache: this.builtInCMapCache,\n      standardFontDataCache: this.standardFontDataCache,\n      globalImageCache: this.globalImageCache,\n      systemFontCache: this.systemFontCache,\n      options: this.evaluatorOptions\n    });\n    const newAnnotationsByPage = !this.xfaFactory ? getNewAnnotationsMap(annotationStorage) : null;\n    let deletedAnnotations = null;\n    let newAnnotationsPromise = Promise.resolve(null);\n    if (newAnnotationsByPage) {\n      const newAnnotations = newAnnotationsByPage.get(this.pageIndex);\n      if (newAnnotations) {\n        const annotationGlobalsPromise = this.pdfManager.ensureDoc(\"annotationGlobals\");\n        let imagePromises;\n        const missingBitmaps = new Set();\n        for (const {\n          bitmapId,\n          bitmap\n        } of newAnnotations) {\n          if (bitmapId && !bitmap && !missingBitmaps.has(bitmapId)) {\n            missingBitmaps.add(bitmapId);\n          }\n        }\n        const {\n          isOffscreenCanvasSupported\n        } = this.evaluatorOptions;\n        if (missingBitmaps.size > 0) {\n          const annotationWithBitmaps = newAnnotations.slice();\n          for (const [key, annotation] of annotationStorage) {\n            if (!key.startsWith(AnnotationEditorPrefix)) {\n              continue;\n            }\n            if (annotation.bitmap && missingBitmaps.has(annotation.bitmapId)) {\n              annotationWithBitmaps.push(annotation);\n            }\n          }\n          imagePromises = AnnotationFactory.generateImages(annotationWithBitmaps, this.xref, isOffscreenCanvasSupported);\n        } else {\n          imagePromises = AnnotationFactory.generateImages(newAnnotations, this.xref, isOffscreenCanvasSupported);\n        }\n        deletedAnnotations = new RefSet();\n        this.#replaceIdByRef(newAnnotations, deletedAnnotations, null);\n        newAnnotationsPromise = annotationGlobalsPromise.then(annotationGlobals => {\n          if (!annotationGlobals) {\n            return null;\n          }\n          return AnnotationFactory.printNewAnnotations(annotationGlobals, partialEvaluator, task, newAnnotations, imagePromises);\n        });\n      }\n    }\n    const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);\n    const pageListPromise = dataPromises.then(([contentStream]) => {\n      const opList = new OperatorList(intent, sink);\n      handler.send(\"StartRenderPage\", {\n        transparency: partialEvaluator.hasBlendModes(this.resources, this.nonBlendModesSet),\n        pageIndex: this.pageIndex,\n        cacheKey\n      });\n      return partialEvaluator.getOperatorList({\n        stream: contentStream,\n        task,\n        resources: this.resources,\n        operatorList: opList\n      }).then(function () {\n        return opList;\n      });\n    });\n    return Promise.all([pageListPromise, this._parsedAnnotations, newAnnotationsPromise]).then(function ([pageOpList, annotations, newAnnotations]) {\n      if (newAnnotations) {\n        annotations = annotations.filter(a => !(a.ref && deletedAnnotations.has(a.ref)));\n        for (let i = 0, ii = newAnnotations.length; i < ii; i++) {\n          const newAnnotation = newAnnotations[i];\n          if (newAnnotation.refToReplace) {\n            const j = annotations.findIndex(a => a.ref && isRefsEqual(a.ref, newAnnotation.refToReplace));\n            if (j >= 0) {\n              annotations.splice(j, 1, newAnnotation);\n              newAnnotations.splice(i--, 1);\n              ii--;\n            }\n          }\n        }\n        annotations = annotations.concat(newAnnotations);\n      }\n      if (annotations.length === 0 || intent & RenderingIntentFlag.ANNOTATIONS_DISABLE) {\n        pageOpList.flush(true);\n        return {\n          length: pageOpList.totalLength\n        };\n      }\n      const renderForms = !!(intent & RenderingIntentFlag.ANNOTATIONS_FORMS),\n        intentAny = !!(intent & RenderingIntentFlag.ANY),\n        intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY),\n        intentPrint = !!(intent & RenderingIntentFlag.PRINT);\n      const opListPromises = [];\n      for (const annotation of annotations) {\n        if (intentAny || intentDisplay && annotation.mustBeViewed(annotationStorage, renderForms) || intentPrint && annotation.mustBePrinted(annotationStorage)) {\n          opListPromises.push(annotation.getOperatorList(partialEvaluator, task, intent, renderForms, annotationStorage).catch(function (reason) {\n            warn(\"getOperatorList - ignoring annotation data during \" + `\"${task.name}\" task: \"${reason}\".`);\n            return {\n              opList: null,\n              separateForm: false,\n              separateCanvas: false\n            };\n          }));\n        }\n      }\n      return Promise.all(opListPromises).then(function (opLists) {\n        let form = false,\n          canvas = false;\n        for (const {\n          opList,\n          separateForm,\n          separateCanvas\n        } of opLists) {\n          pageOpList.addOpList(opList);\n          form ||= separateForm;\n          canvas ||= separateCanvas;\n        }\n        pageOpList.flush(true, {\n          form,\n          canvas\n        });\n        return {\n          length: pageOpList.totalLength\n        };\n      });\n    });\n  }\n  extractTextContent({\n    handler,\n    task,\n    includeMarkedContent,\n    disableNormalization,\n    sink\n  }) {\n    const contentStreamPromise = this.getContentStream();\n    const resourcesPromise = this.loadResources([\"ExtGState\", \"Font\", \"Properties\", \"XObject\"]);\n    const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);\n    return dataPromises.then(([contentStream]) => {\n      const partialEvaluator = new PartialEvaluator({\n        xref: this.xref,\n        handler,\n        pageIndex: this.pageIndex,\n        idFactory: this._localIdFactory,\n        fontCache: this.fontCache,\n        builtInCMapCache: this.builtInCMapCache,\n        standardFontDataCache: this.standardFontDataCache,\n        globalImageCache: this.globalImageCache,\n        systemFontCache: this.systemFontCache,\n        options: this.evaluatorOptions\n      });\n      return partialEvaluator.getTextContent({\n        stream: contentStream,\n        task,\n        resources: this.resources,\n        includeMarkedContent,\n        disableNormalization,\n        sink,\n        viewBox: this.view\n      });\n    });\n  }\n  async getStructTree() {\n    const structTreeRoot = await this.pdfManager.ensureCatalog(\"structTreeRoot\");\n    if (!structTreeRoot) {\n      return null;\n    }\n    await this._parsedAnnotations;\n    const structTree = await this.pdfManager.ensure(this, \"_parseStructTree\", [structTreeRoot]);\n    return structTree.serializable;\n  }\n  _parseStructTree(structTreeRoot) {\n    const tree = new StructTreePage(structTreeRoot, this.pageDict);\n    tree.parse(this.ref);\n    return tree;\n  }\n  async getAnnotationsData(handler, task, intent) {\n    const annotations = await this._parsedAnnotations;\n    if (annotations.length === 0) {\n      return annotations;\n    }\n    const annotationsData = [],\n      textContentPromises = [];\n    let partialEvaluator;\n    const intentAny = !!(intent & RenderingIntentFlag.ANY),\n      intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY),\n      intentPrint = !!(intent & RenderingIntentFlag.PRINT);\n    for (const annotation of annotations) {\n      const isVisible = intentAny || intentDisplay && annotation.viewable;\n      if (isVisible || intentPrint && annotation.printable) {\n        annotationsData.push(annotation.data);\n      }\n      if (annotation.hasTextContent && isVisible) {\n        partialEvaluator ||= new PartialEvaluator({\n          xref: this.xref,\n          handler,\n          pageIndex: this.pageIndex,\n          idFactory: this._localIdFactory,\n          fontCache: this.fontCache,\n          builtInCMapCache: this.builtInCMapCache,\n          standardFontDataCache: this.standardFontDataCache,\n          globalImageCache: this.globalImageCache,\n          systemFontCache: this.systemFontCache,\n          options: this.evaluatorOptions\n        });\n        textContentPromises.push(annotation.extractTextContent(partialEvaluator, task, [-Infinity, -Infinity, Infinity, Infinity]).catch(function (reason) {\n          warn(`getAnnotationsData - ignoring textContent during \"${task.name}\" task: \"${reason}\".`);\n        }));\n      }\n    }\n    await Promise.all(textContentPromises);\n    return annotationsData;\n  }\n  get annotations() {\n    const annots = this._getInheritableProperty(\"Annots\");\n    return shadow(this, \"annotations\", Array.isArray(annots) ? annots : []);\n  }\n  get _parsedAnnotations() {\n    const promise = this.pdfManager.ensure(this, \"annotations\").then(async annots => {\n      if (annots.length === 0) {\n        return annots;\n      }\n      const annotationGlobals = await this.pdfManager.ensureDoc(\"annotationGlobals\");\n      if (!annotationGlobals) {\n        return [];\n      }\n      const annotationPromises = [];\n      for (const annotationRef of annots) {\n        annotationPromises.push(AnnotationFactory.create(this.xref, annotationRef, annotationGlobals, this._localIdFactory, false, this.ref).catch(function (reason) {\n          warn(`_parsedAnnotations: \"${reason}\".`);\n          return null;\n        }));\n      }\n      const sortedAnnotations = [];\n      let popupAnnotations, widgetAnnotations;\n      for (const annotation of await Promise.all(annotationPromises)) {\n        if (!annotation) {\n          continue;\n        }\n        if (annotation instanceof WidgetAnnotation) {\n          (widgetAnnotations ||= []).push(annotation);\n          continue;\n        }\n        if (annotation instanceof PopupAnnotation) {\n          (popupAnnotations ||= []).push(annotation);\n          continue;\n        }\n        sortedAnnotations.push(annotation);\n      }\n      if (widgetAnnotations) {\n        sortedAnnotations.push(...widgetAnnotations);\n      }\n      if (popupAnnotations) {\n        sortedAnnotations.push(...popupAnnotations);\n      }\n      return sortedAnnotations;\n    });\n    return shadow(this, \"_parsedAnnotations\", promise);\n  }\n  get jsActions() {\n    const actions = collectActions(this.xref, this.pageDict, PageActionEventType);\n    return shadow(this, \"jsActions\", actions);\n  }\n}\nconst PDF_HEADER_SIGNATURE = new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d]);\nconst STARTXREF_SIGNATURE = new Uint8Array([0x73, 0x74, 0x61, 0x72, 0x74, 0x78, 0x72, 0x65, 0x66]);\nconst ENDOBJ_SIGNATURE = new Uint8Array([0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a]);\nconst FINGERPRINT_FIRST_BYTES = 1024;\nconst EMPTY_FINGERPRINT = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\";\nfunction find(stream, signature, limit = 1024, backwards = false) {\n  const signatureLength = signature.length;\n  const scanBytes = stream.peekBytes(limit);\n  const scanLength = scanBytes.length - signatureLength;\n  if (scanLength <= 0) {\n    return false;\n  }\n  if (backwards) {\n    const signatureEnd = signatureLength - 1;\n    let pos = scanBytes.length - 1;\n    while (pos >= signatureEnd) {\n      let j = 0;\n      while (j < signatureLength && scanBytes[pos - j] === signature[signatureEnd - j]) {\n        j++;\n      }\n      if (j >= signatureLength) {\n        stream.pos += pos - signatureEnd;\n        return true;\n      }\n      pos--;\n    }\n  } else {\n    let pos = 0;\n    while (pos <= scanLength) {\n      let j = 0;\n      while (j < signatureLength && scanBytes[pos + j] === signature[j]) {\n        j++;\n      }\n      if (j >= signatureLength) {\n        stream.pos += pos;\n        return true;\n      }\n      pos++;\n    }\n  }\n  return false;\n}\nclass PDFDocument {\n  constructor(pdfManager, stream) {\n    if (stream.length <= 0) {\n      throw new InvalidPDFException(\"The PDF file is empty, i.e. its size is zero bytes.\");\n    }\n    this.pdfManager = pdfManager;\n    this.stream = stream;\n    this.xref = new XRef(stream, pdfManager);\n    this._pagePromises = new Map();\n    this._version = null;\n    const idCounters = {\n      font: 0\n    };\n    this._globalIdFactory = class {\n      static getDocId() {\n        return `g_${pdfManager.docId}`;\n      }\n      static createFontId() {\n        return `f${++idCounters.font}`;\n      }\n      static createObjId() {\n        unreachable(\"Abstract method `createObjId` called.\");\n      }\n      static getPageObjId() {\n        unreachable(\"Abstract method `getPageObjId` called.\");\n      }\n    };\n  }\n  parse(recoveryMode) {\n    this.xref.parse(recoveryMode);\n    this.catalog = new Catalog(this.pdfManager, this.xref);\n  }\n  get linearization() {\n    let linearization = null;\n    try {\n      linearization = Linearization.create(this.stream);\n    } catch (err) {\n      if (err instanceof MissingDataException) {\n        throw err;\n      }\n      info(err);\n    }\n    return shadow(this, \"linearization\", linearization);\n  }\n  get startXRef() {\n    const stream = this.stream;\n    let startXRef = 0;\n    if (this.linearization) {\n      stream.reset();\n      if (find(stream, ENDOBJ_SIGNATURE)) {\n        stream.skip(6);\n        let ch = stream.peekByte();\n        while (isWhiteSpace(ch)) {\n          stream.pos++;\n          ch = stream.peekByte();\n        }\n        startXRef = stream.pos - stream.start;\n      }\n    } else {\n      const step = 1024;\n      const startXRefLength = STARTXREF_SIGNATURE.length;\n      let found = false,\n        pos = stream.end;\n      while (!found && pos > 0) {\n        pos -= step - startXRefLength;\n        if (pos < 0) {\n          pos = 0;\n        }\n        stream.pos = pos;\n        found = find(stream, STARTXREF_SIGNATURE, step, true);\n      }\n      if (found) {\n        stream.skip(9);\n        let ch;\n        do {\n          ch = stream.getByte();\n        } while (isWhiteSpace(ch));\n        let str = \"\";\n        while (ch >= 0x20 && ch <= 0x39) {\n          str += String.fromCharCode(ch);\n          ch = stream.getByte();\n        }\n        startXRef = parseInt(str, 10);\n        if (isNaN(startXRef)) {\n          startXRef = 0;\n        }\n      }\n    }\n    return shadow(this, \"startXRef\", startXRef);\n  }\n  checkHeader() {\n    const stream = this.stream;\n    stream.reset();\n    if (!find(stream, PDF_HEADER_SIGNATURE)) {\n      return;\n    }\n    stream.moveStart();\n    stream.skip(PDF_HEADER_SIGNATURE.length);\n    let version = \"\",\n      ch;\n    while ((ch = stream.getByte()) > 0x20 && version.length < 7) {\n      version += String.fromCharCode(ch);\n    }\n    if (PDF_VERSION_REGEXP.test(version)) {\n      this._version = version;\n    } else {\n      warn(`Invalid PDF header version: ${version}`);\n    }\n  }\n  parseStartXRef() {\n    this.xref.setStartXRef(this.startXRef);\n  }\n  get numPages() {\n    let num = 0;\n    if (this.catalog.hasActualNumPages) {\n      num = this.catalog.numPages;\n    } else if (this.xfaFactory) {\n      num = this.xfaFactory.getNumPages();\n    } else if (this.linearization) {\n      num = this.linearization.numPages;\n    } else {\n      num = this.catalog.numPages;\n    }\n    return shadow(this, \"numPages\", num);\n  }\n  _hasOnlyDocumentSignatures(fields, recursionDepth = 0) {\n    const RECURSION_LIMIT = 10;\n    if (!Array.isArray(fields)) {\n      return false;\n    }\n    return fields.every(field => {\n      field = this.xref.fetchIfRef(field);\n      if (!(field instanceof Dict)) {\n        return false;\n      }\n      if (field.has(\"Kids\")) {\n        if (++recursionDepth > RECURSION_LIMIT) {\n          warn(\"_hasOnlyDocumentSignatures: maximum recursion depth reached\");\n          return false;\n        }\n        return this._hasOnlyDocumentSignatures(field.get(\"Kids\"), recursionDepth);\n      }\n      const isSignature = isName(field.get(\"FT\"), \"Sig\");\n      const rectangle = field.get(\"Rect\");\n      const isInvisible = Array.isArray(rectangle) && rectangle.every(value => value === 0);\n      return isSignature && isInvisible;\n    });\n  }\n  get _xfaStreams() {\n    const acroForm = this.catalog.acroForm;\n    if (!acroForm) {\n      return null;\n    }\n    const xfa = acroForm.get(\"XFA\");\n    const entries = {\n      \"xdp:xdp\": \"\",\n      template: \"\",\n      datasets: \"\",\n      config: \"\",\n      connectionSet: \"\",\n      localeSet: \"\",\n      stylesheet: \"\",\n      \"/xdp:xdp\": \"\"\n    };\n    if (xfa instanceof BaseStream && !xfa.isEmpty) {\n      entries[\"xdp:xdp\"] = xfa;\n      return entries;\n    }\n    if (!Array.isArray(xfa) || xfa.length === 0) {\n      return null;\n    }\n    for (let i = 0, ii = xfa.length; i < ii; i += 2) {\n      let name;\n      if (i === 0) {\n        name = \"xdp:xdp\";\n      } else if (i === ii - 2) {\n        name = \"/xdp:xdp\";\n      } else {\n        name = xfa[i];\n      }\n      if (!entries.hasOwnProperty(name)) {\n        continue;\n      }\n      const data = this.xref.fetchIfRef(xfa[i + 1]);\n      if (!(data instanceof BaseStream) || data.isEmpty) {\n        continue;\n      }\n      entries[name] = data;\n    }\n    return entries;\n  }\n  get xfaDatasets() {\n    const streams = this._xfaStreams;\n    if (!streams) {\n      return shadow(this, \"xfaDatasets\", null);\n    }\n    for (const key of [\"datasets\", \"xdp:xdp\"]) {\n      const stream = streams[key];\n      if (!stream) {\n        continue;\n      }\n      try {\n        const str = stringToUTF8String(stream.getString());\n        const data = {\n          [key]: str\n        };\n        return shadow(this, \"xfaDatasets\", new DatasetReader(data));\n      } catch {\n        warn(\"XFA - Invalid utf-8 string.\");\n        break;\n      }\n    }\n    return shadow(this, \"xfaDatasets\", null);\n  }\n  get xfaData() {\n    const streams = this._xfaStreams;\n    if (!streams) {\n      return null;\n    }\n    const data = Object.create(null);\n    for (const [key, stream] of Object.entries(streams)) {\n      if (!stream) {\n        continue;\n      }\n      try {\n        data[key] = stringToUTF8String(stream.getString());\n      } catch {\n        warn(\"XFA - Invalid utf-8 string.\");\n        return null;\n      }\n    }\n    return data;\n  }\n  get xfaFactory() {\n    let data;\n    if (this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm) {\n      data = this.xfaData;\n    }\n    return shadow(this, \"xfaFactory\", data ? new XFAFactory(data) : null);\n  }\n  get isPureXfa() {\n    return this.xfaFactory ? this.xfaFactory.isValid() : false;\n  }\n  get htmlForXfa() {\n    return this.xfaFactory ? this.xfaFactory.getPages() : null;\n  }\n  async loadXfaImages() {\n    const xfaImagesDict = await this.pdfManager.ensureCatalog(\"xfaImages\");\n    if (!xfaImagesDict) {\n      return;\n    }\n    const keys = xfaImagesDict.getKeys();\n    const objectLoader = new ObjectLoader(xfaImagesDict, keys, this.xref);\n    await objectLoader.load();\n    const xfaImages = new Map();\n    for (const key of keys) {\n      const stream = xfaImagesDict.get(key);\n      if (stream instanceof BaseStream) {\n        xfaImages.set(key, stream.getBytes());\n      }\n    }\n    this.xfaFactory.setImages(xfaImages);\n  }\n  async loadXfaFonts(handler, task) {\n    const acroForm = await this.pdfManager.ensureCatalog(\"acroForm\");\n    if (!acroForm) {\n      return;\n    }\n    const resources = await acroForm.getAsync(\"DR\");\n    if (!(resources instanceof Dict)) {\n      return;\n    }\n    const objectLoader = new ObjectLoader(resources, [\"Font\"], this.xref);\n    await objectLoader.load();\n    const fontRes = resources.get(\"Font\");\n    if (!(fontRes instanceof Dict)) {\n      return;\n    }\n    const options = Object.assign(Object.create(null), this.pdfManager.evaluatorOptions);\n    options.useSystemFonts = false;\n    const partialEvaluator = new PartialEvaluator({\n      xref: this.xref,\n      handler,\n      pageIndex: -1,\n      idFactory: this._globalIdFactory,\n      fontCache: this.catalog.fontCache,\n      builtInCMapCache: this.catalog.builtInCMapCache,\n      standardFontDataCache: this.catalog.standardFontDataCache,\n      options\n    });\n    const operatorList = new OperatorList();\n    const pdfFonts = [];\n    const initialState = {\n      get font() {\n        return pdfFonts.at(-1);\n      },\n      set font(font) {\n        pdfFonts.push(font);\n      },\n      clone() {\n        return this;\n      }\n    };\n    const fonts = new Map();\n    fontRes.forEach((fontName, font) => {\n      fonts.set(fontName, font);\n    });\n    const promises = [];\n    for (const [fontName, font] of fonts) {\n      const descriptor = font.get(\"FontDescriptor\");\n      if (!(descriptor instanceof Dict)) {\n        continue;\n      }\n      let fontFamily = descriptor.get(\"FontFamily\");\n      fontFamily = fontFamily.replaceAll(/[ ]+(\\d)/g, \"$1\");\n      const fontWeight = descriptor.get(\"FontWeight\");\n      const italicAngle = -descriptor.get(\"ItalicAngle\");\n      const cssFontInfo = {\n        fontFamily,\n        fontWeight,\n        italicAngle\n      };\n      if (!validateCSSFont(cssFontInfo)) {\n        continue;\n      }\n      promises.push(partialEvaluator.handleSetFont(resources, [Name.get(fontName), 1], null, operatorList, task, initialState, null, cssFontInfo).catch(function (reason) {\n        warn(`loadXfaFonts: \"${reason}\".`);\n        return null;\n      }));\n    }\n    await Promise.all(promises);\n    const missingFonts = this.xfaFactory.setFonts(pdfFonts);\n    if (!missingFonts) {\n      return;\n    }\n    options.ignoreErrors = true;\n    promises.length = 0;\n    pdfFonts.length = 0;\n    const reallyMissingFonts = new Set();\n    for (const missing of missingFonts) {\n      if (!getXfaFontName(`${missing}-Regular`)) {\n        reallyMissingFonts.add(missing);\n      }\n    }\n    if (reallyMissingFonts.size) {\n      missingFonts.push(\"PdfJS-Fallback\");\n    }\n    for (const missing of missingFonts) {\n      if (reallyMissingFonts.has(missing)) {\n        continue;\n      }\n      for (const fontInfo of [{\n        name: \"Regular\",\n        fontWeight: 400,\n        italicAngle: 0\n      }, {\n        name: \"Bold\",\n        fontWeight: 700,\n        italicAngle: 0\n      }, {\n        name: \"Italic\",\n        fontWeight: 400,\n        italicAngle: 12\n      }, {\n        name: \"BoldItalic\",\n        fontWeight: 700,\n        italicAngle: 12\n      }]) {\n        const name = `${missing}-${fontInfo.name}`;\n        const dict = getXfaFontDict(name);\n        promises.push(partialEvaluator.handleSetFont(resources, [Name.get(name), 1], null, operatorList, task, initialState, dict, {\n          fontFamily: missing,\n          fontWeight: fontInfo.fontWeight,\n          italicAngle: fontInfo.italicAngle\n        }).catch(function (reason) {\n          warn(`loadXfaFonts: \"${reason}\".`);\n          return null;\n        }));\n      }\n    }\n    await Promise.all(promises);\n    this.xfaFactory.appendFonts(pdfFonts, reallyMissingFonts);\n  }\n  async serializeXfaData(annotationStorage) {\n    return this.xfaFactory ? this.xfaFactory.serializeData(annotationStorage) : null;\n  }\n  get version() {\n    return this.catalog.version || this._version;\n  }\n  get formInfo() {\n    const formInfo = {\n      hasFields: false,\n      hasAcroForm: false,\n      hasXfa: false,\n      hasSignatures: false\n    };\n    const acroForm = this.catalog.acroForm;\n    if (!acroForm) {\n      return shadow(this, \"formInfo\", formInfo);\n    }\n    try {\n      const fields = acroForm.get(\"Fields\");\n      const hasFields = Array.isArray(fields) && fields.length > 0;\n      formInfo.hasFields = hasFields;\n      const xfa = acroForm.get(\"XFA\");\n      formInfo.hasXfa = Array.isArray(xfa) && xfa.length > 0 || xfa instanceof BaseStream && !xfa.isEmpty;\n      const sigFlags = acroForm.get(\"SigFlags\");\n      const hasSignatures = !!(sigFlags & 0x1);\n      const hasOnlyDocumentSignatures = hasSignatures && this._hasOnlyDocumentSignatures(fields);\n      formInfo.hasAcroForm = hasFields && !hasOnlyDocumentSignatures;\n      formInfo.hasSignatures = hasSignatures;\n    } catch (ex) {\n      if (ex instanceof MissingDataException) {\n        throw ex;\n      }\n      warn(`Cannot fetch form information: \"${ex}\".`);\n    }\n    return shadow(this, \"formInfo\", formInfo);\n  }\n  get documentInfo() {\n    const docInfo = {\n      PDFFormatVersion: this.version,\n      Language: this.catalog.lang,\n      EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null,\n      IsLinearized: !!this.linearization,\n      IsAcroFormPresent: this.formInfo.hasAcroForm,\n      IsXFAPresent: this.formInfo.hasXfa,\n      IsCollectionPresent: !!this.catalog.collection,\n      IsSignaturesPresent: this.formInfo.hasSignatures\n    };\n    let infoDict;\n    try {\n      infoDict = this.xref.trailer.get(\"Info\");\n    } catch (err) {\n      if (err instanceof MissingDataException) {\n        throw err;\n      }\n      info(\"The document information dictionary is invalid.\");\n    }\n    if (!(infoDict instanceof Dict)) {\n      return shadow(this, \"documentInfo\", docInfo);\n    }\n    for (const key of infoDict.getKeys()) {\n      const value = infoDict.get(key);\n      switch (key) {\n        case \"Title\":\n        case \"Author\":\n        case \"Subject\":\n        case \"Keywords\":\n        case \"Creator\":\n        case \"Producer\":\n        case \"CreationDate\":\n        case \"ModDate\":\n          if (typeof value === \"string\") {\n            docInfo[key] = stringToPDFString(value);\n            continue;\n          }\n          break;\n        case \"Trapped\":\n          if (value instanceof Name) {\n            docInfo[key] = value;\n            continue;\n          }\n          break;\n        default:\n          let customValue;\n          switch (typeof value) {\n            case \"string\":\n              customValue = stringToPDFString(value);\n              break;\n            case \"number\":\n            case \"boolean\":\n              customValue = value;\n              break;\n            default:\n              if (value instanceof Name) {\n                customValue = value;\n              }\n              break;\n          }\n          if (customValue === undefined) {\n            warn(`Bad value, for custom key \"${key}\", in Info: ${value}.`);\n            continue;\n          }\n          if (!docInfo.Custom) {\n            docInfo.Custom = Object.create(null);\n          }\n          docInfo.Custom[key] = customValue;\n          continue;\n      }\n      warn(`Bad value, for key \"${key}\", in Info: ${value}.`);\n    }\n    return shadow(this, \"documentInfo\", docInfo);\n  }\n  get fingerprints() {\n    function validate(data) {\n      return typeof data === \"string\" && data.length > 0 && data !== EMPTY_FINGERPRINT;\n    }\n    function hexString(hash) {\n      const buf = [];\n      for (const num of hash) {\n        const hex = num.toString(16);\n        buf.push(hex.padStart(2, \"0\"));\n      }\n      return buf.join(\"\");\n    }\n    const idArray = this.xref.trailer.get(\"ID\");\n    let hashOriginal, hashModified;\n    if (Array.isArray(idArray) && validate(idArray[0])) {\n      hashOriginal = stringToBytes(idArray[0]);\n      if (idArray[1] !== idArray[0] && validate(idArray[1])) {\n        hashModified = stringToBytes(idArray[1]);\n      }\n    } else {\n      hashOriginal = calculateMD5(this.stream.getByteRange(0, FINGERPRINT_FIRST_BYTES), 0, FINGERPRINT_FIRST_BYTES);\n    }\n    return shadow(this, \"fingerprints\", [hexString(hashOriginal), hashModified ? hexString(hashModified) : null]);\n  }\n  async _getLinearizationPage(pageIndex) {\n    const {\n      catalog,\n      linearization,\n      xref\n    } = this;\n    const ref = Ref.get(linearization.objectNumberFirst, 0);\n    try {\n      const obj = await xref.fetchAsync(ref);\n      if (obj instanceof Dict) {\n        let type = obj.getRaw(\"Type\");\n        if (type instanceof Ref) {\n          type = await xref.fetchAsync(type);\n        }\n        if (isName(type, \"Page\") || !obj.has(\"Type\") && !obj.has(\"Kids\")) {\n          if (!catalog.pageKidsCountCache.has(ref)) {\n            catalog.pageKidsCountCache.put(ref, 1);\n          }\n          if (!catalog.pageIndexCache.has(ref)) {\n            catalog.pageIndexCache.put(ref, 0);\n          }\n          return [obj, ref];\n        }\n      }\n      throw new FormatError(\"The Linearization dictionary doesn't point to a valid Page dictionary.\");\n    } catch (reason) {\n      warn(`_getLinearizationPage: \"${reason.message}\".`);\n      return catalog.getPageDict(pageIndex);\n    }\n  }\n  getPage(pageIndex) {\n    const cachedPromise = this._pagePromises.get(pageIndex);\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n    const {\n      catalog,\n      linearization,\n      xfaFactory\n    } = this;\n    let promise;\n    if (xfaFactory) {\n      promise = Promise.resolve([Dict.empty, null]);\n    } else if (linearization?.pageFirst === pageIndex) {\n      promise = this._getLinearizationPage(pageIndex);\n    } else {\n      promise = catalog.getPageDict(pageIndex);\n    }\n    promise = promise.then(([pageDict, ref]) => {\n      return new Page({\n        pdfManager: this.pdfManager,\n        xref: this.xref,\n        pageIndex,\n        pageDict,\n        ref,\n        globalIdFactory: this._globalIdFactory,\n        fontCache: catalog.fontCache,\n        builtInCMapCache: catalog.builtInCMapCache,\n        standardFontDataCache: catalog.standardFontDataCache,\n        globalImageCache: catalog.globalImageCache,\n        systemFontCache: catalog.systemFontCache,\n        nonBlendModesSet: catalog.nonBlendModesSet,\n        xfaFactory\n      });\n    });\n    this._pagePromises.set(pageIndex, promise);\n    return promise;\n  }\n  async checkFirstPage(recoveryMode = false) {\n    if (recoveryMode) {\n      return;\n    }\n    try {\n      await this.getPage(0);\n    } catch (reason) {\n      if (reason instanceof XRefEntryException) {\n        this._pagePromises.delete(0);\n        await this.cleanup();\n        throw new XRefParseException();\n      }\n    }\n  }\n  async checkLastPage(recoveryMode = false) {\n    const {\n      catalog,\n      pdfManager\n    } = this;\n    catalog.setActualNumPages();\n    let numPages;\n    try {\n      await Promise.all([pdfManager.ensureDoc(\"xfaFactory\"), pdfManager.ensureDoc(\"linearization\"), pdfManager.ensureCatalog(\"numPages\")]);\n      if (this.xfaFactory) {\n        return;\n      } else if (this.linearization) {\n        numPages = this.linearization.numPages;\n      } else {\n        numPages = catalog.numPages;\n      }\n      if (!Number.isInteger(numPages)) {\n        throw new FormatError(\"Page count is not an integer.\");\n      } else if (numPages <= 1) {\n        return;\n      }\n      await this.getPage(numPages - 1);\n    } catch (reason) {\n      this._pagePromises.delete(numPages - 1);\n      await this.cleanup();\n      if (reason instanceof XRefEntryException && !recoveryMode) {\n        throw new XRefParseException();\n      }\n      warn(`checkLastPage - invalid /Pages tree /Count: ${numPages}.`);\n      let pagesTree;\n      try {\n        pagesTree = await catalog.getAllPageDicts(recoveryMode);\n      } catch (reasonAll) {\n        if (reasonAll instanceof XRefEntryException && !recoveryMode) {\n          throw new XRefParseException();\n        }\n        catalog.setActualNumPages(1);\n        return;\n      }\n      for (const [pageIndex, [pageDict, ref]] of pagesTree) {\n        let promise;\n        if (pageDict instanceof Error) {\n          promise = Promise.reject(pageDict);\n          promise.catch(() => {});\n        } else {\n          promise = Promise.resolve(new Page({\n            pdfManager,\n            xref: this.xref,\n            pageIndex,\n            pageDict,\n            ref,\n            globalIdFactory: this._globalIdFactory,\n            fontCache: catalog.fontCache,\n            builtInCMapCache: catalog.builtInCMapCache,\n            standardFontDataCache: catalog.standardFontDataCache,\n            globalImageCache: catalog.globalImageCache,\n            systemFontCache: catalog.systemFontCache,\n            nonBlendModesSet: catalog.nonBlendModesSet,\n            xfaFactory: null\n          }));\n        }\n        this._pagePromises.set(pageIndex, promise);\n      }\n      catalog.setActualNumPages(pagesTree.size);\n    }\n  }\n  fontFallback(id, handler) {\n    return this.catalog.fontFallback(id, handler);\n  }\n  async cleanup(manuallyTriggered = false) {\n    return this.catalog ? this.catalog.cleanup(manuallyTriggered) : clearGlobalCaches();\n  }\n  async #collectFieldObjects(name, fieldRef, promises, annotationGlobals, visitedRefs) {\n    const {\n      xref\n    } = this;\n    if (!(fieldRef instanceof Ref) || visitedRefs.has(fieldRef)) {\n      return;\n    }\n    visitedRefs.put(fieldRef);\n    const field = await xref.fetchAsync(fieldRef);\n    if (!(field instanceof Dict)) {\n      return;\n    }\n    if (field.has(\"T\")) {\n      const partName = stringToPDFString(await field.getAsync(\"T\"));\n      name = name === \"\" ? partName : `${name}.${partName}`;\n    } else {\n      let obj = field;\n      while (true) {\n        obj = obj.getRaw(\"Parent\");\n        if (obj instanceof Ref) {\n          if (visitedRefs.has(obj)) {\n            break;\n          }\n          obj = await xref.fetchAsync(obj);\n        }\n        if (!(obj instanceof Dict)) {\n          break;\n        }\n        if (obj.has(\"T\")) {\n          const partName = stringToPDFString(await obj.getAsync(\"T\"));\n          name = name === \"\" ? partName : `${name}.${partName}`;\n          break;\n        }\n      }\n    }\n    if (!promises.has(name)) {\n      promises.set(name, []);\n    }\n    promises.get(name).push(AnnotationFactory.create(xref, fieldRef, annotationGlobals, null, true, null).then(annotation => annotation?.getFieldObject()).catch(function (reason) {\n      warn(`#collectFieldObjects: \"${reason}\".`);\n      return null;\n    }));\n    if (!field.has(\"Kids\")) {\n      return;\n    }\n    const kids = await field.getAsync(\"Kids\");\n    if (Array.isArray(kids)) {\n      for (const kid of kids) {\n        await this.#collectFieldObjects(name, kid, promises, annotationGlobals, visitedRefs);\n      }\n    }\n  }\n  get fieldObjects() {\n    if (!this.formInfo.hasFields) {\n      return shadow(this, \"fieldObjects\", Promise.resolve(null));\n    }\n    const promise = Promise.all([this.pdfManager.ensureDoc(\"annotationGlobals\"), this.pdfManager.ensureCatalog(\"acroForm\")]).then(async ([annotationGlobals, acroForm]) => {\n      if (!annotationGlobals) {\n        return null;\n      }\n      const visitedRefs = new RefSet();\n      const allFields = Object.create(null);\n      const fieldPromises = new Map();\n      for (const fieldRef of await acroForm.getAsync(\"Fields\")) {\n        await this.#collectFieldObjects(\"\", fieldRef, fieldPromises, annotationGlobals, visitedRefs);\n      }\n      const allPromises = [];\n      for (const [name, promises] of fieldPromises) {\n        allPromises.push(Promise.all(promises).then(fields => {\n          fields = fields.filter(field => !!field);\n          if (fields.length > 0) {\n            allFields[name] = fields;\n          }\n        }));\n      }\n      await Promise.all(allPromises);\n      return allFields;\n    });\n    return shadow(this, \"fieldObjects\", promise);\n  }\n  get hasJSActions() {\n    const promise = this.pdfManager.ensureDoc(\"_parseHasJSActions\");\n    return shadow(this, \"hasJSActions\", promise);\n  }\n  async _parseHasJSActions() {\n    const [catalogJsActions, fieldObjects] = await Promise.all([this.pdfManager.ensureCatalog(\"jsActions\"), this.pdfManager.ensureDoc(\"fieldObjects\")]);\n    if (catalogJsActions) {\n      return true;\n    }\n    if (fieldObjects) {\n      return Object.values(fieldObjects).some(fieldObject => fieldObject.some(object => object.actions !== null));\n    }\n    return false;\n  }\n  get calculationOrderIds() {\n    const acroForm = this.catalog.acroForm;\n    if (!acroForm?.has(\"CO\")) {\n      return shadow(this, \"calculationOrderIds\", null);\n    }\n    const calculationOrder = acroForm.get(\"CO\");\n    if (!Array.isArray(calculationOrder) || calculationOrder.length === 0) {\n      return shadow(this, \"calculationOrderIds\", null);\n    }\n    const ids = [];\n    for (const id of calculationOrder) {\n      if (id instanceof Ref) {\n        ids.push(id.toString());\n      }\n    }\n    if (ids.length === 0) {\n      return shadow(this, \"calculationOrderIds\", null);\n    }\n    return shadow(this, \"calculationOrderIds\", ids);\n  }\n  get annotationGlobals() {\n    return shadow(this, \"annotationGlobals\", AnnotationFactory.createGlobals(this.pdfManager));\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/pdf_manager.js\n\n\n\n\n\nfunction parseDocBaseUrl(url) {\n  if (url) {\n    const absoluteUrl = createValidAbsoluteUrl(url);\n    if (absoluteUrl) {\n      return absoluteUrl.href;\n    }\n    warn(`Invalid absolute docBaseUrl: \"${url}\".`);\n  }\n  return null;\n}\nclass BasePdfManager {\n  constructor(args) {\n    if (this.constructor === BasePdfManager) {\n      unreachable(\"Cannot initialize BasePdfManager.\");\n    }\n    this._docBaseUrl = parseDocBaseUrl(args.docBaseUrl);\n    this._docId = args.docId;\n    this._password = args.password;\n    this.enableXfa = args.enableXfa;\n    args.evaluatorOptions.isOffscreenCanvasSupported &&= FeatureTest.isOffscreenCanvasSupported;\n    this.evaluatorOptions = args.evaluatorOptions;\n  }\n  get docId() {\n    return this._docId;\n  }\n  get password() {\n    return this._password;\n  }\n  get docBaseUrl() {\n    return this._docBaseUrl;\n  }\n  get catalog() {\n    return this.pdfDocument.catalog;\n  }\n  ensureDoc(prop, args) {\n    return this.ensure(this.pdfDocument, prop, args);\n  }\n  ensureXRef(prop, args) {\n    return this.ensure(this.pdfDocument.xref, prop, args);\n  }\n  ensureCatalog(prop, args) {\n    return this.ensure(this.pdfDocument.catalog, prop, args);\n  }\n  getPage(pageIndex) {\n    return this.pdfDocument.getPage(pageIndex);\n  }\n  fontFallback(id, handler) {\n    return this.pdfDocument.fontFallback(id, handler);\n  }\n  loadXfaFonts(handler, task) {\n    return this.pdfDocument.loadXfaFonts(handler, task);\n  }\n  loadXfaImages() {\n    return this.pdfDocument.loadXfaImages();\n  }\n  serializeXfaData(annotationStorage) {\n    return this.pdfDocument.serializeXfaData(annotationStorage);\n  }\n  cleanup(manuallyTriggered = false) {\n    return this.pdfDocument.cleanup(manuallyTriggered);\n  }\n  async ensure(obj, prop, args) {\n    unreachable(\"Abstract method `ensure` called\");\n  }\n  requestRange(begin, end) {\n    unreachable(\"Abstract method `requestRange` called\");\n  }\n  requestLoadedStream(noFetch = false) {\n    unreachable(\"Abstract method `requestLoadedStream` called\");\n  }\n  sendProgressiveData(chunk) {\n    unreachable(\"Abstract method `sendProgressiveData` called\");\n  }\n  updatePassword(password) {\n    this._password = password;\n  }\n  terminate(reason) {\n    unreachable(\"Abstract method `terminate` called\");\n  }\n}\nclass LocalPdfManager extends BasePdfManager {\n  constructor(args) {\n    super(args);\n    const stream = new Stream(args.source);\n    this.pdfDocument = new PDFDocument(this, stream);\n    this._loadedStreamPromise = Promise.resolve(stream);\n  }\n  async ensure(obj, prop, args) {\n    const value = obj[prop];\n    if (typeof value === \"function\") {\n      return value.apply(obj, args);\n    }\n    return value;\n  }\n  requestRange(begin, end) {\n    return Promise.resolve();\n  }\n  requestLoadedStream(noFetch = false) {\n    return this._loadedStreamPromise;\n  }\n  terminate(reason) {}\n}\nclass NetworkPdfManager extends BasePdfManager {\n  constructor(args) {\n    super(args);\n    this.streamManager = new ChunkedStreamManager(args.source, {\n      msgHandler: args.handler,\n      length: args.length,\n      disableAutoFetch: args.disableAutoFetch,\n      rangeChunkSize: args.rangeChunkSize\n    });\n    this.pdfDocument = new PDFDocument(this, this.streamManager.getStream());\n  }\n  async ensure(obj, prop, args) {\n    try {\n      const value = obj[prop];\n      if (typeof value === \"function\") {\n        return value.apply(obj, args);\n      }\n      return value;\n    } catch (ex) {\n      if (!(ex instanceof MissingDataException)) {\n        throw ex;\n      }\n      await this.requestRange(ex.begin, ex.end);\n      return this.ensure(obj, prop, args);\n    }\n  }\n  requestRange(begin, end) {\n    return this.streamManager.requestRange(begin, end);\n  }\n  requestLoadedStream(noFetch = false) {\n    return this.streamManager.requestAllChunks(noFetch);\n  }\n  sendProgressiveData(chunk) {\n    this.streamManager.onReceiveData({\n      chunk\n    });\n  }\n  terminate(reason) {\n    this.streamManager.abort(reason);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/shared/message_handler.js\n\nconst CallbackKind = {\n  UNKNOWN: 0,\n  DATA: 1,\n  ERROR: 2\n};\nconst StreamKind = {\n  UNKNOWN: 0,\n  CANCEL: 1,\n  CANCEL_COMPLETE: 2,\n  CLOSE: 3,\n  ENQUEUE: 4,\n  ERROR: 5,\n  PULL: 6,\n  PULL_COMPLETE: 7,\n  START_COMPLETE: 8\n};\nfunction wrapReason(reason) {\n  if (!(reason instanceof Error || typeof reason === \"object\" && reason !== null)) {\n    unreachable('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n  }\n  switch (reason.name) {\n    case \"AbortException\":\n      return new AbortException(reason.message);\n    case \"MissingPDFException\":\n      return new MissingPDFException(reason.message);\n    case \"PasswordException\":\n      return new PasswordException(reason.message, reason.code);\n    case \"UnexpectedResponseException\":\n      return new UnexpectedResponseException(reason.message, reason.status);\n    case \"UnknownErrorException\":\n      return new UnknownErrorException(reason.message, reason.details);\n    default:\n      return new UnknownErrorException(reason.message, reason.toString());\n  }\n}\nclass MessageHandler {\n  constructor(sourceName, targetName, comObj) {\n    this.sourceName = sourceName;\n    this.targetName = targetName;\n    this.comObj = comObj;\n    this.callbackId = 1;\n    this.streamId = 1;\n    this.streamSinks = Object.create(null);\n    this.streamControllers = Object.create(null);\n    this.callbackCapabilities = Object.create(null);\n    this.actionHandler = Object.create(null);\n    this._onComObjOnMessage = event => {\n      const data = event.data;\n      if (data.targetName !== this.sourceName) {\n        return;\n      }\n      if (data.stream) {\n        this.#processStreamMessage(data);\n        return;\n      }\n      if (data.callback) {\n        const callbackId = data.callbackId;\n        const capability = this.callbackCapabilities[callbackId];\n        if (!capability) {\n          throw new Error(`Cannot resolve callback ${callbackId}`);\n        }\n        delete this.callbackCapabilities[callbackId];\n        if (data.callback === CallbackKind.DATA) {\n          capability.resolve(data.data);\n        } else if (data.callback === CallbackKind.ERROR) {\n          capability.reject(wrapReason(data.reason));\n        } else {\n          throw new Error(\"Unexpected callback case\");\n        }\n        return;\n      }\n      const action = this.actionHandler[data.action];\n      if (!action) {\n        throw new Error(`Unknown action from worker: ${data.action}`);\n      }\n      if (data.callbackId) {\n        const cbSourceName = this.sourceName;\n        const cbTargetName = data.sourceName;\n        new Promise(function (resolve) {\n          resolve(action(data.data));\n        }).then(function (result) {\n          comObj.postMessage({\n            sourceName: cbSourceName,\n            targetName: cbTargetName,\n            callback: CallbackKind.DATA,\n            callbackId: data.callbackId,\n            data: result\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName: cbSourceName,\n            targetName: cbTargetName,\n            callback: CallbackKind.ERROR,\n            callbackId: data.callbackId,\n            reason: wrapReason(reason)\n          });\n        });\n        return;\n      }\n      if (data.streamId) {\n        this.#createStreamSink(data);\n        return;\n      }\n      action(data.data);\n    };\n    comObj.addEventListener(\"message\", this._onComObjOnMessage);\n  }\n  on(actionName, handler) {\n    const ah = this.actionHandler;\n    if (ah[actionName]) {\n      throw new Error(`There is already an actionName called \"${actionName}\"`);\n    }\n    ah[actionName] = handler;\n  }\n  send(actionName, data, transfers) {\n    this.comObj.postMessage({\n      sourceName: this.sourceName,\n      targetName: this.targetName,\n      action: actionName,\n      data\n    }, transfers);\n  }\n  sendWithPromise(actionName, data, transfers) {\n    const callbackId = this.callbackId++;\n    const capability = Promise.withResolvers();\n    this.callbackCapabilities[callbackId] = capability;\n    try {\n      this.comObj.postMessage({\n        sourceName: this.sourceName,\n        targetName: this.targetName,\n        action: actionName,\n        callbackId,\n        data\n      }, transfers);\n    } catch (ex) {\n      capability.reject(ex);\n    }\n    return capability.promise;\n  }\n  sendWithStream(actionName, data, queueingStrategy, transfers) {\n    const streamId = this.streamId++,\n      sourceName = this.sourceName,\n      targetName = this.targetName,\n      comObj = this.comObj;\n    return new ReadableStream({\n      start: controller => {\n        const startCapability = Promise.withResolvers();\n        this.streamControllers[streamId] = {\n          controller,\n          startCall: startCapability,\n          pullCall: null,\n          cancelCall: null,\n          isClosed: false\n        };\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          action: actionName,\n          streamId,\n          data,\n          desiredSize: controller.desiredSize\n        }, transfers);\n        return startCapability.promise;\n      },\n      pull: controller => {\n        const pullCapability = Promise.withResolvers();\n        this.streamControllers[streamId].pullCall = pullCapability;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.PULL,\n          streamId,\n          desiredSize: controller.desiredSize\n        });\n        return pullCapability.promise;\n      },\n      cancel: reason => {\n        assert(reason instanceof Error, \"cancel must have a valid reason\");\n        const cancelCapability = Promise.withResolvers();\n        this.streamControllers[streamId].cancelCall = cancelCapability;\n        this.streamControllers[streamId].isClosed = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CANCEL,\n          streamId,\n          reason: wrapReason(reason)\n        });\n        return cancelCapability.promise;\n      }\n    }, queueingStrategy);\n  }\n  #createStreamSink(data) {\n    const streamId = data.streamId,\n      sourceName = this.sourceName,\n      targetName = data.sourceName,\n      comObj = this.comObj;\n    const self = this,\n      action = this.actionHandler[data.action];\n    const streamSink = {\n      enqueue(chunk, size = 1, transfers) {\n        if (this.isCancelled) {\n          return;\n        }\n        const lastDesiredSize = this.desiredSize;\n        this.desiredSize -= size;\n        if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n          this.sinkCapability = Promise.withResolvers();\n          this.ready = this.sinkCapability.promise;\n        }\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ENQUEUE,\n          streamId,\n          chunk\n        }, transfers);\n      },\n      close() {\n        if (this.isCancelled) {\n          return;\n        }\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CLOSE,\n          streamId\n        });\n        delete self.streamSinks[streamId];\n      },\n      error(reason) {\n        assert(reason instanceof Error, \"error must have a valid reason\");\n        if (this.isCancelled) {\n          return;\n        }\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ERROR,\n          streamId,\n          reason: wrapReason(reason)\n        });\n      },\n      sinkCapability: Promise.withResolvers(),\n      onPull: null,\n      onCancel: null,\n      isCancelled: false,\n      desiredSize: data.desiredSize,\n      ready: null\n    };\n    streamSink.sinkCapability.resolve();\n    streamSink.ready = streamSink.sinkCapability.promise;\n    this.streamSinks[streamId] = streamSink;\n    new Promise(function (resolve) {\n      resolve(action(data.data, streamSink));\n    }).then(function () {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        success: true\n      });\n    }, function (reason) {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        reason: wrapReason(reason)\n      });\n    });\n  }\n  #processStreamMessage(data) {\n    const streamId = data.streamId,\n      sourceName = this.sourceName,\n      targetName = data.sourceName,\n      comObj = this.comObj;\n    const streamController = this.streamControllers[streamId],\n      streamSink = this.streamSinks[streamId];\n    switch (data.stream) {\n      case StreamKind.START_COMPLETE:\n        if (data.success) {\n          streamController.startCall.resolve();\n        } else {\n          streamController.startCall.reject(wrapReason(data.reason));\n        }\n        break;\n      case StreamKind.PULL_COMPLETE:\n        if (data.success) {\n          streamController.pullCall.resolve();\n        } else {\n          streamController.pullCall.reject(wrapReason(data.reason));\n        }\n        break;\n      case StreamKind.PULL:\n        if (!streamSink) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n          break;\n        }\n        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n          streamSink.sinkCapability.resolve();\n        }\n        streamSink.desiredSize = data.desiredSize;\n        new Promise(function (resolve) {\n          resolve(streamSink.onPull?.());\n        }).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        break;\n      case StreamKind.ENQUEUE:\n        assert(streamController, \"enqueue should have stream controller\");\n        if (streamController.isClosed) {\n          break;\n        }\n        streamController.controller.enqueue(data.chunk);\n        break;\n      case StreamKind.CLOSE:\n        assert(streamController, \"close should have stream controller\");\n        if (streamController.isClosed) {\n          break;\n        }\n        streamController.isClosed = true;\n        streamController.controller.close();\n        this.#deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.ERROR:\n        assert(streamController, \"error should have stream controller\");\n        streamController.controller.error(wrapReason(data.reason));\n        this.#deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.CANCEL_COMPLETE:\n        if (data.success) {\n          streamController.cancelCall.resolve();\n        } else {\n          streamController.cancelCall.reject(wrapReason(data.reason));\n        }\n        this.#deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.CANCEL:\n        if (!streamSink) {\n          break;\n        }\n        new Promise(function (resolve) {\n          resolve(streamSink.onCancel?.(wrapReason(data.reason)));\n        }).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        streamSink.sinkCapability.reject(wrapReason(data.reason));\n        streamSink.isCancelled = true;\n        delete this.streamSinks[streamId];\n        break;\n      default:\n        throw new Error(\"Unexpected stream case\");\n    }\n  }\n  async #deleteStreamController(streamController, streamId) {\n    await Promise.allSettled([streamController.startCall?.promise, streamController.pullCall?.promise, streamController.cancelCall?.promise]);\n    delete this.streamControllers[streamId];\n  }\n  destroy() {\n    this.comObj.removeEventListener(\"message\", this._onComObjOnMessage);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/worker_stream.js\n\nclass PDFWorkerStream {\n  constructor(msgHandler) {\n    this._msgHandler = msgHandler;\n    this._contentLength = null;\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n  getFullReader() {\n    assert(!this._fullRequestReader, \"PDFWorkerStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler);\n    return this._fullRequestReader;\n  }\n  getRangeReader(begin, end) {\n    const reader = new PDFWorkerStreamRangeReader(begin, end, this._msgHandler);\n    this._rangeRequestReaders.push(reader);\n    return reader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n}\nclass PDFWorkerStreamReader {\n  constructor(msgHandler) {\n    this._msgHandler = msgHandler;\n    this.onProgress = null;\n    this._contentLength = null;\n    this._isRangeSupported = false;\n    this._isStreamingSupported = false;\n    const readableStream = this._msgHandler.sendWithStream(\"GetReader\");\n    this._reader = readableStream.getReader();\n    this._headersReady = this._msgHandler.sendWithPromise(\"ReaderHeadersReady\").then(data => {\n      this._isStreamingSupported = data.isStreamingSupported;\n      this._isRangeSupported = data.isRangeSupported;\n      this._contentLength = data.contentLength;\n    });\n  }\n  get headersReady() {\n    return this._headersReady;\n  }\n  get contentLength() {\n    return this._contentLength;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n  async read() {\n    const {\n      value,\n      done\n    } = await this._reader.read();\n    if (done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    return {\n      value: value.buffer,\n      done: false\n    };\n  }\n  cancel(reason) {\n    this._reader.cancel(reason);\n  }\n}\nclass PDFWorkerStreamRangeReader {\n  constructor(begin, end, msgHandler) {\n    this._msgHandler = msgHandler;\n    this.onProgress = null;\n    const readableStream = this._msgHandler.sendWithStream(\"GetRangeReader\", {\n      begin,\n      end\n    });\n    this._reader = readableStream.getReader();\n  }\n  get isStreamingSupported() {\n    return false;\n  }\n  async read() {\n    const {\n      value,\n      done\n    } = await this._reader.read();\n    if (done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    return {\n      value: value.buffer,\n      done: false\n    };\n  }\n  cancel(reason) {\n    this._reader.cancel(reason);\n  }\n}\n\n;// CONCATENATED MODULE: ./src/core/worker.js\n\n\n\n\n\n\n\n\n\n\nclass WorkerTask {\n  constructor(name) {\n    this.name = name;\n    this.terminated = false;\n    this._capability = Promise.withResolvers();\n  }\n  get finished() {\n    return this._capability.promise;\n  }\n  finish() {\n    this._capability.resolve();\n  }\n  terminate() {\n    this.terminated = true;\n  }\n  ensureNotTerminated() {\n    if (this.terminated) {\n      throw new Error(\"Worker task was terminated\");\n    }\n  }\n}\nclass WorkerMessageHandler {\n  static setup(handler, port) {\n    let testMessageProcessed = false;\n    handler.on(\"test\", function (data) {\n      if (testMessageProcessed) {\n        return;\n      }\n      testMessageProcessed = true;\n      handler.send(\"test\", data instanceof Uint8Array);\n    });\n    handler.on(\"configure\", function (data) {\n      setVerbosityLevel(data.verbosity);\n    });\n    handler.on(\"GetDocRequest\", function (data) {\n      return WorkerMessageHandler.createDocumentHandler(data, port);\n    });\n  }\n  static createDocumentHandler(docParams, port) {\n    let pdfManager;\n    let terminated = false;\n    let cancelXHRs = null;\n    const WorkerTasks = new Set();\n    const verbosity = getVerbosityLevel();\n    const {\n      docId,\n      apiVersion\n    } = docParams;\n    const workerVersion = \"4.2.67\";\n    if (apiVersion !== workerVersion) {\n      throw new Error(`The API version \"${apiVersion}\" does not match ` + `the Worker version \"${workerVersion}\".`);\n    }\n    const enumerableProperties = [];\n    for (const property in []) {\n      enumerableProperties.push(property);\n    }\n    if (enumerableProperties.length) {\n      throw new Error(\"The `Array.prototype` contains unexpected enumerable properties: \" + enumerableProperties.join(\", \") + \"; thus breaking e.g. `for...in` iteration of `Array`s.\");\n    }\n    const workerHandlerName = docId + \"_worker\";\n    let handler = new MessageHandler(workerHandlerName, docId, port);\n    function ensureNotTerminated() {\n      if (terminated) {\n        throw new Error(\"Worker was terminated\");\n      }\n    }\n    function startWorkerTask(task) {\n      WorkerTasks.add(task);\n    }\n    function finishWorkerTask(task) {\n      task.finish();\n      WorkerTasks.delete(task);\n    }\n    async function loadDocument(recoveryMode) {\n      await pdfManager.ensureDoc(\"checkHeader\");\n      await pdfManager.ensureDoc(\"parseStartXRef\");\n      await pdfManager.ensureDoc(\"parse\", [recoveryMode]);\n      await pdfManager.ensureDoc(\"checkFirstPage\", [recoveryMode]);\n      await pdfManager.ensureDoc(\"checkLastPage\", [recoveryMode]);\n      const isPureXfa = await pdfManager.ensureDoc(\"isPureXfa\");\n      if (isPureXfa) {\n        const task = new WorkerTask(\"loadXfaFonts\");\n        startWorkerTask(task);\n        await Promise.all([pdfManager.loadXfaFonts(handler, task).catch(reason => {}).then(() => finishWorkerTask(task)), pdfManager.loadXfaImages()]);\n      }\n      const [numPages, fingerprints] = await Promise.all([pdfManager.ensureDoc(\"numPages\"), pdfManager.ensureDoc(\"fingerprints\")]);\n      const htmlForXfa = isPureXfa ? await pdfManager.ensureDoc(\"htmlForXfa\") : null;\n      return {\n        numPages,\n        fingerprints,\n        htmlForXfa\n      };\n    }\n    function getPdfManager({\n      data,\n      password,\n      disableAutoFetch,\n      rangeChunkSize,\n      length,\n      docBaseUrl,\n      enableXfa,\n      evaluatorOptions\n    }) {\n      const pdfManagerArgs = {\n        source: null,\n        disableAutoFetch,\n        docBaseUrl,\n        docId,\n        enableXfa,\n        evaluatorOptions,\n        handler,\n        length,\n        password,\n        rangeChunkSize\n      };\n      const pdfManagerCapability = Promise.withResolvers();\n      let newPdfManager;\n      if (data) {\n        try {\n          pdfManagerArgs.source = data;\n          newPdfManager = new LocalPdfManager(pdfManagerArgs);\n          pdfManagerCapability.resolve(newPdfManager);\n        } catch (ex) {\n          pdfManagerCapability.reject(ex);\n        }\n        return pdfManagerCapability.promise;\n      }\n      let pdfStream,\n        cachedChunks = [];\n      try {\n        pdfStream = new PDFWorkerStream(handler);\n      } catch (ex) {\n        pdfManagerCapability.reject(ex);\n        return pdfManagerCapability.promise;\n      }\n      const fullRequest = pdfStream.getFullReader();\n      fullRequest.headersReady.then(function () {\n        if (!fullRequest.isRangeSupported) {\n          return;\n        }\n        pdfManagerArgs.source = pdfStream;\n        pdfManagerArgs.length = fullRequest.contentLength;\n        pdfManagerArgs.disableAutoFetch ||= fullRequest.isStreamingSupported;\n        newPdfManager = new NetworkPdfManager(pdfManagerArgs);\n        for (const chunk of cachedChunks) {\n          newPdfManager.sendProgressiveData(chunk);\n        }\n        cachedChunks = [];\n        pdfManagerCapability.resolve(newPdfManager);\n        cancelXHRs = null;\n      }).catch(function (reason) {\n        pdfManagerCapability.reject(reason);\n        cancelXHRs = null;\n      });\n      let loaded = 0;\n      const flushChunks = function () {\n        const pdfFile = arrayBuffersToBytes(cachedChunks);\n        if (length && pdfFile.length !== length) {\n          warn(\"reported HTTP length is different from actual\");\n        }\n        try {\n          pdfManagerArgs.source = pdfFile;\n          newPdfManager = new LocalPdfManager(pdfManagerArgs);\n          pdfManagerCapability.resolve(newPdfManager);\n        } catch (ex) {\n          pdfManagerCapability.reject(ex);\n        }\n        cachedChunks = [];\n      };\n      new Promise(function (resolve, reject) {\n        const readChunk = function ({\n          value,\n          done\n        }) {\n          try {\n            ensureNotTerminated();\n            if (done) {\n              if (!newPdfManager) {\n                flushChunks();\n              }\n              cancelXHRs = null;\n              return;\n            }\n            loaded += value.byteLength;\n            if (!fullRequest.isStreamingSupported) {\n              handler.send(\"DocProgress\", {\n                loaded,\n                total: Math.max(loaded, fullRequest.contentLength || 0)\n              });\n            }\n            if (newPdfManager) {\n              newPdfManager.sendProgressiveData(value);\n            } else {\n              cachedChunks.push(value);\n            }\n            fullRequest.read().then(readChunk, reject);\n          } catch (e) {\n            reject(e);\n          }\n        };\n        fullRequest.read().then(readChunk, reject);\n      }).catch(function (e) {\n        pdfManagerCapability.reject(e);\n        cancelXHRs = null;\n      });\n      cancelXHRs = function (reason) {\n        pdfStream.cancelAllRequests(reason);\n      };\n      return pdfManagerCapability.promise;\n    }\n    function setupDoc(data) {\n      function onSuccess(doc) {\n        ensureNotTerminated();\n        handler.send(\"GetDoc\", {\n          pdfInfo: doc\n        });\n      }\n      function onFailure(ex) {\n        ensureNotTerminated();\n        if (ex instanceof PasswordException) {\n          const task = new WorkerTask(`PasswordException: response ${ex.code}`);\n          startWorkerTask(task);\n          handler.sendWithPromise(\"PasswordRequest\", ex).then(function ({\n            password\n          }) {\n            finishWorkerTask(task);\n            pdfManager.updatePassword(password);\n            pdfManagerReady();\n          }).catch(function () {\n            finishWorkerTask(task);\n            handler.send(\"DocException\", ex);\n          });\n        } else if (ex instanceof InvalidPDFException || ex instanceof MissingPDFException || ex instanceof UnexpectedResponseException || ex instanceof UnknownErrorException) {\n          handler.send(\"DocException\", ex);\n        } else {\n          handler.send(\"DocException\", new UnknownErrorException(ex.message, ex.toString()));\n        }\n      }\n      function pdfManagerReady() {\n        ensureNotTerminated();\n        loadDocument(false).then(onSuccess, function (reason) {\n          ensureNotTerminated();\n          if (!(reason instanceof XRefParseException)) {\n            onFailure(reason);\n            return;\n          }\n          pdfManager.requestLoadedStream().then(function () {\n            ensureNotTerminated();\n            loadDocument(true).then(onSuccess, onFailure);\n          });\n        });\n      }\n      ensureNotTerminated();\n      getPdfManager(data).then(function (newPdfManager) {\n        if (terminated) {\n          newPdfManager.terminate(new AbortException(\"Worker was terminated.\"));\n          throw new Error(\"Worker was terminated\");\n        }\n        pdfManager = newPdfManager;\n        pdfManager.requestLoadedStream(true).then(stream => {\n          handler.send(\"DataLoaded\", {\n            length: stream.bytes.byteLength\n          });\n        });\n      }).then(pdfManagerReady, onFailure);\n    }\n    handler.on(\"GetPage\", function (data) {\n      return pdfManager.getPage(data.pageIndex).then(function (page) {\n        return Promise.all([pdfManager.ensure(page, \"rotate\"), pdfManager.ensure(page, \"ref\"), pdfManager.ensure(page, \"userUnit\"), pdfManager.ensure(page, \"view\")]).then(function ([rotate, ref, userUnit, view]) {\n          return {\n            rotate,\n            ref,\n            refStr: ref?.toString() ?? null,\n            userUnit,\n            view\n          };\n        });\n      });\n    });\n    handler.on(\"GetPageIndex\", function (data) {\n      const pageRef = Ref.get(data.num, data.gen);\n      return pdfManager.ensureCatalog(\"getPageIndex\", [pageRef]);\n    });\n    handler.on(\"GetDestinations\", function (data) {\n      return pdfManager.ensureCatalog(\"destinations\");\n    });\n    handler.on(\"GetDestination\", function (data) {\n      return pdfManager.ensureCatalog(\"getDestination\", [data.id]);\n    });\n    handler.on(\"GetPageLabels\", function (data) {\n      return pdfManager.ensureCatalog(\"pageLabels\");\n    });\n    handler.on(\"GetPageLayout\", function (data) {\n      return pdfManager.ensureCatalog(\"pageLayout\");\n    });\n    handler.on(\"GetPageMode\", function (data) {\n      return pdfManager.ensureCatalog(\"pageMode\");\n    });\n    handler.on(\"GetViewerPreferences\", function (data) {\n      return pdfManager.ensureCatalog(\"viewerPreferences\");\n    });\n    handler.on(\"GetOpenAction\", function (data) {\n      return pdfManager.ensureCatalog(\"openAction\");\n    });\n    handler.on(\"GetAttachments\", function (data) {\n      return pdfManager.ensureCatalog(\"attachments\");\n    });\n    handler.on(\"GetDocJSActions\", function (data) {\n      return pdfManager.ensureCatalog(\"jsActions\");\n    });\n    handler.on(\"GetPageJSActions\", function ({\n      pageIndex\n    }) {\n      return pdfManager.getPage(pageIndex).then(function (page) {\n        return pdfManager.ensure(page, \"jsActions\");\n      });\n    });\n    handler.on(\"GetOutline\", function (data) {\n      return pdfManager.ensureCatalog(\"documentOutline\");\n    });\n    handler.on(\"GetOptionalContentConfig\", function (data) {\n      return pdfManager.ensureCatalog(\"optionalContentConfig\");\n    });\n    handler.on(\"GetPermissions\", function (data) {\n      return pdfManager.ensureCatalog(\"permissions\");\n    });\n    handler.on(\"GetMetadata\", function (data) {\n      return Promise.all([pdfManager.ensureDoc(\"documentInfo\"), pdfManager.ensureCatalog(\"metadata\")]);\n    });\n    handler.on(\"GetMarkInfo\", function (data) {\n      return pdfManager.ensureCatalog(\"markInfo\");\n    });\n    handler.on(\"GetData\", function (data) {\n      return pdfManager.requestLoadedStream().then(function (stream) {\n        return stream.bytes;\n      });\n    });\n    handler.on(\"GetAnnotations\", function ({\n      pageIndex,\n      intent\n    }) {\n      return pdfManager.getPage(pageIndex).then(function (page) {\n        const task = new WorkerTask(`GetAnnotations: page ${pageIndex}`);\n        startWorkerTask(task);\n        return page.getAnnotationsData(handler, task, intent).then(data => {\n          finishWorkerTask(task);\n          return data;\n        }, reason => {\n          finishWorkerTask(task);\n          throw reason;\n        });\n      });\n    });\n    handler.on(\"GetFieldObjects\", function (data) {\n      return pdfManager.ensureDoc(\"fieldObjects\");\n    });\n    handler.on(\"HasJSActions\", function (data) {\n      return pdfManager.ensureDoc(\"hasJSActions\");\n    });\n    handler.on(\"GetCalculationOrderIds\", function (data) {\n      return pdfManager.ensureDoc(\"calculationOrderIds\");\n    });\n    handler.on(\"SaveDocument\", async function ({\n      isPureXfa,\n      numPages,\n      annotationStorage,\n      filename\n    }) {\n      const globalPromises = [pdfManager.requestLoadedStream(), pdfManager.ensureCatalog(\"acroForm\"), pdfManager.ensureCatalog(\"acroFormRef\"), pdfManager.ensureDoc(\"startXRef\"), pdfManager.ensureDoc(\"xref\"), pdfManager.ensureDoc(\"linearization\"), pdfManager.ensureCatalog(\"structTreeRoot\")];\n      const promises = [];\n      const newAnnotationsByPage = !isPureXfa ? getNewAnnotationsMap(annotationStorage) : null;\n      const [stream, acroForm, acroFormRef, startXRef, xref, linearization, _structTreeRoot] = await Promise.all(globalPromises);\n      const catalogRef = xref.trailer.getRaw(\"Root\") || null;\n      let structTreeRoot;\n      if (newAnnotationsByPage) {\n        if (!_structTreeRoot) {\n          if (await StructTreeRoot.canCreateStructureTree({\n            catalogRef,\n            pdfManager,\n            newAnnotationsByPage\n          })) {\n            structTreeRoot = null;\n          }\n        } else if (await _structTreeRoot.canUpdateStructTree({\n          pdfManager,\n          xref,\n          newAnnotationsByPage\n        })) {\n          structTreeRoot = _structTreeRoot;\n        }\n        const imagePromises = AnnotationFactory.generateImages(annotationStorage.values(), xref, pdfManager.evaluatorOptions.isOffscreenCanvasSupported);\n        const newAnnotationPromises = structTreeRoot === undefined ? promises : [];\n        for (const [pageIndex, annotations] of newAnnotationsByPage) {\n          newAnnotationPromises.push(pdfManager.getPage(pageIndex).then(page => {\n            const task = new WorkerTask(`Save (editor): page ${pageIndex}`);\n            return page.saveNewAnnotations(handler, task, annotations, imagePromises).finally(function () {\n              finishWorkerTask(task);\n            });\n          }));\n        }\n        if (structTreeRoot === null) {\n          promises.push(Promise.all(newAnnotationPromises).then(async newRefs => {\n            await StructTreeRoot.createStructureTree({\n              newAnnotationsByPage,\n              xref,\n              catalogRef,\n              pdfManager,\n              newRefs\n            });\n            return newRefs;\n          }));\n        } else if (structTreeRoot) {\n          promises.push(Promise.all(newAnnotationPromises).then(async newRefs => {\n            await structTreeRoot.updateStructureTree({\n              newAnnotationsByPage,\n              pdfManager,\n              newRefs\n            });\n            return newRefs;\n          }));\n        }\n      }\n      if (isPureXfa) {\n        promises.push(pdfManager.serializeXfaData(annotationStorage));\n      } else {\n        for (let pageIndex = 0; pageIndex < numPages; pageIndex++) {\n          promises.push(pdfManager.getPage(pageIndex).then(function (page) {\n            const task = new WorkerTask(`Save: page ${pageIndex}`);\n            return page.save(handler, task, annotationStorage).finally(function () {\n              finishWorkerTask(task);\n            });\n          }));\n        }\n      }\n      const refs = await Promise.all(promises);\n      let newRefs = [];\n      let xfaData = null;\n      if (isPureXfa) {\n        xfaData = refs[0];\n        if (!xfaData) {\n          return stream.bytes;\n        }\n      } else {\n        newRefs = refs.flat(2);\n        if (newRefs.length === 0) {\n          return stream.bytes;\n        }\n      }\n      const needAppearances = acroFormRef && acroForm instanceof Dict && newRefs.some(ref => ref.needAppearances);\n      const xfa = acroForm instanceof Dict && acroForm.get(\"XFA\") || null;\n      let xfaDatasetsRef = null;\n      let hasXfaDatasetsEntry = false;\n      if (Array.isArray(xfa)) {\n        for (let i = 0, ii = xfa.length; i < ii; i += 2) {\n          if (xfa[i] === \"datasets\") {\n            xfaDatasetsRef = xfa[i + 1];\n            hasXfaDatasetsEntry = true;\n          }\n        }\n        if (xfaDatasetsRef === null) {\n          xfaDatasetsRef = xref.getNewTemporaryRef();\n        }\n      } else if (xfa) {\n        warn(\"Unsupported XFA type.\");\n      }\n      let newXrefInfo = Object.create(null);\n      if (xref.trailer) {\n        const infoObj = Object.create(null);\n        const xrefInfo = xref.trailer.get(\"Info\") || null;\n        if (xrefInfo instanceof Dict) {\n          xrefInfo.forEach((key, value) => {\n            if (typeof value === \"string\") {\n              infoObj[key] = stringToPDFString(value);\n            }\n          });\n        }\n        newXrefInfo = {\n          rootRef: catalogRef,\n          encryptRef: xref.trailer.getRaw(\"Encrypt\") || null,\n          newRef: xref.getNewTemporaryRef(),\n          infoRef: xref.trailer.getRaw(\"Info\") || null,\n          info: infoObj,\n          fileIds: xref.trailer.get(\"ID\") || null,\n          startXRef: linearization ? startXRef : xref.lastXRefStreamPos ?? startXRef,\n          filename\n        };\n      }\n      return incrementalUpdate({\n        originalData: stream.bytes,\n        xrefInfo: newXrefInfo,\n        newRefs,\n        xref,\n        hasXfa: !!xfa,\n        xfaDatasetsRef,\n        hasXfaDatasetsEntry,\n        needAppearances,\n        acroFormRef,\n        acroForm,\n        xfaData,\n        useXrefStream: isDict(xref.topDict, \"XRef\")\n      }).finally(() => {\n        xref.resetNewTemporaryRef();\n      });\n    });\n    handler.on(\"GetOperatorList\", function (data, sink) {\n      const pageIndex = data.pageIndex;\n      pdfManager.getPage(pageIndex).then(function (page) {\n        const task = new WorkerTask(`GetOperatorList: page ${pageIndex}`);\n        startWorkerTask(task);\n        const start = verbosity >= VerbosityLevel.INFOS ? Date.now() : 0;\n        page.getOperatorList({\n          handler,\n          sink,\n          task,\n          intent: data.intent,\n          cacheKey: data.cacheKey,\n          annotationStorage: data.annotationStorage\n        }).then(function (operatorListInfo) {\n          finishWorkerTask(task);\n          if (start) {\n            info(`page=${pageIndex + 1} - getOperatorList: time=` + `${Date.now() - start}ms, len=${operatorListInfo.length}`);\n          }\n          sink.close();\n        }, function (reason) {\n          finishWorkerTask(task);\n          if (task.terminated) {\n            return;\n          }\n          sink.error(reason);\n        });\n      });\n    });\n    handler.on(\"GetTextContent\", function (data, sink) {\n      const {\n        pageIndex,\n        includeMarkedContent,\n        disableNormalization\n      } = data;\n      pdfManager.getPage(pageIndex).then(function (page) {\n        const task = new WorkerTask(\"GetTextContent: page \" + pageIndex);\n        startWorkerTask(task);\n        const start = verbosity >= VerbosityLevel.INFOS ? Date.now() : 0;\n        page.extractTextContent({\n          handler,\n          task,\n          sink,\n          includeMarkedContent,\n          disableNormalization\n        }).then(function () {\n          finishWorkerTask(task);\n          if (start) {\n            info(`page=${pageIndex + 1} - getTextContent: time=` + `${Date.now() - start}ms`);\n          }\n          sink.close();\n        }, function (reason) {\n          finishWorkerTask(task);\n          if (task.terminated) {\n            return;\n          }\n          sink.error(reason);\n        });\n      });\n    });\n    handler.on(\"GetStructTree\", function (data) {\n      return pdfManager.getPage(data.pageIndex).then(function (page) {\n        return pdfManager.ensure(page, \"getStructTree\");\n      });\n    });\n    handler.on(\"FontFallback\", function (data) {\n      return pdfManager.fontFallback(data.id, handler);\n    });\n    handler.on(\"Cleanup\", function (data) {\n      return pdfManager.cleanup(true);\n    });\n    handler.on(\"Terminate\", function (data) {\n      terminated = true;\n      const waitOn = [];\n      if (pdfManager) {\n        pdfManager.terminate(new AbortException(\"Worker was terminated.\"));\n        const cleanupPromise = pdfManager.cleanup();\n        waitOn.push(cleanupPromise);\n        pdfManager = null;\n      } else {\n        clearGlobalCaches();\n      }\n      if (cancelXHRs) {\n        cancelXHRs(new AbortException(\"Worker was terminated.\"));\n      }\n      for (const task of WorkerTasks) {\n        waitOn.push(task.finished);\n        task.terminate();\n      }\n      return Promise.all(waitOn).then(function () {\n        handler.destroy();\n        handler = null;\n      });\n    });\n    handler.on(\"Ready\", function (data) {\n      setupDoc(docParams);\n      docParams = null;\n    });\n    return workerHandlerName;\n  }\n  static initializeFromPort(port) {\n    const handler = new MessageHandler(\"worker\", \"main\", port);\n    WorkerMessageHandler.setup(handler, port);\n    handler.send(\"ready\", null);\n  }\n}\nfunction isMessagePort(maybePort) {\n  return typeof maybePort.postMessage === \"function\" && \"onmessage\" in maybePort;\n}\nif (typeof window === \"undefined\" && !isNodeJS && typeof self !== \"undefined\" && isMessagePort(self)) {\n  WorkerMessageHandler.initializeFromPort(self);\n}\n\n;// CONCATENATED MODULE: ./src/pdf.worker.js\n\nconst pdfjsVersion = \"4.2.67\";\nconst pdfjsBuild = \"49b388101\";\n\nvar __webpack_exports__WorkerMessageHandler = __nested_webpack_exports__.WorkerMessageHandler;\n\n\n//# sourceMappingURL=pdf.worker.mjs.map\n\n//# sourceURL=webpack://semanticfinder/./node_modules/pdfjs-dist/build/pdf.worker.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./node_modules/pdfjs-dist/build/pdf.worker.mjs"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ })()
;